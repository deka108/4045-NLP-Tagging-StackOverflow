Question-28276423, answer-28276463
If all of the streams have been instantiated then closing only the outermost is just fine. The documentation on Closeable interface states that close method: #blockquote The releasing system resources includes closing streams. It also states that: #blockquote So if you close them explicitly afterwards, nothing wrong will happen.

Question-12146298
I would like to know what is the cleanest and best way to perform form validation of user inputs. I have seen some developers implement org.springframework.validation.Validator . A question about that: I saw it validates a class. Does the class have to be filled manually with the values from the user input, and then passed to the validator? I am confused about the cleanest and best way to validate the user input. I know about the traditional method of using request.getParameter(args) and then manually checking for nulls , but I don't want to do all the validation in my Controller . Some good advice on this area will be greatly appreciated. I am not using Hibernate in this application.

Question-5192512, answer-5192545
Edit Updated to bring in feedback. So two ways that work: #li Use StringBulderObj.setLength(args) . #li Allocate a new one instead of clearing the buffer

Question-5868369, answer-31265714
In Java 8, there is also an alternative to using Files.lines() . If your input source isn't a file but something more abstract like a Reader or an InputStream , you can stream the lines via the BufferedReader s lines(args) method. For example: #pre will call processLine(args) for each input line read by the BufferedReader .

Question-8172420, answer-32174377
We have various ways to convert a char to String . One way is to make use of static method toString(args) in Character class: #pre Actually this toString method internally makes use of valueOf method from String class which makes use of char array: #pre So second way is to use this directly: String str2 = String.valueOf(args); This valueOf method in String class makes use of char array: #pre So the third way is to make use of an anonymous array to wrap a single character and then passing it to String constructor: String str4 = new String(args); The fourth way is to make use of concatenation: String str3 = StringLiteral + ch; This will actually make use of append method from StringBuilder class which is actually preferred when we are doing concatenation in a loop.

Question-25441088, answer-25441208
I think you're just looking for the overload which takes another Collector to specify what to do with each group... and then Collectors.counting(args) to do the counting: #pre Result: {Hello=2, World=1} (There's also the possibility of using groupingByConcurrent for more efficiency. Something to bear in mind for your real code, if it would be safe in your context.)

Question-12552863, answer-16229988
My solution is to do a "extract method" refactoring, as following: #pre printToFile can be written either #pre or #pre For class lib designers, I will suggest them extend the AutoClosable interface with an additional method to suppress the close. In this case we can then manually control the close behavior. For language designers, the lesson is that adding a new feature could mean adding a lot others. In this Java case, obviously ARM feature will work better with a resource ownership transfer mechanism. UPDATE Originally the code above requires @SuppressWarning since the BufferedWriter inside the function requires close(args) . As suggested by a comment, if flush(args) to be called before close the writer, we need to do so before any return (implicit or explicit) statements inside the try block. There is currently no way to ensure the caller doing this I think, so this must be documented for writeFileWriter . UPDATE AGAIN The above update makes @SuppressWarning unnecessary since it require the function to return the resource to the caller, so itself does not necessary being closed. Unfortunately, this pull us back to the beginning of the situation: the warning is now moved back to the caller side. So to properly solve this, we need a customised AutoClosable that whenever it closes, the underline BufferedWriter shall be flush(args) ed. Actually, this shows us another way to bypass the warning, since the BufferWriter is never closed in either way.

Question-24511052
I am looking for a concise way to convert an Iterator to a Stream or more specifically to "view" the iterator as a stream. For performance reason, I would like to avoid a copy of the iterator in a new list: #pre Based on the some suggestions in the comments, I have also tried to use Stream.generate : #pre However, I get a NoSuchElementException (since there is no invocation of hasNext ) #pre I have looked at StreamSupport and Collections but I didn't find anything.

Question-34172978, answer-34173040
Since there are only 4 elements that pass the filter, limit(args) never reaches 10 elements, so the Stream pipeline keeps generating new elements and feeding them to the filter, trying to reach 10 elements that pass the filter, but since only the first 4 elements pass the filter, the processing never ends (at least until i overflows). The Stream pipeline is not smart enough to know that no more elements can pass the filter, so it keeps processing new elements.

Question-26791441, answer-26886202
You are performing multiple search-replace operations on the input. This will produce undesired results when the replacement strings contain search strings. Consider the foo->bar, bar-foo example, here are the results for each iteration: #li Once upon a time, there was a foo and a bar. (input) #li Once upon a time, there was a bar and a bar. (foo->bar) #li Once upon a time, there was a foo and a foo. (bar->foo, output) You need to perform the replacement in one iteration without going back. A brute-force solution is as follows: #li Search the input from current position to end for multiple search strings until a match is found #li Replace the matched search string with corresponding replace string #li Set current position to the next character after the replaced string #li Repeat A function such as String.indexOfAny(args) -> int[]{index, whichString} would be useful. Here is an example (not the most efficient one): #pre Some tests: #pre Demo on IDEONE Demo on IDEONE, alternate code

Question-6840803, answer-6840856
SimpleDateFormat stores intermediate results in instance fields. So if one instance is used by two threads they can mess each other's results. Looking at the source code reveals that there is a Calendar instance field, which is used by operations on DateFormat / SimpleDateFormat For example parse(args) calls calendar.clear(args) initially and then calendar.add(args) . If another thread invokes parse(args) before the completion of the first invocation, it will clear the calendar, but the other invocation will expect it to be populated with intermediate results of the calculation. One way to reuse date formats without trading thread-safety is to put them in a ThreadLocal - some libraries do that. That's if you need to use the same format multiple times within one thread. But in case you are using a servlet container (that has a thread pool), remember to clean the thread-local after you finish. To be honest, I don't understand why they need the instance field, but that's the way it is. You can also use joda-time DateTimeFormat which is threadsafe.

Question-13195797, answer-20043507
Peter Lawrey's answer is great because it is simple and not depending on anything special, and it's the way you should do it. If you need something that removes subdirectories and their contents as well, use recursion: #pre To spare subdirectories and their contents (part of your question), modify as follows: #pre Or, since you wanted a one-line solution: for(args) if(args) file.delete(args); Using an external library for such a trivial task is not a good idea unless you need this library for something else anyway, in which case it is preferrable to use existing code. You appear to be using the Apache library anyway so use its FileUtils.cleanDirectory(args) method.

Question-23453287
One of the most useful features of Java 8 are the new default methods on interfaces. There are essentially two reasons (there may be others) why they have been introduced: #li Providing actual default implementations. Example: Iterator.remove() #li Allowing for JDK API evolution. Example: Iterable.forEach() From an API designer's perspective, I would have liked to be able to use other modifiers on interface methods, e.g. final . This would be useful when adding convenience methods, preventing "accidental" overrides in implementing classes: #pre The above is already common practice if Sender were a class: #pre Now, default and final are obviously contradicting keywords, but the default keyword itself would not have been strictly required , so I'm assuming that this contradiction is deliberate, to reflect the subtle differences between "class methods with body" (just methods) and "interface methods with body" (default methods), i.e. differences which I have not yet understood. At some point of time, support for modifiers like static and final on interface methods was not yet fully explored, citing Brian Goetz : #blockquote Since that time in late 2011, obviously, support for static methods in interfaces was added. Clearly, this added a lot of value to the JDK libraries themselves, such as with Comparator.comparing() . Question: What is the reason final (and also static final ) never made it to Java 8 interfaces?

Question-22435833
In Java 8, there is a new method String.chars() which returns a stream of int s ( IntStream ) that represent the character codes. I guess many people would expect a stream of char s here instead. What was the motivation to design the API this way?

Question-32164385, answer-32167166
#blockquote I must agree with other answers that there is no direct way to determine that method will modify your object or not and yes to make sure that method can not modify your Object you all have to do it is from your side. #blockquote Here the method name comes to the scene. Moving ahead with the naming convention of method we have to take a look at some method declarations which clearly convince you that your Object will not be changed at all. For example, You know that Arrays.copyOf will not change your actual array, System.out.println(args) will not change your boo Method names are real weapons to provide as much information as possible to the method user. (Yes! it's always not possible but quite a good practice to follow.) Let's consider it in your case that say printBoo will only print, copyBoo will only copy, clearBoo will reset all attributes, checkAndCreateNewBoo will check your boo Object and create new if required. So, ultimately if we can use them in a proper way caller can be assured with the fact that Object will remain the same after calling the method.

Question-17828584, answer-17836189
I think the others have done a good job at explaining why cnt > 0, but there's not enough details regarding why cnt = 4, and why cnt varies so widely among different settings. I will attempt to fill that void here. Let #li X be the total stack size #li M be the stack space used when we enter main the first time #li R be the stack space increase each time we enter into main #li P be the stack space necessary to run System.out.println When we first get into main, the space left over is X-M. Each recursive call takes up R more memory. So for 1 recursive call (1 more than original), the memory use is M + R. Suppose that StackOverflowError is thrown after C successful recursive calls, that is, M + C * R <= X and M + C * (R + 1) > X. At the time of the first StackOverflowError, there's X - M - C * R memory left. To be able to run System.out.prinln , we need P amount of space left on the stack. If it so happens that X - M - C * R >= P, then 0 will be printed. If P requires more space, then we remove frames from the stack, gaining R memory at the cost of cnt++. When println is finally able to run, X - M - (C - cnt) * R >= P. So if P is large for a particular system, then cnt will be large. Let's look at this with some examples. Example 1: Suppose #li X = 100 #li M = 1 #li R = 2 #li P = 1 Then C = floor((X-M)/R) = 49, and cnt = ceiling((P - (X - M - C*R))/R) = 0. Example 2: Suppose that #li X = 100 #li M = 1 #li R = 5 #li P = 12 Then C = 19, and cnt = 2. Example 3: Suppose that #li X = 101 #li M = 1 #li R = 5 #li P = 12 Then C = 20, and cnt = 3. Example 4: Suppose that #li X = 101 #li M = 2 #li R = 5 #li P = 12 Then C = 19, and cnt = 2. Thus, we see that both the system (M, R, and P) and the stack size (X) affects cnt. As a side note, it does not matter how much space catch requires to start. As long as there is not enough space for catch , then cnt will not increase, so there are no external effects. EDIT I take back what I said about catch . It does play a role. Suppose it requires T amount of space to start. cnt starts to increment when the leftover space is greater than T, and println runs when the leftover space is greater than T + P. This adds an extra step to the calculations and further muddies up the already muddy analysis. EDIT I finally found time to run some experiments to back up my theory. Unfortunately, the theory doesn't seem to match up with the experiments. What actually happens is very different. Experiment setup: Ubuntu 12.04 server with default java and default-jdk. Xss starting at 70,000 at 1 byte increments to 460,000. The results are available at: #a I've created another version where every repeated data point is removed. In other words, only points that are different from the previous are shown. This makes it easier to see anomalies. #a

Question-14636178
I am trying to use the org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy in my Spring project, but I am not sure how to use it or whether it's exactly what I am looking for. I realize it can help make my DAOs work with a plain JDO PersistenceManagerFactory . Another question is: what happens if the proxy doesn't get made properly? Can I still use it to access my factory to create a transaction aware persistence manager? If the object managed by the factory is a singleton, does this change things? Why not just access the PersistenceManagerFactory directly? Perhaps PersistenceManagerFactoryUtils.getPersistenceManager would be more suited to my needs? Can getObject return null?

Question-27888429, answer-27888452
Alternative to @sol4me's solution: Stream.of(args) Of the difference between this and Arrays.stream(args) : it does make a difference if your array is of a primitive type. For instance, if you do: Arrays.stream(args) where someArray is a long[] , it will return a LongStream . Stream.of(args) , on the other hand, will return a Stream<T> with a single element.

Question-22182669, answer-22223113
The most common cause of StackOverFlowError is excessively deep or infinite recursion. For instance: #pre In Java: There are two areas in memory the heap and stack. The stack memory is used to store local variables and function call, while heap memory is used to store objects in Java. If there is no memory left in stack for storing function call or local variable, JVM will throw java.lang.StackOverFlowError while if there is no more heap space for creating object, JVM will throw java.lang.OutOfMemoryError

Question-32475166, answer-32475290
The chief difference is that an if else block is a statement whereas the ternary (more often known as the conditional operator in Java) is an expression . A statement can do things like return to the caller on some of the control paths. An expression can be used in an assignment: int n = condition ? 3 : 2; So the two expressions in the ternary after the condition need to be coercable to the same type. This can cause some odd effects in Java particularly with auto-boxing and automatic reference casting - this is what the comment in your posted code is referring to. The coercion of the expressions in your case would be to a java.lang.reflect.Executable type (as that's the most specialised type ) and that does not exist in older versions of Java. Stylistically you should use an if else block if the code is statement-like, and a ternary if it's expression-like. Of course, you can make an if else block behave like an expression if you use a lambda function.

Question-23114015, answer-32874755
If you know the size you could use java.util.Collection which provides the stream(args) method: #pre And then: new Hand(args).stream(args).map(args) I faced the same problem and was surprised that my Iterable implementation could be very easily extended to an AbstractCollection implementation by simply adding the size(args) method (luckily I had the size of the collection :-) You should also consider to override Spliterator<T> spliterator(args) .

Question-31696485, answer-31696584
Your question is based on assumption that the code which may throw NullPointerException is worse than the code which may not. This assumption is wrong. If you expect that your foobar is never null due to the program logic, it's much better to use Optional.of(args) as you will see a NullPointerException which will indicate that your program has a bug. If you use Optional.ofNullable(args) and the foobar happens to be null due to the bug, then your program will silently continue working incorrectly, which may be a bigger disaster. This way an error may occur much later and it would be much harder to understand at which point it went wrong.
Question-18263489, answer-29873100
It isn't pretty, but String.valueOf(args) allows you to use a null String in a switch. If it finds null , it converts it to StringLiteral , otherwise it just returns the same String you passed it. If you don't handle StringLiteral explicitly, then it will go to default . The only caveat is that there is no way of distinguishing between the String StringLiteral and an actual null String. #pre

Question-5785745, answer-34845194
You can also use Arrays.copyOfRange . Example : #pre This method is similar to Arrays.copyOf , but it's more flexible. Both of them use System.arraycopy under the hood. See : #li #a #li #a #li #a

Question-16148575, answer-16148619
use int as Object not as primitive type HashMap<T> myMap = new HashMap<T>(args);

Question-7488643, answer-7488710
Arrays.asList returns a fixed-size List backed by the array. If you want a normal mutable java.util.ArrayList you need to do this: List<T> list = new ArrayList<T>(args); Or, using Guava : List<T> list = Lists.newArrayList(args); Using a Splitter gives you more flexibility in how you split the string and gives you the ability to, for example, skip empty strings in the results and trim results. It also has less weird behavior than String.split as well as not requiring you to split by regex (that's just one option).

Question-27482579
How is the compiler not complaining when I write the following code? #pre Even though it is an instance of the same class in which testPrivate is written, shouldn't it give a compilation error at System.out.println(args) ? After all, I am trying to access a private variable directly. The code even runs fine.

Question-10786042, answer-25735202
You need to first create a URI like: #pre Then convert that Uri to ASCII string: urlStr=uri.toASCIIString(args); Now your url string is completely encoded first we did simple url encoding and then we converted it to ASCII String to make sure no character outside US-ASCII are remaining in string. This is exactly how browsers do.

Question-9510125, answer-9511880
validate(args) : In Swing when you create Component, it is not valid i.e. it's valid property is false . A component is said to be valid, when it's width, height, location and stuff has been determined. This is usually done by calling their validate(args) method, directly or indirectly. When we call validate(args) on containers, it will validate the container (if it is invalid) by calling its doLayout(args) method, which typically will invoke the LayoutManager . Now each child placed on this container will be validated recursively, so that the entire tree will be laid out and will become valid. revalidate(args) : revalidate(args) is to be called when you change an attribute that would affect their width/height and call repaint() when you change an attribute that would affect their appearance. For Example, If your JFrame contains a JPanel , now at certain point of time you removed that JPanel and inserted a new one in it's place, depending on the contents of the newly placed JPanel , the size of the components inside the JPanel as well as The CONTAINER itself (by virtue of the layout manager used by it), changes. Which pushes it to the invalidate state. So in order to validate this change, you have to explicitly call revalidate(args) . invalidate(args) : This thing is something, I had never used, so might be not much of the info I can give. But seems like the scenario presented above, can give a bit of hint, as to what happens in invalidate(args) .

Question-22561614
Note: this question originates from a dead link which was a previous SO question, but here goes... See this code (note: I do know that this code won't "work" and that Integer::compare should be used -- I just extracted it from the linked question): #pre According to the javadoc of .min() and .max() , the argument of both should be a Comparator . Yet here the method references are to static methods of the Integer class. So, why does this compile at all?

Question-14534767, answer-33687544
For HTML response below code can be used bufString.append(args);

Question-32623834, answer-32624143
You just changed the String of String constant pool Mario to Luigi which was referenced by multiple String s, so every referencing literal Mario is now Luigi . Field stringValue = String.class.getDeclaredField(args); You have fetched the char[] named value field from class String stringValue.setAccessible(args); Make it accessible. stringValue.set(args); You changed original String field to Luigi . But original is Mario the String literal and literal belongs to the String pool and all are interned . Which means all the literals which has same content refers to the same memory address. #pre Basically you have changed the Mario of String pool which got reflected in all the referencing fields. If you create String Object (i.e. new String(args) ) instead of literal you will not face this behavior because than you will have two different Mario s .

Question-28584669, answer-28596792
To me, it seems that "because it should behave the same as zero" would make a good answer. Arithmetic overflow and underflow should be handlable similarly. If you underflow from the largest near-infinitesimally small value which can be stored in a float, you get zero, and zeros compare as identical. If you overflow from the largest near-infinitely large value which can be stored in a float, you get INF, and INFs compare as identical. This means that code which handles numbers which are out-of-scope in both directions will not require separate special-casing for one or the other. Instead, either both or neither will need to be treated differently. And the simplest requirement is covered by the "neither" case: you want to check if something over/underflowed, you can compare it to zero/INF using just the normal arithmetic comparison operators, without needing to know you current language's special syntax for the checking command: is it Math.isInfinite(), Float.checkForPositiveInfinity(), hasOverflowed()...?

Question-23699371
In Java 8 how can I filter a collection using the Stream API by checking the distinctness of a property of each object? For example I have a list of Person object and I want to remove people with the same name, persons.stream(args).distinct(args); Will use the default equality check for a Person object, so I need something like, persons.stream(args).distinct(args); Unfortunately the distinct(args) method has no such overload. Without modifying the equality check inside the Person class is it possible to do this succinctly?

Question-16635398
Which of the following is better practice in Java 8? Java 8: joins.forEach(args); Java 7: #pre I have lots of for loops that could be "simplified" with lambdas, but is there really any advantage of using them including performance and readability? EDIT I'll also extend this question to longer methods - I know that you cant return or break the parent function from a lambda and this should be mentioned to if they are compared, but is there anything else to be considered?

Question-25850328, answer-25850576
#li Is the definition of a marker interface mentioned above in 1st point wrong? - It is correct in the parts that (1) a marker interface must be empty, and (2) implementing it is meant to imply some special treatment of the implementing class. The part that is incorrect is that it implies that JVM or the compiler would treat the objects of that class differently: you are correct in observing that it is the code of Java class library that treats these objects as cloneable, serializable, etc. It has nothing to do with the compiler or the JVM. #li instead of using the instanceOf operator why can't the method be something like writeObject(args) so that there is a compile-time type checking - This lets you avoid polluting your code with the name of the marker interface when a "plain Object " is needed. For example, if you make a class that needs to be serializable, and has object members, you would be forced to either do casting or make your objects Serializable at compile time. This is inconvenient, because the interface is devoid of any functionality. #li How Annotations are better than Marker Interfaces? - They let you achieve the same purpose of conveying metadata about the class to its consumers without creating a separate type for it. Annotations are more powerful, too, letting programmers pass more sophisticated information to classes that "consume" it.

Question-8579657, answer-13134221
Actually Thread.start(args) creates a new thread and have its own execution scenario. Thread.start(args) calls the run(args) method asynchronously,which changes the state of new Thread to Runnable. But Thread.run(args) does not create any new thread. Instead it execute the run method in the current running thread synchronously. If you are using Thread.run(args) then you are not using the features of multi threading at all.

Question-5585779, answer-33233407
We can use the parseInt(args) method of the Integer wrapper class for converting a String value to an integer value. For example: #pre The Integer class also provides the valueOf(args) method: #pre We can also use toInt(args) of NumberUtils Utility Class for the conversion: #pre

Question-9481865, answer-9482369
This could be a bit tricky in the most general case. On the face of it, InetAddress.getLocalHost(args) should give you the IP address of this host. The problem is that a host could have lots of network interfaces, and an interface could be bound to more than one IP address. And to top that, not all IP addresses will be reachable outside of your machine or your LAN. For example, they could be IP addresses for virtual network devices, private network IP addresses, and so on. What this means is that the IP address returned by InetAddress.getLocalHost(args) might not be the right one to use. How can you deal with this? #li One approach is to use NetworkInterface.getNetworkInterfaces(args) to get all of the known network interfaces on the host, and then iterate over each NI's addresses. #li Another approach is to (somehow) get the externally advertized FQDN for the host, and use InetAddress.getByName(args) to look up the primary IP address. (But how do you get it, and how do you deal with a DNS-based load balancer?) #li A variation of the previous is to get the preferred FQDN from a config file or a command line parameter. #li Another variation is to get the preferred IP address from a config file or a command line parameter. In summary, InetAddress.getLocalHost(args) will typically work, but you may need to provide an alternative method for the cases where your code is run in an environment with "complicated" networking. #blockquote #li Any address in the range 127.xxx.xxx.xxx is a "loopback" address. It is only visible to "this" host. #li Any address in the range 192.168.xxx.xxx is a private (aka site local) IP address. These are reserved for use within an organization. The same applies to 10.xxx.xxx.xxx addresses, and 172.16.xxx.xxx through 172.31.xxx.xxx. #li Addresses in the range 169.254.xxx.xxx are link local IP addresses. These are reserved for use on a single network segment. #li Addresses in the range 224.xxx.xxx.xxx through 239.xxx.xxx.xxx are multicast addresses. #li The address 255.255.255.255 is the broadcast address. #li Anything else should be a valid public point-to-point IPv4 address. In fact, the InetAddress API provides methods for testing for loopback, link local, site local, multicast and broadcast addresses. You can use these to sort out which of the IP addresses you get back is most appropriate.

Question-20945049, answer-20945268
In Java, if two string primitive variables are initialized to the same literal, it assigns the same reference to both variables: #pre #blockquote That is the reason the comparison returns true. The third string is created using substring(args) which makes a new string instead of pointing to the same. #blockquote When you access a string using reflection, you get the actual pointer: #pre So change to this will change the string holding a pointer to it, but as s3 is created with a new string due to substring(args) it would not change. #blockquote

Question-14316487, answer-14316543
A very simple implementation with String.split() : #pre

Question-23932061, answer-23932216
You can easily create a Stream out of an Iterable or Iterator : #pre

Question-12468764, answer-13368831
Actual Answer: The default deserializer for enums uses .name(args) to deserialize, so it's not using the @JsonValue . So as @OldCurmudgeon pointed out, you'd need to pass in {StringLiteral: StringLiteral} to match the .name(args) value. An other option (assuming you want the write and read json values to be the same)... More Info: There is (yet) another way to manage the serialization and deserialization process with Jackson. You can specify these annotations to use your own custom serializer and deserializer: #pre Then you have to write MySerializer and MyDeserializer which look like this: MySerializer #pre MyDeserializer #pre Last little bit, particularly for doing this to an enum JsonEnum that serializes with the method getYourValue(args) , your serializer and deserializer might look like this: #pre

Question-8189466
Note: I am aware of the Iterator#remove(args) method. In the following code sample, I don't understand why the List.remove in main method throws ConcurrentModificationException but not in the remove method. #pre

Question-32175145, answer-32182250
Integer a.equals( a ) can return false But you have to be really evil and use reflections and Multithreading: If you run this code, there is a chance that a racing condition can change the internal Value of myInt while the comparision takes place. If you want to simulate this condition, just set a breakpoint inside of Integer.intValue(args) run the code in debug and hit continue. This will create a delay which creates the race condition artificially and the console will return false. #pre

Question-8725387, answer-8725470
List iterators guarantee first and foremost that you get the list's elements in the internal order of the list (aka. insertion order ). More specifically it is in the order you've inserted the elements or on how you've manipulated the list. Sorting can be seen as a manipulation of the data structure, and there are several ways to sort the list. I'll order the ways in the order of usefulness as I personally see it: 1. Consider using Set or Bag collections instead NOTE: I put this option at the top because this is what you normally want to do anyway. A sorted set automatically sorts the collection at insertion , meaning that it does the sorting while you add elements into the collection. It also means you don't need to manually sort it. Furthermore if you are sure that you don't need to worry about (or have) duplicate elements then you can use the TreeSet<T> instead. It implements SortedSet and NavigableSet interfaces and works as you'd probably expect from a list: #pre If you don't want the natural ordering you can use the constructor parameter that takes a Comparator<T> . Alternatively you can use Multisets (also known as Bags ) , that is a Set that allows duplicate elements, instead and there are third party implementations of them. Most notably from the Guava libraries there is a TreeMultiset , that works a lot like the TreeSet . 2. Sort your list with Collections.sort(args) As mentioned above, sorting of List s is an manipulation of the data structure. So for situations where you need "one source of truth" that will be sorted in a variety of ways then sorting it manually is the way to go. You can sort your list with the java.util.Collections.sort() method. Here is a code sample on how: #pre Using comparators One clear benefit is that you may use Comparator in the sort method. Java also provides some implementations for the Comparator such as the Collator which is useful for locale sensitive sorting strings. Here is one example: #pre Sorting in concurrent environments Do note though that using the sort method is not friendly in concurrent environments, since the collection instance will be manipulated, and you should consider using immutable collections instead. This is something Guava provides in the Ordering class and is a simple one-liner: List<T> sorted = Ordering.natural(args).sortedCopy(args); 3. Wrap your list with java.util.PriorityQueue Though there is no sorted list in Java there is however a sorted queue which would probably work just as well for you. It is the java.util.PriorityQueue class. Nico Haase linked in the comments to a related question that also answers this. In a sorted collection you most likely don't want to manipulate the internal data structure which is why PriorityQueue doesn't implement the List interface (because that would give you direct access to it's elements). Caveat on the PriorityQueue iterator The PriorityQueue class implements the Iterable<T> and Collection<T> interfaces so it can be iterated as usual. However the iterator is not guaranteed to return elements in the sorted order. Instead (as Alderath points out in the comments) you need to poll(args) the queue until empty. Note that you can convert a list to a priority queue via the constructor that takes any collection : #pre 4. Write your own SortedList class NOTE: You shouldn't have to do this. You can write your own List class that sorts each time you add a new element. This can get rather computation heavy depending on your implementation and is pointless , unless you want to do it as an exercise, because of two main reasons: #li It breaks the contract that List<T> interface has, because the add methods should ensure that the element will reside in the index that the user specifies. #li Why reinvent the wheel? You should be using the TreeSet or Multisets instead as pointed out in the first point above. However if you want to do it as an exercise here is a code sample to get you started, it uses the AbstractList abstract class: #pre Note that if you haven't overridden the methods you need, then the default implementations from AbstractList will throw UnsupportedOperationException s.

Question-29183904
I used to define a set of related constants like Bundle keys together in an interface like below: #pre This provides me a nicer way to group related constants together and used them by making a static import (not implements). I know Android framework also uses the constants in same way like Toast.LENTH_LONG , View.GONE . However, I often feel that the Java Enums provide much better and powerful way to represent the constant. But is there a performence issue in using enums on Android ? With a bit of research I ended up in confusion. From this question "Avoid Enums Where You Only Need Ints” removed from Android's performance tips? it's clear that Google has removed "Avoid enums" from its performance tips, but from it's official training docs Be aware of memory overhead section it clearly says: "Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android." Is this still holds good? (say in Java versions after 1.6) One more issue that I observed is to send enums across intents using Bundle I should send them by serializing (i.e putSerializable(args) , that I think an expensive operation compared to primitive putString(args) method, eventhough enums provides it for free). Can someone please clarify which one is the best way to represent the same in Android ? Should I strictly avoid using enums on Android ?

Question-5439529
I'm trying to determine if a particular item in an Array of strings is an integer or not. I am .split(args)'ing an infix expression in String form, and then trying to split the resultant array into two arrays; one for integers, one for operators, whilst discarding parentheses, and other miscellaneous items. What would be the best way to accomplish this? I thought I might be able to find a Integer.isInteger(args) method or something, but no such luck.

Question-13659217
I declare an enum as : enum Sex {MALE,FEMALE}; And then, iterate enum as shown below : #pre I checked the Java API but can't find the values() method? I'm curious as to where this method comes from? API link : #a

Question-29691513, answer-29727412
The JLS describes a few special behaviors of what it calls constant variables , which are final variables (whether static or not) which are initialized with constant expressions of String or primitive type. Constant variables have a major difference with respect to binary compatibility: the values of constant variables become part of the class's API, as far as the compiler is concerned. An example: #pre Here, XFOO is a "constant variable" and YFOO is not, but they are otherwise equivalent. Class Z prints out each of them. Compile those classes, then disassemble them with javap -v X Y Z , and here is the output: Class X: #pre Class Y: #pre Class Z: #pre Things to notice in the disassembly, which tell you the differences between X and Y run deeper than syntactic sugar: #li XFOO has a ConstantValue attribute, signifying that its value is a compile-time constant. Whereas YFOO does not, and uses a static block with a putstatic instruction to initialize the value at runtime. #li The String constant StringLiteral has become part of class Z 's constant pool , but StringLiteral has not. #li Z.main uses the ldc (load constant) instruction to load StringLiteral onto the stack directly from its own constant pool, but it uses a getstatic instruction to load the value of Y.YFOO . Other differences you will find: #li If you change the value of XFOO and recompile X.java but not Z.java , you have a problem: class Z is still using the old value. If you change the value of YFOO and recompile Y.java , class Z uses the new value whether you recompile Z.java or not. #li If you delete the X.class file entirely, class Z still runs correctly. Z has no runtime dependency on X . Whereas if you delete the Y.class file, class Z fails to initialize with a ClassNotFoundException: Y . #li If you generate documentation for the classes with javadoc, the "Constant Field Values" page will document the value of XFOO , but not the value of YFOO . The JLS describes the above effects constant variables have on compiled class files in §13.1.3 : #blockquote And in §13.4.9 : #blockquote The upshot is that if your public library exposes any constant variables, you must never change their values if your new library version is otherwise supposed to be compatible with code compiled against old versions of the library. It won't necessarily cause an error, but the existing code will probably malfunction since it will have outdated ideas about the values of constants. (If your new library version needs for classes which use it to be recompiled anyway, then changing constants doesn't cause this problem.) Thus, initializing a constant with a block gives you more freedom to change its value, because it prevents the compiler embedding the value into other classes.

Question-28459498, answer-28460301
Stream s are built around Spliterator s which are stateful, mutable objects. They don’t have a “reset” action and in fact, requiring to support such rewind action would “take away much power”. How would Random.ints() be supposed to handle such a request? On the other hand, for Stream s which have a retraceable origin, it is easy to construct an equivalent Stream to be used again. Just put the steps made to construct the Stream into a reusable method. Keep in mind that repeating these steps is not an expensive operation as all these steps are lazy operations; the actual work starts with the terminal operation and depending on the actual terminal operation entirely different code might get executed. It would be up to you, the writer of such a method, to specify what calling the method twice implies: does it reproduce exactly the same sequence, as streams created for an unmodified array or collection do, or does it produce a stream with a similar semantics but different elements like a stream of random ints or a stream of console input lines, etc. By the way, to avoid confusion, a terminal operation consumes the Stream which is distinct from closing the Stream as calling close(args) on the stream does (which is required for streams having associated resources like, e.g. produced by Files.lines(args) ). It seems that a lot of confusion stems from misguiding comparison of IEnumerable with Stream . An IEnumerable represents the ability to provide an actual IEnumerator , so its like an Iterable in Java. In contrast, a Stream is a kind of iterator and comparable to an IEnumerator so it’s wrong to claim that this kind of data type can be used multiple times in .NET, the support for IEnumerator.Reset is optional. The examples discussed here rather use the fact that an IEnumerable can be used to fetch new IEnumerator s and that works with Java’s Collection s as well; you can get a new Stream . If the Java developers decided to add the Stream operations to Iterable directly, with intermediate operations returning another Iterable , it was really comparable and it could work the same way. However, the developers decided against it and the decision is discussed in this question . The biggest point is the confusion about eager Collection operations and lazy Stream operations. By looking at the .NET API, I (yes, personally) find it justified. While it looks reasonable looking at IEnumerable alone, a particular Collection will have lots of methods manipulating the Collection directly and lots of methods returning a lazy IEnumerable , while the particular nature of a method isn’t always intuitively recognizable. The worst example I found (within the few minutes I looked at it) is List.Reverse() whose name matches exactly the name of the inherited (is this the right terminus for extension methods?) Enumerable.Reverse() while having an entirely contradicting behavior. Of course, these are two distinct decisions. The first one to make Stream a type distinct from Iterable / Collection and the second to make Stream a kind of one time iterator rather than another kind of iterable. But these decision were made together and it might be the case that separating these two decision never was considered. It wasn’t created with being comparable to .NET’s in mind. The actual API design decision was to add an improved type of iterator, the Spliterator . Spliterator s can be provided by the old Iterable s (which is the way how these were retrofitted) or entirely new implementations. Then, Stream was added as a high-level front-end to the rather low level Spliterator s. That’s it. You may discuss about whether a different design would be better, but that’s not productive, it won’t change, given the way they are designed now. There is another implementation aspect you have to consider. Stream s are not immutable data structures. Each intermediate operation may return a new Stream instance encapsulating the old one but it may also manipulate its own instance instead and return itself (that doesn’t preclude doing even both for the same operation). Commonly known examples are operations like parallel or unordered which do not add another step but manipulate the entire pipeline). Having such a mutable data structure and attempts to reuse (or even worse, using it multiple times at the same time) doesn’t play well… For completeness, here is your quicksort example translated to the Java Stream API. It shows that it does not really “take away much power”. #pre It can be used like #pre You can write it even more compact as #pre

Question-5038204, answer-5039178
The commons/lang builders are great and I have been using them for years without noticeable performance overhead (with and without hibernate). But as Alain writes, the Guava way is even nicer: Here's a sample Bean: #pre Here's equals() and hashCode() implemented with Commons/Lang: #pre and here with Guava: #pre As you can see the Guava version is shorter and avoids superfluous helper objects. In case of equals, it even allows for short-circuiting the evaluation if an earlier Object.equal(args) call returns false (to be fair: commons / lang has an ObjectUtils.equals(args) method with identical semantics which could be used instead of EqualsBuilder to allow short-circuiting as above). So: yes, the commons lang builders are very preferable over manually constructed equals(args) and hashCode(args) methods (or those awful monsters Eclipse will generate for you), but the Guava versions are even better. And a note about Hibernate: be careful about using lazy collections in your equals(), hashCode() and toString() implementations. That will fail miserably if you don't have an open Session. Note (about equals()): a) in both versions of equals() above, you might want to use one or both of these shortcuts also: #pre b) depending on your interpretation of the equals() contract, you might also change the line(s) if(args){ to #pre If you use the second version, you probably also want to call super(args) inside your equals(args) method. Opinions differ here, the topic is discussed in this question: #blockquote (although it's about hashCode(args) , the same applies to equals(args) ) Note (inspired by Comment from kayahr ) Objects.hashCode(args) (just as the underlying Arrays.hashCode(args) ) might perform badly if you have many primitive fields. In such cases, EqualsBuilder may actually be the better solution.

Question-21163108, answer-34930831
To measure the actual number of used threads, you can check Thread.activeCount(args) : #pre This can produce on a 4-core CPU an output like: #pre Without .parallel(args) it gives: #pre

Question-29229373, answer-33839551
In my free StreamEx library I introduced the short-circuiting collectors. When collecting sequential stream with short-circuiting collector (like MoreCollectors.first() ) exactly one element is consumed from the source. Internally it's implemented in quite dirty way: using a custom exception to break the control flow. Using my library your sample could be rewritten in this way: #pre The result is the following: #pre

Question-31202946, answer-31203218
You can of course choose to shoot yourself in the foot, but that doesn't mean you must. #blockquote Because the recommended way to create a start a thread is not to subclass Thread. The recommended way is to define a Runnable , and pass it as argument to the Thread constructor: #pre #blockquote Yes and no. You can't replace the implementation of start() by your own implementation, but you can do additional things in start() if you want: #pre That said, if Java was redesigned from scratch today, there is a good chance the design would be different. Remember that this class dates from Java 1.0, and is still backward-compatible.

Question-4759570, answer-19459145
This works on Windows with Cygwin installed: System.getenv(args)

Question-31170459, answer-31170506
No, you appear to have a legit bug. The bug presents in JDK7 but fixed in JDK8. Your values are correctly representable as BigDecimal s, and should behave correctly, but don't. Tracing through the source code of BigDecimal , on line 2585, this.precision(args) is 1, and this.scale is -2147483647 . this.precision(args) - this.scale therefore overflows, and the following overflow is not handled correctly. This bug has been fixed in JDK8 by doing the subtraction in long arithmetic .

Question-5585779, answer-5585800
int foo = Integer.parseInt(args); See the Java Documentation for more information. (If you have it in a StringBuilder (or the ancient StringBuffer ), you'll need to do Integer.parseInt(args); instead).

Question-16252269, answer-29652714
You can use Collections.sort(args) to sort list if your list contains Comparable elements. Otherwise I would recommend you to implement that interface like here: public class Circle implements Comparable<T> {} and of course provide your own realization of compareTo method like here: #pre And then you can again use Colection.sort(args) as now list contains objects of Comparable type and can be sorted. Order depends on compareTo method. Check this #a for more detailed information.

Question-5243754, answer-13612866
It is crucial to know that attributes are not parameters . The return type for attributes is an Object , whereas the return type for a parameter is a String . When calling the getAttribute(args) method, bear in mind that the attributes must be cast. Additionally, there is no servlet specific attributes , and there are no session parameters . This post is written with the purpose to connect on @Bozho's response, as additional information that can be useful for other people.

Question-26791441, answer-26826286
It's easy to write a method to do this using String.regionMatches : #pre Testing: #pre Output: #blockquote It is not immediately obvious, but a function like this can still be dependent on the order in which the replacements are specified. Consider: #pre Output: #blockquote But reverse the replacements: truth += StringLiteral + simultaneousReplace(args); Output: #blockquote Oops! :) Therefore it is sometimes useful to make sure to look for the longest match (as PHP's strtr function does, for example). This version of the method will do that: #pre Note that the above methods are case-sensitive. If you need a case-insensitive version it is easy to modify the above because String.regionMatches can take an ignoreCase parameter.

Question-17781150, answer-17781168
The value you are looking for is Integer.MIN_VALUE . #blockquote That's off-topic for Stack Exchange. But you could do it starting from the definition of Java integers ( JLS 4.2 ) #blockquote and #blockquote and the definition of the Java unary '-' operator ( JLS 15.15.4 ): #blockquote

Question-13102045, answer-24907860
Instead of input.nextLine(args) use input.next(args) , that should solve the problem. Modified code: #pre

Question-10827872, answer-30749407
replace(args) method doesn't uses regex pattern whereas replaceAll(args) method uses regex pattern. So replace(args) performs faster than replaceAll(args) .

Question-13102045
I am using Scanner methods nextInt(args) and nextLine(args) for reading input. Basically, it looks like this: #pre The problem is that after entering the numerical value, the first input.nextLine(args) is skipped and the second input.nextLine(args) is executed, so that my output looks like this: #pre I tested my application and it looks like the problem lies in using input.nextInt(args) . If I delete it, then both string1 = input.nextLine(args) and string2 = input.nextLine(args) are executed as I want them to be.

Question-9297899, answer-25816501
Even though this is not a direct answer to the question, it is an addition to the .length vs .size(args) argument. I was researching something related to this question so when I came across it I noticed that the definition(s) provided here #blockquote is not "exactly" correct. The field length contains the number of available places to put a component, not the number of components present in the array. So it represents the total available memory allocated to that array, not how much of that memory is filled. #img Example: #pre Output: #pre However, the .size(args) property of the ArrayList does give the number of elements in the list: #pre Output: #pre

Question-29095967, answer-29097694
Please do not vote. I do not have enough place to explain this in comments . This is a solution with a Stream and a foreach but this is strictly equivalent to Alexis's solution or a foreach loop (and less clear, and I could not get rid of the copy constructor) : #pre I understand that you want to find a more elegant solution with Java 8 but I truly think that it has not been designed for this case. And as said by Mr spoon, highly prefer the naive way in this case.

Question-8894258, answer-8894384
This is just micro-optimisation that you shouldn't worry about. char[] chars = str.toCharArray(args); returns you a copy of str character arrays (in JDK, it returns a copy of characters by calling System.arrayCopy ). Other than that, str.charAt(args) only checks if the index is indeed in bounds and returns a character within the array index. The first one doesn't create additional memory in JVM.

Question-10796160, answer-21025279
Use proper escaping: string.split(args) Or the helper Regexp.quote(args) which has been created for exactly this purpose: string.split(args) which works with arbitrary input strings. Very useful when you need to quote / escape user input.

Question-22740464
I can add streams or extra elements, like this: Stream stream = Stream.concat(stream1, Stream.concat(args); And I can add new stuff as I go, like this: Stream stream = Stream.concat(args) .filter(args); But this is ugly, because concat is static. If concat were an instance method, the above examples would be much easier to read: Stream stream = stream1.concat(args).concat(args); And Stream stream = stream1 .filter(args) .concat(args) .filter(args) .concat(args) .filter(args); My question is: 1) Is there any good reason why concat is static? Or is there some equivalent instance method I'm missing? 2) In any case, is there a better way of doing this?

Question-6416706, answer-6416800
With Guava you can use Lists.newArrayList(Iterable) or Sets.newHashSet(Iterable) , among other similar methods. This will of course copy all the elements in to memory. If that isn't acceptable, I think your code that works with these ought to take Iterable rather than Collection . Guava also happens to provide convenient methods for doing things you can do on a Collection using an Iterable (such as Iterables.isEmpty(args) or Iterables.contains(args) ), but the performance implications are more obvious.
Question-5585779, answer-35834484
Integer.decode You can also use public static Integer decode(args) throws NumberFormatException . It also works for base 8 and 16: #pre If you want to get int instead of Integer you can use: #li Unboxing: int val = Integer.decode(args); #li intValue(args) : Integer.decode(args).intValue(args);

Question-8777257, answer-8777312
Arrays inherit equals(args) from Object and hence compare only returns true if comparing an array against itself. On the other hand, Arrays.equals compares the elements of the arrays. This snippet elucidates the difference: #pre See also Arrays.equals() . Another static method there may also be of interest: Arrays.deepEquals() .

Question-18448671, answer-26937769
Though one answer is accepted and this is an old one, I thought posting this answer as it does not use Iterator #pre

Question-19416644, answer-19775881
Create your own class System in tha same package with Condition . In this case your System class will hide java.lang.System class #pre Ideone DEMO

Question-23653778, answer-25564062
Try OnStart(args) method and just use View view = getView(args).findViewById(args); or Declare any View using getView(args).findViewById method in onStart(args) Declare click listener on view by anyView.setOnClickListener(args);

Question-14491966, answer-14526729
The real problem with this is that it's output histogram is dependent on the initial seed far to much - much of the time it will end up with a near uniform output but a lot of the time will have distinctly un-uniform output. Inspired by this article about how bad php's rand() function is , I made some random matrix images using QuickRandom and System.Random . This run shows how sometimes the seed can have a bad effect (in this case favouring lower numbers) where as System.Random is pretty uniform. QuickRandom #img System.Random #img Even Worse If we initialise QuickRandom as new QuickRandom(args) we get this image: #img The Code #pre

Question-29262002, answer-29262511
The first case is ok because you are invoking a "special" method (a constructor) and you are no actually taking the created object. Just to make it more clear, I'll put the optional braces in your lambdas: #pre And more clear, I'll translate that to the older notation: #pre In the first case you are executing a constructor, but you are NOT returning the created object, in the second case you are attempting to return a String value, but your method in your interface BiConsumer returns void, hence the compiler error.

Question-27949213, answer-27949581
Imagine you have a phone book, which contains people, which have a String firstName and a String lastName . And it happens that in your phone book, 100,000 people have the same firstName = StringLiteral . Because you get the data from a database or a file those strings are not interned so your JVM memory contains the char array {CharLiteral, CharLiteral, CharLiteral, CharLiteral} 100 thousand times, one per John string. Each of these arrays takes, say, 20 bytes of memory so those 100k Johns take up 2 MB of memory. With deduplication, the JVM will realise that "John" is duplicated many times and make all those John strings point to the same underlying char array, decreasing the memory usage from 2MB to 20 bytes. You can find a more detailed explanation in the JEP . In particular: #blockquote

Question-15156857
I have a method with a void return type. It can also throw a number of exceptions so I'd like to test those exceptions being thrown. All attempts have failed with the same reason: #blockquote Any ideas how I can get the method to throw a specified exception? doThrow(args).when(args);

Question-22561614, answer-22561687
This works because Integer::min resolves to an implementation of the Comparable<T> interface. The method reference of Integer::min resolves to Integer.min(args) , resolved to IntBinaryOperator , and presumably autoboxing occurs somewhere making it a BinaryOperator<T> . And the min(args) resp max(args) methods of the Stream<T> ask the Comparable<T> interface to be implemented. Now this resolves to the single method Integer compareTo(args) . Which is of type BinaryOperator<T> . And thus the magic has happened as both methods are a BinaryOperator<T> .

Question-29280857, answer-29382161
As stated previously, you should lock on both accounts, always in the same order. The key part, however, is ensuring both high granularity and singularity across the VM instance. This can be done using String.intern() : #pre

Question-11359187, answer-11359320
#li java.util.logging was introduced in Java 1.4. There were uses for logging before that, that's why many other logging APIs exist. Those APIs where used heavily before Java 1.4 and thus had a great marketshare that didn't just drop to 0 when 1.4 was release. #li JUL didn't start out all that great, many of the things you mentioned where a lot worse in 1.4 and only got better in 1.5 (and I guess in 6 as well, but I'm not too sure). #li JUL isn't well suited for multiple applications with different configurations in the same JVM (think multiple web applications that should not interact). Tomcat needs to jump through some hoops to get that working (effectively re-implementing JUL if I understood that correctly). #li You can't always influence what logging framework your libraries use. Therefore using SLF4J (which is actually just a very thin API layer above other libraries) helps keeping a somewhat consistent picture of the entire logging world (so you can decide the underlying logging framework while still having library logging in the same system). #li Libraries can't easily change. If a previous version of a library used to use logging-library-X it can't easily switch to logging-library-Y (for example JUL), even if the latter is clearly superious: any user of that library would need to learn the new logging framework and (at least) reconfigure their logging. That's a big no-no, especially when it brings no apparent gain to most people. Having said all that I think JUL is at least a valid alternative to other logging frameworks these days.

Question-4871051, answer-20810612
I'm on Linux and get same result for both of these approaches: #pre Paths.get("") docs System.getProperty("user.dir") docs

Question-16148575
I am trying to build a HashMap which will have integer as keys and objects as values. My syntax is: HashMap<T> myMap = new HashMap<T>(args); However, the error returned is - Syntax error on token "int", Dimensions expected after this token - I don't understand why I should add a dimension (ie: making the int into an array) since I only need to store a digit as key. What could I do? Thanks in advance! :)

Question-32820722, answer-32820984
Let's rewrite that lambda expression with parentheses to make it more clear: IntFunction<T> curriedAdd = a -> (b -> (a + b)); So we are declaring a function taking an int which returns a Function . More specifically, the function returned takes an int and returns an int (the sum of the two elements): this can be represented as an IntUnaryOperator . Therefore, curriedAdd is a function taking an int and returning an IntUnaryOperator , so it can be represented as IntFunction<IntUnaryOperator> .

Question-29140402, answer-29141638
Every class in java has toString(args) method in it by default, which is called by System.out.println(args) if you pass some object of a class to it. When you try to print object of a class, the System.out.println(args) method will call toString(args) of the class which returns the className@hashcode of that object. #pre You can override the toString method of a class to get different output. See this example #pre

Question-28276423, answer-28276498
Assuming all the streams get created okay, yes, just closing bw is fine with those stream implementations ; but that's a big assumption. I'd use try-with-resources ( tutorial ) so that any issues constructing the subsequent streams that throw exceptions don't leave the previous streams hanging, and so you don't have to rely on the stream implementation having the call to close the underlying stream: #pre Note you no longer call close at all. Important note : To have try-with-resources close them, you must assign the streams to variables as you open them, you cannot use nesting. If you use nesting, an exception during construction of one of the later streams (say, GZIPOutputStream ) will leave any stream constructed by the nested calls inside it open. From JLS §14.20.3 : #blockquote Note the word "variables" (my emphasis) . E.g., don't do this: #pre ...because an exception from the GZIPOutputStream(OutputStream) constructor (which says it may throw IOException , and writes a header to the underlying stream) would leave the FileOutputStream open. Since some resources have constructors that may throw and others don't, it's a good habit to just list them separately. We can double-check our interpretation of that JLS section with this program: #pre ...which has the output: #pre Note that there are no calls to close there. If we fix main : #pre then we get the appropriate close calls: #pre (Yes, two calls to InnerMost#close is correct; one is from Middle , the other from try-with-resources.)

Question-9481865
I am trying to develop a system where there are different nodes that are run on different system or on different ports on the same system. Now all the nodes create a Socket with a target IP as the IP of a special node known as a bootstrapping node. The nodes then create their own ServerSocket and start listening for connections. The bootstrapping node maintains a list of Nodes and returns them on being quired. Now what I need is the node must register its IP to the bootstrapping node. I tried using cli.getInetAddress(args) once the client connects to the ServerSocket of bootstrapping node but that didn't work. #li I need the client to register its PPP IP if available; #li Otherwise the LAN IP if available; #li Otherwise it must register 127.0.0.1 assuming its the same computer. Please help me with this. EDIT using the code: System.out.println(args); or System.out.println(args); My PPP Connection IP address is: 117.204.44.192 but the above returns me 192.168.1.2 EDIT2 I am using the following code: #pre I am able to get all the IP addresses associated all NetworkInterface s, but how do I distinguish them?? This is the output I am getting: #pre

Question-14376807, answer-22092971
For those looking for a general strategy for reading and writing a string to file: First, get a file object You'll need the storage path. For the internal storage, use: File path = context.getFilesDir(args); For the external storage (SD card), use: File path = context.getExternalFilesDir(args); Then create your file object: File file = new File(args); Write a string to the file #pre Or with Google Guava Files.write(args); Read the file to a string #pre Or if you are using Google Guava String contents = Files.toString(args); For completeness I'll mention String contents = new Scanner(args).useDelimiter(args).next(args); which requires no libraries, but benchmarks 50% - 400% slower than the other options (in various tests on my Nexus 5). Notes For each of these strategies, you'll be asked to catch an IOException. The default character encoding on Android is UTF-8. If you are using external storage, you'll need to add to your manifest either: <uses-permission android:name=StringLiteral/> or <uses-permission android:name=StringLiteral/> Write permission implies read permission, so you don't need both.

Question-8579657, answer-33375616
Most of these answers miss the big picture, which is that, as far as the Java language is concerned, there is no more difference between t.start(args) and r.run(args) than there is between any other two methods. They're both just methods. They both run in the thread that called them . They both do whatever they were coded to do, and then they both return, still in the same thread, to their callers. The biggest difference is that most of the code for t.start(args) is native code while, in most cases, the code for r.run(args) is going to be pure Java. But that's not much of a difference. Code is code. Native code is harder to find, and harder to understand when you find it, but it's still just code that tells the computer what to do. So, what does t.start(args) do? It creates a new native thread, it arranges for that thread to call t.run(args) , and then it tells the OS to let the new thread run. Then it returns. And what does r.run(args) do? The funny thing is, the person asking this question is the person who wrote it . r.run(args) does whatever you (i.e., the developer who wrote it) designed it to do. t.start(args) is the method that the library provides for your code to call when you want a new thread. r.run(args) is the method that you provide for the library to call in the new thread.

Question-22725537, answer-36334855
As my previous answer appeared not to be very popular, I will give this another go. A short answer: You are mostly on a right track. The shortest code to get to your desired output I could come up with is this: things.stream(args) .map(args) .filter(args) .findFirst(args) .flatMap(args); This will fit all your requirements: #li It will find first response that resolves to a nonempty Optional<T> #li It calls this::resolve lazily as needed #li this::resolve will not be called after first non-empty result #li It will return Optional<T> Longer answer The only modification compared to OP initial version was that I removed .map(args) before call to .findFirst(args) and added .flatMap(args) as the last call in the chain. This has a nice effect of getting rid of the double-Optional, whenever stream finds an actual result. You can't really go any shorter than this in Java. The alternative snippet of code using the more conventional for loop technique is going to be about same number of lines of code and have more or less same order and number of operations you need to perform: #li Calling this.resolve , #li filtering based on Optional.isPresent #li returning the result and #li some way of dealing with negative result (when nothing was found) Just to prove that my solution works as advertised, I wrote a small test program: #pre (It does have few extra lines for debugging and verifying that only as many calls to resolve as needed...) Executing this on a command line, I got the following results: #pre

Question-18410035, answer-37409771
In Java 8 collection classes that implement Iterable (for example all lists) now have forEach method: Arrays.asList(args).forEach(args); The above example makes use of method-reference introduced in Java 8. We can also iterate over a list using Stream as: Arrays.asList(args).stream(args).forEach(args); The advantage with later option is that we can also make use of parallel streams wherever appropriate. If the objective is only to print the items irrespective of the order then we can use parallel stream as: Arrays.asList(args).parallelStream(args).forEach(args);

Question-27845223, answer-27846417
Pavel Horal's answer is nice. As he says, the word "file" has totally different (practically unrelated) meanings in URL#getFile vs java.io.File - may be that's part of the confusion. Just to add: #li A resource in Java is an abstract concept, a source of data that can be read. The location (or address) of a resource is represented in Java by a URL object. #li A resource can correspond to a regular file in the local filesystem (specifically, when its URL begins with file:// ). But a resource is more general (it can be also some file stored in a jar, or some data to be read from the network, or from memory, or...). And it's also more limited, because a File (besides being other things than a regular file: a directory, a link) can also be created and writen to. #li Remember in Java a File object does not really represents "a file" but the location (the full name, with path) of a file. So, a File object allows you to locate (and open) a file, as a URL allows you to access (and open) a resource. (There is no Resource class in Java to represent a resource, but neither there is one to represent a file! once more : File is not a file, it's the path of a file).

Question-28276423, answer-28276497
No, the topmost level Stream or reader will ensure that all underlying streams / readers are closed. Check the close(args) method implementation of your topmost level stream.

Question-4576352
I can use this: #pre Is there a way to remove all occurrences of character X from a String in Java? I tried this and is not what I want: str.replace(args); //replace with space

Question-31419029, answer-31419047
An empty HashMap object is much smaller than an array of 2000 Object references. Even though you pass 2000 to the initialCapacity parameter of the HashMap constructor, it's not actually creating 2000 spaces for objects yet.

Question-5554217, answer-17300003
Another way is to use an array as a type, e.g.: MyClass[] mcArray = gson.fromJson(args); This way you avoid all the hassle with the Type object, and if you really need a list you can always convert the array to a list by: List<T> mcList = Arrays.asList(args); IMHO this is much more readable. And to make it be an actual list (that can be modified, see limitations of Arrays.asList(args) ) then just do the following: List<T> mcList = new ArrayList<T>(args);

Question-22694884, answer-39385411
As Collectors.toMap(args) uses a throwing merger to handle multiple entries with the same key it is easy: #pre You will get a IllegalStateException for duplicate keys. But at the end I am not sure if the code would not be even more readable using an if .

Question-32714194, answer-32714222
+ is implemented in java compilers . The compiler replaces String + String with either compile time constants or StringBuilder code. Note that this applies to primitives too. i.e, int i=1+2 could get directly replaced to int i=3 during compilation itself.

Question-18723596, answer-18723651
Println(args) uses String.valueOf(args) #pre Print(args) does null check. #pre

Question-22740464, answer-37436520
Just do: Stream.of(args).flatMap(args); where identity(args) is a static import of Function.identity(args) . Concatenating multiple streams into one stream is the same as flattening a stream. However, unfortunately, for some reason there is no flatten(args) method on Stream , so you have to use flatMap(args) with the identity function.
Question-18092160
Why were 181783497276652981 and 8682522807148012 chosen in Random.java ? Here's the relevant source code from Java SE JDK 1.7: #pre So, invoking new Random(args) without any seed parameter takes the current "seed uniquifier" and XORs it with System.nanoTime(args) . Then it uses 181783497276652981 to create another seed uniquifier to be stored for the next time new Random(args) is called. The literals 181783497276652981L and 8682522807148012L are not placed in constants, but they don't appear anywhere else. At first the comment gives me an easy lead. Searching online for that article yields the actual article . 8682522807148012 doesn't appear in the paper, but 181783497276652981 does appear -- as a substring of another number, 1181783497276652981 , which is 181783497276652981 with a 1 prepended. The paper claims that 1181783497276652981 is a number that yields good "merit" for a linear congruential generator. Was this number simply mis-copied into Java? Does 181783497276652981 have an acceptable merit? And why was 8682522807148012 chosen? Searching online for either number yields no explanation, only this page that also notices the dropped 1 in front of 181783497276652981 . Could other numbers have been chosen that would have worked as well as these two numbers? Why or why not?

Question-21242110, answer-27378709
Better way is: #pre Advantages of this version: #li works regardless the input is an instance of java.util.Date or it's subclass java.sql.Date (unlike @JodaStephen's way). This is common with JDBC originated data. java.sql.Date.toInstant(args) always throws an exception. #li it's the same for JDK8 and JDK7 with JSR-310 backport I personally use an utility class (but this is not backport-compatible): #pre The asLocalDate(args) method here is null-safe, uses toLocalDate(args) , if input is java.sql.Date (it may be overriden by the JDBC driver to avoid timezone problems or unnecessary calculations), otherwise uses the abovementioned method.

Question-6684665, answer-6684852
What Arrays.toString(args) does is create a string representation of each individual byte in your byteArray. Please check the API documentation Arrays API To convert your response string back to the original byte array, you have to use split(args) or something and convert it into a collection and then convert each individual item in there to a byte to recreate your byte array.

Question-9481865, answer-9481939
You can use java.net.InetAddress API. Try this : InetAddress.getLocalHost(args).getHostAddress(args);

Question-14846920, answer-14846963
#blockquote For the same reason you'd use Collections.unmodifiableMap() at some point. You want to return a Map instance that throws an exception if the user attempts to modify it. It's just a special case: the empty Map.

Question-18723596, answer-18723704
You can cast null to any reference type. You can also call methods which handle a null as an argument, e.g. System.out.println(args) does, but you cannot reference a null value and call a method on it. BTW There is a tricky situation where it appears you can call static methods on null values. #pre

Question-6470651, answer-6470695
A simple thing to do is to use a HashSet with an incorrect (or non-existent) hashCode(args) or equals(args) , and then keep adding "duplicates". Instead of ignoring duplicates as it should, the set will only ever grow and you won't be able to remove them. If you want these bad keys/elements to hang around you can use a static field like #pre

Question-22725537, answer-27215810
A slightly shorter version using reduce : things.stream(args) .map(args) .reduce(args); You could also move the reduce function to a static utility method and then it becomes: .reduce(args);

Question-14833008, answer-14833098
"." is a special character in java. You have to use "\." to escape this character : final String extensionRemoved = filename.split(args)[0]; I hope this helps

Question-26684562
In Java 8, what's the difference between Stream.map and Stream.flatMap methods?

Question-7693324
I got a simple question in Java: How can I convert a String that was obtained by Long.toString(args) to long ?

Question-29494800, answer-29502668
#blockquote It's checking simple equality (likely for the purpose of a micro-optimization, but more on that later). The unusual casting is necessary because Class<T> (the type of Object[].class ) and Class<T> are incomparable types. Basically, for an equality comparison with == to compile, one of the sides has to be a subtype or supertype of the other. I.e. we can't do: #pre The rules for generic types are a bit more complicated and there are a few cases where a comparison doesn't compile, but it may still evaluate to true. The reason Class<T> is not a supertype of Class<T> , despite Object[] being a supertype of all object array types, is that Java generics are invariant without the presence of a wildcard. Another way to do the comparison would be: (newType == (Class<T>)Object[].class) #blockquote #li new Object[...] creates an array the normal way, of a type that is statically known. Remember, the code has just checked that T[] is Object[] . #li Array.newInstance(args) uses reflection to dynamically create an array of the Class type passed in. #blockquote An operation using reflection is generally slower than its non-reflective counterpart. The reflection tutorial says: #blockquote Java SE is filled with micro-optimization like this. The writers of SE try to squeeze everything they can out of it. But I wouldn't be worried about a performance hit in this case: newInstance and copyOf are HotSpot intrinsics . This means that ideally calls to these methods get replaced with machine-specific assembly. Anecdotally, I ran some tests and found the difference between new Object[...] and Array.newInstance(args) to be negligible. The code in the question is probably a relic, although it may still be useful on less well-equipped JVMs. Reflection can also be disabled in certain contexts with strict security (such as an applet), but not typically for a normal desktop application. #blockquote In general, you will probably never use this overload. This overload is only useful if you want to change the type of the array. #li Widening: #pre #li Narrowing: #pre It's more typical to use Arrays.copyOf(T[], int) .

Question-22409102, answer-22409270
You can use Float.floatToIntBits to convert it to an int and look at the bit pattern: #pre

Question-16232833
I'm using Spring MVC for a simple JSON API, with @ResponseBody based approach like the following. (I already have a service layer producing JSON directly.) #pre Question is, in the given scenario, what is the simplest, cleanest way to respond with a HTTP 400 error ? I did come across approaches like: return new ResponseEntity(args); ...but I can't use it here since my method's return type is String, not ResponseEntity.

Question-32175145, answer-32175175
Note that a . b and c are instances of primitive wrapper classes (such as Integer, Double, etc...). These classes are final and cannot be extended, so you can't override their equals implementation. Therefore a.equals(args) will always return true, since those classes implement equals properly.

Question-6470651, answer-6548647
Static field holding object reference [esp final field] #pre Calling String.intern() on lengthy String #pre (Unclosed) open streams ( file , network etc... ) #pre Unclosed connections #pre Areas that are unreachable from JVM's garbage collector , such as memory allocated through native methods In web applications, some objects are stored in application scope until the application is explicitly stopped or removed. getServletContext(args).setAttribute(args); Incorrect or inappropriate JVM options , such as the noclassgc option on IBM JDK that prevents unused class garbage collection See IBM jdk settings .

Question-29140402
I have a class defined as follows: #pre I tried to print an instance of my class: System.out.println(args); but I got the following output: com.foo.Person@2f92e0f4 . A similar thing happened when I tried to print an array of Person objects: #pre I got the output: [Lcom.foo.Person;@28a418fc What does this output mean? How do I change this output so it contains the name of my person? And how do I print collections of my objects? Note : this is intended as a canonical Q&A about this subject.

Question-24603186
In Java 8, the Collection interface was extended with two methods that return Stream<T> : stream(args) , which returns a sequential stream, and parallelStream(args) , which returns a possibly-parallel stream. Stream itself also has a parallel(args) method that returns an equivalent parallel stream (either mutating the current stream to be parallel or creating a new stream). The duplication has obvious disadvantages: #li It's confusing. A question asks whether calling both parallelStream().parallel() is necessary to be sure the stream is parallel , given that parallelStream() may return a sequential stream. Why does parallelStream() exist if it can't make a guarantee? The other way around is also confusing -- if parallelStream() returns a sequential stream, there's probably a reason (e.g., an inherently sequential data structure for which parallel streams are a performance trap); what should Stream.parallel() do for such a stream? (UnsupportedOperationException is not allowed by parallel()'s specification.) #li Adding methods to an interface risks conflicts if an existing implementation has a similarly-named method with an incompatible return type. Adding parallelStream() in addition to stream() doubles the risk for little gain. (Note that parallelStream() was at one point just named parallel(), though I don't know if it was renamed to avoid name clashes or for another reason.) Why does Collection.parallelStream() exist when calling Collection.stream().parallel() does the same thing?

Question-14491966, answer-14513598
java.util.Random is not much different, a basic LCG described by Knuth. However it has main 2 main advantages/differences: #li thread safe - each update is a CAS which is more expensive than a simple write and needs a branch (even if perfectly predicted single threaded). Depending on the CPU it could be significant difference. #li undisclosed internal state - this is very important for anything non-trivial. You wish the random numbers not to be predictable. Below it's the main routine generating 'random' integers in java.util.Random. #pre If you remove the AtomicLong and the undisclosed sate (i.e. using all bits of the long ), you'd get more performance than the double multiplication/modulo. Last note: Math.random should not be used for anything but simple tests, it's prone to contention and if you have even a couple of threads calling it concurrently the performance degrades. One little known historical feature of it is the introduction of CAS in java - to beat an infamous benchmark (first by IBM via intrinsics and then Sun made "CAS from Java")

Question-5192512, answer-30190425
I'll vote for sb.setLength(args); not only because it's one function call but because it don't actually copy the array into another array like sb.delete(args); , It just fill the remaining characters to be 0 and set the length variable to the new length. You can take a look into their implementation to validate my point from here at setLength function and delete0 function.

Question-18571223, answer-20262456
You might wanna try return new String(args)

Question-22725537, answer-22735184
You cannot do it more concise as you are already doing. You claim that you do not want .filter(args) and .map(args) . This has been resolved by the method @StuartMarks describes, however as a result you now map it to an Optional<T> , so now you need to use .flatMap(args) and a get(args) in the end. So it still consists of two statements and you can now get exceptions with the new method! Because, what if every optional is empty? Then the findFirst(args) will return an empty optional and your get(args) will fail! So what you have: things.stream(args) .map(args) .filter(args) .map(args) .findFirst(args); is actually the best way to accomplish what you want, and that is you want to save the result as a T , not as an Optional<T> . I took the liberty of creating a CustomOptional<T> class that wraps the Optional<T> and provides an extra method, flatStream(args) . Note that you cannot extend Optional<T> : #pre You will see that I added flatStream(args) , as here: #pre Used as: String result = Stream.of(args) .map(args) .flatMap(args) .findFirst(args) .get(args); You still will need to return a Stream<T> here, as you cannot return T , because if !optional.isPresent(args) , then T == null if you declare it such, but then your .flatMap(args) would attempt to add null to a stream and that is not possible. As example: #pre Used as: String result = Stream.of(args) .map(args) .map(args) .findFirst(args) .get(args); Will now throw a NullPointerException inside the stream operations. Conclusion The method you used, is actually the best method.

Question-5455794, answer-5455809
st.replaceAll(args) removes all whitespaces and non-visible characters (e.g., tab, \n ). st.replaceAll(args) and st.replaceAll(args) produce the same result. The second regex is 20% faster than the first one, but as the number consecutive spaces increases, the first one performs better than the second one. Assign the value to a variable, if not used directly: st = st.replaceAll(args)

Question-30727515, answer-30739477
Since this hasn’t addressed yet, here an explanation, why the translation of Unicode escapes happens before any other source code processing: The idea behind it was that it allows lossless translations of Java source code between different character encodings. Today, there is widespread Unicode support, and this doesn’t look like a problem, but back then it wasn’t easy for a developer from a western country to receive some source code from his Asian colleague containing Asian characters, make some changes (including compiling and testing it) and sending the result back, all without damaging something. So, Java source code can be written in any encoding and allows a wide range of characters within identifiers, character and String literals and comments. Then, in order to transfer it losslessly, all characters not supported by the target encoding are replaced by their Unicode escapes. This is a reversible process and the interesting point is that the translation can be done by a tool which doesn’t need to know anything about the Java source code syntax as the translation rule is not dependent on it. This works as the translation to their actual Unicode characters inside the compiler happens independently to the Java source code syntax as well. It implies that you can perform an arbitrary number of translation steps in both directions without ever changing the meaning of the source code. This is the reason for another weird feature which hasn’t even mentioned: the \uuuuuuxxxx syntax: When a translation tool is escaping characters and encounters a sequence that is already an escaped sequence, it should insert an additional u into the sequence, converting \ucafe to \uucafe . The meaning doesn’t change, but when converting into the other direction, the tool should just remove one u and replace only sequences containing a single u by their Unicode characters. That way, even Unicode escapes are retained in their original form when converting back and forth. I guess, no-one ever used that feature…

Question-6470651, answer-6540248
Below there will be a non-obvious case where Java leaks, besides the standard case of forgotten listeners, static references, bogus/modifiable keys in hashmaps, or just threads stuck without any chance to end their life-cycle. #li File.deleteOnExit(args) - always leaks the string, if the string is a substring, the leak is even worse (the underlying char[] is also leaked) - in Java 7 substring also copies the char[] , so the later doesn't apply ; @Daniel, no needs for votes, though. I'll concentrate on threads to show the danger of unmanaged threads mostly, don't wish to even touch swing. #li Runtime.addShutdownHook and not remove... and then even with removeShutdownHook due to a bug in ThreadGroup class regarding unstarted threads it may not get collected, effectively leak the ThreadGroup. JGroup has the leak in GossipRouter. #li Creating, but not starting, a Thread goes into the same category as above. #li Creating a thread inherits the ContextClassLoader and AccessControlContext , plus the ThreadGroup and any InheritedThreadLocal , all those references are potential leaks, along with the entire classes loaded by the classloader and all static references, and ja-ja. The effect is especially visible with the entire j.u.c.Executor framework that features a super simple ThreadFactory interface, yet most developers have no clue of the lurking danger. Also a lot of libraries do start threads upon request (way too many industry popular libraries). #li ThreadLocal caches; those are evil in many cases. I am sure everyone has seen quite a bit of simple caches based on ThreadLocal, well the bad news: if the thread keeps going more than expected the life the context ClassLoader, it is a pure nice little leak. Do not use ThreadLocal caches unless really needed. #li Calling ThreadGroup.destroy(args) when the ThreadGroup has no threads itself, but it still keeps child ThreadGroups. A bad leak that will prevent the ThreadGroup to remove from its parent, but all the children become un-enumerateable. #li Using WeakHashMap and the value (in)directly references the key. This is a hard one to find without a heap dump. That applies to all extended Weak/SoftReference that might keep a hard reference back to the guarded object. #li Using java.net.URL with the HTTP(S) protocol and loading the resource from(!). This one is special, the KeepAliveCache creates a new thread in the system ThreadGroup which leaks the current thread's context classloader. The thread is created upon the first request when no alive thread exists, so either you may get lucky or just leak. The leak is already fixed in Java 7 and the code that creates thread properly removes the context classloader. There are few more cases ( like ImageFetcher , also fixed ) of creating similar threads. #li Using InflaterInputStream passing new java.util.zip.Inflater(args) in the constructor ( PNGImageDecoder for instance) and not calling end(args) of the inflater. Well, if you pass in the constructor with just new , no chance... And yes, calling close(args) on the stream does not close the inflater if it's manually passed as constructor parameter. This is not a true leak since it'd be released by the finalizer... when it deems it necessary. Till that moment it eats native memory so badly it can cause Linux oom_killer to kill the process with impunity. The main issue is that finalization in Java is very unreliable and G1 made it worse till 7.0.2. Moral of the story: release native resources as soon as you can; the finalizer is just too poor. #li The same case with java.util.zip.Deflater . This one is far worse since Deflater is memory hungry in Java, i.e. always uses 15 bits (max) and 8 memory levels (9 is max) allocating several hundreds KB of native memory. Fortunately, Deflater is not widely used and to my knowledge JDK contains no misuses. Always call end(args) if you manually create a Deflater or Inflater . The best part of the last two: you can't find them via normal profiling tools available. (I can add some more time wasters I have encountered upon request.) Good luck and stay safe; leaks are evil!

Question-27908213, answer-27908402
Although there is no explicit guarantee of this, the end result is bound to be such that the comparison always succeeds for enum constants with identical names: #pre The reason for this is that Java compiler constructs subclasses of Enum in such a way that they end up calling Enum 's sole protected constructor, passing it the name of enum value: protected Enum(args); The name is embedded into the generated code in the form of a string literal. According to String documentation, #blockquote This amounts to an implicit guarantee of your expression succeeding when names of enum constants are identical. However, I would not rely on this behavior, and use equals(args) instead, because anyone reading my code would be scratching his head, thinking that I made a mistake.

Question-29945627, answer-29945754
The lambda: () -> { System.out.println(args); }; actually represents an implementation for an interface like: #pre which is completely different than the one you've defined. That's why you get an error. Since you can't extend your @FunctionalInterface , nor introduce a brand new one, then I think you don't have much options. You can use the Optional<T> interfaces to denote that some of the values (return type or method parameter) is missing, though. However, this won't make the lambda body simpler.

Question-24676877, answer-24681959
I have a few points to add to Brian Goetz' excellent answer . It's quite common to return a Stream from a "getter" style method call. See the Stream usage page in the Java 8 javadoc and look for "methods... that return Stream" for the packages other than java.util.Stream . These methods are usually on classes that represent or can contain multiple values or aggregations of something. In such cases, APIs typically have returned collections or arrays of them. For all the reasons that Brian noted in his answer, it's very flexible to add Stream-returning methods here. Many of these classes have collections- or array-returning methods already, because the classes predate the Streams API. If you're designing a new API, and it makes sense to provide Stream-returning methods, it might not be necessary to add collection-returning methods as well. Brian mentioned the cost of "materializing" the values into a collection. To amplify this point, there are actually two costs here: the cost of storing values in the collection (memory allocation and copying) and also the cost of creating the values in the first place. The latter cost can often be reduced or avoided by taking advantage of a Stream's laziness-seeking behavior. A good example of this are the APIs in java.nio.file.Files : #pre Not only does readAllLines have to hold the entire file contents in memory in order to store it into the result list, it also has to read the file to the very end before it returns the list. The lines method can return almost immediately after it has performed some setup, leaving file reading and line breaking until later when it's necessary -- or not at all. This is a huge benefit, if for example, the caller is interested only in the first ten lines: List<T> firstTen = Files.lines(args).limit(args).collect(args); Of course considerable memory space can be saved if the caller filters the stream to return only lines matching a pattern, etc. An idiom that seems to be emerging is to name stream-returning methods after the plural of the name of the things that it represents or contains, without a get prefix. Also, while stream(args) is a reasonable name for a stream-returning method when there is only one possible set of values to be returned, sometimes there are classes that have aggregations of multiple types of values. For example, suppose you have some object that contains both attributes and elements. You might provide two stream-returning APIs: #pre

Question-8430805, answer-22332291
Sudheesh B Nair 's has a nice (and accepted) answer on the question, which i think should have a better alternative such as; What's wrong with measuring time passed and checking if TIME_INTERVAL miliseconds (say 2000) passed since the last back press. The following sample code uses System.currentTimeMillis(args); to store the time onBackPressed(args) is called; #pre Back on accepted answer critique ; Using a flag to indicate if it was pressed in last TIME_INTERVAL (say 2000) milliseconds and set - reset is via Handler 's postDelayed(args) method was the first thing to come in my mind. But the postDelayed(args) action should be cancelled when activity is closing, removing the Runnable . In order to remove the Runnable , it must not be declared anonymous , and be declared as member along with the Handler aswell. Then removeCallbacks(args) method of Handler can be called appropriately. The following sample is the demonstration; #pre Thanks to @NSouth for contributing; In order to prevent toast message appearing even after the application is closed, Toast can be declared as a member - say mExitToast - and can be cancelled via mExitToast.cancel(args); just before super.onBackPressed(args); call.

Question-31922866, answer-31923015
I believe the reson of being is you have to first check whether or not Optional is null itself and then try to evaluate value it wraps. Too many unnecessary validations.

Question-27908213, answer-27908294
The Oracle documentation about Enum says (first line): #blockquote If this is true then, yes, your enum1.name(args) == enum2.name(args) is guaranteed to be true if the names are the same. Also, in the method name(args) javadoc: #blockquote For example, if you had two enums, Days and MyDays , where SUNDAY is a common value, == between the enum object values, SUNDAY will return true as you are comparing two strings - see the working example in #a . #pre

Question-16148575, answer-32866218
The main reason with HashMap not allowing primitive as keys is that HashMap is designed in such a way that for comparing the keys, it makes use of equals() method, and a method can be called only on an object not on a primitive. Thus when int is autoboxed to Integer, Hashmap can call equals() method on Integer object. That is why, you should use Integer instead of int. I mean hashmap throws an error while putting int as a key (Don't know the meaning of the error that is thrown) And if you think that, you can make Map performance faster by making a primitive as a key, there is a library called FastUtil which contains a Map implementation with int type as a key. Because of this, it is much faster than Hashmap
Question-7438612, answer-7438613
Replace will replace all instances of a letter. All you need to do is use substring() : #pre

Question-16252269, answer-16252296
Use util method of java.util.Collections class, i.e Collections.sort(args) In fact, if you want to sort custom object you can use Collections.sort(args) see collections api

Question-5192512, answer-5193094
There are basically two alternatives, using setLength(args) to reset the StringBuilder or creating a new one in each iteration. Both can have pros and cons depending on the usage. If you know the expected capacity of the StringBuilder beforehand, creating a new one each time should be just as fast as setting a new length. It will also help the garbage collector, since each StringBuilder will be relatively short-lived and the gc is optimized for that. When you don't know the capacity, reusing the same StringBuilder might be faster. Each time you exceed the capacity when appending, a new backing array has to be allocated and the previous content has to be copied. By reusing the same StringBuilder, it will reach the needed capacity after some iterations and there won't be any copying thereafter.

Question-27949213
Since String in Java (like other languages) consumes a lot of memory because each character consumes two bytes, Java 8 has introduced a new feature called String Deduplication which takes advantage of the fact that the char arrays are internal to strings and final, so the JVM can mess around with them. I have read this example so far but since I am not a pro java coder, I am having a hard time grasping the concept. Here is what it says, #blockquote My First question, There is still a lack of resources on this topic since it is recently added in Java 8 update 20, could anyone here share some practical examples on how it help in reducing the memory consumed by String in Java ? Edit: The above link says, #blockquote My 2nd question, If hash code of two String are same then the Strings are already the same, then why compare them char by char once it is found that the two String have same hash code ?

Question-20746429, answer-20765715
Such an operation ought to be possible with a Java 8 Stream , but it can't necessarily be done efficiently -- for example, you can't necessarily parallelize such an operation, as you have to look at elements in order. The API doesn't provide an easy way to do it, but what's probably the simplest way is to take Stream.iterator(args) , wrap the Iterator to have a "take-while" implementation, and then go back to a Spliterator and then a Stream . Or -- maybe -- wrap the Spliterator , though it can't really be split anymore in this implementation. Here's an untested implementation of takeWhile on a Spliterator : #pre

Question-11408427, answer-11408482
The Java language provides special support for the string concatenation operator (+) and for conversion of other objects to strings. String concatenation is implemented through the StringBuilder (or StringBuffer ) class and its append method.

Question-29262002, answer-29262520
Basicly, new String(args) is an executable piece of code that actually does something (it creates a new String and then returns it). The returned value can be ignored and new String(args) can still be used in void-return lambda to create a new String. However, StringLiteral is just a constant that doesn't do anything on it's own. The only reasonable thing to do with it in lambda body is to return it. But the lambda method would have to have return type String or Object , but it returns void , hence the String cannot be casted to void error.

Question-14491966, answer-14502259
There are many, many pseudo random number generators out there. For example Knuth's ranarray , the Mersenne twister , or look for LFSR generators. Knuth's monumental "Seminumerical algorithms" analizes the area, and proposes some linear congruential generators (simple to implement, fast). But I'd suggest you just stick to java.util.Random or Math.random , they fast and at least OK for occasional use (i.e., games and such). If you are just paranoid on the distribution (some Monte Carlo program, or a genetic algorithm), check out their implementation (source is available somewhere), and seed them with some truly random number, either from your operating system or from random.org . If this is required for some application where security is critical, you'll have to dig yourself. And as in that case you shouldn't believe what some colored square with missing bits spouts here, I'll shut up now.

Question-15430247
The usual constructor of ArrayList is: ArrayList<T> list = new ArrayList<T>(args); But there is also an overloaded constructor with a parameter for its initial capacity: ArrayList<T> list = new ArrayList<T>(args); Why is it useful to create an ArrayList with an initial capacity when we can append to it as we please?

Question-8579657, answer-19629304
If you do run(args) in main method, the thread of main method will invoke the run method instead of the thread you require to run. The start(args) method creates new thread and for which the run(args) method has to be done

Question-23756966
While investigating for a little debate w.r.t. using StringLiteral + n and Integer.toString(int) to convert an integer primitive to a string I wrote this JMH microbenchmark: #pre I ran it with the default JMH options with both Java VMs that exist on my Linux machine (up-to-date Mageia 4 64-bit, Intel i7-3770 CPU, 32GB RAM). The first JVM was the one supplied with Oracle JDK 8u5 64-bit: #pre With this JVM I got pretty much what I expected: #pre I.e. using the StringBuilder class is slower due to the additional overhead of creating the StringBuilder object and appending an empty string. Using String.format(args) is even slower, by an order of magnitude or so. The distribution-provided compiler, on the other hand, is based on OpenJDK 1.7: #pre The results here were interesting : #pre Why does StringBuilder.append(args) appear so much faster with this JVM? Looking at the StringBuilder class source code revealed nothing particularly interesting - the method in question is almost identical to Integer#toString(args) . Interestingly enough, appending the result of Integer.toString(args) (the stringBuilder2 microbenchmark) does not appear to be faster. Is this performance discrepancy an issue with the testing harness? Or does my OpenJDK JVM contain optimizations that would affect this particular code (anti)-pattern? EDIT: For a more straight-forward comparison, I installed Oracle JDK 1.7u55: #pre The results are similar to those of OpenJDK: #pre It seems that this is a more general Java 7 vs Java 8 issue. Perhaps Java 7 had more aggressive string optimizations? EDIT 2 : For completeness, here are the string-related VM options for both of these JVMs: For Oracle JDK 8u5: #pre For OpenJDK 1.7: #pre The UseStringCache option was removed in Java 8 with no replacement, so I doubt that makes any difference. The rest of the options appear to have the same settings. EDIT 3: A side-by-side comparison of the source code of the AbstractStringBuilder , StringBuilder and Integer classes from the src.zip file of reveals nothing noteworty. Apart from a whole lot of cosmetic and documentation changes, Integer now has some support for unsigned integers and StringBuilder has been slightly refactored to share more code with StringBuffer . None of these changes seem to affect the code paths used by StringBuilder#append(args) , although I may have missed something. A comparison of the assembly code generated for IntStr#integerToString(args) and IntStr#stringBuilder0(args) is far more interesting. The basic layout of the code generated for IntStr#integerToString(args) was similar for both JVMs, although Oracle JDK 8u5 seemed to be more aggressive w.r.t. inlining some calls within the Integer#toString(args) code. There was a clear correspondence with the Java source code, even for someone with minimal assembly experience. The assembly code for IntStr#stringBuilder0(args) , however, was radically different. The code generated by Oracle JDK 8u5 was once again directly related to the Java source code - I could easily recognise the same layout. On the contrary, the code generated by OpenJDK 7 was almost unrecognisable to the untrained eye (like mine). The new StringBuilder(args) call was seemingly removed, as was the creation of the array in the StringBuilder constructor. Additionaly, the disassembler plugin was not able to provide as many references to the source code as it did in JDK 8. I assume that this is either the result of a much more aggressive optimization pass in OpenJDK 7, or more probably the result of inserting hand-written low-level code for certain StringBuilder operations. I am unsure why this optimization does not happen in my JVM 8 implementation or why the same optimizations were not implemented for Integer#toString(args) in JVM 7. I guess someone familiar with the related parts of the JRE source code would have to answer these questions...

Question-32820722, answer-32820940
An IntFunction<T> is a function int -> R . An IntUnaryOperator is a function int -> int . Thus an IntFunction<T> is a function that takes an int as parameter and return a function that takes an int as parameter and return an int . #pre Maybe it is more clear if you use anonymous classes to "decompose" the lambda: #pre

Question-28770822, answer-28816219
Looking at the issue and fix, it looks like this has been done to resolve a handling of a header file generation for special classes in jigsaw Jigsaw is a module system designated to use in Java SE Platform and JDK. More details here Here is a corresponding changeset . You can see a comment, #blockquote From the changeset I see that for the sake of purpose in addition to java.lang.Integer and java.lang.Long , also some properties in java.net.SocketOptions , sun.nio.ch.IOStatus , java.io.FileSystem have been changed to @Native . So I assume only those were needed to solve the dependency with jigsaw.

Question-5263187, answer-5263201
System.out.println(args);

Question-20358883, answer-31965160
With Java 8 Streams: Stream.of(args).collect(args) or if you need a set: Stream.of(args).collect(args)

Question-28818506, answer-32653133
This is looks like a good fit for pattern matching and a more traditional Option interface with Some and None implementations (such as those in Javaslang , FunctionalJava ) or a lazy Maybe implementation in cyclops-react .I'm the author of this library. With cyclops-react you can also use structural pattern matching on JDK types. For Optional you can match on the present and absent cases via the visitor pattern . it would look something like this - #pre

Question-7348711, answer-7353205
InetAddress.getLocalHost(args).getHostName(args) is the more portable way. exec(args) actually calls out to the operating system to execute the hostname command. Here are a couple other related answers on SO: #li Java current machine name and logged in user? #li Get DNS name of local machine as seen by a remote machine EDIT: You should take a look at A.H.'s answer or Arnout Engelen's answer for details on why this might not work as expected, depending on your situation. As an answer for this person who specifically requested portable, I still think getHostName(args) is fine, but they bring up some good points that should be considered.

Question-8189466, answer-8189786
Here's why: As it is says in the Javadoc: #blockquote This check is done in the next(args) method of the iterator (as you can see by the stacktrace). But we will reach the next(args) method only if hasNext(args) delivered true, which is what is called by the for each to check if the boundary is met. In your remove method, when hasNext(args) checks if it needs to return another element, it will see that it returned two elements, and now after one element was removed the list only contains two elements. So all is peachy and we are done with iterating. The check for concurrent modifications does not occur, as this is done in the next(args) method which is never called. Next we get to the second loop. After we remove the second number the hasNext method will check again if can return more values. It has returned two values already, but the list now only contains one. But the code here is: #pre 1 != 2, so we continue to the next(args) method, which now realizes that someone has been messing with the list and fires the exception. Hope that clears your question up.

Question-6094575, answer-26159586
when using (i.e.) getConstructor(args) the constructor has to be declared public. Otherwise a NoSuchMethodException is thrown. if you want to access a non-public constructor you have to use instead (i.e.) getDeclaredConstructor(args) .

Question-4818699, answer-4818916
The primary use of AtomicInteger is when you are in a multithreaded context and you need to perform thread safe operations on an integer without using synchronized . The assignation and retrieval on the primitive type int are already atomic but AtomicInteger comes with many operations which are not atomic on int . The simplest are the getAndXXX or xXXAndGet . For instance getAndIncrement(args) is an atomic equivalent to i++ which is not atomic because it is actually a short cut for three operations: retrieval, addition and assignation. compareAndSet is very useful to implements semaphores, locks, latches, etc. Using the AtomicInteger is faster and more readable than performing the same using synchronization. A simple test: #pre On my PC with Java 1.6 the atomic test runs in 3 seconds while the synchronized one runs in about 5.5 seconds. The problem here is that the operation to synchronize ( notAtomic++ ) is really short. So the cost of the synchronization is really important compared to the operation. Beside atomicity AtomicInteger can be use as a mutable version of Integer for instance in Map s as values.

Question-29494800, answer-29495113
#blockquote (Object)newType == (Object)Object[].class It is checking whether variable newType holds a reference to an instance of java.lang.Class representing type Object[] . The casts are unneeded. #blockquote As far as I can tell, Array.newInstance(args) could be used in both cases, but non-reflective ordinary array construction is likely a bit faster. Thus, I suppose that Object[] is called out as a special case for performance reasons, but I have no idea whether that case is exercised frequently enough for the optimization to be important. #blockquote Integer[] nums = Arrays.copyOf(args) You should use it when you need to copy an array to an array with a possibly different (but compatible) element type, especially when the element types are not statically known. If you know you want the copy to have the same element type as the original, then it's easier to use the original array's clone(args) method.

Question-31188231, answer-31188818
Ironically default methods in interfaces were introduced to allow existing libraries using those interfaces not to break, while introducing massive new functionality in the interfaces. (backward compatibility.) Conflicts like that sort method might arise. Something to pay for the extra functionality. In your case also something to investigate (should new functionality be used instead?). Java forward compatibility breaks are little, more in its typing system, which was constantly enlarged. First with generic types and now with inferred types from functional interfaces. From version to version and from compiler to compiler there were slight differences.

Question-19431234
Java 8 has a completely new API for date and time. One of the most useful classes in this API is LocalDateTime , for holding a timezone-independent date-with-time value. There are probably millions of lines of code using the legacy class java.util.Date for this purpose. As such, when interfacing old and new code there will be a need for converting between the two. As there seems to be no direct methods for accomplishing this, how can it be done?

Question-12539365
I write jUnit test cases for 3 purposes: #li To ensure that my code satisfies all of the required functionality, under all (or most of) the input combinations/values. #li To ensure that I can change the implementation, and rely on JUnit test cases to tell me that all my functionality is still satisfied. #li As a documentation of all the use cases my code handles, and act as a spec for refactoring - should the code ever need to be rewritten. (Refactor the code, and if my jUnit tests fail - you probably missed some use case). I do not understand why or when Mockito.verify(args) should be used. When I see verify(args) being called, it is telling me that my jUnit is becoming aware of the implementation. (Thus changing my implementation would break my jUnits, even though my functionality was unaffected). I'm looking for: #li What should be the guidelines for appropriate usage of Mockito.verify(args) ? #li Is it fundamentally correct for jUnits to be aware of, or tightly coupled to, the implementation of the class under test?

Question-13195797
I want to delete all files inside ABC directory. When I tried with FileUtils.deleteDirectory(args); it also deletes folder ABC. Is there a one liner solution where I can delete files inside directory but not directory?

Question-16148575, answer-16148593
Use Integer instead. HashMap<T> myMap = new HashMap<T>(args); Java will automatically autobox your int primitive values to Integer objects. Read more about autoboxing from Oracle Java documentations.

Question-22725537
The new Java 8 stream framework and friends make for some very concise java code, but I have come across a seemingly-simple situation that is tricky to do concisely. Consider a List<T> things and method Optional<T> resolve(args) . I want to map the Thing s to Optional<T> s and get the first Other . The obvious solution would be to use things.stream(args).flatMap(args).findFirst(args) , but flatMap requires that you return a stream, and Optional doesn't have a stream(args) method (or is it a Collection or provide a method to convert it to or view it as a Collection ). The best I can come up with is this: things.stream(args) .map(args) .filter(args) .map(args) .findFirst(args); But that seems awfully long-winded for what seems like a very common case. Anyone have a better idea?

Question-16635398, answer-16637740
forEach(args) can be implemented to be faster than for-each loop, because the iterable knows the best way to iterate its elements, as opposed to the standard iterator way. So the difference is loop internally or loop externally. For example ArrayList.forEach(args) may be simply implemented as #pre as opposed to the for-each loop which requires a lot of scaffolding #pre However, we also need to account for two overhead costs by using forEach(args) , one is making the lambda object, the other is invoking the lambda method. They are probably not significant. see also #a for comparing internal/external iterations for different use cases.

Question-13291076, answer-13291109
It really depends on what you want to do with the returned value: #li If you need to get the exact name used to declare the enum constant, you should use name(args) as toString may have been overriden #li If you want to print the enum constant in a user friendly way, you should use toString which may have been overriden (or not!). When I feel that it might be confusing, I provide a more specific getXXX method, for example: #pre

Question-8579657, answer-8579702
If you just invoke run(args) directly, it's executed on the calling thread, just like any other method call. Thread.start(args) is required to actually create a new thread so that the runnable's run method is executed in parallel.

Question-18636561, answer-18824858
Whenever a new keyword is used it Creates a Object at the Heap 1)StringBuilder sample = new StringBuilder(); 2) StringBuilder referToSample = sample; In 2) the Reference of referSample is created on same object sample thus referToSample = null; is Nulling Only the referSample Reference giving no effect to sample that's why you are not getting NULL Pointer Exception Thanks to Java's Garbage Collection

Question-7693324, answer-7693341
To convert a String to a Long (object), use Long.valueOf(args).longValue(args); See link

Question-22561614, answer-22561853
Let me explain what is happening here, because it isn't obvious! First, Stream.max() accepts an instance of Comparator so that items in the stream can be compared against each other to find the minimum or maximum, in some optimal order that you don't need to worry too much about. So the question is, of course, why is Integer::max accepted? After all it's not a comparator! The answer is in the way that the new lambda functionality works in Java 8. It relies on a concept which is informally known as "single abstract method" interfaces, or "SAM" interfaces. The idea is that any interface with one abstract method can be automatically implemented by any lambda - or method reference - whose method signature is a match for the one method on the interface. So examining the Comparator interface (simple version): #pre If a method is looking for a Comparator<T> , then it's essentially looking for this signature: int xxx(args); I use "xxx" because the method name is not used for matching purposes . Therefore, both Integer.min(args) and Integer.max(args) are close enough that autoboxing will allow this to appear as a Comparator<T> in a method context.

Question-32356762
Is there a good reason that the Collections.list() method in the java.utils package returns an ArrayList<T> instead of List<T> ? Obviously an ArrayList is a List , but I'm under the impression that it's generally good practice to return the interface type instead of implementation type.

Question-20918650, answer-20918709
A subsequent post by the same user in the same conversation: #blockquote (This was in response to a statement by another user, namely that "it seems in some situations 'new T' would be better", the idea being that new T(args) is impossible due to type erasure. (This is debatable — even if T were available at runtime, it could be an abstract class or interface, or it could be Void , or it could lack a no-arg constructor, or its no-arg constructor could be private (e.g., because it's supposed to be a singleton class), or its no-arg constructor could specify a checked exception that the generic method does not catch or specify — but that was the premise. Regardless, it's true that without erasure you could at least write T.class.newInstance(args) , which handles those issues.)) This view, that types are isomorphic to propositions, suggests that the user has a background in formal type theory. (S)he very likely does not like "dynamic types" or "runtime-types" and would prefer a Java without downcasts and instanceof and reflection and so on. (Think of a language like Standard ML, which has a very rich (static) type system and whose dynamic semantics do not depend on any type information whatsoever.) It's worth keeping in mind, by the way, that the user is trolling: while (s)he likely sincerely prefers (statically) typed languages, (s)he is not sincerely trying to persuade others of that view. Rather, the main purpose of the original tweet was to mock those who disagree, and after some of those disagree-ers chimed in, the user posted follow-up tweets such as "the reason java has type erasure is that Wadler et al know what they are doing, unlike users of java". Unfortunately, this makes it hard to find out what (s)he's actually thinking; but fortunately, it also likely means that it's not very important to do so. People with actual depth to their views don't generally resort to trolls that are quite this content-free.

Question-8725387, answer-8727998
Another point is the time complexity of insert operations. For a list insert, one expects a complexity of O(1). But this could not be guaranteed with a sorted list. And the most important point is that lists assume nothing about their elements. For example, you can make lists of things that do not implement equals or compare .

Question-33147339
I was reading Java's ArrayList source code and noticed some comparisons in if-statements. In Java 7, the method grow(int) uses if(args) newCapacity = minCapacity; In Java 6, grow didn't exist. The method ensureCapacity(int) however uses if(args) newCapacity = minCapacity; What was the reason behind the change? Was it a performance issue or just a style? I could imagine that comparing against zero is faster, but performing a complete subtraction just to check whether it's negative seems a bit overkill to me. Also in terms of bytecode, this would involve two instructions ( ISUB and IF_ICMPGE ) instead of one ( IFGE ).

Question-29095967, answer-29098447
The solution is to use Stream.collect . To create a Collector using its builder pattern is already given as solution. The alternative is the other overloaded collect being a tiny bit more primitive. #pre As one sees, I make a list of string lists, where there always is at least one last (empty) string list. #li The first function creates a starting list of string lists. It specifies the result (typed) object. #li The second function is called to process each element. It is an action on the partial result and an element. #li The third is not really used, it comes into play on parallelising the processing, when partial results must be combined. A solution with an accumulator: As @StuartMarks points out, the combiner does not fullfill the contract for parallelism. Due to the comment of @ArnaudDenoyelle a version using reduce . #pre #li The first parameter is the accumulated object. #li The second function accumulates. #li The third is the aforementioned combiner.

Question-31471444, answer-31471530
You should not. The INTEGER_ONE name is no more meaningful than 1. If however this value has some other meaning (for example, month in the year), then using a constant (like Calendar.FEBRUARY ) will make your code clearer. I can guess that this constant in Commons Math library was created in Java 1.4 when there were no Integer cache and autoboxing, so it had sense in terms that you may reuse the same Integer object (not primitive int ) in different places to save memory. So it was added for performance reasons, not for code clarity. Now it's obsolete: even if you need an Integer object, you can use Integer.valueOf(args) or implicit autoboxing and get the cached one.

Question-21375659, answer-21375716
String is immutable irrespective of how it is instantiated 1) Short answer is yes , new String(args) is immutable too. Because every possible mutable operation (like replace , toLowerCase etcetra) that you perform on String does not affect the original String instance and returns you a new instance . You may check this in Javadoc for String . Each public method of String that is exposed returns a new String instance and does not alter the present instance on which you called the method. This is very helpful in Multi-threaded environment as you don't have to think about mutability ( someone will change the value ) every time you pass or share the String around. String can easily be the most used data type, so the designers have blessed us all to not think about mutability everytime and saved us a lot of pain. Immutability allowed String pool or caching It is because of immutability property that the internal pool of string was possible, as when same String value is required at some other place then that immutable reference is returned. If String would have been mutable then it would not have been possible to share String s like this to save memory. String immutablity was not because of pooling, but immutability has more benefits attached to it. String interning or pooling is an example of Flyweight Design pattern 2) Yes it will be interned like any other String as a blank String is also as much a String as other String instances. References: #li Immutability benefits of String

Question-13102045, answer-22593693
There seem to be many questions about this issue with java.util.Scanner . I think a more readable/idiomatic solution would be to call scanner.skip(args) to drop any newline characters after calling nextInt(args) .

Question-18448671, answer-18448699
Use an Iterator and call remove() : #pre

Question-29945627, answer-29946155
The syntax you're after is possible with a little helper function that converts a Runnable into Action<T> (you can place it in Action for example): #pre

Question-10631715, answer-10631738
You could do this: #pre Basically the .split() method will split the string according to (in this case) delimiter you are passing and will return an array of strings. However, you seem to be after a List of Strings rather than an array, so the array must be turned into a list by using the Arrays.asList() utility. Just as an FYI you could also do something like so: #pre But it is usually better practice to program to an interface rather than to an actual concrete implementation, so I would recommend the 1st option.

Question-27908213
Are enum names interned in Java? I.e. is it guaranteed that enum1.name(args) == enum2.name(args) in case of the same name? And is it safe to compare enum.name(args) to a String that is guaranteed to be interned.

Question-5243754, answer-5243798
#li getParameter(args) returns http request parameters. Those passed from the client to the server. For example http://example.com/servlet?parameter=1 . Can only return String #li getAttribute(args) is for server-side usage only - you fill the request with attributes that you can use within the same request. For example - you set an attribute in a servlet, and read it from a JSP. Can be used for any object, not just string.

Question-24676877, answer-24679745
The answer is, as always, "it depends". It depends on how big the returned collection will be. It depends on whether the result changes over time, and how important consistency of the returned result is. And it depends very much on how the user is likely to use the answer. First, note that you can always get a Collection from a Stream, and vice versa: // If API returns Collection, convert with stream(args) getFoo(args).stream(args)... // If API returns Stream, use collect(args) Collection<T> c = getFooStream(args).collect(args); So the question is, which is more useful to your callers. If your result might be infinite, there's only one choice: Stream. If your result might be very large, you probably prefer Stream, since there may not be any value in materializing it all at once, and doing so could create significant heap pressure. If all the caller is going to do is iterate through it (search, filter, aggregate), you should prefer Stream, since Stream has these built-in already and there's no need to materialize a collection (especially if the user might not process the whole result.) This is a very common case. Even if you know that the user will iterate it multiple times or otherwise keep it around, you still may want to return a Stream instead, for the simple fact that whatever Collection you choose to put it in (e.g., ArrayList) may not be the form they want, and then the caller has to copy it anyway. if you return a stream, they can do collect(args) and get it in exactly the form they want. The above "prefer Stream" cases mostly derive from the fact that Stream is more flexible; you can late-bind to how you use it without incurring the costs and constraints of materializing it to a Collection. The one case where you must return a Collection is when there are strong consistency requirements, and you have to produce a consistent snapshot of a moving target. Then, you will want put the elements into a collection that will not change. So I would say that most of the time, Stream is the right answer -- it is more flexible, it doesn't impose usually-unnecessary materialization costs, and can be easily turned into the Collection of your choice if needed. But sometimes, you may have to return a Collection (say, due to strong consistency requirements), or you may want to return Collection because you know how the user will be using it and know this is the most convenient thing for them.

Question-7935858, answer-7935881
The documentation on split() says: #blockquote (Emphasis mine.) A dot is a special character in regular expression syntax. Use Pattern.quote() on the parameter to split() if you want the split to be on a literal string pattern: String[] words = temp.split(args);
Question-9297899
We can determine the length of an ArrayList<T> using its public method size(args) , like #pre Similarly we can determine the length of an Array object using the length property #pre Whereas the size(args) method of ArrayList is defined inside the ArrayList class, where is this length property of Array defined?

Question-21524642, answer-21524694
Or.. Pattern#quote : String[] value_split = rat_values.split(args); This is happening because String#split accepts a regex : | has a special meaning in regex . quote will return a String representation for the regex .

