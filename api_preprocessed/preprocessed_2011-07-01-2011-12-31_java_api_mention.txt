{
    "items": [
        {
            "cleaned": "If I run the following program, which parses two date strings referencing times one second apart and compares them: #pre The output is: #pre Why is ld4-ld3 not 1 (as I would expect from the one-second difference in the times), but 353 ? If I change the dates to times one second later: #pre Then ld4-ld3 will be 1 . ",
            "question_id": 6841333
        },
        {
            "cleaned": "I got a simple question in Java: How can I convert a String that was obtained by Long.toString(_exprs) to long ?",
            "question_id": 7693324
        },
        {
            "cleaned": "I wanted to clarify if I understand this correctly: #li == -> is a reference comparison, i.e. both objects point to the same memory location #li .equals(_exprs) -> evaluates to the comparison of values in the objects Am I correct in my understanding ?",
            "question_id": 7520432
        },
        {
            "cleaned": "Which of the following is the best and most portable way to get the hostname of the current computer in Java? Runtime.getRuntime(_exprs).exec(_exprs) vs InetAddress.getLocalHost(_exprs).getHostName(_exprs)",
            "question_id": 7348711
        },
        {
            "cleaned": "What is the best way to use the values stored in an Enum as String literals?\nFor example: #pre Then later I could use Mode.mode1 to return its string representation as mode1 . Without having to keep calling Mode.model.toString(_exprs) .",
            "question_id": 6667243
        },
        {
            "cleaned": "Note: I am aware of the Iterator#remove(_exprs) method. In the following code sample, I don't understand why the List.remove in main method throws ConcurrentModificationException but not in the remove method. #pre",
            "question_id": 8189466
        },
        {
            "cleaned": "Assuming that arraylist is defined as ArrayList<String> arraylist , is #a equivalent to #a ? If so, can I assume that the clear(_exprs) method is more efficient for emptying the array list? Are there any caveats in using arraylist.removeAll(_exprs) instead of arraylist.clear(_exprs) ?",
            "question_id": 7032070
        },
        {
            "cleaned": "#blockquote Is there a convenience method to strip any leading or trailing spaces from a Java String? Something like: #pre Result: #pre myString.replace(_exprs) would replace the space between keep and this. Thanks",
            "question_id": 6652687
        },
        {
            "cleaned": "I wonder what the difference is between Class.getResource(_exprs) and ClassLoader.getResource(_exprs) ?  AFAIK the following should essentially do the same, but they are not: #pre I discovered this when fiddling with some report generation code that creates a new file in WEB-INF/classes/ from an existing file in that directory. When using the method from Class, I could find files that were there at deployment using getClass(_exprs).getResource(_exprs) , but when trying to fetch the newly created file, I recieved a null object. Browsing the directory clearly shows that the new file is there. The filenames were prepended with a forward slash as in \"/myFile.txt\". The ClassLoader version of getResource(_exprs) on the other hand did find the generated file. From this experience it seems that there is some kind of caching of the directory listing going on. Am I right, and if so, where is this documented? From the #a on Class.getResource(_exprs) #blockquote To me, this reads \"Class.getResource is really calling its own classloader's getResource()\". Which would be the same as doing getClass(_exprs).getClassLoader(_exprs).getResource(_exprs) . But it is obviously not. Could someone please provide me with some illumination into this matter?",
            "question_id": 6608795
        },
        {
            "cleaned": "I have prepared a simple code snippet in order to separate the erroneous portion from my web application. #pre I have tested it while building a web application JSF. I just want to know why in the above code temp.split(_exprs) does not work. The statement, #pre displays nothing on the console means that it doesn't go through the loop. When I change the argument of the temp.split(_exprs) method to other characters, It works just fine as usual. What might be the problem?",
            "question_id": 7935858
        },
        {
            "answer_id": 20906129,
            "cleaned": "As explained by others, there's a time discontinuity there. There are two possible timezone offsets for 1927-12-31 23:54:08 at Asia/Shanghai , but only one offset for 1927-12-31 23:54:07 . So, depending on which offset is used, there's either a one second difference or a 5 minutes and 53 seconds difference. This slight shift of offsets, instead of the usual one-hour daylight savings (summer time) we are used to, obscures the problem a bit. Note that the 2013a update of the timezone database moved this discontinuity a few seconds earlier, but the effect would still be observable. The new java.time package on Java 8 let use see this more clearly, and provide tools to handle it. Given: #pre Then durationAtEarlierOffset will be one second, while durationAtLaterOffset will be five minutes and 53 seconds. Also, these two offsets are the same: #pre But these two are different: #pre You can see the same problem comparing 1927-12-31 23:59:59 with 1928-01-01 00:00:00 , though, in this case, it is the earlier offset that produce the longer divergence, and it is the earlier date that has two possible offsets. Another way to approach this is to check whether there's a transition going on. We can do this like this: #pre You can check whether the transition is an overlap - in which case there's more than one valid offset for that date/time - or a gap - in which case that date/time is not valid for that zone id - by using the isOverlap(_exprs) and isGap(_exprs) methods on zot4 . I hope this helps people handle this sort of issue once Java 8 becomes widely available, or to those using Java 7 who adopt the JSR 310 backport.",
            "question_id": 6841333
        },
        {
            "answer_id": 8172439,
            "cleaned": "You can use #a . Note that this method simply returns a call to #a , which also works. As others have noted, string concatenation works as a shortcut as well: #pre But this compiles down to: #pre which is less efficient because the StringBuilder is backed by a char[] (over-allocated by #a to 16 ), only for that array to be defensively copied by the resulting String . String.valueOf(_exprs) \"gets in the back door\" by wrapping the char in a single-element array and passing it to the package private constructor #a , which avoids the array copy.",
            "question_id": 8172420
        },
        {
            "answer_id": 8172444,
            "cleaned": "Try this: Character.toString(_exprs) or just this: aChar + _str",
            "question_id": 8172420
        },
        {
            "answer_id": 15633542,
            "cleaned": "Nice question. I've got of the following 6 methods to do it. #pre #blockquote String.valueOf(_exprs) invokes new String(_exprs) , which in turn sets the value char array. #pre On the other hand String.valueOf(_exprs) invokes the following #pre  #blockquote #li #a #li #a",
            "question_id": 8172420
        },
        {
            "answer_id": 32174377,
            "cleaned": "We have various ways to convert a char to String . way is to make use of static method toString(_exprs) in Character class: #pre Actually this toString method internally makes use of valueOf method from String class which makes use of char array: #pre So way is to use this directly: #pre This valueOf method in String class makes use of char array: #pre So the way is to make use of an anonymous array to wrap a single character and then passing it to String constructor: #pre The way is to make use of concatenation: #pre This will actually make use of append method from StringBuilder class which is actually preferred when we are doing concatenation in a loop.",
            "question_id": 8172420
        },
        {
            "answer_id": 6802523,
            "cleaned": "There is no direct way to do this - Java has no Map literals (yet - I think they were proposed for Java 8). Some people like this: #pre This creates an anonymous subclass of HashMap, whose instance initializer puts these values. (By the way, a map can't contain twice the same value, your second put will overwrite the first one. I'll use different values for the next examples.) The normal way would be this (for a local variable): #pre If your test map is an instance variable, put the initialization in a constructor or instance initializer: #pre If your test map is a class variable, put the initialization in a static initializer: #pre If you want your map to never change, you should after the initialization wrap your map by Collections.unmodifiableMap(_exprs) . You can do this in a static initializer too: #pre (I'm not sure if you can now make test final ... try it out and report here.)",
            "question_id": 6802483
        },
        {
            "answer_id": 7488669,
            "cleaned": "Two steps: #li String [] items = commaSeparated.split(_exprs); #li List<String> container = Arrays.asList(_exprs);",
            "question_id": 7488643
        },
        {
            "answer_id": 7488683,
            "cleaned": "You can first split them using String.split(_exprs) , and then convert the returned String array to an ArrayList using Arrays.asList(_exprs)",
            "question_id": 7488643
        },
        {
            "answer_id": 7488710,
            "cleaned": "Arrays.asList returns a fixed-size List backed by the array. If you want a normal mutable java.util.ArrayList you need to do this: #pre Or, using #a : #pre Using a Splitter gives you more flexibility in how you split the string and gives you the ability to, for example, skip empty strings in the results and trim results. It also has less weird behavior than String.split as well as not requiring you to split by regex (that's just one option).",
            "question_id": 7488643
        },
        {
            "answer_id": 7693341,
            "cleaned": "To convert a to a (object), use Long.valueOf(_exprs).longValue(_exprs); See #a",
            "question_id": 7693324
        },
        {
            "answer_id": 7520464,
            "cleaned": "In general, the answer to  your question is \"yes\", but... #li equals will only compare what it is written to compare, no more, no less. #li if a class does not override the equals method, then it defaults to the equals(_exprs) method of the closest parent class that has overridden this method. #li If no parent classes have provided an override, then it defaults to the method from the ultimate parent class, Object, and so  you're left with the Object#equals(_exprs) method. Per the Object API this is the same as == ; that is, it returns true both variables refer to the same object, if their references are one and the same. Thus you will be testing  for and not . #li Always remember to override hashCode if you override equals so as not to \"break the contract\". As per the API, the result returned from the hashCode(_exprs) method for two objects be the same if their equals methods shows that they are equivalent. The converse is necessarily true.",
            "question_id": 7520432
        },
        {
            "answer_id": 7521675,
            "cleaned": "Just remember that .equals(_exprs) has to be implemented by the class you are trying to compare. Otherwise, there isn't much of a point; the version of the method for the Object class does the same thing as the comparison operation: #a . The only time you really want to use the comparison operator for objects is wen you are comparing Enums. This is because there is only one instance of an Enum value at a time. For instance, given the enum #pre You will never have more than one instance of A at a time, and the same for B and C . This means that you can actually write a method like so: #pre And you will have no problems whatsoever.",
            "question_id": 7520432
        },
        {
            "answer_id": 27478241,
            "cleaned": "== can be used in many object types but you can use Object.equals for any type , especially Strings and Google Map Markers.",
            "question_id": 7520432
        },
        {
            "answer_id": 29226136,
            "cleaned": "Also note that .equals(_exprs) normally contains == for testing as this is the first thing you would wish to test for if you wanted to test if two objects are equal. And == actually does look at values for primitive types, for objects it checks the reference.",
            "question_id": 7520432
        },
        {
            "answer_id": 35399386,
            "cleaned": "blur the difference further, and may allow you to use == for objects in some cases instead of .equals This can give you greater performance (?), at the cost of greater complexity. E.g.: #pre Complexity tradeoff: the following may surprise you: #pre I advise you to stay away from such micro-optimization, and use .equals for objects, and == for primitives: #pre",
            "question_id": 7520432
        },
        {
            "answer_id": 36875991,
            "cleaned": "Basically, == compares if two objects have the same reference on the heap, so unless two references are linked to the same object, this comparison will be false. equals(_exprs) is a method inherited from class. This method by default compares if two objects have the same referece. It means: object1.equals(_exprs) object1 == object2 However, if you want to establish equality between two objects of the same class you should override this method. It is also very important to override the method hashCode(_exprs) if you have overriden equals(_exprs) . Implement hashCode(_exprs) when establishing equality is part of the Java Object Contract. If you are working with collections, and you haven't implemented hashCode(_exprs) , Strange Bad Things could happen: #pre null will be printed after executing the previous code if you haven't implemented hashCode(_exprs) .",
            "question_id": 7520432
        },
        {
            "answer_id": 6992643,
            "cleaned": "There's no built in type for ConcurrentHashSet because you can always a set from a map. Since there are many types of maps, you use a method to produce a set from a given map (or map class). Prior to Java 8, you produce a concurrent hash set backed by a concurrent hash map, by using #a In Java 8 (pointed out by @Matt), you can get a concurrent hash set via #a . This is a bit simpler than the old newSetFromMap which required you to pass in an empty map object. But it is specific to ConcurrentHashMap . Anyway, the Java designers could have created a new set interface every time a new map interface was created, but that pattern would be impossible to enforce when third parties create their own maps. It is better to have the static methods that derive new sets; that approach always works, even when you create your own map implementations.",
            "question_id": 6992608
        },
        {
            "answer_id": 26764904,
            "cleaned": "As pointed by #a the best way to obtain a concurrency-able HashSet is by means of Collections.synchronizedSet(_exprs) #pre This worked for me and I haven't seen anybody really pointing to it. This is less efficient than the currently aproved solution, as Eugene points out, since it just wraps your set into a synchronized decorator, while a ConcurrentHashMap actually implements low-level concurrency and it can back your Set just as fine. So thanks to Mr. Stepanenkov for making that clear. #a",
            "question_id": 6992608
        },
        {
            "answer_id": 7438613,
            "cleaned": "Replace will replace all instances of a letter. All you need to do is use #a : #pre",
            "question_id": 7438612
        },
        {
            "answer_id": 39329245,
            "cleaned": "As others have pointed out the preferred way is to use: new StringBuilder(_exprs).reverse(_exprs).toString(_exprs) but if you want to implement this by youself, i'am afraid that the rest of responses have flaws. The reason is that String represent a list of points, encoded in a char[] array according to the variable-length encoding: #a . This means some code points use a single element of the array (one code unit) but others use two of them, so there might be pairs of characters that must be treated as a single unit (consecutive \"high\" and \"low\" surrogates) #pre",
            "question_id": 7569335
        },
        {
            "answer_id": 7655177,
            "cleaned": "String text = String.copyValueOf(_exprs); or String text = String.valueOf(_exprs); is arguably better (encapsulates the new String call).",
            "question_id": 7655127
        },
        {
            "answer_id": 7353205,
            "cleaned": "InetAddress.getLocalHost(_exprs).getHostName(_exprs) is the more portable way. exec(_exprs) actually calls out to the operating system to execute the hostname command. Here are a couple other related answers on SO: #li #a #li #a You should take a look at #a or #a for details on why this might not work as expected, depending on your situation. As an answer for this person who specifically requested portable, I still think getHostName(_exprs) is fine, but they bring up some good points that should be considered.",
            "question_id": 7348711
        },
        {
            "answer_id": 7353473,
            "cleaned": "InetAddress.getLocalHost(_exprs).getHostName(_exprs) is better (as explained by Nick), but still not very good One host can be known under many different hostnames. Usually you'll be looking for the hostname your host has in a specific context. For example, in a web application, you might be looking for the hostname used by whoever issued the request you're currently handling. How to best find that one depends on which framework you're using for your web application. In some kind of other internet-facing service, you'll want the hostname your service is available through from the 'outside'. Due to proxies, firewalls etc this might not even be a hostname on the machine your service is installed on - you might try to come up with a reasonable default, but you should definitely make this configurable for whoever installs this.",
            "question_id": 7348711
        },
        {
            "answer_id": 7800008,
            "cleaned": "Strictly speaking - you have no choice but calling either hostname(_exprs) or - on Unix gethostname(_exprs) . This is the name of your computer. Any attempt to determine the hostname by an IP address like this #pre is bound to fail in some circumstances: #li The IP address might not resolve into any name. Bad DNS setup, bad system setup or bad provider setup may be the reason for this. #li A name in DNS can have many aliases called CNAMEs. These can only be resolved in one direction properly: name to address. The reverse direction is ambiguous. Which one is the \"official\" name? #li A host can have many different IP addresses - and each address can have many different names. Two common cases are: One ethernet port has several \"logical\" IP addresses or the computer has several ethernet ports. It is configurable whether they share an IP or have different IPs. This is called \"multihomed\". #li One Name in DNS can resolve to several IP Addresses. And not all of those addresses must be located on the same computer! (Usecase: A simple form of load-balancing) #li Let's not even start talking about dynamic IP addresses. Also don't confuse the name of an IP-address with the name of the host (hostname). A metaphor might make it clearer: #blockquote This illustrates it pretty much I think. The good news is: The hostname is not necessary. In most cases any name which resolves into an IP address on this host will do. (The stranger might enter the city by Northgate, but helpful locals translate the \"2nd left\" part.) If the remaining corner cases you must use the source of this configuration setting - which is the C function gethostname(_exprs) . That function is also called by the program hostname .",
            "question_id": 7348711
        },
        {
            "answer_id": 20793241,
            "cleaned": "Environment variables may also provide a useful means -- COMPUTERNAME on Windows, HOSTNAME on most modern Unix/Linux shells. See: #a I'm using these as \"supplementary\" methods to InetAddress.getLocalHost(_exprs).getHostName(_exprs) , since as several people point out, that function doesn't work in all environments. Runtime.getRuntime(_exprs).exec(_exprs) is another possible supplement. At this stage, I haven't used it. #pre",
            "question_id": 7348711
        },
        {
            "answer_id": 28043703,
            "cleaned": "As others have noted, getting the hostname based on DNS resolution is unreliable. Since this question is unfortunately still relevant in , I'd like to share with you my network-independent solution, with some test runs on different systems. The following code tries to do the following: #li On Windows #li Read the COMPUTERNAME environment variable through System.getenv(_exprs) . #li Execute hostname.exe and read the response #li On Linux #li Read the HOSTNAME environment variable through System.getenv(_exprs) #li Execute hostname and read the response #li Read /etc/hostname (to do this I'm executing cat since the snippet already contains code to execute and read. Simply reading the file would be better, though). The code: #pre Results for different operating systems:  #pre This one is kinda strange since echo $HOSTNAME returns the correct hostname, but System.getenv(_exprs) does not: #pre According to #a , System.getenv(_exprs) works on Ubuntu 14.04 if you run export HOSTNAME before executing the Java code.  #pre The machine names have been replaced but I kept the capitalization and structure. Note the extra newline when executing hostname , you might have to take it into account in some cases.",
            "question_id": 7348711
        },
        {
            "answer_id": 8103083,
            "cleaned": "The first thing to keep in mind is that Java ternary operators have a \"type\", and that this is what the compiler will determine and consider no matter what the actual/real types of the second or third parameter are. Depending on several factors the ternary operator type is determined in different ways as illustrated in the #a In the question above we should consider the last case: #blockquote This is by far the most complex case once you take a look at #a and most of all at . In plain English and after an extreme simplification we can describe the process as calculating the \"Least Common Superclass\" (yes, think of the LCM) of the second and third parameters. This will give us the ternary operator \"type\". Again, what I just said is an extreme simplification (consider classes that implement multiple common interfaces). For example, if you try the following: #pre You'll notice that resulting type of the conditional expression is java.util.Date since it's the \"Least Common Superclass\" for the Timestamp / Time pair. Since null can be autoboxed to anything, the \"Least Common Superclass\" is the Integer class and this will be the return type of the conditional expression (ternary operator) above. The return value will then be a null pointer of type Integer and that is what will be returned by the ternary operator. At runtime, when the Java Virtual Machine unboxes the Integer a NullPointerException is thrown. This happens because the JVM attempts to invoke the function null.intValue(_exprs) , where null is the result of autoboxing. In my opinion (and since my opinion is not in the Java Language Specification many people will find it wrong anyway) the compiler does a poor job in evaluating the expression in your question. Given that you wrote true ? param1 : param2 the compiler should determine right away that the first parameter - null - will be returned and it should generate a compiler error. This is somewhat similar to when you write while(_exprs){} etc... and the compiler complains about the code underneath the loop and flags it with Unreachable Statements . Your second case is pretty straightforward and this answer is already too long... ;)  After another analysis I believe that I was wrong to say that a null value can be boxed/autoboxed to anything. Talking about the class Integer, explicit boxing consists in invoking the new Integer(_exprs) constructor or maybe the Integer.valueOf(_exprs); (I found this version somewhere). The former would throw a NumberFormatException (and this does not happen) while the second would just not make sense since an int cannot be null ...",
            "question_id": 8098953
        },
        {
            "answer_id": 22332291,
            "cleaned": "#a 's has a nice (and accepted) answer on the question, which i think should have a better alternative such as; What's wrong with measuring time passed and checking if TIME_INTERVAL miliseconds (say 2000) passed since the last back press. The following sample code uses System.currentTimeMillis(_exprs); to store the time onBackPressed(_exprs) is called; #pre ",
            "question_id": 8430805
        },
        {
            "answer_id": 6667307,
            "cleaned": "mode1.name(_exprs) or String.valueOf(_exprs) . It doesn't get better than that, I'm afraid",
            "question_id": 6667243
        },
        {
            "answer_id": 6667310,
            "cleaned": "You can use Mode.mode1.name(_exprs) however you often don't need to do this. #pre",
            "question_id": 6667243
        },
        {
            "answer_id": 6667354,
            "cleaned": "Enum is just a little bit special class. Enums can store additional fields, implement methods etc. For example #pre Now you can say: System.out.println(_exprs) and see output: a",
            "question_id": 6667243
        },
        {
            "answer_id": 25575077,
            "cleaned": "You could override the toString(_exprs) method for each enum value.  #pre  #pre",
            "question_id": 6667243
        },
        {
            "answer_id": 8275508,
            "cleaned": "Just use TheClassName.class instead of getClass(_exprs) .",
            "question_id": 8275499
        },
        {
            "answer_id": 8275761,
            "cleaned": "getClass(_exprs) method is defined in Object class with the following signature: #blockquote Since it is not defined as static , you can not call it within a static code block. See these answers for more information: #a , #a , #a . If you're in a static context, then you have to use the class literal expression to get the Class, so you basically have to do like: #blockquote This type of expression is called and they are explained in #a as follows: #blockquote You can also find information about this subject on #a for Class.",
            "question_id": 8275499
        },
        {
            "answer_id": 17397548,
            "cleaned": "As for the code example in the question, the standard solution is to reference the class explicitly by its name, and it is even possible to do without getClassLoader(_exprs) call: #pre This approach still has a back side that it is not very safe against copy/paste errors in case you need to replicate this code to a number of similar classes. And as for the exact question in the headline, there is a trick posted in the #a : #pre It uses a nested anonymous Object subclass to get hold of the execution context. This trick has a benefit of being copy/paste safe... It may be also worth noting that if this snippet is shaped as a static method of some base class, then currenClass value will always be a reference to that base class rather than to any subclass that may be using that method.",
            "question_id": 8275499
        },
        {
            "answer_id": 8189786,
            "cleaned": "Here's why:\nAs it is says in the Javadoc: #blockquote This check is done in the next(_exprs) method of the iterator (as you can see by the stacktrace). But we will reach the next(_exprs) method only if hasNext(_exprs) delivered true, which is what is called by the for each to check if the boundary is met. In your remove method, when hasNext(_exprs) checks if it needs to return another element, it will see that it returned two elements, and now after one element was removed the list only contains two elements. So all is peachy and we are done with iterating. The check for concurrent modifications does not occur, as this is done in the next(_exprs) method which is never called. Next we get to the second loop. After we remove the second number the hasNext method will check again if can return more values. It has returned two values already, but the list now only contains one. But the code here is: #pre 1 != 2, so we continue to the next(_exprs) method, which now realizes that someone has been messing with the list and fires the exception. Hope that clears your question up.",
            "question_id": 8189466
        },
        {
            "answer_id": 23592535,
            "cleaned": "I had that same problem but in case that I was adding en element into iterated list.\nI made it this way #pre Now everything goes fine because you don't create any iterator over your list, you iterate over it \"manually\". And condition i < integerList.size(_exprs) will never fool you because when you remove/add something into List size of the List decrement/increment.. Hope it helps, for me that was solution.",
            "question_id": 8189466
        },
        {
            "answer_id": 7032137,
            "cleaned": "Unless there is a specific optimization that checks if the argument passed to removeAll(_exprs) is the collection itself (and I doubt that such an optimization is there) it will be slower than a simple .clear(_exprs) . Apart from that (and equally important): arraylist.removeAll(_exprs) is just obtuse, confusing code. It is a very backwards way of saying \"clear this collection\". What advantage would it have over the arraylist.clear(_exprs) ?",
            "question_id": 7032070
        },
        {
            "answer_id": 7032144,
            "cleaned": "The source code for clear(_exprs) : #pre The source code for removeAll(_exprs) (As defined in AbstractCollection ): #pre clear(_exprs) is much faster since it doesn't have to deal with all those extra method calls. And as Atrey points out, c.contains(_exprs) increases the time complexity of removeAll to O(n^2) as opposed to clear 's O(n).",
            "question_id": 7032070
        },
        {
            "answer_id": 7032180,
            "cleaned": "The clear(_exprs) method removes all the elements of a single ArrayList . It's a fast operation, as it just sets some array elements to null . The removeAll(_exprs) method, which is inherited from AbstractCollection , removes all the elements that are in the argument collection from the collection you call the method on. It's a relatively slow operation, as it has to search through one of the collections involved.",
            "question_id": 7032070
        },
        {
            "answer_id": 7032208,
            "cleaned": "clear(_exprs) will go through the underlying Array and set each entry to null; removeAll(_exprs) will go through the ArrayList checking for collection and remove(_exprs) it if it exists. I would imagine that clear(_exprs) is way faster then removeAll because it's not comparing, etc.",
            "question_id": 7032070
        },
        {
            "answer_id": 6840856,
            "cleaned": "SimpleDateFormat stores intermediate results in instance fields. So if one instance is used by two threads they can mess each other's results. Looking at the #a reveals that there is a Calendar instance field, which is used by operations on DateFormat / SimpleDateFormat For example parse(_exprs) calls calendar.clear(_exprs) initially and then calendar.add(_exprs) . If another thread invokes parse(_exprs) before the completion of the first invocation, it will clear the calendar, but the other invocation will expect it to be populated with intermediate results of the calculation. One way to reuse date formats without trading thread-safety is to put them in a ThreadLocal - some libraries do that. That's if you need to use the same format multiple times within one thread. But in case you are using a servlet container (that has a thread pool), remember to clean the thread-local after you finish. To be honest, I don't understand why they need the instance field, but that's the way it is. You can also use #a DateTimeFormat which is threadsafe.",
            "question_id": 6840803
        },
        {
            "answer_id": 6652772,
            "cleaned": "Use #a method or String allRemoved = myString.replaceAll(_exprs) for trim both the end. For left trim: #pre For right trim: #pre",
            "question_id": 6652687
        },
        {
            "answer_id": 7283475,
            "cleaned": "Because any particular implementation of Set may or may not be #a . You can always get an #a and step through the Set, using the iterators' next(_exprs) method to return the result you want once you find the equal element.  This works regardless of the implementation.  If the implementation is NOT random access (picture a linked-list backed Set), a get(_exprs) method in the interface would be deceptive, since it would have to iterate the collection to find the element to return, and a get(_exprs) would seem to imply this would be necessary, that the Set could jump directly to the element to get. contains(_exprs) may or may not have to do the same thing, of course, depending on the implementation, but the name doesn't seem to lend itself to the same sort of misunderstandings.",
            "question_id": 7283338
        },
        {
            "answer_id": 8157791,
            "cleaned": "If you want the value you are assigning in the constructor, you need to add a method in the enum definition to return that value. If you want a unique number that represent the enum value, you can use ordinal(_exprs) .",
            "question_id": 8157755
        },
        {
            "answer_id": 6684822,
            "cleaned": "You can't just take the returned string and construct a string from it... it's not a byte[] data type anymore, it's already a string; you need to parse it. For example : #pre ** ** You get an hint of your problem in your question, where you say \" Whatever I seem to try I end up getting a byte array which looks as follows... [91, 45, ... \", because 91 is the byte value for [ , so [91, 45, ... is the byte array of the string \" [-45, 1, 16, ... \" string. The method Arrays.toString(_exprs) will return a String representation of the specified array; meaning that the returned value will not be a array anymore. For example : #pre As you can see, s1 holds the string representation of the b1 , while s2 holds the string representation of the contained in b1 . Now, in your problem, your server returns a string similar to s1 , therefore to get the array representation back, you need the opposite constructor method. If s2.getBytes(_exprs) is the opposite of new String(_exprs) , you need to find the opposite of Arrays.toString(_exprs) , thus the code I pasted in the first snippet of this answer.",
            "question_id": 6684665
        },
        {
            "answer_id": 6684852,
            "cleaned": "What Arrays.toString(_exprs) does is create a string representation of each individual byte in your byteArray. Please check the API documentation #a To convert your response string back to the original byte array, you have to use split(_exprs) or something and convert it into a collection and then convert each individual item in there to a byte to recreate your byte array.",
            "question_id": 6684665
        },
        {
            "answer_id": 6684935,
            "cleaned": "If you want to convert the string back into a byte array you will need to use String.getBytes(_exprs) (or equivalent Python function) and this will allow you print out the original byte array.",
            "question_id": 6684665
        },
        {
            "answer_id": 12685471,
            "cleaned": "The kind of output you are seeing from your byte array ( [B@405217f8 ) is also an output for a zero length byte array (ie new byte[0] ). It looks like this string is a reference to the array rather than a description of the contents of the array like we might expect from a regular collection's toString(_exprs) method. As with other respondents, I would point you to the String constructors that accept a byte[] parameter to construct a string from the contents of a byte array. You should be able to read raw bytes from a socket's InputStream if you want to obtain bytes from a TCP connection. If you have already read those bytes as a String (using an InputStreamReader ), then, the string can be converted to bytes using the getBytes(_exprs) function. Be sure to pass in your desired character set to both the String constructor and getBytes(_exprs) functions, and this will only work if the byte data can be converted to characters by the InputStreamReader . If you want to deal with raw bytes you should really avoid using this stream reader layer.",
            "question_id": 6684665
        },
        {
            "answer_id": 15870428,
            "cleaned": " The toString(_exprs) method has a base implementation in Object . CharSequence is an interface; and although the toString(_exprs) method appears as part of that interface, there is nothing at compile-time that will force you to override it and honor the additional constraints that the CharSequence toString(_exprs) method's javadoc puts on the toString(_exprs) method; ie that it should return a string containing the characters in the order returned by charAt(_exprs) . Your IDE won't even help you out by reminding that you that you override toString(_exprs) . For example, in intellij, this is what you'll see if you create a new CharSequence implementation: #a . Note the absence of toString(_exprs) . If you rely on toString(_exprs) on an arbitrary CharSequence , it work provided the CharSequence implementer did their job properly. But if you want to avoid any uncertainty altogether, you should use a StringBuilder and append(_exprs) , like so: #pre",
            "question_id": 7707556
        },
        {
            "answer_id": 8579702,
            "cleaned": "If you just invoke run(_exprs) directly, it's executed on the calling thread, just like any other method call. Thread.start(_exprs) is required to actually create a new thread so that the runnable's run method is executed in parallel.",
            "question_id": 8579657
        },
        {
            "answer_id": 8641412,
            "cleaned": "Thread.start(_exprs) code registers the Thread with scheduler and the scheduler calls the run(_exprs) method. Also, Thread is class while Runnable is an interface.",
            "question_id": 8579657
        },
        {
            "answer_id": 13134221,
            "cleaned": "Actually Thread.start(_exprs) creates a new thread and have its own execution scenario. Thread.start(_exprs) calls the run(_exprs) method asynchronously,which changes the state of new Thread to Runnable. But Thread.run(_exprs) does not create any new thread. Instead it execute the run method in the current running thread synchronously. If you are using Thread.run(_exprs) then you are not using the features of multi threading at all.",
            "question_id": 8579657
        },
        {
            "answer_id": 19629304,
            "cleaned": "If you do run(_exprs) in main method, the thread of main method will invoke the run method instead of the thread you require to run. The start(_exprs) method creates new thread and for which the run(_exprs) method has to be done",
            "question_id": 8579657
        },
        {
            "answer_id": 26159918,
            "cleaned": "invoke run(_exprs) is  executing on the calling thread, like any other method call. whereas Thread.start(_exprs) creates a new thread.\ninvoking run(_exprs) is a programmatic bug.",
            "question_id": 8579657
        },
        {
            "answer_id": 33375616,
            "cleaned": "Most of these answers miss the big picture, which is that, as far as the Java language is concerned, there is no more difference between t.start(_exprs) and r.run(_exprs) than there is between any other two methods. They're both just methods.  They both run .  They both do whatever they were coded to do, and then they both return, still in the same thread, to their callers. The biggest difference is that most of the code for t.start(_exprs) is code while, in most cases, the code for r.run(_exprs) is going to be pure Java.  But that's not much of a difference.  Code is code.  Native code is harder to find, and harder to understand when you find it, but it's still just code that tells the computer what to do. So, what does t.start(_exprs) do? It creates a new native thread, it arranges for that thread to call t.run(_exprs) , and then it tells the OS to let the new thread run.  Then it returns. And what does r.run(_exprs) do? The funny thing is, the person asking this question is the person who . r.run(_exprs) does whatever (i.e., the developer who wrote it) designed it to do. ",
            "question_id": 8579657
        },
        {
            "answer_id": 35264580,
            "cleaned": "Main difference is that when program calls start(_exprs) method a is created and code inside run() method is executed in new Thread while if you call run(_exprs) method directly is created and code inside run() will execute on . Another is that you . once started, second call of start() will throw IllegalStateException in Java while you can call run() method twice.",
            "question_id": 8579657
        },
        {
            "answer_id": 35931153,
            "cleaned": "If you directly call run(_exprs) method, you are not using multi-threading feature since run(_exprs) method is executed as part of caller thread. If you call start(_exprs) method on Thread, the Java Virtual Machine will call run() method and two threads will run concurrently - Current Thread ( main(_exprs) in your example) and Other Thread (Runnable r1 in your example). Have a look at source code of start(_exprs) method in #a #pre In above code, you can't see invocation to run(_exprs) method. private native void start0(_exprs) is responsible for calling run(_exprs) method. JVM executes this native method.",
            "question_id": 8579657
        },
        {
            "answer_id": 20069798,
            "cleaned": "All these answers around here, as well as the answers in #a , suggest that loading absolute URLs, like \"/foo/bar.properties\" treated the same by class.getResourceAsStream(_exprs) and class.getClassLoader(_exprs).getResourceAsStream(_exprs) . This is NOT the case, at least not in my Tomcat configuration/version (currently 7.0.40). #pre Sorry, I have absolutely no satisfying explanation, but I guess that tomcat does dirty tricks and his black magic with the classloaders and cause the difference. I always used class.getResourceAsStream(_exprs) in the past and haven't had any problems. PS: I also posted this over #a",
            "question_id": 6608795
        },
        {
            "answer_id": 22327270,
            "cleaned": "I tried reading from input1.txt which was inside one of my packages The following works: #pre The most important part was to call getPath(_exprs) if you want the correct path name in String format. because it will add some extra formatting text which will TOTALLY MESS UP the fileName (you can try it and see the print out). Spent 2 hours debugging this... :(",
            "question_id": 6608795
        },
        {
            "answer_id": 7935873,
            "cleaned": "#a splits on regular expressions, and . in a regular expression means \"any character\". Try temp.split(_exprs) .",
            "question_id": 7935858
        },
        {
            "answer_id": 7935881,
            "cleaned": "The #a says: #blockquote (Emphasis mine.) A dot is a special character in regular expression syntax. Use #a on the parameter to split() if you want the split to be on a literal string pattern: #pre",
            "question_id": 7935858
        }
    ]
}