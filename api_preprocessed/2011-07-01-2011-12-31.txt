Question-5455794
I have a string like this: mysz = _str; I want to remove the whitespaces in the string. I tried trim(_exprs) but this removes only whitespaces before and after the whole string. I also tried replaceAll(_exprs) but then the = also gets removed. How can I achieve a string with: mysz2 = _str

Question-4645020
It is supposed to be generally preferable to use a StringBuilder for string concatenation in Java. Is this always the case? What I mean is this: Is the overhead of creating a StringBuilder object, calling the append(_exprs) method and finally toString(_exprs) already smaller then concatenating existing strings with the + operator for two strings, or is it only advisable for more (than two) strings? If there is such a threshold, what does it depend on (perhaps the string length, but in which way)? And finally, would you trade the readability and conciseness of the + concatenation for the performance of the StringBuilder in smaller cases like two, three or four strings? 

Question-4576352
I can use this:  Is there a way to remove all occurrences of character X from a String in Java? I tried this and is not what I want: str.replace(_exprs); //replace with space

Question-5031614
There have been #a #a here about JPA entities and which hashCode(_exprs) / equals(_exprs) implementation should be used for JPA entity classes.  Most (if not all) of them depend on Hibernate, but I'd like to discuss them JPA-implementation-neutrally (I am using EclipseLink, by the way). All possible implementations are having their own and regarding: #li contract (immutability) for List / Set operations #li Whether objects (e.g. from different sessions, dynamic proxies from lazily-loaded data structures) can be detected #li Whether entities behave correctly in As far I can see, there are : #li Do not override them; rely on Object.equals(_exprs) and Object.hashCode(_exprs) #li hashCode(_exprs) / equals(_exprs) work #li cannot identify identical objects, problems with dynamic proxies #li no problems with detached entities #li Override them, based on the #li hashCode(_exprs) / equals(_exprs) are broken #li correct identity (for all managed entities) #li problems with detached entities #li Override them, based on the (non-primary key fields; what about foreign keys?) #li hashCode(_exprs) / equals(_exprs) are broken #li correct identity (for all managed entities) #li no problems with detached entities  #li Did I miss an option and/or pro/con point? #li What option did you choose and why?  By " hashCode(_exprs) / equals(_exprs) are broken", I mean that successive hashCode(_exprs) invocations may return differing values, which is (when correctly implemented) not broken in the sense of the Object API documentation, but which causes problems when trying to retrieve a changed entity from a Map , Set or other hash-based Collection .  Consequently, JPA implementations (at least EclipseLink) will not work correctly in some cases.  Thank you for your answers -- most of them have remarkable quality.

Question-5011932
I am storing a SQL query in my strings.xml file and I want to use String.Format to build the final string in code.  The SELECT statement uses a like, something like this: SELECT Field1, Field2 FROM mytable WHERE Field1 LIKE '%something%' In order to format that I replace 'something' with %1$s so it becomes: SELECT Field1, Field2 FROM mytable WHERE Field1 LIKE \'%%1$s%\' I escape the single quotes with the backslash.  However I am not able to escape the % sign. How can I include a like statement in my strings.xml file?

Question-5439529
I'm trying to determine if a particular item in an Array of strings is an integer or not. I am .split(_exprs)'ing an infix expression in String form, and then trying to split the resultant array into two arrays; one for integers, one for operators, whilst discarding parentheses, and other miscellaneous items. What would be the best way to accomplish this? I thought I might be able to find a Integer.isInteger(_exprs) method or something, but no such luck.

Question-5243754
What is the difference between getAttribute(_exprs) and getParameter(_exprs) methods within HttpServletRequest class?

Question-4812570
How can I get the e.printStackTrace(_exprs) and store it into a String variable?
I want to use the string generated by e.printStackTrace(_exprs) later in my program. I'm still new to Java so I'm not too familiar with StringWriter that I think
will be the solution. Or if you have any other ideas please let me know.  Thanks

Question-6470651, answer-6470695
A simple thing to do is to use a HashSet with an incorrect (or non-existent) hashCode(_exprs) or equals(_exprs) , and then keep adding "duplicates".  Instead of ignoring duplicates as it should, the set will only ever grow and you won't be able to remove them. If you want these bad keys/elements to hang around you can use a static field like 

Question-6470651, answer-6540248
Below there will be a non-obvious case where Java leaks, besides the standard case of forgotten listeners, static references, bogus/modifiable keys in hashmaps, or just threads stuck without any chance to end their life-cycle. #li File.deleteOnExit(_exprs) - always leaks the string, - ; @Daniel, no needs for votes, though. I'll concentrate on threads to show the danger of unmanaged threads mostly, don't wish to even touch swing. #li Runtime.addShutdownHook and not remove... and then even with removeShutdownHook due to a bug in ThreadGroup class regarding unstarted threads it may not get collected, effectively leak the ThreadGroup. JGroup has the leak in GossipRouter. #li Creating, but not starting, a Thread goes into the same category as above. #li Creating a thread inherits the ContextClassLoader and AccessControlContext , plus the ThreadGroup and any InheritedThreadLocal , all those references are potential leaks, along with the entire classes loaded by the classloader and all static references, and ja-ja. The effect is especially visible with the entire j.u.c.Executor framework that features a super simple ThreadFactory interface, yet most developers have no clue of the lurking danger. Also a lot of libraries do start threads upon request (way too many industry popular libraries). #li ThreadLocal caches; those are evil in many cases. I am sure everyone has seen quite a bit of simple caches based on ThreadLocal, well the bad news: if the thread keeps going more than expected the life the context ClassLoader, it is a pure nice little leak. Do not use ThreadLocal caches unless really needed. #li Calling ThreadGroup.destroy(_exprs) when the ThreadGroup has no threads itself, but it still keeps child ThreadGroups. A bad leak that will prevent the ThreadGroup to remove from its parent, but all the children become un-enumerateable. #li Using WeakHashMap and the value (in)directly references the key. This is a hard one to find without a heap dump. That applies to all extended Weak/SoftReference that might keep a hard reference back to the guarded object. #li Using java.net.URL with the HTTP(S) protocol and loading the resource from(!). This one is special, the KeepAliveCache creates a new thread in the system ThreadGroup which leaks the current thread's context classloader. The thread is created upon the first request when no alive thread exists, so either you may get lucky or just leak. There are few more cases ( , ) of creating similar threads. #li Using InflaterInputStream passing new java.util.zip.Inflater(_exprs) in the constructor ( PNGImageDecoder for instance) and not calling end(_exprs) of the inflater. Well, if you pass in the constructor with just new , no chance... And yes, calling close(_exprs) on the stream does not close the inflater if it's manually passed as constructor parameter. This is not a true leak since it'd be released by the finalizer... when it deems it necessary. Till that moment it eats native memory so badly it can cause Linux oom_killer to kill the process with impunity. The main issue is that finalization in Java is very unreliable and G1 made it worse till 7.0.2. Moral of the story: release native resources as soon as you can; the finalizer is just too poor. #li The same case with java.util.zip.Deflater . This one is far worse since Deflater is memory hungry in Java, i.e. always uses 15 bits (max) and 8 memory levels (9 is max) allocating several hundreds KB of native memory. Fortunately, Deflater is not widely used and to my knowledge JDK contains no misuses. Always call end(_exprs) if you manually create a Deflater or Inflater . The best part of the last two:  Good luck and stay safe; leaks are evil!

Question-6470651, answer-6548647
        , such as memory allocated through native methods In web applications, some objects are stored in application scope until the application is explicitly stopped or removed. getServletContext(_exprs).setAttribute(_exprs); , such as the noclassgc option on IBM JDK that prevents unused class garbage collection See #a .

Question-6470651, answer-6780439
Here's a simple/sinister one via #a .  Because the substring refers to the internal representation of the original, much longer string, the original stays in memory. Thus, as long as you have a StringLeaker in play, you have the whole original string in memory, too, even though you might think you're just holding on to a single-character string. The way to avoid storing an unwanted reference to the original string is to do something like this:  For added badness, you might also .intern(_exprs) the substring:  Doing so will keep both the original long string and the derived substring in memory even after the StringLeaker instance has been discarded.

Question-6470651, answer-18544736
Threads are not collected until they terminate. They serve as #a of garbage collection. They are one of the few objects that won't be reclaimed simply by forgetting about them or clearing references to them. Consider: the basic pattern to terminate a worker thread is to set some condition variable seen by the thread. The thread can check the variable periodically and use that as a signal to terminate. If the variable is not declared volatile , then the change to the variable might not be seen by the thread, so it won't know to terminate. Or imagine if some threads want to update a shared object, but deadlock while trying to lock on it. If you only have a handful of threads these bugs will probably be obvious because your program will stop working properly. If you have a thread pool that creates more threads as needed, then the obsolete/stuck threads might not be noticed, and will accumulate indefinitely, causing a memory leak. Threads are likely to use other data in your application, so will also prevent anything they directly reference from ever being collected. As a toy example:  Call System.gc(_exprs) all you like, but the object passed to leakMe will never die. (*edited*)

Question-5585779, answer-5585800
int foo = Integer.parseInt(_exprs); See the #a for more information. 

Question-5585779, answer-5585876
For example, here are two ways:  There is a slight difference between these methods: #li valueOf returns a new or cached instance of java.lang.Integer #li parseInt returns primitive int . The same is for all cases: Short.valueOf / parseShort , Long.valueOf / parseLong , etc.

Question-5585779, answer-33233407
We can use the parseInt(_exprs) method of the Integer wrapper class for converting a String value to an integer value. For example:  The Integer class also provides the valueOf(_exprs) method:  We can also use toInt(_exprs) of #a for the conversion: 

Question-5585779, answer-35834484
 You can also use public static Integer decode(_exprs) throws NumberFormatException . It also works for base 8 and 16:  If you want to get int instead of Integer you can use: #li Unboxing: int val = Integer.decode(_exprs); #li intValue(_exprs) : Integer.decode(_exprs).intValue(_exprs);

Question-5585779, answer-36394016
Whenever there is the slightest possibility that the given String does not contain an Integer, you have to handle this special case. Sadly, the standard Java methods Integer::parseInt and Integer::valueOf throw a NumberFormatException to signal this special case. Thus, you have to use exceptions for flow control, which is generally considered bad coding style. In my opinion, this special case should be handled by returning an Optional<Integer> . Since Java does not offer such a method, I use the following wrapper:  Usage:  While this is still using exceptions for flow control internally, the usage code becomes very clean.

Question-5374311, answer-5374346
What is happening is that stock_list.toArray(_exprs) is creating an Object[] rather than a String[] and hence the typecast is failing. The correct code would be: String [] stockArr = stockList.toArray(_exprs); or even String [] stockArr = stockList.toArray(_exprs); For more details, refer to the javadocs for the two overloads of List.toArray . (From a technical perspective, the reason for this API behaviour / design is that an implementation of the List<T>.toArray(_exprs) method has no information of what the <T> is at runtime.  All it knows is that the raw element type is Object .  By contrast, in the other case, the array parameter gives the base type of the array.  (If the supplied array is big enough, it is used.  Otherwise a new array of the same type and a larger size will be allocated and returned as the result.)

Question-5374311, answer-17909134
 

Question-5374311, answer-17909839
The correct way to do this is: String[] stockArr = stock_list.toArray(_exprs); I'd like to add to the other great answers here and explain how you could have used the Javadocs to answer your question. The Javadoc for toArray(_exprs) (no arguments) is #a . As you can see, this method returns an Object[] and String[] which is an array of the runtime type of your list: #blockquote Right below that method, though, is #a for toArray(_exprs) . As you can see, this method returns a T[] where T is the type of the array you pass in. At first this seems like what you're looking for, but it's unclear exactly why you're passing in an array (are you adding to it, using it for just the type, etc). The documentation makes it clear that the purpose of the passed array is essentially to define the type of array to return (which is exactly your use case): #blockquote Of course, an understanding of generics (as described in the other answers) is required to really understand the difference between these two methods. Nevertheless, if you first go to the Javadocs, you will usually find your answer and then see for yourself what else you need to learn (if you really do). Also note that reading the Javadocs here helps you to understand what the structure of the array you pass in should be. Though it may not really practically matter, you should not pass in an empty array like this: String [] stockArr = stockList.toArray(_exprs); Because, from the doc, this implementation checks if the array is large enough to contain the collection; There's no need for the extra overhead in creating a new array when you could easily pass in the size. As is usually the case, the Javadocs provide you with a wealth of information and direction. Hey wait a minute, what's reflection?

Question-5778658, answer-5778863
An OutputStream is one where you write data to. If some module exposes an OutputStream , the expectation is that there is something at the other end that is reading. Something that exposes an InputStream on the other hand is indicating that you will need to listen to this stream, and there will be data that you can read. So it is possible to connect an InputStream to an OutputStream InputStream----read---> intermediateBytes[n] ----write----> OutputStream As someone metioned, this is what the copy(_exprs) method from #a lets you do. It does not make sense to go the other way... hopefully this makes some sense  Of course the more I think of this, the more I can see how this actually would be a requirement. I know some of the comments mentioned Piped input/ouput streams, but there is another possibility. If the output stream that is exposed is a ByteArrayOutputStream , then you can always get the full contents by calling the toByteArray(_exprs) method. Then you can create an input stream wrapper by using the ByteArrayInputStream sub-class. These two are pseudo-streams, they both basically just wrap an array of bytes. Using the streams this way, therefore, is technically possible, but to me it is still very strange...

Question-5778658, answer-10768914
You will need an intermediate class which will buffer between. Each time InputStream.read(_exprs) is called, the buffering class will fill the passed in byte array with the next chunk passed in from OutputStream.write(_exprs) . Since the sizes of the chunks may not be the same, the adapter class will need to store a certain amount until it has enough to fill the read buffer and/or be able to store up any buffer overflow. This article has a nice breakdown of a few different approaches to this problem: #a

Question-5243754, answer-5243798
#li getParameter(_exprs) returns http request parameters. Those passed from the client to the server. For example http://example.com/servlet?parameter=1 . Can only return String #li getAttribute(_exprs) is for server-side usage only - you fill the request with attributes that you can use within the same request. For example - you set an attribute in a servlet, and read it from a JSP. Can be used for any object, not just string.

Question-5243754, answer-13612866
It is crucial to know that are not . The return type for attributes is an , whereas the return type for a parameter is a . When calling the getAttribute(_exprs) method, bear in mind that the attributes must be cast. Additionally, there is , and there are no . This post is written with the purpose to connect on @Bozho's response, as additional information that can be useful for other people.

Question-5243754, answer-25074487
- :  request.getParameter(_exprs) will get the value from the posted form of the input box named "testParam" which is "Client param". It will then print it out, so you should see "Client Param" on the screen. So request.getParameter() will retrieve a value that the client has submitted. You will get the value on the server side. - request.getAttribute(_exprs) , this is all done server side. YOU add the attribute to the request and YOU submit the request to another resource, the client does not know about this. So all the code handling this would typically be in servlets.getAttribute always return object.

Question-5243754, answer-34295445
 We use request.getParameter(_exprs) to extract request parameters (i.e. data sent by posting a html form ). The request.getParameter(_exprs) always returns String value and the data come from client.  We use request.getAttribute(_exprs) to get an object added to the request scope on the server side i.e. using request.setAttribute(_exprs) . You can add any type of object you like here, Strings , Custom objects, in fact any object. You add the attribute to the request and forward the request to another resource, the client does not know about this. So all the code handling this would typically be in JSP/servlets. You can use request.setAttribute(_exprs) to add extra-information and forward/redirect the current request to another resource. For example,consider about first.jsp,  and second.jsp:  From your browser, run and the output on your browser is  The basic difference between getAttribute(_exprs) and getParameter(_exprs) is that the first method extracts a (serialized) Java object and the other provides a String value. For both cases a name is given so that its value (be it string or a java bean) can be looked up and extracted.

Question-4871051, answer-4871135
Current working directory is defined differently in different Java implementations For certain prior to Java 7 there was no consistent way to get the working directory. You could work around this by launching Java with -D and defining a variable to hold the info Something like java -Dcom.mycompany.workingDir=_str That's not quite right, but you get the idea. Then System.getProperty(_exprs) ...

Question-4871051, answer-20810612
I'm on Linux and get same result for both of these approaches:  #a #a

Question-4871051, answer-21274808
Use #a . This works fine in JAR files as well. You can obtain CodeSource by #a and the ProtectionDomain in turn can be obtained by #a . 

Question-4871051, answer-27760556
System.getProperty(_exprs)

Question-5868369, answer-5868454
You need to use the readLine(_exprs) method in class BufferedReader .
Create a new object from that class and operate this method on him and save it to a string. #a

Question-5868369, answer-20593147
In Java 8, you could do:  Some notes: The stream returned by Files.lines (unlike most streams) needs to be closed. For the reasons #a I avoid using forEach(_exprs) . The strange code (_exprs) lines::iterator casts a Stream to an Iterable.

Question-5868369, answer-31265714
In Java 8, there is also an alternative to using #a . If your input source isn't a file but something more abstract like a Reader or an InputStream , you can the lines via the BufferedReader s lines(_exprs) method. For example:  will call processLine(_exprs) for each input line read by the BufferedReader .

Question-5868369, answer-32542424
What you can do is scan the entire text using Scanner and go through the text line by line.
Of course you should import the following:  Scanner basically scans all the text. The while loop is used to traverse through the entire text. The .hasNextLine(_exprs) function is a boolean that returns true if there are still more lines in the text. The .nextLine(_exprs) function gives you an entire line as a String which you can then use the way you want. Try System.out.println(_exprs) to print the text. Side Note: .txt is the file type text.

Question-5982447, answer-5982478
Use the #a method taking a typed array argument of the same size. String[] GPXFILES1 = myset.toArray(_exprs); A different size can also, but that would force the toArray(_exprs) method to create a new array to return instead of reusing the provided argument, which may end up to be less efficient. See also #a .

Question-5455794, answer-5455809
st.replaceAll(_exprs) removes all whitespaces and non-visible characters (e.g., tab, \n ). 

Question-5455794, answer-5455820
How about replaceAll(_exprs) . Refer #a .

Question-5769669, answer-5769679
You can use #a to convert a String to a double :  For your case it looks like you want: 

Question-5192512, answer-5192545
Updated to bring in feedback. So two ways that work: #li Use StringBulderObj.setLength(_exprs) . #li Allocate a new one instead of clearing the buffer

Question-5192512, answer-5193094
There are basically two alternatives, using setLength(_exprs) to reset the StringBuilder or creating a new one in each iteration. Both can have pros and cons depending on the usage. If you know the expected capacity of the StringBuilder beforehand, creating a new one each time should be just as fast as setting a new length. It will also help the garbage collector, since each StringBuilder will be relatively short-lived and the gc is optimized for that. When you don't know the capacity, reusing the same StringBuilder might be faster. Each time you exceed the capacity when appending, a new backing array has to be allocated and the previous content has to be copied. By reusing the same StringBuilder, it will reach the needed capacity after some iterations and there won't be any copying thereafter.

Question-5192512, answer-22694891
I think many of the answers here may be missing a quality method included in StringBuilder : .delete(_exprs) . I know this is a late reply; however, this should be made known (and explained a bit more thoroughly). Let's say you have a StringBuilder table - which you wish to modify, dynamically, throughout your program (one I am working on right now does this), e.g. StringBuilder table = new StringBuilder(_exprs); If you are looping through the method and alter the content, use the content, then wish to discard the content to "clean up" the StringBuilder for the next iteration, you can delete it's contents, e.g. table.delete(_exprs). start and end being the indices of the chars you wish to remove. Don't know the length in chars and want to delete the whole thing? table.delete(_exprs); NOW, for the kicker. StringBuilders , as mentioned previously, take a lot of overhead when altered  frequently (and can cause safety issues with regard to threading); therefore, use StringBuffer - same as StringBuilder (with a few exceptions) - if your StringBuilder is used for the purpose of interfacing with the user.

Question-5192512, answer-30190425
I'll vote for sb.setLength(_exprs); not only because it's one function call but like sb.delete(_exprs); , It just fill the remaining characters to be 0 and set the length variable to the new length. You can take a look into their implementation to validate my point from #a at setLength function and delete0 function.

Question-6094575, answer-6094600
You can use #a to get a #a object of the desired class. Then use #a to find the desired #a object. Finally, call #a on that object to get your new instance. 

Question-6094575, answer-6094602
Yes, something like:  That will only work for a single string parameter of course, but you can modify it pretty easily. Note that the class name has to be a fully-qualified one, i.e. including the namespace. For nested classes, you need to use a dollar (as that's what the compiler uses). For example:  To obtain the Class object for that, you'd need Class.forName(_exprs) .

Question-6094575, answer-26159586
when using (i.e.) getConstructor(_exprs) the constructor has to be declared public.
Otherwise a NoSuchMethodException is thrown. if you want to access a you have to use instead (i.e.) getDeclaredConstructor(_exprs) .

Question-5175728, answer-5175771
Have a look at the #a class. There's also the newer #a class which is the preferred method of doing many date / time operations (a lot of the methods on Date have been deprecated.) If you just want the current date, then either create a new Date object or call Calendar.getInstance(_exprs); .

Question-5175728, answer-5175900
It depends on what form of date / time you want: #li If you want the date / time as a single numeric value, then System.currentTimeMillis(_exprs) gives you that, expressed as the number of milliseconds after the UNIX epoch (as a Java long ).  This value is a delta from a UTC time-point, and is independent of the local time-zone ... assuming that the system clock has been set correctly. #li If you want the date / time in a form that allows you to access the components (year, month, etc) numerically, you could use one of the following: #li new Date(_exprs) gives you a Date object initialized with the current date / time.  The problem is that the Date API methods are mostly flawed ... and deprecated. #li Calendar.getInstance(_exprs) gives you a Calendar object initialized with the current date / time, using the default Locale and TimeZone .  Other overloads allow you to use a specific Locale and/or TimeZone .  Calendar works ... but the APIs are still cumbersome. #li new org.joda.time.DateTime(_exprs) gives you a #a object initialized with the current date / time, using the default time zone and chronology.  There are lots of other Joda alternatives ... too many to describe here. #li in Java 8, calling LocalDateTime.now(_exprs) and ZonedDateTime.now(_exprs) will give you representations for the current date / time. Prior to Java 8, most people who know about these things recommended #a as having (by far) the best Java APIs for doing things involving time point and duration calculations.  With Java 8, this is no longer true.  However, if you are already using Joda time in your codebase, there is no strong reason to migrate.

Question-4772425, answer-4772461
Use #a (or #a if the string happens to contain a time zone part) to parse a String in a certain pattern into a LocalDateTime .  Use #a (or #a ) to format a LocalDateTime into a String in a certain pattern.  , when you're not on Java 8 yet, use #a to parse a String in a certain pattern into a Date .  Use #a to format a Date into a String in a certain pattern.   #li #a 

Question-4772425, answer-18953213
remove one y form SimpleDateFormat dt1 = new SimpleDateFormat(_exprs); should be SimpleDateFormat dt1 = new SimpleDateFormat(_exprs);

Question-5839359, answer-5839392
You're essentially running out of memory to run the process smoothly. Options that come to mind: #li Specify more memory like you mentioned, try something in between like -Xmx512m first #li Work with smaller batches of HashMap objects to process at once if possible #li If you have a lot of duplicate strings, use #a on them before putting them into the HashMap #li Use the #a constructor to tune for your case

Question-6252678, answer-6252802
You need a #a appropriate to the format you're using.  Take a look at the docs for instructions on how to build one. Off the cuff, I think you need format = DateTimeFormat.forPattern(_exprs)

Question-4709175, answer-4709284
#blockquote You can use an Enum to represent a smallish fixed set of constants or an internal class mode while increasing readability. Also, Enums can enforce a certain rigidity when used in method parameters. They offer the interesting possibility of passing information to a constructor like in the #a and, as you've discovered, also allow a simple way to create a singleton pattern. ex: Locale.setDefault(_exprs) reads better than Locale.setDefault(_exprs) and enforces the use of fixed set of values shown in an IDE when you add the . separator instead of all integers.

Question-4709175, answer-4709892
Something none of the other answers have covered that make enums particularly powerful are the ability to have #a . Methods can be part of the base enum and overridden by each type. And, with the behavior attached to the enum, it often eliminates the need for if-else constructs or switch statements as this #a - where enum.method(_exprs) does what originally would be executed inside the conditional. The same example also shows the use of static imports with enums as well producing much cleaner DSL like code. Some other interesting qualities include the fact that enums provide implementation for equals(_exprs) , toString(_exprs) and hashCode(_exprs) and implement Serializable and Comparable . For a complete rundown of all that enums have to offer I highly recommend Bruce Eckel's #a which devotes an entire chapter to the topic. Particularly illuminating are the examples involving a Rock, Paper, Scissors (i.e. RoShamBo) game as enums.

Question-4818699, answer-4818753
There are two main uses of AtomicInteger : #li As an atomic counter ( incrementAndGet(_exprs) , etc) that can be used by many threads concurrently #li As a primitive that supports #a instruction ( compareAndSet(_exprs) ) to implement non-blocking algorithms. Here is an example of non-blocking random number generator from #a : As you can see, it basically works almost the same way as incrementAndGet(_exprs) , but performs arbitrary calculation ( calculateNext(_exprs) ) instead of increment (and processes the result before return).

Question-4818699, answer-4818783
The absolute simplest example I can think of is to make incrementing an atomic operation. With standard ints:  With AtomicInteger:  The latter is a very simple way to perform simple mutations effects (especially counting, or unique-indexing), without having to resort to synchronizing all access. More complex synchronization-free logic can be employed by using compareAndSet(_exprs) as a type of optimistic locking - get the current value, compute result based on this, set this result value is still the input used to do the calculation, else start again - but the counting examples are very useful, and I'll often use AtomicIntegers for counting and VM-wide unique generators if there's any hint of multiple threads being involved, because they're so easy to work with I'd almost consider it premature optimisation to use plain ints . While you can almost always achieve the same synchronization guarantees with ints and appropriate synchronized declarations, the beauty of AtomicInteger is that the thread-safety is built into the actual object itself, rather than you needing to worry about the possible interleavings, and monitors held, of every method that happens to access the int value.  It's much harder to accidentally violate threadsafety when calling getAndIncrement(_exprs) than when returning i++ and remembering (or not) to acquire the correct set of monitors beforehand.

Question-4818699, answer-4818916
The primary use of AtomicInteger is when you are in a multithreaded context and you need to perform thread safe operations on an integer without using synchronized . The assignation and retrieval on the primitive type int are already atomic but AtomicInteger comes with many operations which are not atomic on int . The simplest are the getAndXXX or xXXAndGet . For instance getAndIncrement(_exprs) is an atomic equivalent to i++ which is not atomic because it is actually a short cut for three operations: retrieval, addition and assignation. compareAndSet is very useful to implements semaphores, locks, latches, etc. Using the AtomicInteger is faster and more readable than performing the same using synchronization. A simple test:  On my PC with Java 1.6 the atomic test runs in 3 seconds while the synchronized one runs in about 5.5 seconds. The problem here is that the operation to synchronize ( notAtomic++ ) is really short. So the cost of the synchronization is really important compared to the operation. Beside atomicity AtomicInteger can be use as a mutable version of Integer for instance in Map s as values.

Question-4818699, answer-4819109
If you look at the methods AtomicInteger has, you'll notice that they tend to correspond to common operations on ints.  For instance:  is the thread-safe version of this:  The methods map like this: There are other convenience methods as well, like compareAndSet or addAndGet

Question-4759570, answer-19459145
This works on Windows with Cygwin installed: System.getenv(_exprs)

Question-6271417, answer-6271460
The "$1" is not "useless non-sense". If your class is anonymous, a number is appended. If you don't want the class itself, but its declaring class, then you can use getEnclosingClass(_exprs) . For example:  You can move that in some static utility method. But note that this is not the current class name. The anonymous class is different class than its enclosing class. The case is similar for inner classes.

Question-6271417, answer-6271520
Try using this.getClass(_exprs).getCanonicalName(_exprs) or this.getClass(_exprs).getSimpleName(_exprs) .  If it's an anonymous class, use this.getClass.getSuperclass.getName(_exprs)

Question-6271417, answer-6271668
I'm assuming this is happening for an anonymous class. When you create an anonymous class you actually create a class that extends the class whose name you got. The "cleaner" way to get the name you want is: If your class is an anonymous inner class, getSuperClass(_exprs) should give you the class that it was created from. If you created it from an interface than you're sort of SOL because the best you can do is getInterfaces(_exprs) which might give you more than one interface. The "hacky" way is to just get the name with getClassName(_exprs) and use a regex to drop the $1 .

Question-6271417, answer-29938300
Use this method,but be careful to make an object in your main. public static void setName(_exprs){
        Class setClass = obj.getClass(_exprs);
        String className = setClass.getName(_exprs);
        System.out.println(_exprs);
    }

Question-5263187, answer-5263201
System.out.println(_exprs);

Question-5038204, answer-5039178
The commons/lang builders are great and I have been using them for years without noticeable performance overhead (with and without hibernate). But as Alain writes, the Guava way is even nicer: Here's a sample Bean:  Here's equals() and hashCode() implemented with Commons/Lang:  and here with Guava:  As you can see the Guava version is shorter and avoids superfluous helper objects. In case of equals, it even allows for short-circuiting the evaluation if an earlier Object.equal(_exprs) call returns false (to be fair: commons / lang has an ObjectUtils.equals(_exprs) method with identical semantics which could be used instead of EqualsBuilder to allow short-circuiting as above). So: yes, the commons lang builders are very preferable over manually constructed equals(_exprs) and hashCode(_exprs) methods (or those awful monsters Eclipse will generate for you), but the Guava versions are even better. And a note about Hibernate: be careful about using lazy collections in your equals(), hashCode() and toString() implementations. That will fail miserably if you don't have an open Session. 

Question-4812570, answer-4812585
You have to use getStackTrace (_exprs) method instead of printStackTrace(_exprs) . Here is a #a : 

Question-4812570, answer-21765043
You can use the ExceptionUtils.getStackTrace(_exprs); from Apache Commons 3 class org.apache.commons.lang3.exception.ExceptionUtils . #a

Question-5071040, answer-5071064
There are multiple ways: #li String.valueOf(_exprs) (my preference) #li _str + number (I don't know how the compiler handles it, perhaps it is as efficient as the above) #li Integer.toString(_exprs)

Question-5071040, answer-22547954
Always use either String.valueOf(_exprs) or Integer.toString(_exprs) . Using "" + number is an overhead and does the following: 

Question-4576352, answer-4576367
using public String replaceAll(_exprs) will work usage would be str.replace(_exprs); executing _str.replaceAll(_exprs); returns: lakjsdf xx

Question-4576352, answer-11325546
You can use str = str.replace(_exprs); as mentioned before and you will be fine. For your information _char is not an empty (or a valid) character but _char is. So you could use str = str.replace(_exprs); instead.

Question-5031614, answer-5032837
If you want to use equals(_exprs)/hashCode(_exprs) for your Sets, in the sense that the can only be in there once, then there is only one option: Option 2. That's because a for an entity by definition never changes (if somebody indeed updates it, it's not the same entity anymore) You should take that literally: Since your equals(_exprs)/hashCode(_exprs) are based on the primary key, you must not use these methods, until the primary key is set. So you shouldn't put entities in the set, until they're assigned a primary key. (Yes, UUIDs and similar concepts may help to assign primary keys early.) Now, it's theoretically also possible to achieve that with Option 3, even though so-called "business-keys" have the nasty drawback that they can change: "All you'll have to do is delete the already inserted entities from the set(s), and re-insert them." That is true - but it also means, that in a distributed system, you'll have to make sure, that this is done absolutely everywhere the data has been inserted to (and you'll have to make sure, that the update is performed, before other things occur). You'll need a sophisticated update mechanism, especially if some remote systems aren't currently reachable... Option 1 can only be used, if all the objects in your sets are from the same Hibernate session. The Hibernate documentation makes this very clear in chapter #a : #blockquote It continues to argue in favor of Option 3: #blockquote This is true, you #li cannot assign the id early (e.g. by using UUIDs) #li and yet you absolutely want to put your objects in sets while they're in transient state. Otherwise, you're free to choose Option 2. Then it mentions the need for a relative stability: #blockquote This is correct. The practical problem I see with this is: If you can't guarantee absolute stability, how will you be able to guarantee stability "as long as the objects are in the same Set". I can imagine some special cases (like using sets only for a conversation and then throwing it away), but I would question the general practicability of this. 

Question-5031614, answer-5103360
We usually have two IDs in our entities: #li Is for persistence layer only (so that persistence provider and database can figure out relationships between objects). #li Is for our application needs ( equals(_exprs) and hashCode(_exprs) in particular) Take a look:  

Question-5031614, answer-26826084
#li If you have a #a , then you should use that for equals / hashCode . #li If you don't have a business key, you should not leave it with the default Object equals and hashCode implementations because that does not work after you merge and entity. #li You can #a . The only catch is that you need to use a hashCode implementation that always return the same value, like this:

Question-5554217, answer-17300003
Another way is to use an array as a type, e.g.: MyClass[] mcArray = gson.fromJson(_exprs); This way you avoid all the hassle with the Type object, and if you really need a list you can always convert the array to a list by: List<MyClass> mcList = Arrays.asList(_exprs); IMHO this is much more readable. And to make it be an actual list (that can be modified, see limitations of Arrays.asList(_exprs) ) then just do the following: List<MyClass> mcList = new ArrayList<>(_exprs);

Question-5673260, answer-5673356
 Generally speaking, when you have response.getOutputStream(_exprs) , you can write anything there. You can pass this output stream as a place to put generated PDF to your generator. Also, if you know what file type you are sending, you can set response.setContentType(_exprs);

Question-5673260, answer-5673375
You should be able to write the file on the response directly. Something like  and then write the file as a binary stream on response.getOutputStream(_exprs) . Remember to do response.flush(_exprs) at the end and that should do it.

Question-5785745, answer-15962949
If you want to make a copy of: int[] a = {1,2,3,4,5}; This is the way to go: int[] b = Arrays.copyOf(_exprs); Arrays.copyOf may be faster than a.clone(_exprs) on small arrays. Both copy elements equally fast but clone() returns Object so the compiler has to insert an implicit cast to int[] . You can see it in the bytecode, something like this: 

Question-5785745, answer-34845194
You can also use #a . :  This method is similar to #a , but it's more flexible. Both of them use System.arraycopy under the hood. : #li #a #li #a #li #a

Question-5694385, answer-5694464
Rather than spoon-feed you code, here's how to look in the #a . First, you're dealing with IO, so look in the java.io #a . There are two classes that look interesting: #a and #a . When I clicked on the first, it showed me that there was a a listFiles(_exprs) method in the #a class. And the documentation for that method says: #blockquote Scrolling up in the File JavaDoc, I see the constructors. And that's really all I need to be able to create a File instance and call listFiles(_exprs) on it. Scrolling still further, I can see some information about how files are named in different operating systems.

Question-5694385, answer-5694473
Create a #a object, passing the directory path to the constructor. Use the listFiles(_exprs) to retrieve an array of File objects for each file in the directory, and then call the getName(_exprs) method to get the filename. 

Question-5439529, answer-5439543
You can use Integer.parseInt(_exprs) or Integer.valueOf(_exprs) to get the integer from the string, and catch the exception if it is not a parsable int.  You want to be sure to catch the NumberFormatException it can throw. It may be helpful to note that valueOf() will return an Integer object, not the primitive int.

Question-5439529, answer-5439600
As an alternative to trying to parse the string and catching NumberFormatException , you could use a regex; e.g.  This is likely to be faster, especially if you precompile and reuse the regex.  However, the catch is that Integer.parseInt(_exprs) will still fail if str represents a number that is outside range of legal int values.

Question-5439529, answer-9991624
You can use Integer.parseInt(_exprs) and catch the NumberFormatException if the string is not a valid integer, in the following fashion (as pointed out by all answers):  However, note here that if the evaluated integer overflows, the same exception will be thrown. Your purpose was to find out whether or not, it was a valid integer. So its safer to make your own method to check for validity: 

Question-5439529, answer-15357940
Or simply mystring.matches(_exprs) though it would return true for numbers larger than an int

Question-6416706, answer-6416788
As soon as you call contains , containsAll , equals , hashCode , remove , retainAll , size or toArray , you'd have to traverse the elements anyway. If you're occasionally only calling methods such as isEmpty or clear I suppose you'd be better of by creating the collection lazily. You could for instance have a backing ArrayList for storing previously iterated elements. I don't know of any such class in any library, but it should be a fairly simple exercise to write up.

Question-6416706, answer-6416800
With #a you can use #a or #a , among other similar methods. This will of course copy all the elements in to memory. If that isn't acceptable, I think your code that works with these ought to take Iterable rather than Collection . Guava also happens to provide convenient methods for doing things you can do on a Collection using an Iterable (such as Iterables.isEmpty(_exprs) or Iterables.contains(_exprs) ), but the performance implications are more obvious.
