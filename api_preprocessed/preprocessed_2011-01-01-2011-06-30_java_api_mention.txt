{
    "items": [
        {
            "question_id": 5455794,
            "cleaned": "I have a string like this: #pre I want to remove the whitespaces in the string. I tried trim(_exprs) but this removes only whitespaces before and after the whole string. I also tried replaceAll(_exprs) but then the = also gets removed. How can I achieve a string with: #pre"
        },
        {
            "question_id": 4645020,
            "cleaned": "It is supposed to be generally preferable to use a StringBuilder for string concatenation in Java. Is this always the case? What I mean is this: Is the overhead of creating a StringBuilder object, calling the append(_exprs) method and finally toString(_exprs) already smaller then concatenating existing strings with the + operator for two strings, or is it only advisable for more (than two) strings? If there is such a threshold, what does it depend on (perhaps the string length, but in which way)? And finally, would you trade the readability and conciseness of the + concatenation for the performance of the StringBuilder in smaller cases like two, three or four strings? "
        },
        {
            "question_id": 4576352,
            "cleaned": "I can use this: #pre Is there a way to remove all occurrences of character X from a String in Java? I tried this and is not what I want: str.replace(_exprs); //replace with space"
        },
        {
            "question_id": 5031614,
            "cleaned": "There have been #a #a here about JPA entities and which hashCode(_exprs) / equals(_exprs) implementation should be used for JPA entity classes.  Most (if not all) of them depend on Hibernate, but I'd like to discuss them JPA-implementation-neutrally (I am using EclipseLink, by the way). All possible implementations are having their own and regarding: #li contract (immutability) for List / Set operations #li Whether objects (e.g. from different sessions, dynamic proxies from lazily-loaded data structures) can be detected #li Whether entities behave correctly in As far I can see, there are : #li Do not override them; rely on Object.equals(_exprs) and Object.hashCode(_exprs) #li hashCode(_exprs) / equals(_exprs) work #li cannot identify identical objects, problems with dynamic proxies #li no problems with detached entities #li Override them, based on the #li hashCode(_exprs) / equals(_exprs) are broken #li correct identity (for all managed entities) #li problems with detached entities #li Override them, based on the (non-primary key fields; what about foreign keys?) #li hashCode(_exprs) / equals(_exprs) are broken #li correct identity (for all managed entities) #li no problems with detached entities  #li Did I miss an option and/or pro/con point? #li What option did you choose and why?  By \" hashCode(_exprs) / equals(_exprs) are broken\", I mean that successive hashCode(_exprs) invocations may return differing values, which is (when correctly implemented) not broken in the sense of the Object API documentation, but which causes problems when trying to retrieve a changed entity from a Map , Set or other hash-based Collection .  Consequently, JPA implementations (at least EclipseLink) will not work correctly in some cases.  Thank you for your answers -- most of them have remarkable quality."
        },
        {
            "question_id": 5011932,
            "cleaned": "I am storing a SQL query in my strings.xml file and I want to use String.Format to build the final string in code.  The SELECT statement uses a like, something like this: #pre In order to format that I replace 'something' with %1$s so it becomes: #pre I escape the single quotes with the backslash.  However I am not able to escape the % sign. How can I include a like statement in my strings.xml file?"
        },
        {
            "question_id": 5439529,
            "cleaned": "I'm trying to determine if a particular item in an Array of strings is an integer or not. I am .split(_exprs)'ing an infix expression in String form, and then trying to split the resultant array into two arrays; one for integers, one for operators, whilst discarding parentheses, and other miscellaneous items. What would be the best way to accomplish this? I thought I might be able to find a Integer.isInteger(_exprs) method or something, but no such luck."
        },
        {
            "question_id": 5243754,
            "cleaned": "What is the difference between getAttribute(_exprs) and getParameter(_exprs) methods within HttpServletRequest class?"
        },
        {
            "question_id": 4812570,
            "cleaned": "How can I get the e.printStackTrace(_exprs) and store it into a String variable?\nI want to use the string generated by e.printStackTrace(_exprs) later in my program. I'm still new to Java so I'm not too familiar with StringWriter that I think\nwill be the solution. Or if you have any other ideas please let me know.  Thanks"
        },
        {
            "answer_id": 6470695,
            "question_id": 6470651,
            "cleaned": "A simple thing to do is to use a HashSet with an incorrect (or non-existent) hashCode(_exprs) or equals(_exprs) , and then keep adding \"duplicates\".  Instead of ignoring duplicates as it should, the set will only ever grow and you won't be able to remove them. If you want these bad keys/elements to hang around you can use a static field like #pre"
        },
        {
            "answer_id": 6540248,
            "question_id": 6470651,
            "cleaned": "Below there will be a non-obvious case where Java leaks, besides the standard case of forgotten listeners, static references, bogus/modifiable keys in hashmaps, or just threads stuck without any chance to end their life-cycle. #li File.deleteOnExit(_exprs) - always leaks the string, - ; @Daniel, no needs for votes, though. I'll concentrate on threads to show the danger of unmanaged threads mostly, don't wish to even touch swing. #li Runtime.addShutdownHook and not remove... and then even with removeShutdownHook due to a bug in ThreadGroup class regarding unstarted threads it may not get collected, effectively leak the ThreadGroup. JGroup has the leak in GossipRouter. #li Creating, but not starting, a Thread goes into the same category as above. #li Creating a thread inherits the ContextClassLoader and AccessControlContext , plus the ThreadGroup and any InheritedThreadLocal , all those references are potential leaks, along with the entire classes loaded by the classloader and all static references, and ja-ja. The effect is especially visible with the entire j.u.c.Executor framework that features a super simple ThreadFactory interface, yet most developers have no clue of the lurking danger. Also a lot of libraries do start threads upon request (way too many industry popular libraries). #li ThreadLocal caches; those are evil in many cases. I am sure everyone has seen quite a bit of simple caches based on ThreadLocal, well the bad news: if the thread keeps going more than expected the life the context ClassLoader, it is a pure nice little leak. Do not use ThreadLocal caches unless really needed. #li Calling ThreadGroup.destroy(_exprs) when the ThreadGroup has no threads itself, but it still keeps child ThreadGroups. A bad leak that will prevent the ThreadGroup to remove from its parent, but all the children become un-enumerateable. #li Using WeakHashMap and the value (in)directly references the key. This is a hard one to find without a heap dump. That applies to all extended Weak/SoftReference that might keep a hard reference back to the guarded object. #li Using java.net.URL with the HTTP(S) protocol and loading the resource from(!). This one is special, the KeepAliveCache creates a new thread in the system ThreadGroup which leaks the current thread's context classloader. The thread is created upon the first request when no alive thread exists, so either you may get lucky or just leak. There are few more cases ( , ) of creating similar threads. #li Using InflaterInputStream passing new java.util.zip.Inflater(_exprs) in the constructor ( PNGImageDecoder for instance) and not calling end(_exprs) of the inflater. Well, if you pass in the constructor with just new , no chance... And yes, calling close(_exprs) on the stream does not close the inflater if it's manually passed as constructor parameter. This is not a true leak since it'd be released by the finalizer... when it deems it necessary. Till that moment it eats native memory so badly it can cause Linux oom_killer to kill the process with impunity. The main issue is that finalization in Java is very unreliable and G1 made it worse till 7.0.2. Moral of the story: release native resources as soon as you can; the finalizer is just too poor. #li The same case with java.util.zip.Deflater . This one is far worse since Deflater is memory hungry in Java, i.e. always uses 15\u00a0bits (max) and 8\u00a0memory levels (9 is max) allocating several hundreds KB of native memory. Fortunately, Deflater is not widely used and to my knowledge JDK contains no misuses. Always call end(_exprs) if you manually create a Deflater or Inflater . The best part of the last two:  Good luck and stay safe; leaks are evil!"
        },
        {
            "answer_id": 6548647,
            "question_id": 6470651,
            "cleaned": " #pre  #pre  #pre  #pre , such as memory allocated through native methods In web applications, some objects are stored in application scope until the application is explicitly stopped or removed. #pre , such as the noclassgc option on IBM JDK that prevents unused class garbage collection See #a ."
        },
        {
            "answer_id": 6780439,
            "question_id": 6470651,
            "cleaned": "Here's a simple/sinister one via #a . #pre Because the substring refers to the internal representation of the original, much longer string, the original stays in memory. Thus, as long as you have a StringLeaker in play, you have the whole original string in memory, too, even though you might think you're just holding on to a single-character string. The way to avoid storing an unwanted reference to the original string is to do something like this: #pre For added badness, you might also .intern(_exprs) the substring: #pre Doing so will keep both the original long string and the derived substring in memory even after the StringLeaker instance has been discarded."
        },
        {
            "answer_id": 18544736,
            "question_id": 6470651,
            "cleaned": "Threads are not collected until they terminate. They serve as #a of garbage collection. They are one of the few objects that won't be reclaimed simply by forgetting about them or clearing references to them. Consider: the basic pattern to terminate a worker thread is to set some condition variable seen by the thread. The thread can check the variable periodically and use that as a signal to terminate. If the variable is not declared volatile , then the change to the variable might not be seen by the thread, so it won't know to terminate. Or imagine if some threads want to update a shared object, but deadlock while trying to lock on it. If you only have a handful of threads these bugs will probably be obvious because your program will stop working properly. If you have a thread pool that creates more threads as needed, then the obsolete/stuck threads might not be noticed, and will accumulate indefinitely, causing a memory leak. Threads are likely to use other data in your application, so will also prevent anything they directly reference from ever being collected. As a toy example: #pre Call System.gc(_exprs) all you like, but the object passed to leakMe will never die. (*edited*)"
        },
        {
            "answer_id": 5585800,
            "question_id": 5585779,
            "cleaned": "#pre See the #a for more information. "
        },
        {
            "answer_id": 5585876,
            "question_id": 5585779,
            "cleaned": "For example, here are two ways: #pre There is a slight difference between these methods: #li valueOf returns a new or cached instance of java.lang.Integer #li parseInt returns primitive int . The same is for all cases: Short.valueOf / parseShort , Long.valueOf / parseLong , etc."
        },
        {
            "answer_id": 33233407,
            "question_id": 5585779,
            "cleaned": "We can use the parseInt(_exprs) method of the Integer wrapper class for converting a String value to an integer value. For example: #pre The Integer class also provides the valueOf(_exprs) method: #pre We can also use toInt(_exprs) of #a for the conversion: #pre"
        },
        {
            "answer_id": 35834484,
            "question_id": 5585779,
            "cleaned": " You can also use public static Integer decode(_exprs) throws NumberFormatException . It also works for base 8 and 16: #pre If you want to get int instead of Integer you can use: #li Unboxing: #pre #li intValue(_exprs) : #pre"
        },
        {
            "answer_id": 36394016,
            "question_id": 5585779,
            "cleaned": "Whenever there is the slightest possibility that the given String does not contain an Integer, you have to handle this special case. Sadly, the standard Java methods Integer::parseInt and Integer::valueOf throw a NumberFormatException to signal this special case. Thus, you have to use exceptions for flow control, which is generally considered bad coding style. In my opinion, this special case should be handled by returning an Optional<Integer> . Since Java does not offer such a method, I use the following wrapper: #pre Usage: #pre While this is still using exceptions for flow control internally, the usage code becomes very clean."
        },
        {
            "answer_id": 5374346,
            "question_id": 5374311,
            "cleaned": "What is happening is that stock_list.toArray(_exprs) is creating an Object[] rather than a String[] and hence the typecast is failing. The correct code would be: #pre or even #pre For more details, refer to the javadocs for the two overloads of List.toArray . (From a technical perspective, the reason for this API behaviour / design is that an implementation of the List<T>.toArray(_exprs) method has no information of what the <T> is at runtime.  All it knows is that the raw element type is Object .  By contrast, in the other case, the array parameter gives the base type of the array.  (If the supplied array is big enough, it is used.  Otherwise a new array of the same type and a larger size will be allocated and returned as the result.)"
        },
        {
            "answer_id": 17909134,
            "question_id": 5374311,
            "cleaned": " "
        },
        {
            "answer_id": 17909839,
            "question_id": 5374311,
            "cleaned": "The correct way to do this is: #pre I'd like to add to the other great answers here and explain how you could have used the Javadocs to answer your question. The Javadoc for toArray(_exprs) (no arguments) is #a . As you can see, this method returns an Object[] and String[] which is an array of the runtime type of your list: #blockquote Right below that method, though, is #a for toArray(_exprs) . As you can see, this method returns a T[] where T is the type of the array you pass in. At first this seems like what you're looking for, but it's unclear exactly why you're passing in an array (are you adding to it, using it for just the type, etc). The documentation makes it clear that the purpose of the passed array is essentially to define the type of array to return (which is exactly your use case): #blockquote Of course, an understanding of generics (as described in the other answers) is required to really understand the difference between these two methods. Nevertheless, if you first go to the Javadocs, you will usually find your answer and then see for yourself what else you need to learn (if you really do). Also note that reading the Javadocs here helps you to understand what the structure of the array you pass in should be. Though it may not really practically matter, you should not pass in an empty array like this: #pre Because, from the doc, this implementation checks if the array is large enough to contain the collection; There's no need for the extra overhead in creating a new array when you could easily pass in the size. As is usually the case, the Javadocs provide you with a wealth of information and direction. Hey wait a minute, what's reflection?"
        },
        {
            "answer_id": 5778863,
            "question_id": 5778658,
            "cleaned": "An OutputStream is one where you write data to. If some module exposes an OutputStream , the expectation is that there is something at the other end that is reading. Something that exposes an InputStream on the other hand is indicating that you will need to listen to this stream, and there will be data that you can read. So it is possible to connect an InputStream to an OutputStream InputStream----read---> intermediateBytes[n] ----write----> OutputStream As someone metioned, this is what the copy(_exprs) method from #a lets you do. It does not make sense to go the other way... hopefully this makes some sense  Of course the more I think of this, the more I can see how this actually would be a requirement. I know some of the comments mentioned Piped input/ouput streams, but there is another possibility. If the output stream that is exposed is a ByteArrayOutputStream , then you can always get the full contents by calling the toByteArray(_exprs) method. Then you can create an input stream wrapper by using the ByteArrayInputStream sub-class. These two are pseudo-streams, they both basically just wrap an array of bytes. Using the streams this way, therefore, is technically possible, but to me it is still very strange..."
        },
        {
            "answer_id": 10768914,
            "question_id": 5778658,
            "cleaned": "You will need an intermediate class which will buffer between. Each time InputStream.read(_exprs) is called, the buffering class will fill the passed in byte array with the next chunk passed in from OutputStream.write(_exprs) . Since the sizes of the chunks may not be the same, the adapter class will need to store a certain amount until it has enough to fill the read buffer and/or be able to store up any buffer overflow. This article has a nice breakdown of a few different approaches to this problem: #a"
        },
        {
            "answer_id": 5243798,
            "question_id": 5243754,
            "cleaned": "#li getParameter(_exprs) returns http request parameters. Those passed from the client to the server. For example http://example.com/servlet?parameter=1 . Can only return String #li getAttribute(_exprs) is for server-side usage only - you fill the request with attributes that you can use within the same request. For example - you set an attribute in a servlet, and read it from a JSP. Can be used for any object, not just string."
        },
        {
            "answer_id": 13612866,
            "question_id": 5243754,
            "cleaned": "It is crucial to know that are not . The return type for attributes is an , whereas the return type for a parameter is a . When calling the getAttribute(_exprs) method, bear in mind that the attributes must be cast. Additionally, there is , and there are no . This post is written with the purpose to connect on @Bozho's response, as additional information that can be useful for other people."
        },
        {
            "answer_id": 25074487,
            "question_id": 5243754,
            "cleaned": "- : #pre request.getParameter(_exprs) will get the value from the posted form of the input box named \"testParam\" which is \"Client param\". It will then print it out, so you should see \"Client Param\" on the screen. So request.getParameter() will retrieve a value that the client has submitted. You will get the value on the server side. - request.getAttribute(_exprs) , this is all done server side. YOU add the attribute to the request and YOU submit the request to another resource, the client does not know about this. So all the code handling this would typically be in servlets.getAttribute always return object."
        },
        {
            "answer_id": 34295445,
            "question_id": 5243754,
            "cleaned": " We use request.getParameter(_exprs) to extract request parameters (i.e. data sent by posting a html form ). The request.getParameter(_exprs) always returns String value and the data come from client.  We use request.getAttribute(_exprs) to get an object added to the request scope on the server side i.e. using request.setAttribute(_exprs) . You can add any type of object you like here, Strings , Custom objects, in fact any object. You add the attribute to the request and forward the request to another resource, the client does not know about this. So all the code handling this would typically be in JSP/servlets. You can use request.setAttribute(_exprs) to add extra-information and forward/redirect the current request to another resource. For example,consider about first.jsp, #pre and second.jsp: #pre From your browser, run and the output on your browser is #pre The basic difference between getAttribute(_exprs) and getParameter(_exprs) is that the first method extracts a (serialized) Java object and the other provides a String value. For both cases a name is given so that its value (be it string or a java bean) can be looked up and extracted."
        },
        {
            "answer_id": 4871135,
            "question_id": 4871051,
            "cleaned": "Current working directory is defined differently in different Java implementations For certain prior to Java 7 there was no consistent way to get the working directory. You could work around this by launching Java with -D and defining a variable to hold the info Something like #pre That's not quite right, but you get the idea. Then System.getProperty(_exprs) ..."
        },
        {
            "answer_id": 20810612,
            "question_id": 4871051,
            "cleaned": "I'm on Linux and get same result for both of these approaches: #pre #a #a"
        },
        {
            "answer_id": 21274808,
            "question_id": 4871051,
            "cleaned": "Use #a . This works fine in JAR files as well. You can obtain CodeSource by #a and the ProtectionDomain in turn can be obtained by #a . #pre"
        },
        {
            "answer_id": 27760556,
            "question_id": 4871051,
            "cleaned": "System.getProperty(_exprs)"
        },
        {
            "answer_id": 5868454,
            "question_id": 5868369,
            "cleaned": "You need to use the readLine(_exprs) method in class BufferedReader .\nCreate a new object from that class and operate this method on him and save it to a string. #a"
        },
        {
            "answer_id": 20593147,
            "question_id": 5868369,
            "cleaned": "In Java 8, you could do: #pre Some notes: The stream returned by Files.lines (unlike most streams) needs to be closed. For the reasons #a I avoid using forEach(_exprs) . The strange code (_exprs) lines::iterator casts a Stream to an Iterable."
        },
        {
            "answer_id": 31265714,
            "question_id": 5868369,
            "cleaned": "In Java 8, there is also an alternative to using #a . If your input source isn't a file but something more abstract like a Reader or an InputStream , you can the lines via the BufferedReader s lines(_exprs) method. For example: #pre will call processLine(_exprs) for each input line read by the BufferedReader ."
        },
        {
            "answer_id": 32542424,
            "question_id": 5868369,
            "cleaned": "What you can do is scan the entire text using Scanner and go through the text line by line.\nOf course you should import the following: #pre Scanner basically scans all the text. The while loop is used to traverse through the entire text. The .hasNextLine(_exprs) function is a boolean that returns true if there are still more lines in the text. The .nextLine(_exprs) function gives you an entire line as a String which you can then use the way you want. Try System.out.println(_exprs) to print the text. Side Note: .txt is the file type text."
        },
        {
            "answer_id": 5982478,
            "question_id": 5982447,
            "cleaned": "Use the #a method taking a typed array argument of the same size. #pre A different size can also, but that would force the toArray(_exprs) method to create a new array to return instead of reusing the provided argument, which may end up to be less efficient. See also #a ."
        },
        {
            "answer_id": 5455809,
            "question_id": 5455794,
            "cleaned": "st.replaceAll(_exprs) removes all whitespaces and non-visible characters (e.g., tab, \\n ). "
        },
        {
            "answer_id": 5455820,
            "question_id": 5455794,
            "cleaned": "How about replaceAll(_exprs) . Refer #a ."
        },
        {
            "answer_id": 5769679,
            "question_id": 5769669,
            "cleaned": "You can use #a to convert a String to a double : #pre For your case it looks like you want: #pre"
        },
        {
            "answer_id": 5192545,
            "question_id": 5192512,
            "cleaned": "Updated to bring in feedback. So two ways that work: #li Use StringBulderObj.setLength(_exprs) . #li Allocate a new one instead of clearing the buffer"
        },
        {
            "answer_id": 5193094,
            "question_id": 5192512,
            "cleaned": "There are basically two alternatives, using setLength(_exprs) to reset the StringBuilder or creating a new one in each iteration. Both can have pros and cons depending on the usage. If you know the expected capacity of the StringBuilder beforehand, creating a new one each time should be just as fast as setting a new length. It will also help the garbage collector, since each StringBuilder will be relatively short-lived and the gc is optimized for that. When you don't know the capacity, reusing the same StringBuilder might be faster. Each time you exceed the capacity when appending, a new backing array has to be allocated and the previous content has to be copied. By reusing the same StringBuilder, it will reach the needed capacity after some iterations and there won't be any copying thereafter."
        },
        {
            "answer_id": 22694891,
            "question_id": 5192512,
            "cleaned": "I think many of the answers here may be missing a quality method included in StringBuilder : .delete(_exprs) . I know this is a late reply; however, this should be made known (and explained a bit more thoroughly). Let's say you have a StringBuilder table - which you wish to modify, dynamically, throughout your program (one I am working on right now does this), e.g. #pre If you are looping through the method and alter the content, use the content, then wish to discard the content to \"clean up\" the StringBuilder for the next iteration, you can delete it's contents, e.g. #pre start and end being the indices of the chars you wish to remove. Don't know the length in chars and want to delete the whole thing? #pre NOW, for the kicker. StringBuilders , as mentioned previously, take a lot of overhead when altered  frequently (and can cause safety issues with regard to threading); therefore, use StringBuffer - same as StringBuilder (with a few exceptions) - if your StringBuilder is used for the purpose of interfacing with the user."
        },
        {
            "answer_id": 30190425,
            "question_id": 5192512,
            "cleaned": "I'll vote for sb.setLength(_exprs); not only because it's one function call but like sb.delete(_exprs); , It just fill the remaining characters to be 0 and set the length variable to the new length. You can take a look into their implementation to validate my point from #a at setLength function and delete0 function."
        },
        {
            "answer_id": 6094600,
            "question_id": 6094575,
            "cleaned": "You can use #a to get a #a object of the desired class. Then use #a to find the desired #a object. Finally, call #a on that object to get your new instance. #pre"
        },
        {
            "answer_id": 6094602,
            "question_id": 6094575,
            "cleaned": "Yes, something like: #pre That will only work for a single string parameter of course, but you can modify it pretty easily. Note that the class name has to be a fully-qualified one, i.e. including the namespace. For nested classes, you need to use a dollar (as that's what the compiler uses). For example: #pre To obtain the Class object for that, you'd need Class.forName(_exprs) ."
        },
        {
            "answer_id": 26159586,
            "question_id": 6094575,
            "cleaned": "when using (i.e.) getConstructor(_exprs) the constructor has to be declared public.\nOtherwise a NoSuchMethodException is thrown. if you want to access a you have to use instead (i.e.) getDeclaredConstructor(_exprs) ."
        },
        {
            "answer_id": 5175771,
            "question_id": 5175728,
            "cleaned": "Have a look at the #a class. There's also the newer #a class which is the preferred method of doing many date / time operations (a lot of the methods on Date have been deprecated.) If you just want the current date, then either create a new Date object or call Calendar.getInstance(_exprs); ."
        },
        {
            "answer_id": 5175900,
            "question_id": 5175728,
            "cleaned": "It depends on what form of date / time you want: #li If you want the date / time as a single numeric value, then System.currentTimeMillis(_exprs) gives you that, expressed as the number of milliseconds after the UNIX epoch (as a Java long ).  This value is a delta from a UTC time-point, and is independent of the local time-zone ... assuming that the system clock has been set correctly. #li If you want the date / time in a form that allows you to access the components (year, month, etc) numerically, you could use one of the following: #li new Date(_exprs) gives you a Date object initialized with the current date / time.  The problem is that the Date API methods are mostly flawed ... and deprecated. #li Calendar.getInstance(_exprs) gives you a Calendar object initialized with the current date / time, using the default Locale and TimeZone .  Other overloads allow you to use a specific Locale and/or TimeZone .  Calendar works ... but the APIs are still cumbersome. #li new org.joda.time.DateTime(_exprs) gives you a #a object initialized with the current date / time, using the default time zone and chronology.  There are lots of other Joda alternatives ... too many to describe here. #li in Java 8, calling LocalDateTime.now(_exprs) and ZonedDateTime.now(_exprs) will give you representations for the current date / time. Prior to Java 8, most people who know about these things recommended #a as having (by far) the best Java APIs for doing things involving time point and duration calculations.  With Java 8, this is no longer true.  However, if you are already using Joda time in your codebase, there is no strong reason to migrate."
        },
        {
            "answer_id": 4772461,
            "question_id": 4772425,
            "cleaned": "Use #a (or #a if the string happens to contain a time zone part) to parse a String in a certain pattern into a LocalDateTime . #pre Use #a (or #a ) to format a LocalDateTime into a String in a certain pattern. #pre , when you're not on Java 8 yet, use #a to parse a String in a certain pattern into a Date . #pre Use #a to format a Date into a String in a certain pattern. #pre  #li #a "
        },
        {
            "answer_id": 18953213,
            "question_id": 4772425,
            "cleaned": "remove one y form SimpleDateFormat dt1 = new SimpleDateFormat(_exprs); should be SimpleDateFormat dt1 = new SimpleDateFormat(_exprs);"
        },
        {
            "answer_id": 5839392,
            "question_id": 5839359,
            "cleaned": "You're essentially running out of memory to run the process smoothly. Options that come to mind: #li Specify more memory like you mentioned, try something in between like -Xmx512m first #li Work with smaller batches of HashMap objects to process at once if possible #li If you have a lot of duplicate strings, use #a on them before putting them into the HashMap #li Use the #a constructor to tune for your case"
        },
        {
            "answer_id": 6252802,
            "question_id": 6252678,
            "cleaned": "You need a #a appropriate to the format you're using.  Take a look at the docs for instructions on how to build one. Off the cuff, I think you need format = DateTimeFormat.forPattern(_exprs)"
        },
        {
            "answer_id": 4709284,
            "question_id": 4709175,
            "cleaned": "#blockquote You can use an Enum to represent a smallish fixed set of constants or an internal class mode while increasing readability. Also, Enums can enforce a certain rigidity when used in method parameters. They offer the interesting possibility of passing information to a constructor like in the #a and, as you've discovered, also allow a simple way to create a singleton pattern. ex: Locale.setDefault(_exprs) reads better than Locale.setDefault(_exprs) and enforces the use of fixed set of values shown in an IDE when you add the . separator instead of all integers."
        },
        {
            "answer_id": 4709892,
            "question_id": 4709175,
            "cleaned": "Something none of the other answers have covered that make enums particularly powerful are the ability to have #a . Methods can be part of the base enum and overridden by each type. And, with the behavior attached to the enum, it often eliminates the need for if-else constructs or switch statements as this #a - where enum.method(_exprs) does what originally would be executed inside the conditional. The same example also shows the use of static imports with enums as well producing much cleaner DSL like code. Some other interesting qualities include the fact that enums provide implementation for equals(_exprs) , toString(_exprs) and hashCode(_exprs) and implement Serializable and Comparable . For a complete rundown of all that enums have to offer I highly recommend Bruce Eckel's #a which devotes an entire chapter to the topic. Particularly illuminating are the examples involving a Rock, Paper, Scissors (i.e. RoShamBo) game as enums."
        },
        {
            "answer_id": 4818753,
            "question_id": 4818699,
            "cleaned": "There are two main uses of AtomicInteger : #li As an atomic counter ( incrementAndGet(_exprs) , etc) that can be used by many threads concurrently #li As a primitive that supports #a instruction ( compareAndSet(_exprs) ) to implement non-blocking algorithms. Here is an example of non-blocking random number generator from #a : #pre As you can see, it basically works almost the same way as incrementAndGet(_exprs) , but performs arbitrary calculation ( calculateNext(_exprs) ) instead of increment (and processes the result before return)."
        },
        {
            "answer_id": 4818783,
            "question_id": 4818699,
            "cleaned": "The absolute simplest example I can think of is to make incrementing an atomic operation. With standard ints: #pre With AtomicInteger: #pre The latter is a very simple way to perform simple mutations effects (especially counting, or unique-indexing), without having to resort to synchronizing all access. More complex synchronization-free logic can be employed by using compareAndSet(_exprs) as a type of optimistic locking - get the current value, compute result based on this, set this result value is still the input used to do the calculation, else start again - but the counting examples are very useful, and I'll often use AtomicIntegers for counting and VM-wide unique generators if there's any hint of multiple threads being involved, because they're so easy to work with I'd almost consider it premature optimisation to use plain ints . While you can almost always achieve the same synchronization guarantees with ints and appropriate synchronized declarations, the beauty of AtomicInteger is that the thread-safety is built into the actual object itself, rather than you needing to worry about the possible interleavings, and monitors held, of every method that happens to access the int value.  It's much harder to accidentally violate threadsafety when calling getAndIncrement(_exprs) than when returning i++ and remembering (or not) to acquire the correct set of monitors beforehand."
        },
        {
            "answer_id": 4818916,
            "question_id": 4818699,
            "cleaned": "The primary use of AtomicInteger is when you are in a multithreaded context and you need to perform thread safe operations on an integer without using synchronized . The assignation and retrieval on the primitive type int are already atomic but AtomicInteger comes with many operations which are not atomic on int . The simplest are the getAndXXX or xXXAndGet . For instance getAndIncrement(_exprs) is an atomic equivalent to i++ which is not atomic because it is actually a short cut for three operations: retrieval, addition and assignation. compareAndSet is very useful to implements semaphores, locks, latches, etc. Using the AtomicInteger is faster and more readable than performing the same using synchronization. A simple test: #pre On my PC with Java 1.6 the atomic test runs in 3 seconds while the synchronized one runs in about 5.5 seconds. The problem here is that the operation to synchronize ( notAtomic++ ) is really short. So the cost of the synchronization is really important compared to the operation. Beside atomicity AtomicInteger can be use as a mutable version of Integer for instance in Map s as values."
        },
        {
            "answer_id": 4819109,
            "question_id": 4818699,
            "cleaned": "If you look at the methods AtomicInteger has, you'll notice that they tend to correspond to common operations on ints.  For instance: #pre is the thread-safe version of this: #pre The methods map like this: There are other convenience methods as well, like compareAndSet or addAndGet"
        },
        {
            "answer_id": 19459145,
            "question_id": 4759570,
            "cleaned": "This works on Windows with Cygwin installed: System.getenv(_exprs)"
        },
        {
            "answer_id": 6271460,
            "question_id": 6271417,
            "cleaned": "The \"$1\" is not \"useless non-sense\". If your class is anonymous, a number is appended. If you don't want the class itself, but its declaring class, then you can use getEnclosingClass(_exprs) . For example: #pre You can move that in some static utility method. But note that this is not the current class name. The anonymous class is different class than its enclosing class. The case is similar for inner classes."
        },
        {
            "answer_id": 6271520,
            "question_id": 6271417,
            "cleaned": "Try using this.getClass(_exprs).getCanonicalName(_exprs) or this.getClass(_exprs).getSimpleName(_exprs) .  If it's an anonymous class, use this.getClass.getSuperclass.getName(_exprs)"
        },
        {
            "answer_id": 6271668,
            "question_id": 6271417,
            "cleaned": "I'm assuming this is happening for an anonymous class. When you create an anonymous class you actually create a class that extends the class whose name you got. The \"cleaner\" way to get the name you want is: If your class is an anonymous inner class, getSuperClass(_exprs) should give you the class that it was created from. If you created it from an interface than you're sort of SOL because the best you can do is getInterfaces(_exprs) which might give you more than one interface. The \"hacky\" way is to just get the name with getClassName(_exprs) and use a regex to drop the $1 ."
        },
        {
            "answer_id": 29938300,
            "question_id": 6271417,
            "cleaned": "Use this method,but be careful to make an object in your main. public static void setName(_exprs){\n        Class setClass = obj.getClass(_exprs);\n        String className = setClass.getName(_exprs);\n        System.out.println(_exprs);\n    }"
        },
        {
            "answer_id": 5263201,
            "question_id": 5263187,
            "cleaned": "System.out.println(_exprs);"
        },
        {
            "answer_id": 5039178,
            "question_id": 5038204,
            "cleaned": "The commons/lang builders are great and I have been using them for years without noticeable performance overhead (with and without hibernate). But as Alain writes, the Guava way is even nicer: Here's a sample Bean: #pre Here's equals() and hashCode() implemented with Commons/Lang: #pre and here with Guava: #pre As you can see the Guava version is shorter and avoids superfluous helper objects. In case of equals, it even allows for short-circuiting the evaluation if an earlier Object.equal(_exprs) call returns false (to be fair: commons / lang has an ObjectUtils.equals(_exprs) method with identical semantics which could be used instead of EqualsBuilder to allow short-circuiting as above). So: yes, the commons lang builders are very preferable over manually constructed equals(_exprs) and hashCode(_exprs) methods (or those awful monsters Eclipse will generate for you), but the Guava versions are even better. And a note about Hibernate: be careful about using lazy collections in your equals(), hashCode() and toString() implementations. That will fail miserably if you don't have an open Session. "
        },
        {
            "answer_id": 4812585,
            "question_id": 4812570,
            "cleaned": "You have to use getStackTrace (_exprs) method instead of printStackTrace(_exprs) . Here is a #a : #pre"
        },
        {
            "answer_id": 21765043,
            "question_id": 4812570,
            "cleaned": "You can use the ExceptionUtils.getStackTrace(_exprs); from Apache Commons 3 class org.apache.commons.lang3.exception.ExceptionUtils . #a"
        },
        {
            "answer_id": 5071064,
            "question_id": 5071040,
            "cleaned": "There are multiple ways: #li String.valueOf(_exprs) (my preference) #li _str + number (I don't know how the compiler handles it, perhaps it is as efficient as the above) #li Integer.toString(_exprs)"
        },
        {
            "answer_id": 22547954,
            "question_id": 5071040,
            "cleaned": "Always use either String.valueOf(_exprs) or Integer.toString(_exprs) . Using \"\" + number is an overhead and does the following: #pre"
        },
        {
            "answer_id": 4576367,
            "question_id": 4576352,
            "cleaned": "using #pre will work usage would be str.replace(_exprs); executing #pre returns: #pre"
        },
        {
            "answer_id": 11325546,
            "question_id": 4576352,
            "cleaned": "You can use str = str.replace(_exprs); as mentioned before and you will be fine. For your information _char is not an empty (or a valid) character but _char is. So you could use str = str.replace(_exprs); instead."
        },
        {
            "answer_id": 5032837,
            "question_id": 5031614,
            "cleaned": "If you want to use equals(_exprs)/hashCode(_exprs) for your Sets, in the sense that the can only be in there once, then there is only one option: Option 2. That's because a for an entity by definition never changes (if somebody indeed updates it, it's not the same entity anymore) You should take that literally: Since your equals(_exprs)/hashCode(_exprs) are based on the primary key, you must not use these methods, until the primary key is set. So you shouldn't put entities in the set, until they're assigned a primary key. (Yes, UUIDs and similar concepts may help to assign primary keys early.) Now, it's theoretically also possible to achieve that with Option 3, even though so-called \"business-keys\" have the nasty drawback that they can change: \"All you'll have to do is delete the already inserted entities from the set(s), and re-insert them.\" That is true - but it also means, that in a distributed system, you'll have to make sure, that this is done absolutely everywhere the data has been inserted to (and you'll have to make sure, that the update is performed, before other things occur). You'll need a sophisticated update mechanism, especially if some remote systems aren't currently reachable... Option 1 can only be used, if all the objects in your sets are from the same Hibernate session. The Hibernate documentation makes this very clear in chapter #a : #blockquote It continues to argue in favor of Option 3: #blockquote This is true, you #li cannot assign the id early (e.g. by using UUIDs) #li and yet you absolutely want to put your objects in sets while they're in transient state. Otherwise, you're free to choose Option 2. Then it mentions the need for a relative stability: #blockquote This is correct. The practical problem I see with this is: If you can't guarantee absolute stability, how will you be able to guarantee stability \"as long as the objects are in the same Set\". I can imagine some special cases (like using sets only for a conversation and then throwing it away), but I would question the general practicability of this. "
        },
        {
            "answer_id": 5103360,
            "question_id": 5031614,
            "cleaned": "We usually have two IDs in our entities: #li Is for persistence layer only (so that persistence provider and database can figure out relationships between objects). #li Is for our application needs ( equals(_exprs) and hashCode(_exprs) in particular) Take a look: #pre "
        },
        {
            "answer_id": 26826084,
            "question_id": 5031614,
            "cleaned": "#li If you have a #a , then you should use that for equals / hashCode . #li If you don't have a business key, you should not leave it with the default Object equals and hashCode implementations because that does not work after you merge and entity. #li You can #a . The only catch is that you need to use a hashCode implementation that always return the same value, like this: #pre"
        },
        {
            "answer_id": 17300003,
            "question_id": 5554217,
            "cleaned": "Another way is to use an array as a type, e.g.: #pre This way you avoid all the hassle with the Type object, and if you really need a list you can always convert the array to a list by: #pre IMHO this is much more readable. And to make it be an actual list (that can be modified, see limitations of Arrays.asList(_exprs) ) then just do the following: #pre"
        },
        {
            "answer_id": 5673356,
            "question_id": 5673260,
            "cleaned": "#pre Generally speaking, when you have response.getOutputStream(_exprs) , you can write anything there. You can pass this output stream as a place to put generated PDF to your generator. Also, if you know what file type you are sending, you can set #pre"
        },
        {
            "answer_id": 5673375,
            "question_id": 5673260,
            "cleaned": "You should be able to write the file on the response directly. Something like #pre and then write the file as a binary stream on response.getOutputStream(_exprs) . Remember to do response.flush(_exprs) at the end and that should do it."
        },
        {
            "answer_id": 15962949,
            "question_id": 5785745,
            "cleaned": "If you want to make a copy of: #pre This is the way to go: #pre Arrays.copyOf may be faster than a.clone(_exprs) on small arrays. Both copy elements equally fast but clone() returns Object so the compiler has to insert an implicit cast to int[] . You can see it in the bytecode, something like this: #pre"
        },
        {
            "answer_id": 34845194,
            "question_id": 5785745,
            "cleaned": "You can also use #a . : #pre This method is similar to #a , but it's more flexible. Both of them use System.arraycopy under the hood. : #li #a #li #a #li #a"
        },
        {
            "answer_id": 5694464,
            "question_id": 5694385,
            "cleaned": "Rather than spoon-feed you code, here's how to look in the #a . First, you're dealing with IO, so look in the java.io #a . There are two classes that look interesting: #a and #a . When I clicked on the first, it showed me that there was a a listFiles(_exprs) method in the #a class. And the documentation for that method says: #blockquote Scrolling up in the File JavaDoc, I see the constructors. And that's really all I need to be able to create a File instance and call listFiles(_exprs) on it. Scrolling still further, I can see some information about how files are named in different operating systems."
        },
        {
            "answer_id": 5694473,
            "question_id": 5694385,
            "cleaned": "Create a #a object, passing the directory path to the constructor. Use the listFiles(_exprs) to retrieve an array of File objects for each file in the directory, and then call the getName(_exprs) method to get the filename. #pre"
        },
        {
            "answer_id": 5439543,
            "question_id": 5439529,
            "cleaned": "You can use Integer.parseInt(_exprs) or Integer.valueOf(_exprs) to get the integer from the string, and catch the exception if it is not a parsable int.  You want to be sure to catch the NumberFormatException it can throw. It may be helpful to note that valueOf() will return an Integer object, not the primitive int."
        },
        {
            "answer_id": 5439600,
            "question_id": 5439529,
            "cleaned": "As an alternative to trying to parse the string and catching NumberFormatException , you could use a regex; e.g. #pre This is likely to be faster, especially if you precompile and reuse the regex.  However, the catch is that Integer.parseInt(_exprs) will still fail if str represents a number that is outside range of legal int values."
        },
        {
            "answer_id": 9991624,
            "question_id": 5439529,
            "cleaned": "You can use Integer.parseInt(_exprs) and catch the NumberFormatException if the string is not a valid integer, in the following fashion (as pointed out by all answers): #pre However, note here that if the evaluated integer overflows, the same exception will be thrown. Your purpose was to find out whether or not, it was a valid integer. So its safer to make your own method to check for validity: #pre"
        },
        {
            "answer_id": 15357940,
            "question_id": 5439529,
            "cleaned": "Or simply mystring.matches(_exprs) though it would return true for numbers larger than an int"
        },
        {
            "answer_id": 6416788,
            "question_id": 6416706,
            "cleaned": "As soon as you call contains , containsAll , equals , hashCode , remove , retainAll , size or toArray , you'd have to traverse the elements anyway. If you're occasionally only calling methods such as isEmpty or clear I suppose you'd be better of by creating the collection lazily. You could for instance have a backing ArrayList for storing previously iterated elements. I don't know of any such class in any library, but it should be a fairly simple exercise to write up."
        },
        {
            "answer_id": 6416800,
            "question_id": 6416706,
            "cleaned": "With #a you can use #a or #a , among other similar methods. This will of course copy all the elements in to memory. If that isn't acceptable, I think your code that works with these ought to take Iterable rather than Collection . Guava also happens to provide convenient methods for doing things you can do on a Collection using an Iterable (such as Iterables.isEmpty(_exprs) or Iterables.contains(_exprs) ), but the performance implications are more obvious."
        }
    ]
}