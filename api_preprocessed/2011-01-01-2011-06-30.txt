Question-5455794
I have a string like this: mysz = StringLiteral; I want to remove the whitespaces in the string. I tried trim(args) but this removes only whitespaces before and after the whole string. I also tried replaceAll(args) but then the = also gets removed. How can I achieve a string with: mysz2 = StringLiteral

Question-4645020
It is supposed to be generally preferable to use a StringBuilder for string concatenation in Java. Is this always the case? What I mean is this: Is the overhead of creating a StringBuilder object, calling the append(args) method and finally toString(args) already smaller then concatenating existing strings with the + operator for two strings, or is it only advisable for more (than two) strings? If there is such a threshold, what does it depend on (perhaps the string length, but in which way)? And finally, would you trade the readability and conciseness of the + concatenation for the performance of the StringBuilder in smaller cases like two, three or four strings? EDIT Explicit use of StringBuilder for regular concatenations is being mentioned as obsolete at obsolete java optimization tips as well as at java urban myths .

Question-4576352
I can use this: #pre Is there a way to remove all occurrences of character X from a String in Java? I tried this and is not what I want: str.replace(args); //replace with space

Question-5031614
There have been some discussions here about JPA entities and which hashCode(args) / equals(args) implementation should be used for JPA entity classes. Most (if not all) of them depend on Hibernate, but I'd like to discuss them JPA-implementation-neutrally (I am using EclipseLink, by the way). All possible implementations are having their own advantages and disadvantages regarding: #li hashCode(args) / equals(args) contract conformity (immutability) for List / Set operations #li Whether identical objects (e.g. from different sessions, dynamic proxies from lazily-loaded data structures) can be detected #li Whether entities behave correctly in detached (or non-persisted) state As far I can see, there are three options : #li Do not override them; rely on Object.equals(args) and Object.hashCode(args) #li hashCode(args) / equals(args) work #li cannot identify identical objects, problems with dynamic proxies #li no problems with detached entities #li Override them, based on the primary key #li hashCode(args) / equals(args) are broken #li correct identity (for all managed entities) #li problems with detached entities #li Override them, based on the Business-Id (non-primary key fields; what about foreign keys?) #li hashCode(args) / equals(args) are broken #li correct identity (for all managed entities) #li no problems with detached entities My questions are: #li Did I miss an option and/or pro/con point? #li What option did you choose and why? UPDATE 1: By " hashCode(args) / equals(args) are broken", I mean that successive hashCode(args) invocations may return differing values, which is (when correctly implemented) not broken in the sense of the Object API documentation, but which causes problems when trying to retrieve a changed entity from a Map , Set or other hash-based Collection . Consequently, JPA implementations (at least EclipseLink) will not work correctly in some cases. UPDATE 2: Thank you for your answers -- most of them have remarkable quality. Unfortunately, I am still unsure which approach will be the best for a real-life application, or how to determine the best approach for my application. So, I'll keep the question open and hope for some more discussions and/or opinions.

Question-5011932
I am storing a SQL query in my strings.xml file and I want to use String.Format to build the final string in code. The SELECT statement uses a like, something like this: SELECT Field1, Field2 FROM mytable WHERE Field1 LIKE '%something%' In order to format that I replace 'something' with %1$s so it becomes: SELECT Field1, Field2 FROM mytable WHERE Field1 LIKE \'%%1$s%\' I escape the single quotes with the backslash. However I am not able to escape the % sign. How can I include a like statement in my strings.xml file?

Question-5439529
I'm trying to determine if a particular item in an Array of strings is an integer or not. I am .split(args)'ing an infix expression in String form, and then trying to split the resultant array into two arrays; one for integers, one for operators, whilst discarding parentheses, and other miscellaneous items. What would be the best way to accomplish this? I thought I might be able to find a Integer.isInteger(args) method or something, but no such luck.

Question-5243754
What is the difference between getAttribute(args) and getParameter(args) methods within HttpServletRequest class?

Question-4812570
How can I get the e.printStackTrace(args) and store it into a String variable? I want to use the string generated by e.printStackTrace(args) later in my program. I'm still new to Java so I'm not too familiar with StringWriter that I think will be the solution. Or if you have any other ideas please let me know. Thanks

Question-6470651, answer-6470695
A simple thing to do is to use a HashSet with an incorrect (or non-existent) hashCode(args) or equals(args) , and then keep adding "duplicates". Instead of ignoring duplicates as it should, the set will only ever grow and you won't be able to remove them. If you want these bad keys/elements to hang around you can use a static field like #pre

Question-6470651, answer-6540248
Below there will be a non-obvious case where Java leaks, besides the standard case of forgotten listeners, static references, bogus/modifiable keys in hashmaps, or just threads stuck without any chance to end their life-cycle. #li File.deleteOnExit(args) - always leaks the string, if the string is a substring, the leak is even worse (the underlying char[] is also leaked) - in Java 7 substring also copies the char[] , so the later doesn't apply ; @Daniel, no needs for votes, though. I'll concentrate on threads to show the danger of unmanaged threads mostly, don't wish to even touch swing. #li Runtime.addShutdownHook and not remove... and then even with removeShutdownHook due to a bug in ThreadGroup class regarding unstarted threads it may not get collected, effectively leak the ThreadGroup. JGroup has the leak in GossipRouter. #li Creating, but not starting, a Thread goes into the same category as above. #li Creating a thread inherits the ContextClassLoader and AccessControlContext , plus the ThreadGroup and any InheritedThreadLocal , all those references are potential leaks, along with the entire classes loaded by the classloader and all static references, and ja-ja. The effect is especially visible with the entire j.u.c.Executor framework that features a super simple ThreadFactory interface, yet most developers have no clue of the lurking danger. Also a lot of libraries do start threads upon request (way too many industry popular libraries). #li ThreadLocal caches; those are evil in many cases. I am sure everyone has seen quite a bit of simple caches based on ThreadLocal, well the bad news: if the thread keeps going more than expected the life the context ClassLoader, it is a pure nice little leak. Do not use ThreadLocal caches unless really needed. #li Calling ThreadGroup.destroy(args) when the ThreadGroup has no threads itself, but it still keeps child ThreadGroups. A bad leak that will prevent the ThreadGroup to remove from its parent, but all the children become un-enumerateable. #li Using WeakHashMap and the value (in)directly references the key. This is a hard one to find without a heap dump. That applies to all extended Weak/SoftReference that might keep a hard reference back to the guarded object. #li Using java.net.URL with the HTTP(S) protocol and loading the resource from(!). This one is special, the KeepAliveCache creates a new thread in the system ThreadGroup which leaks the current thread's context classloader. The thread is created upon the first request when no alive thread exists, so either you may get lucky or just leak. The leak is already fixed in Java 7 and the code that creates thread properly removes the context classloader. There are few more cases ( like ImageFetcher , also fixed ) of creating similar threads. #li Using InflaterInputStream passing new java.util.zip.Inflater(args) in the constructor ( PNGImageDecoder for instance) and not calling end(args) of the inflater. Well, if you pass in the constructor with just new , no chance... And yes, calling close(args) on the stream does not close the inflater if it's manually passed as constructor parameter. This is not a true leak since it'd be released by the finalizer... when it deems it necessary. Till that moment it eats native memory so badly it can cause Linux oom_killer to kill the process with impunity. The main issue is that finalization in Java is very unreliable and G1 made it worse till 7.0.2. Moral of the story: release native resources as soon as you can; the finalizer is just too poor. #li The same case with java.util.zip.Deflater . This one is far worse since Deflater is memory hungry in Java, i.e. always uses 15 bits (max) and 8 memory levels (9 is max) allocating several hundreds KB of native memory. Fortunately, Deflater is not widely used and to my knowledge JDK contains no misuses. Always call end(args) if you manually create a Deflater or Inflater . The best part of the last two: you can't find them via normal profiling tools available. (I can add some more time wasters I have encountered upon request.) Good luck and stay safe; leaks are evil!

Question-6470651, answer-6548647
Static field holding object reference [esp final field] #pre Calling String.intern() on lengthy String #pre (Unclosed) open streams ( file , network etc... ) #pre Unclosed connections #pre Areas that are unreachable from JVM's garbage collector , such as memory allocated through native methods In web applications, some objects are stored in application scope until the application is explicitly stopped or removed. getServletContext(args).setAttribute(args); Incorrect or inappropriate JVM options , such as the noclassgc option on IBM JDK that prevents unused class garbage collection See IBM jdk settings .

Question-6470651, answer-6780439
Here's a simple/sinister one via #a . #pre Because the substring refers to the internal representation of the original, much longer string, the original stays in memory. Thus, as long as you have a StringLeaker in play, you have the whole original string in memory, too, even though you might think you're just holding on to a single-character string. The way to avoid storing an unwanted reference to the original string is to do something like this: #pre For added badness, you might also .intern(args) the substring: #pre Doing so will keep both the original long string and the derived substring in memory even after the StringLeaker instance has been discarded.

Question-6470651, answer-18544736
Threads are not collected until they terminate. They serve as roots of garbage collection. They are one of the few objects that won't be reclaimed simply by forgetting about them or clearing references to them. Consider: the basic pattern to terminate a worker thread is to set some condition variable seen by the thread. The thread can check the variable periodically and use that as a signal to terminate. If the variable is not declared volatile , then the change to the variable might not be seen by the thread, so it won't know to terminate. Or imagine if some threads want to update a shared object, but deadlock while trying to lock on it. If you only have a handful of threads these bugs will probably be obvious because your program will stop working properly. If you have a thread pool that creates more threads as needed, then the obsolete/stuck threads might not be noticed, and will accumulate indefinitely, causing a memory leak. Threads are likely to use other data in your application, so will also prevent anything they directly reference from ever being collected. As a toy example: #pre Call System.gc(args) all you like, but the object passed to leakMe will never die. (*edited*)

Question-5585779, answer-5585800
int foo = Integer.parseInt(args); See the Java Documentation for more information. (If you have it in a StringBuilder (or the ancient StringBuffer ), you'll need to do Integer.parseInt(args); instead).

Question-5585779, answer-5585876
For example, here are two ways: #pre There is a slight difference between these methods: #li valueOf returns a new or cached instance of java.lang.Integer #li parseInt returns primitive int . The same is for all cases: Short.valueOf / parseShort , Long.valueOf / parseLong , etc.

Question-5585779, answer-33233407
We can use the parseInt(args) method of the Integer wrapper class for converting a String value to an integer value. For example: #pre The Integer class also provides the valueOf(args) method: #pre We can also use toInt(args) of NumberUtils Utility Class for the conversion: #pre

Question-5585779, answer-35834484
Integer.decode You can also use public static Integer decode(args) throws NumberFormatException . It also works for base 8 and 16: #pre If you want to get int instead of Integer you can use: #li Unboxing: int val = Integer.decode(args); #li intValue(args) : Integer.decode(args).intValue(args);

Question-5585779, answer-36394016
Whenever there is the slightest possibility that the given String does not contain an Integer, you have to handle this special case. Sadly, the standard Java methods Integer::parseInt and Integer::valueOf throw a NumberFormatException to signal this special case. Thus, you have to use exceptions for flow control, which is generally considered bad coding style. In my opinion, this special case should be handled by returning an Optional<T> . Since Java does not offer such a method, I use the following wrapper: #pre Usage: #pre While this is still using exceptions for flow control internally, the usage code becomes very clean.

Question-5374311, answer-5374346
What is happening is that stock_list.toArray(args) is creating an Object[] rather than a String[] and hence the typecast is failing. The correct code would be: String [] stockArr = stockList.toArray(args); or even String [] stockArr = stockList.toArray(args); For more details, refer to the javadocs for the two overloads of List.toArray . (From a technical perspective, the reason for this API behaviour / design is that an implementation of the List<T>.toArray(args) method has no information of what the <T> is at runtime. All it knows is that the raw element type is Object . By contrast, in the other case, the array parameter gives the base type of the array. (If the supplied array is big enough, it is used. Otherwise a new array of the same type and a larger size will be allocated and returned as the result.)

Question-5374311, answer-17909134
I can see many answers showing how to solve problem, but only Stephen's answer is trying to explain why problem occurs so I will try to add something more on this subject. It is a story about possible reasons why Object[] toArray wasn't changed to T[] toArray where generics ware introduced to Java. Why String[] stockArr = (String[]) stock_list.toArray(args); wont work? In Java, generic type exists at compile-time only . At runtime information about generic type (like in your case <String> ) is removed and replaced with Object type (take a look at type erasure ). That is why at runtime toArray(args) have no idea about what precise type to use to create new array, so it uses Object as safest type, because each class extends Object so it can safely store instance of any class. Now the problem is that you can't cast instance of Object[] to String[] . Why? Take a look at this example (lets assume that class B extends A ): #pre Although such code will compile, at runtime we will see thrown ClassCastException because instance held by reference a is not actually of type B (or its subtypes). Why is this problem (why this exception needs to be cast)? One of the reasons is that B could have new methods/fields which A doesn't, so it is possible that someone will try to use these new members via b reference even if held instance doesn't have (doesn't support) them. In other words we could end up trying to use data which doesn't exist, which could lead to many problems. So to prevent such situation JVM throws exception, and stop further potentially dangerous code. You could ask now "So why aren't we stopped even earlier? Why code involving such casting is even compilable? Shouldn't compiler stop it?". Answer is: no because compiler can't know for sure what is the actual type of instance held by a reference, and there is a chance that it will hold instance of class B which will support interface of b reference. Take a look at this example: #pre Now lets go back to your arrays. As you see in question, we can't cast instance of Object[] array to more precise type String[] like #pre Here problem is a little different. Now we are sure that String[] array will not have additional fields or methods because every array support only: #li [] operator, #li length filed, #li methods inherited from Object supertype, So it is not arrays interface which is making it impossible. Problem is that Object[] array beside Strings can store any objects (for instance Integers ) so it is possible that one beautiful day we will end up with trying to invoke method like strArray[i].substring(args) on instance of Integer which doesn't have such method. So to make sure that this situation will never happen, in Java array references can hold only #li instances of array of same type as reference (reference String[] strArr can hold String[] ) #li instances of array of subtype ( Object[] can hold String[] because String is subtype of Object ), but can't hold #li array of supertype of type of array from reference ( String[] can't hold Object[] ) #li array of type which is not related to type from reference ( Integer[] can't hold String[] ) In other words something like this is OK #pre You could say that one way to resolve this problem is to find at runtime most common type between all list elements and create array of that type, but this wont work in situations where all elements of list will be of one type derived from generic one. Take a look #pre now most common type is B , not A so toArray(args) A[] arr = elements.toArray(args); would return array of B class new B[] . Problem with this array is that while compiler would allow you to edit its content by adding new A(args) element to it, you would get ArrayStoreException because B[] array can hold only elements of class B or its subclass, to make sure that all elements will support interface of B , but instance of A may not have all methods/fields of B . So this solution is not perfect. Best solution to this problem is explicitly tell what type of array toArray(args) should be returned by passing this type as method argument like String[] arr = list.toArray(args); or String[] arr = list.toArray(args); //if size of array is smaller then list it will be automatically adjusted.

Question-5374311, answer-17909839
The correct way to do this is: String[] stockArr = stock_list.toArray(args); I'd like to add to the other great answers here and explain how you could have used the Javadocs to answer your question. The Javadoc for toArray(args) (no arguments) is here . As you can see, this method returns an Object[] and not String[] which is an array of the runtime type of your list: #blockquote Right below that method, though, is the Javadoc for toArray(args) . As you can see, this method returns a T[] where T is the type of the array you pass in. At first this seems like what you're looking for, but it's unclear exactly why you're passing in an array (are you adding to it, using it for just the type, etc). The documentation makes it clear that the purpose of the passed array is essentially to define the type of array to return (which is exactly your use case): #blockquote Of course, an understanding of generics (as described in the other answers) is required to really understand the difference between these two methods. Nevertheless, if you first go to the Javadocs, you will usually find your answer and then see for yourself what else you need to learn (if you really do). Also note that reading the Javadocs here helps you to understand what the structure of the array you pass in should be. Though it may not really practically matter, you should not pass in an empty array like this: String [] stockArr = stockList.toArray(args); Because, from the doc, this implementation checks if the array is large enough to contain the collection; if not, it allocates a new array of the correct size and type (using reflection). There's no need for the extra overhead in creating a new array when you could easily pass in the size. As is usually the case, the Javadocs provide you with a wealth of information and direction. Hey wait a minute, what's reflection?

Question-5778658, answer-5778863
An OutputStream is one where you write data to. If some module exposes an OutputStream , the expectation is that there is something at the other end that is reading. Something that exposes an InputStream on the other hand is indicating that you will need to listen to this stream, and there will be data that you can read. So it is possible to connect an InputStream to an OutputStream InputStream----read---> intermediateBytes[n] ----write----> OutputStream As someone metioned, this is what the copy(args) method from IOUtils lets you do. It does not make sense to go the other way... hopefully this makes some sense UPDATE: Of course the more I think of this, the more I can see how this actually would be a requirement. I know some of the comments mentioned Piped input/ouput streams, but there is another possibility. If the output stream that is exposed is a ByteArrayOutputStream , then you can always get the full contents by calling the toByteArray(args) method. Then you can create an input stream wrapper by using the ByteArrayInputStream sub-class. These two are pseudo-streams, they both basically just wrap an array of bytes. Using the streams this way, therefore, is technically possible, but to me it is still very strange...

Question-5778658, answer-10768914
You will need an intermediate class which will buffer between. Each time InputStream.read(args) is called, the buffering class will fill the passed in byte array with the next chunk passed in from OutputStream.write(args) . Since the sizes of the chunks may not be the same, the adapter class will need to store a certain amount until it has enough to fill the read buffer and/or be able to store up any buffer overflow. This article has a nice breakdown of a few different approaches to this problem: #a

Question-5243754, answer-5243798
#li getParameter(args) returns http request parameters. Those passed from the client to the server. For example http://example.com/servlet?parameter=1 . Can only return String #li getAttribute(args) is for server-side usage only - you fill the request with attributes that you can use within the same request. For example - you set an attribute in a servlet, and read it from a JSP. Can be used for any object, not just string.

Question-5243754, answer-13612866
It is crucial to know that attributes are not parameters . The return type for attributes is an Object , whereas the return type for a parameter is a String . When calling the getAttribute(args) method, bear in mind that the attributes must be cast. Additionally, there is no servlet specific attributes , and there are no session parameters . This post is written with the purpose to connect on @Bozho's response, as additional information that can be useful for other people.

Question-5243754, answer-25074487
- getParameter() : #pre request.getParameter(args) will get the value from the posted form of the input box named "testParam" which is "Client param". It will then print it out, so you should see "Client Param" on the screen. So request.getParameter() will retrieve a value that the client has submitted. You will get the value on the server side. - getAttribute() : request.getAttribute(args) , this is all done server side. YOU add the attribute to the request and YOU submit the request to another resource, the client does not know about this. So all the code handling this would typically be in servlets.getAttribute always return object.

Question-5243754, answer-34295445
request.getParameter() We use request.getParameter(args) to extract request parameters (i.e. data sent by posting a html form ). The request.getParameter(args) always returns String value and the data come from client. request.getAttribute() We use request.getAttribute(args) to get an object added to the request scope on the server side i.e. using request.setAttribute(args) . You can add any type of object you like here, Strings , Custom objects, in fact any object. You add the attribute to the request and forward the request to another resource, the client does not know about this. So all the code handling this would typically be in JSP/servlets. You can use request.setAttribute(args) to add extra-information and forward/redirect the current request to another resource. For example,consider about first.jsp, #pre and second.jsp: #pre From your browser, run first.jsp?CLIENT=you and the output on your browser is #pre The basic difference between getAttribute(args) and getParameter(args) is that the first method extracts a (serialized) Java object and the other provides a String value. For both cases a name is given so that its value (be it string or a java bean) can be looked up and extracted.

Question-4871051, answer-4871135
Current working directory is defined differently in different Java implementations For certain prior to Java 7 there was no consistent way to get the working directory. You could work around this by launching Java with -D and defining a variable to hold the info Something like java -Dcom.mycompany.workingDir=StringLiteral That's not quite right, but you get the idea. Then System.getProperty(args) ...

Question-4871051, answer-20810612
I'm on Linux and get same result for both of these approaches: #pre Paths.get("") docs System.getProperty("user.dir") docs

Question-4871051, answer-21274808
Use CodeSource#getLocation() . This works fine in JAR files as well. You can obtain CodeSource by ProtectionDomain#getCodeSource() and the ProtectionDomain in turn can be obtained by Class#getProtectionDomain() . #pre

Question-4871051, answer-27760556
System.getProperty(args)

Question-5868369, answer-5868454
You need to use the readLine(args) method in class BufferedReader . Create a new object from that class and operate this method on him and save it to a string. BufferReader API

Question-5868369, answer-20593147
In Java 8, you could do: #pre Some notes: The stream returned by Files.lines (unlike most streams) needs to be closed. For the reasons mentioned here I avoid using forEach(args) . The strange code (Iterable<T>) lines::iterator casts a Stream to an Iterable.

Question-5868369, answer-31265714
In Java 8, there is also an alternative to using Files.lines() . If your input source isn't a file but something more abstract like a Reader or an InputStream , you can stream the lines via the BufferedReader s lines(args) method. For example: #pre will call processLine(args) for each input line read by the BufferedReader .

Question-5868369, answer-32542424
What you can do is scan the entire text using Scanner and go through the text line by line. Of course you should import the following: #pre Scanner basically scans all the text. The while loop is used to traverse through the entire text. The .hasNextLine(args) function is a boolean that returns true if there are still more lines in the text. The .nextLine(args) function gives you an entire line as a String which you can then use the way you want. Try System.out.println(args) to print the text. Side Note: .txt is the file type text.

Question-5982447, answer-5982478
Use the Set#toArray(T[]) method taking a typed array argument of the same size. String[] GPXFILES1 = myset.toArray(args); A different size can also, but that would force the toArray(args) method to create a new array to return instead of reusing the provided argument, which may end up to be less efficient. See also the source code of AbstractCollection#toArray() .

Question-5455794, answer-5455809
st.replaceAll(args) removes all whitespaces and non-visible characters (e.g., tab, \n ). st.replaceAll(args) and st.replaceAll(args) produce the same result. The second regex is 20% faster than the first one, but as the number consecutive spaces increases, the first one performs better than the second one. Assign the value to a variable, if not used directly: st = st.replaceAll(args)

Question-5455794, answer-5455820
How about replaceAll(args) . Refer here .

Question-5769669, answer-5769679
You can use Double.parseDouble() to convert a String to a double : #pre For your case it looks like you want: #pre

Question-5192512, answer-5192545
Edit Updated to bring in feedback. So two ways that work: #li Use StringBulderObj.setLength(args) . #li Allocate a new one instead of clearing the buffer

Question-5192512, answer-5193094
There are basically two alternatives, using setLength(args) to reset the StringBuilder or creating a new one in each iteration. Both can have pros and cons depending on the usage. If you know the expected capacity of the StringBuilder beforehand, creating a new one each time should be just as fast as setting a new length. It will also help the garbage collector, since each StringBuilder will be relatively short-lived and the gc is optimized for that. When you don't know the capacity, reusing the same StringBuilder might be faster. Each time you exceed the capacity when appending, a new backing array has to be allocated and the previous content has to be copied. By reusing the same StringBuilder, it will reach the needed capacity after some iterations and there won't be any copying thereafter.

Question-5192512, answer-22694891
I think many of the answers here may be missing a quality method included in StringBuilder : .delete(args) . I know this is a late reply; however, this should be made known (and explained a bit more thoroughly). Let's say you have a StringBuilder table - which you wish to modify, dynamically, throughout your program (one I am working on right now does this), e.g. StringBuilder table = new StringBuilder(args); If you are looping through the method and alter the content, use the content, then wish to discard the content to "clean up" the StringBuilder for the next iteration, you can delete it's contents, e.g. table.delete(args). start and end being the indices of the chars you wish to remove. Don't know the length in chars and want to delete the whole thing? table.delete(args); NOW, for the kicker. StringBuilders , as mentioned previously, take a lot of overhead when altered frequently (and can cause safety issues with regard to threading); therefore, use StringBuffer - same as StringBuilder (with a few exceptions) - if your StringBuilder is used for the purpose of interfacing with the user.

Question-5192512, answer-30190425
I'll vote for sb.setLength(args); not only because it's one function call but because it don't actually copy the array into another array like sb.delete(args); , It just fill the remaining characters to be 0 and set the length variable to the new length. You can take a look into their implementation to validate my point from here at setLength function and delete0 function.

Question-6094575, answer-6094600
You can use Class.forName() to get a Class object of the desired class. Then use getConstructor() to find the desired Constructor object. Finally, call newInstance() on that object to get your new instance. #pre

Question-6094575, answer-6094602
Yes, something like: #pre That will only work for a single string parameter of course, but you can modify it pretty easily. Note that the class name has to be a fully-qualified one, i.e. including the namespace. For nested classes, you need to use a dollar (as that's what the compiler uses). For example: #pre To obtain the Class object for that, you'd need Class.forName(args) .

Question-6094575, answer-26159586
when using (i.e.) getConstructor(args) the constructor has to be declared public. Otherwise a NoSuchMethodException is thrown. if you want to access a non-public constructor you have to use instead (i.e.) getDeclaredConstructor(args) .

Question-5175728, answer-5175771
Have a look at the Date class. There's also the newer Calendar class which is the preferred method of doing many date / time operations (a lot of the methods on Date have been deprecated.) If you just want the current date, then either create a new Date object or call Calendar.getInstance(args); .

Question-5175728, answer-5175900
It depends on what form of date / time you want: #li If you want the date / time as a single numeric value, then System.currentTimeMillis(args) gives you that, expressed as the number of milliseconds after the UNIX epoch (as a Java long ). This value is a delta from a UTC time-point, and is independent of the local time-zone ... assuming that the system clock has been set correctly. #li If you want the date / time in a form that allows you to access the components (year, month, etc) numerically, you could use one of the following: #li new Date(args) gives you a Date object initialized with the current date / time. The problem is that the Date API methods are mostly flawed ... and deprecated. #li Calendar.getInstance(args) gives you a Calendar object initialized with the current date / time, using the default Locale and TimeZone . Other overloads allow you to use a specific Locale and/or TimeZone . Calendar works ... but the APIs are still cumbersome. #li new org.joda.time.DateTime(args) gives you a Joda-time object initialized with the current date / time, using the default time zone and chronology. There are lots of other Joda alternatives ... too many to describe here. #li in Java 8, calling LocalDateTime.now(args) and ZonedDateTime.now(args) will give you representations for the current date / time. Prior to Java 8, most people who know about these things recommended Joda-time as having (by far) the best Java APIs for doing things involving time point and duration calculations. With Java 8, this is no longer true. However, if you are already using Joda time in your codebase, there is no strong reason to migrate.

Question-4772425, answer-4772461
Use LocalDateTime#parse() (or ZonedDateTime#parse() if the string happens to contain a time zone part) to parse a String in a certain pattern into a LocalDateTime . #pre Use LocalDateTime#format() (or ZonedDateTime#format() ) to format a LocalDateTime into a String in a certain pattern. #pre Or , when you're not on Java 8 yet, use SimpleDateFormat#parse() to parse a String in a certain pattern into a Date . #pre Use SimpleDateFormat#format() to format a Date into a String in a certain pattern. #pre See also: #li Java string to date conversion Update : as per your failed attempt: the patterns are case sensitive . Read the java.text.SimpleDateFormat javadoc what the individual parts stands for. So stands for example M for months and m for minutes. Also, years exist of four digits yyyy , not five yyyyy . Look closer at the code snippets I posted here above.

Question-4772425, answer-18953213
remove one y form SimpleDateFormat dt1 = new SimpleDateFormat(args); should be SimpleDateFormat dt1 = new SimpleDateFormat(args);

Question-5839359, answer-5839392
You're essentially running out of memory to run the process smoothly. Options that come to mind: #li Specify more memory like you mentioned, try something in between like -Xmx512m first #li Work with smaller batches of HashMap objects to process at once if possible #li If you have a lot of duplicate strings, use String.intern() on them before putting them into the HashMap #li Use the HashMap(int initialCapacity, float loadFactor) constructor to tune for your case

Question-6252678, answer-6252802
You need a DateTimeFormatter appropriate to the format you're using. Take a look at the docs for instructions on how to build one. Off the cuff, I think you need format = DateTimeFormat.forPattern(args)

Question-4709175, answer-4709284
#blockquote You can use an Enum to represent a smallish fixed set of constants or an internal class mode while increasing readability. Also, Enums can enforce a certain rigidity when used in method parameters. They offer the interesting possibility of passing information to a constructor like in the Planets example on Oracle's site and, as you've discovered, also allow a simple way to create a singleton pattern. ex: Locale.setDefault(args) reads better than Locale.setDefault(args) and enforces the use of fixed set of values shown in an IDE when you add the . separator instead of all integers.

Question-4709175, answer-4709892
Something none of the other answers have covered that make enums particularly powerful are the ability to have template methods . Methods can be part of the base enum and overridden by each type. And, with the behavior attached to the enum, it often eliminates the need for if-else constructs or switch statements as this blog post demonstrates - where enum.method(args) does what originally would be executed inside the conditional. The same example also shows the use of static imports with enums as well producing much cleaner DSL like code. Some other interesting qualities include the fact that enums provide implementation for equals(args) , toString(args) and hashCode(args) and implement Serializable and Comparable . For a complete rundown of all that enums have to offer I highly recommend Bruce Eckel's Thinking in Java 4th edition which devotes an entire chapter to the topic. Particularly illuminating are the examples involving a Rock, Paper, Scissors (i.e. RoShamBo) game as enums.

Question-4818699, answer-4818753
There are two main uses of AtomicInteger : #li As an atomic counter ( incrementAndGet(args) , etc) that can be used by many threads concurrently #li As a primitive that supports compare-and-swap instruction ( compareAndSet(args) ) to implement non-blocking algorithms. Here is an example of non-blocking random number generator from Brian Göetz's Java Concurrency In Practice : #pre As you can see, it basically works almost the same way as incrementAndGet(args) , but performs arbitrary calculation ( calculateNext(args) ) instead of increment (and processes the result before return).

Question-4818699, answer-4818783
The absolute simplest example I can think of is to make incrementing an atomic operation. With standard ints: #pre With AtomicInteger: #pre The latter is a very simple way to perform simple mutations effects (especially counting, or unique-indexing), without having to resort to synchronizing all access. More complex synchronization-free logic can be employed by using compareAndSet(args) as a type of optimistic locking - get the current value, compute result based on this, set this result iff value is still the input used to do the calculation, else start again - but the counting examples are very useful, and I'll often use AtomicIntegers for counting and VM-wide unique generators if there's any hint of multiple threads being involved, because they're so easy to work with I'd almost consider it premature optimisation to use plain ints . While you can almost always achieve the same synchronization guarantees with ints and appropriate synchronized declarations, the beauty of AtomicInteger is that the thread-safety is built into the actual object itself, rather than you needing to worry about the possible interleavings, and monitors held, of every method that happens to access the int value. It's much harder to accidentally violate threadsafety when calling getAndIncrement(args) than when returning i++ and remembering (or not) to acquire the correct set of monitors beforehand.

Question-4818699, answer-4818916
The primary use of AtomicInteger is when you are in a multithreaded context and you need to perform thread safe operations on an integer without using synchronized . The assignation and retrieval on the primitive type int are already atomic but AtomicInteger comes with many operations which are not atomic on int . The simplest are the getAndXXX or xXXAndGet . For instance getAndIncrement(args) is an atomic equivalent to i++ which is not atomic because it is actually a short cut for three operations: retrieval, addition and assignation. compareAndSet is very useful to implements semaphores, locks, latches, etc. Using the AtomicInteger is faster and more readable than performing the same using synchronization. A simple test: #pre On my PC with Java 1.6 the atomic test runs in 3 seconds while the synchronized one runs in about 5.5 seconds. The problem here is that the operation to synchronize ( notAtomic++ ) is really short. So the cost of the synchronization is really important compared to the operation. Beside atomicity AtomicInteger can be use as a mutable version of Integer for instance in Map s as values.

Question-4818699, answer-4819109
If you look at the methods AtomicInteger has, you'll notice that they tend to correspond to common operations on ints. For instance: #pre is the thread-safe version of this: #pre The methods map like this: ++i is i.incrementAndGet(args) i++ is i.getAndIncrement(args) --i is i.decrementAndGet(args) i-- is i.getAndDecrement(args) i = x is i.set(args) x = i is x = i.get(args) There are other convenience methods as well, like compareAndSet or addAndGet

Question-4759570, answer-19459145
This works on Windows with Cygwin installed: System.getenv(args)

Question-6271417, answer-6271460
The "$1" is not "useless non-sense". If your class is anonymous, a number is appended. If you don't want the class itself, but its declaring class, then you can use getEnclosingClass(args) . For example: #pre You can move that in some static utility method. But note that this is not the current class name. The anonymous class is different class than its enclosing class. The case is similar for inner classes.

Question-6271417, answer-6271520
Try using this.getClass(args).getCanonicalName(args) or this.getClass(args).getSimpleName(args) . If it's an anonymous class, use this.getClass.getSuperclass.getName(args)

Question-6271417, answer-6271668
I'm assuming this is happening for an anonymous class. When you create an anonymous class you actually create a class that extends the class whose name you got. The "cleaner" way to get the name you want is: If your class is an anonymous inner class, getSuperClass(args) should give you the class that it was created from. If you created it from an interface than you're sort of SOL because the best you can do is getInterfaces(args) which might give you more than one interface. The "hacky" way is to just get the name with getClassName(args) and use a regex to drop the $1 .

Question-6271417, answer-29938300
Use this method,but be careful to make an object in your main. public static void setName(args){ Class setClass = obj.getClass(args); String className = setClass.getName(args); System.out.println(args); }

Question-5263187, answer-5263201
System.out.println(args);

Question-5038204, answer-5039178
The commons/lang builders are great and I have been using them for years without noticeable performance overhead (with and without hibernate). But as Alain writes, the Guava way is even nicer: Here's a sample Bean: #pre Here's equals() and hashCode() implemented with Commons/Lang: #pre and here with Guava: #pre As you can see the Guava version is shorter and avoids superfluous helper objects. In case of equals, it even allows for short-circuiting the evaluation if an earlier Object.equal(args) call returns false (to be fair: commons / lang has an ObjectUtils.equals(args) method with identical semantics which could be used instead of EqualsBuilder to allow short-circuiting as above). So: yes, the commons lang builders are very preferable over manually constructed equals(args) and hashCode(args) methods (or those awful monsters Eclipse will generate for you), but the Guava versions are even better. And a note about Hibernate: be careful about using lazy collections in your equals(), hashCode() and toString() implementations. That will fail miserably if you don't have an open Session. Note (about equals()): a) in both versions of equals() above, you might want to use one or both of these shortcuts also: #pre b) depending on your interpretation of the equals() contract, you might also change the line(s) if(args){ to #pre If you use the second version, you probably also want to call super(args) inside your equals(args) method. Opinions differ here, the topic is discussed in this question: #blockquote (although it's about hashCode(args) , the same applies to equals(args) ) Note (inspired by Comment from kayahr ) Objects.hashCode(args) (just as the underlying Arrays.hashCode(args) ) might perform badly if you have many primitive fields. In such cases, EqualsBuilder may actually be the better solution.

Question-4812570, answer-4812585
You have to use getStackTrace(args) method instead of printStackTrace(args) . Here is a good example : #pre

Question-4812570, answer-21765043
You can use the ExceptionUtils.getStackTrace(args); from Apache Commons 3 class org.apache.commons.lang3.exception.ExceptionUtils . #a

Question-5071040, answer-5071064
There are multiple ways: #li String.valueOf(args) (my preference) #li StringLiteral + number (I don't know how the compiler handles it, perhaps it is as efficient as the above) #li Integer.toString(args)

Question-5071040, answer-22547954
Always use either String.valueOf(args) or Integer.toString(args) . Using "" + number is an overhead and does the following: #pre

Question-4576352, answer-4576367
using public String replaceAll(args) will work usage would be str.replace(args); executing StringLiteral.replaceAll(args); returns: lakjsdf xx

Question-4576352, answer-11325546
You can use str = str.replace(args); as mentioned before and you will be fine. For your information CharLiteral is not an empty (or a valid) character but CharLiteral is. So you could use str = str.replace(args); instead.

Question-5031614, answer-5032837
If you want to use equals(args)/hashCode(args) for your Sets, in the sense that the same entity can only be in there once, then there is only one option: Option 2. That's because a primary key for an entity by definition never changes (if somebody indeed updates it, it's not the same entity anymore) You should take that literally: Since your equals(args)/hashCode(args) are based on the primary key, you must not use these methods, until the primary key is set. So you shouldn't put entities in the set, until they're assigned a primary key. (Yes, UUIDs and similar concepts may help to assign primary keys early.) Now, it's theoretically also possible to achieve that with Option 3, even though so-called "business-keys" have the nasty drawback that they can change: "All you'll have to do is delete the already inserted entities from the set(s), and re-insert them." That is true - but it also means, that in a distributed system, you'll have to make sure, that this is done absolutely everywhere the data has been inserted to (and you'll have to make sure, that the update is performed, before other things occur). You'll need a sophisticated update mechanism, especially if some remote systems aren't currently reachable... Option 1 can only be used, if all the objects in your sets are from the same Hibernate session. The Hibernate documentation makes this very clear in chapter 13.1.3. Considering object identity : #blockquote It continues to argue in favor of Option 3: #blockquote This is true, if you #li cannot assign the id early (e.g. by using UUIDs) #li and yet you absolutely want to put your objects in sets while they're in transient state. Otherwise, you're free to choose Option 2. Then it mentions the need for a relative stability: #blockquote This is correct. The practical problem I see with this is: If you can't guarantee absolute stability, how will you be able to guarantee stability "as long as the objects are in the same Set". I can imagine some special cases (like using sets only for a conversation and then throwing it away), but I would question the general practicability of this. Short version: #li Option 1 can only be used with objects within a single session. #li If you can, use Option 2. (Assign PK as early as possible, because you can't use the objects in sets until the PK is assigned.) #li If you can guarantee relative stability, you can use Option 3. But be careful with this.

Question-5031614, answer-5103360
We usually have two IDs in our entities: #li Is for persistence layer only (so that persistence provider and database can figure out relationships between objects). #li Is for our application needs ( equals(args) and hashCode(args) in particular) Take a look: #pre EDIT: to clarify my point regarding calls to setUuid(args) method. Here's a typical scenario: #pre When I run my tests and see the log output I fix the problem: #pre Alternatively, one can provide a separate constructor: #pre So my example would look like this: #pre I use a default constructor and a setter, but you may find two-constructors approach more suitable for you.

Question-5031614, answer-26826084
#li If you have a business key , then you should use that for equals / hashCode . #li If you don't have a business key, you should not leave it with the default Object equals and hashCode implementations because that does not work after you merge and entity. #li You can use the entity identifier as suggested in this post . The only catch is that you need to use a hashCode implementation that always return the same value, like this: #pre

Question-5554217, answer-17300003
Another way is to use an array as a type, e.g.: MyClass[] mcArray = gson.fromJson(args); This way you avoid all the hassle with the Type object, and if you really need a list you can always convert the array to a list by: List<T> mcList = Arrays.asList(args); IMHO this is much more readable. And to make it be an actual list (that can be modified, see limitations of Arrays.asList(args) ) then just do the following: List<T> mcList = new ArrayList<T>(Arrays.asList(args));

Question-5673260, answer-5673356
#pre Generally speaking, when you have response.getOutputStream(args) , you can write anything there. You can pass this output stream as a place to put generated PDF to your generator. Also, if you know what file type you are sending, you can set response.setContentType(args);

Question-5673260, answer-5673375
You should be able to write the file on the response directly. Something like #pre and then write the file as a binary stream on response.getOutputStream(args) . Remember to do response.flush(args) at the end and that should do it.

Question-5785745, answer-15962949
If you want to make a copy of: int[] a = {1,2,3,4,5}; This is the way to go: int[] b = Arrays.copyOf(args); Arrays.copyOf may be faster than a.clone(args) on small arrays. Both copy elements equally fast but clone() returns Object so the compiler has to insert an implicit cast to int[] . You can see it in the bytecode, something like this: #pre

Question-5785745, answer-34845194
You can also use Arrays.copyOfRange . Example : #pre This method is similar to Arrays.copyOf , but it's more flexible. Both of them use System.arraycopy under the hood. See : #li #a #li #a #li #a

Question-5694385, answer-5694464
Rather than spoon-feed you code, here's how to look in the documentation . First, you're dealing with IO, so look in the java.io package . There are two classes that look interesting: FileFilter and FileNameFilter . When I clicked on the first, it showed me that there was a a listFiles(args) method in the File class. And the documentation for that method says: #blockquote Scrolling up in the File JavaDoc, I see the constructors. And that's really all I need to be able to create a File instance and call listFiles(args) on it. Scrolling still further, I can see some information about how files are named in different operating systems.

Question-5694385, answer-5694473
Create a File object, passing the directory path to the constructor. Use the listFiles(args) to retrieve an array of File objects for each file in the directory, and then call the getName(args) method to get the filename. #pre

Question-5439529, answer-5439543
You can use Integer.parseInt(args) or Integer.valueOf(args) to get the integer from the string, and catch the exception if it is not a parsable int. You want to be sure to catch the NumberFormatException it can throw. It may be helpful to note that valueOf() will return an Integer object, not the primitive int.

Question-5439529, answer-5439600
As an alternative to trying to parse the string and catching NumberFormatException , you could use a regex; e.g. #pre This is likely to be faster, especially if you precompile and reuse the regex. However, the catch is that Integer.parseInt(args) will still fail if str represents a number that is outside range of legal int values.

Question-5439529, answer-9991624
You can use Integer.parseInt(args) and catch the NumberFormatException if the string is not a valid integer, in the following fashion (as pointed out by all answers): #pre However, note here that if the evaluated integer overflows, the same exception will be thrown. Your purpose was to find out whether or not, it was a valid integer. So its safer to make your own method to check for validity: #pre

Question-5439529, answer-15357940
Or simply mystring.matches(args) though it would return true for numbers larger than an int

Question-6416706, answer-6416788
As soon as you call contains , containsAll , equals , hashCode , remove , retainAll , size or toArray , you'd have to traverse the elements anyway. If you're occasionally only calling methods such as isEmpty or clear I suppose you'd be better of by creating the collection lazily. You could for instance have a backing ArrayList for storing previously iterated elements. I don't know of any such class in any library, but it should be a fairly simple exercise to write up.

Question-6416706, answer-6416800
With Guava you can use Lists.newArrayList(Iterable) or Sets.newHashSet(Iterable) , among other similar methods. This will of course copy all the elements in to memory. If that isn't acceptable, I think your code that works with these ought to take Iterable rather than Collection . Guava also happens to provide convenient methods for doing things you can do on a Collection using an Iterable (such as Iterables.isEmpty(args) or Iterables.contains(args) ), but the performance implications are more obvious.
