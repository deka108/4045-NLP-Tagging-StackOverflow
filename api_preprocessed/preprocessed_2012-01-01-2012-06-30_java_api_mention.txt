{
    "items": [
        {
            "cleaned": "In Swing, the password field has a getPassword(_exprs) (returns char[] ) method instead of the usual getText(_exprs) (returns String ) method. Similarly, I have come across a suggestion not to use String to handle passwords. Why does String pose a threat to security when it comes to passwords?\nIt feels inconvenient to use char[] .",
            "question_id": 8881291
        },
        {
            "cleaned": "Say I have a URL #pre and I have a query entered by the user such as: #blockquote I want the result to be a properly encoded URL: #pre What's the best way to achieve this? I tried URLEncoder and creating URI/URL objects but none of them come out quite right.",
            "question_id": 10786042
        },
        {
            "cleaned": "In Java there are the SortedSet and SortedMap interfaces. Both belong to Java's standard Collections framework and provide a sorted way to access the elements. However, in my understanding there is no SortedList in Java. You can use java.util.Collections.sort(_exprs) to sort a list. Any idea why it is designed like that?",
            "question_id": 8725387
        },
        {
            "cleaned": "We can determine the length of an ArrayList<E> using its public method size(_exprs) , like #pre Similarly we can determine the length of an Array object using the length property #pre Whereas the size(_exprs) method of ArrayList is defined inside the ArrayList class, where is this length property of Array defined?",
            "question_id": 9297899
        },
        {
            "cleaned": "I looked at the default Zip library that comes with the JDK and the Apache compression libs and I am unhappy with them for 3 reasons: #li They are bloated and have bad API design. I have to #a ? Why can't I have a simple API that looks like this Zipper.unzip(_exprs) and Zipper.zip(_exprs) that just works? #li It seems zipping unzipping destroys file meta-data and password handling is broken. #li Also, all the libraries I tried were 2-3x slow compared to the command line zip tools I get with UNIX? For me (2) and (3) are minor points but I really want a good tested library with a one-line interface.",
            "question_id": 9324933
        },
        {
            "cleaned": "I am trying to develop a system where there are different nodes that are run on different system or on different ports on the same system. Now all the nodes create a Socket with a target IP as the IP of a special node known as a bootstrapping node. The nodes then create their own ServerSocket and start listening for connections. The bootstrapping node maintains a list of Nodes and returns them on being quired. Now what I need is the node must register its IP to the bootstrapping node. I tried using cli.getInetAddress(_exprs) once the client connects to the ServerSocket of bootstrapping node but that didn't work. #li I need the client to register its PPP IP if available; #li Otherwise the LAN IP if available; #li Otherwise it must register 127.0.0.1 assuming its the same computer. Please help me with this.  using the code: #pre or #pre My PPP Connection IP address is: 117.204.44.192 but the above returns me 192.168.1.2  I am using the following code: #pre I am able to get all the IP addresses associated all NetworkInterface s, but how do I distinguish them??\nThis is the output I am getting: #pre",
            "question_id": 9481865
        },
        {
            "cleaned": "How do atomic / volatile / synchronized work internally? What is the difference between the following code blocks? Code 1 #pre Code 2 #pre Code 3 #pre ",
            "question_id": 9749746
        },
        {
            "cleaned": "With Mockito, I want to verify(_exprs) a method call with byte[] in its argument list, but I didn't find how to write this. #pre I just want something like anyByteArray(_exprs) , how to do that with Mockito ?",
            "question_id": 10066590
        },
        {
            "cleaned": "In Java, what would the fastest way to iterate over all the chars in a String, this: #pre Or this: #pre  What I'd like to know is if the cost of repeatedly calling the charAt method during a long iteration ends up being either less than or greater than the cost of performing a single call to toCharArray at the beginning and then directly accessing the array during the iteration. It'd be great if someone could provide a robust benchmark for different string lengths, having in mind JIT warm-up time, JVM start-up time, etc. and not just the difference between two calls to System.currentTimeMillis(_exprs) .",
            "question_id": 8894258
        },
        {
            "cleaned": "What's the difference between java.lang.String 's replace(_exprs) and replaceAll(_exprs) methods, \nother than later uses regex? For simple substitutions like, replace . with / , \nis there any difference?",
            "question_id": 10827872
        },
        {
            "cleaned": "Swing components have multiple methods related to updates of screen layout, in particular: #li #a #li #a #li #a The Java documentation defines these somewhat from a technical perspective, but it's not particularly clear how they are meant to be used. What is the difference between these, and in what circumstances should you use one rather than the others?",
            "question_id": 9510125
        },
        {
            "cleaned": "I am using trying to use the toString(_exprs) method, but I think I am doing it wrong: #a My code: #pre The output is: #pre Also I tried printing like this, but: #pre  I am looking for output, like in Oracle's documentation: #blockquote",
            "question_id": 10904911
        },
        {
            "cleaned": "#pre We can use Iterator to traverse a Set or a List or a Map . But ListIterator can only be used to traverse a List , it can't traverse a Set . Why? I know that the main difference is that with iterator we can travel in only one direction but with ListIterator we can travel both directions. Are there any other differences? And any advantages of ListIterator over Iterator ?",
            "question_id": 10977992
        },
        {
            "cleaned": "#li in Java if you store password as plain text it will be available in memory until Garbage collector clears it and since Strings are used in String pool for re-usability there is pretty high chance that it will be remain in memory for long duration, which pose a security threat. Since any one who has access to memory dump can find the password in clear text #li using getPassword(_exprs) method of JPasswordField which returns a char[] and deprecated getText(_exprs) method which returns password in clear text stating security reason. #li there is always a risk of printing plain text in log file or console but if use Array you won't print contents of array instead its memory location get printed. #pre #blockquote Though using char[] is not just enough you need to erase content to be more secure. I also suggest working with hash'd or encrypted password instead of plaintext and clearing it from memory as soon as authentication is completed.",
            "question_id": 8881291,
            "answer_id": 14060804
        },
        {
            "cleaned": "You need #pre split uses regular expression and in | is metacharacter representing OR operator. You need to escape that character using \\ (written in String as _str since \\ is also metacharacter in String literals and require another \\ to escape it). You can also use #pre and let Pattern.quote create escaped version of regex representing | .",
            "question_id": 10796160,
            "answer_id": 10796174
        },
        {
            "cleaned": "Use proper escaping: string.split(_exprs) Or the helper Regexp.quote(_exprs) which has been created for exactly this purpose: #pre which works with arbitrary input strings. Very useful when you need to quote / escape user input.",
            "question_id": 10796160,
            "answer_id": 21025279
        },
        {
            "cleaned": "#a should be the way to go. You only need to keep in mind to encode the individual query string parameter name and/or value, not the entire URL, for sure not the query string parameter separator character & nor the parameter name-value separator character = . #pre ",
            "question_id": 10786042,
            "answer_id": 10786112
        },
        {
            "cleaned": "I would not use URLEncoder . Besides being incorrectly named ( URLEncoder has nothing to do with URLs), inefficient (it uses a StringBuffer instead of Builder and does a couple of other things that are slow) Its also way too easy to screw it up. Instead I would use #a .\nThe reason being you have to escape the query parameters name (ie BalusC's answer q ) differently than the parameter value. The only downside to the above (that I found out painfully) is that #a . ",
            "question_id": 10786042,
            "answer_id": 16226168
        },
        {
            "cleaned": "You need to first create a URI like: #pre Then convert that Uri to ASCII string: #pre Now your url string is completely encoded first we did simple url encoding and then we converted it to ASCII String to make sure no character outside US-ASCII are remaining in string. This is exactly how browsers do.",
            "question_id": 10786042,
            "answer_id": 25735202
        },
        {
            "cleaned": "The first one using str.charAt should be faster. If you dig inside the source code of String class, we can see that charAt is implemented as follows: #pre Here, all it does is index an array and return the value. Now, if we see the implementation of toCharArray , we will find the below: #pre As you see, it is doing a System.arraycopy which is definitely going to be a tad slower than not doing it.",
            "question_id": 8894258,
            "answer_id": 8894348
        },
        {
            "cleaned": "Looks like niether is faster or slower #pre For long strings I'll chose the first one. Why copy around long strings?\nDocumentations says: #blockquote  I've changed the test to trick JIT optimisation.  Repeat test 10 times to let JVM warm up.  Conclusions: First of all str.toCharArray(_exprs); copies entire string in memory. It can be memory consuming for long strings. Method String.charAt(_exprs) looks up char in char array inside String class checking index before.\nIt looks like for short enough Strings first method (i.e. chatAt method) is a bit slower due to this index check. But if the String is long enough, copying whole char array gets slower, and the first method is faster. The longer the string is, the slower toCharArray performs. Try to change limit in for(_exprs) loop to see it.\nIf we let JVM warm up code runs faster, but proportions are the same. After all it's just micro-optimisation.",
            "question_id": 8894258,
            "answer_id": 8894356
        },
        {
            "cleaned": "This is just micro-optimisation that you shouldn't worry about. #pre returns you a copy of str character arrays (in JDK, it returns a copy of characters by calling System.arrayCopy ). Other than that, str.charAt(_exprs) only checks if the index is indeed in bounds and returns a character within the array index. The first one doesn't create additional memory in JVM.",
            "question_id": 8894258,
            "answer_id": 8894384
        },
        {
            "cleaned": "Despite @Saint Hill's answer if you consider the time complexity of , the first one is faster even for very large strings. You can run the code below to see it for yourself. #pre output: #pre",
            "question_id": 8894258,
            "answer_id": 22676782
        },
        {
            "cleaned": "In java.lang.String , the replace method either takes a pair of char's or a pair of CharSequence 's (of which String is a subclass, so it'll happily take a pair of String's). The replace method will replace all occurrences of a char or CharSequence . On the other hand, both String arguments to replaceFirst and replaceAll are regular expressions (regex). Using the wrong function can lead to subtle bugs.",
            "question_id": 10827872,
            "answer_id": 10827900
        },
        {
            "cleaned": "The replace(_exprs) method is overloaded to accept both a primitive char and a CharSequence as arguments. Now as far as the performance is concerned, the replace(_exprs) method is a bit faster than replaceAll(_exprs) because the later first compiles the regex pattern and then matches before finally replacing whereas the former simply matches for the provided argument and replaces. Since we know the regex pattern matching is a bit more complex and consequently slower, then preferring replace(_exprs) over replaceAll(_exprs) is suggested whenever possible. For example, for simple substitutions like you mentioned, it is better to use: #pre instead of: #pre Note: the above conversion method arguments are system-dependent.",
            "question_id": 10827872,
            "answer_id": 10827945
        },
        {
            "cleaned": "Old thread I know but I am sort of new to Java and discover one of it's strange things. I have used String.replaceAll(_exprs) but get unpredictable results. Something like this mess up the string: #pre So I designed this function to get around the weird problem: #pre Which make you able to do: #pre",
            "question_id": 10827872,
            "answer_id": 22578124
        },
        {
            "cleaned": "replace(_exprs) method doesn't uses regex pattern whereas replaceAll(_exprs) method uses regex pattern. So replace(_exprs) performs faster than replaceAll(_exprs) .",
            "question_id": 10827872,
            "answer_id": 30749407
        },
        {
            "cleaned": "Since all lists are already \"sorted\" by the order the items were added (FIFO ordering), you can \"resort\" them with another ordering, including the natural ordering of elements, using java.util.Collections.sort(_exprs) . EDIT: Lists as data structures are based in what is interesting is the ordering in which the items where inserted. Sets do not have that information. If you want to order by addition time, use List . If you want to order by other criteria, use SortedSet .",
            "question_id": 8725387,
            "answer_id": 8725453
        },
        {
            "cleaned": "List iterators guarantee first and foremost that you get the list's elements in the internal order of the list (aka. ). More specifically it is in the order you've inserted the elements or on how you've manipulated the list. Sorting can be seen as a manipulation of the data structure, and there are several ways to sort the list. I'll order the ways in the order of as I personally see it:  I put this option at the top because this is what you normally want to do anyway. A sorted set , meaning that it does the sorting while you add elements into the collection. It also means you don't need to manually sort it. Furthermore if you are sure that you don't need to worry about (or have) duplicate elements then you can use the #a instead. It implements SortedSet and NavigableSet interfaces and works as you'd probably expect from a list: #pre If you don't want the natural ordering you can use the constructor parameter that takes a #a . Alternatively you can use , that is a Set that allows duplicate elements, instead and there are third party implementations of them. Most notably from the #a there is a #a , that works a lot like the TreeSet .  As mentioned above, sorting of List s is an manipulation of the data structure. So for situations where you need \"one source of truth\" that will be sorted in a variety of ways then sorting it manually is the way to go. You can sort your list with the #a method. Here is a code sample on how: #pre  One clear benefit is that you may use #a in the sort method. Java also provides some implementations for the Comparator such as the #a which is useful for locale sensitive sorting strings. Here is one example: #pre  Do note though that using the sort method is not friendly in concurrent environments, since the collection instance will be manipulated, and you should consider using immutable collections instead. This is something Guava provides in the #a class and is a simple one-liner: #pre  Though there is no sorted list in Java there is however a sorted queue which would probably work just as well for you. It is the #a class. Nico Haase linked in the comments to a #a that also answers this. In a sorted collection the internal data structure which is why PriorityQueue doesn't implement the List interface (because that would give you direct access to it's elements).  The PriorityQueue class implements the Iterable<E> and Collection<E> interfaces so it can be iterated as usual. However the iterator is not guaranteed to return elements in the sorted order. Instead (as Alderath points out in the comments) you need to poll(_exprs) the queue until empty. Note that you can convert a list to a priority queue via the #a : #pre  You shouldn't have to do this. You can write your own List class that sorts each time you add a new element. This can get rather computation heavy depending on your implementation , unless you want to do it as an exercise, because of two main reasons: #li It breaks the contract that List<E> interface has, because the add methods should ensure that the element will reside in the index that the user specifies. #li Why reinvent the wheel? You should be using the TreeSet or Multisets instead as pointed out in the first point above. However if you want to do it as an exercise here is a code sample to get you started, it uses the AbstractList abstract class: #pre Note that if you haven't overridden the methods you need, then the default implementations from AbstractList will throw UnsupportedOperationException s.",
            "question_id": 8725387,
            "answer_id": 8725470
        },
        {
            "cleaned": "Because the concept of a List is incompatible with the concept of an automatically sorted collection. The point of a List is that after calling list.add(_exprs) , a call to list.get(_exprs) will return elem . With an auto-sorted list, the element could end up in an arbitrary position.",
            "question_id": 8725387,
            "answer_id": 8725518
        },
        {
            "cleaned": "Think of it like this: the List interface has methods like add(_exprs) , set(_exprs) . The contract is that once you added an element at position X you will find it there unless you add or remove elements before it. If any list implementation would store elements in some order other than based on the index, the above list methods would make no sense.",
            "question_id": 8725387,
            "answer_id": 8725550
        },
        {
            "cleaned": "Another point is the time complexity of insert operations.\nFor a list insert, one expects a complexity of O(1).\nBut this could not be guaranteed with a sorted list. And the most important point is that lists assume nothing about their elements.\nFor example, you can make lists of things that do not implement equals or compare .",
            "question_id": 8725387,
            "answer_id": 8727998
        },
        {
            "cleaned": "Set and Map are non-linear data structure. List is linear data structure. #a ",
            "question_id": 8725387,
            "answer_id": 34405789
        },
        {
            "cleaned": "Even though this is not a direct answer to the question, it is an addition to the .length vs .size(_exprs) argument. I was researching something related to this question so when I came across it I noticed that the definition(s) provided here #blockquote is not \"exactly\" correct. The field length contains the number of to put a component, not the number of components present in the array. So it represents the total available memory allocated to that array, not how much of that memory is filled. #img Example: #pre Output: #pre However, the .size(_exprs) property of the ArrayList does give the number of elements in the list: #pre Output: #pre",
            "question_id": 9297899,
            "answer_id": 25816501
        },
        {
            "cleaned": "You could do this: #pre Basically the #a method will split the string according to (in this case) delimiter you are passing and will return an array of strings. However, you seem to be after a List of Strings rather than an array, so the array must be turned into a list by using the #a utility. Just as an FYI you could also do something like so: #pre But it is usually better practice to program to an interface rather than to an actual concrete implementation, so I would recommend the 1st option.",
            "question_id": 10631715,
            "answer_id": 10631738
        },
        {
            "cleaned": "There is a function called replaceAll(_exprs) that can remove all whitespaces by replacing them with whatever you want. As an example #pre will give you: #pre",
            "question_id": 10631715,
            "answer_id": 30270403
        },
        {
            "cleaned": "For completeness, using the #a library, you'd do: Splitter.on(_exprs).split(_exprs) Another example: #pre Splitter.split(_exprs) returns an Iterable, so if you need a List, wrap it in Lists.newArrayList(_exprs) as above. Otherwise just go with the Iterable, for example: #pre Note how trimResults(_exprs) handles all your trimming needs without having to #a , as with String.split(_exprs) . If your project uses Guava already, this should be your preferred solution. See Splitter documentation in #a or the #a for more configuration options.",
            "question_id": 10631715,
            "answer_id": 32362691
        },
        {
            "cleaned": "There are two differences: #li We can use Iterator to traverse Set and List and also Map type of Objects. While a ListIterator can be used to traverse for List-type Objects, but not for Set-type of Objects. That is, we can get a Iterator object by using Set and List, see here: By using Iterator we can retrieve the elements from Collection Object in forward direction only. Methods in Iterator: #li hasNext(_exprs) #li next(_exprs) #li remove(_exprs) #pre #li But we get ListIterator object only from the List interface, see here: where as a ListIterator allows you to traverse in either directions (Both forward and backward). So it has two more methods like hasPrevious(_exprs) and previous(_exprs) other than  those of Iterator. Also, we can get indexes of the next or previous elements (using nextIndex(_exprs) and previousIndex(_exprs) respectively ) Methods in ListIterator: #li hasNext() #li next() #li previous() #li hasPrevious() #li remove() #li nextIndex() #li previousIndex() #pre i.e., we can't get ListIterator object from Set interface.",
            "question_id": 10977992,
            "answer_id": 17939167
        },
        {
            "cleaned": "Just IMHO. Not sure it's 100% correct. invalidate(_exprs) marks the container as invalid. Means the content is somehow wrong and must be relayed out. But it's just a kind of mark/flag. It's possible that multiple invalid containers must be refreshed later. validate(_exprs) performs relayout. It means invalid content is asked for all the sizes and all the subcomponents' sizes are set to proper values by LayoutManager . revalidate(_exprs) is just sum of both. It marks the container as invalid and performs layout of the container.",
            "question_id": 9510125,
            "answer_id": 9511578
        },
        {
            "cleaned": "validate(_exprs) : In Swing when you create Component, it is not valid i.e. it's valid property is false . A component is said to be valid, when it's width, height, location and stuff has been determined. This is usually done by calling their validate(_exprs) method, directly or indirectly. When we call validate(_exprs) on containers, it will validate the container (if it is invalid) by calling its doLayout(_exprs) method, which typically will invoke the LayoutManager . Now each child placed on this container will be validated recursively, so that the entire tree will be laid out and will become valid. revalidate(_exprs) : revalidate(_exprs) is to be called when you change an attribute that would affect their width/height and call repaint() when you change an attribute that would affect their appearance.\nFor Example, If your JFrame contains a JPanel , now at certain point of time you removed that JPanel and inserted a new one in it's place, depending on the contents of the newly placed JPanel , the size of the components inside the JPanel as well as The CONTAINER itself (by virtue of the layout manager used by it), changes. Which pushes it to the invalidate state. So in order to validate this change, you have to explicitly call revalidate(_exprs) . invalidate(_exprs) : This thing is something, I had never used, so might be not much of the info I can give. But seems like the scenario presented above, can give a bit of hint, as to what happens in invalidate(_exprs) .",
            "question_id": 9510125,
            "answer_id": 9511880
        },
        {
            "cleaned": "What you want is the Arrays.toString(_exprs) method: #pre There is a static Arrays.toString helper method for every different primitive java type; the one for #a : #blockquote",
            "question_id": 10904911,
            "answer_id": 10904956
        },
        {
            "cleaned": "You can use java.net.InetAddress API.\nTry this : #pre",
            "question_id": 9481865,
            "answer_id": 9481939
        },
        {
            "cleaned": "This could be a bit tricky in the most general case. On the face of it, InetAddress.getLocalHost(_exprs) should give you the IP address of this host.  The problem is that a host could have lots of network interfaces, and an interface could be bound to more than one IP address.  And to top that, not all IP addresses will be reachable outside of your machine or your LAN.  For example, they could be IP addresses for virtual network devices, private network IP addresses, and so on. What this means is that the IP address returned by InetAddress.getLocalHost(_exprs) might not be the right one to use. How can you deal with this? #li One approach is to use NetworkInterface.getNetworkInterfaces(_exprs) to get all of the known network interfaces on the host, and then iterate over each NI's addresses. #li Another approach is to (somehow) get the externally advertized FQDN for the host, and use InetAddress.getByName(_exprs) to look up the primary IP address.  (But how do you get it, and how do you deal with a DNS-based load balancer?) #li A variation of the previous is to get the preferred FQDN from a config file or a command line parameter. #li Another variation is to get the preferred IP address from a config file or a command line parameter. In summary, InetAddress.getLocalHost(_exprs) will typically work, but you may need to provide an alternative method for the cases where your code is run in an environment with \"complicated\" networking. ",
            "question_id": 9481865,
            "answer_id": 9482369
        },
        {
            "cleaned": "You may try isReachable(_exprs) method of InetAddress class to figure out which IP address is your real publicly available IP address. I think other type of addresses (site local,link local) are not reachable from outside. #pre",
            "question_id": 9481865,
            "answer_id": 33093380
        },
        {
            "cleaned": "It's a  famous problem: .equals(_exprs) for arrays is badly broken, just don't use it, ever. That said, it's not \"broken\" as in \"someone has done it in a really wrong way\" \u2014 it's just doing what's defined and not what's usually expected. So for purists: it's perfectly fine, and that also means, Now the expected behaviour for equals is to compare data. The default behaviour is to compare the identity, as Object does not have any data (for purists: yes it has, but it's not the point); assumption is, if you need equals in subclasses, you'll implement it. In arrays, there's no implementation for you, so you're not supposed to use it. So the difference is, Arrays.equals(_exprs) works (i.e. compares content), array1.equals(_exprs) falls back to Object.equals implementation, which in turn compares identity, and thus better replaced by == (for purists: yes I know about null ). Problem is, even Arrays.equals(_exprs) will bite you hard if elements of array do not implement equals properly. It's a very naive statement, I know, but there's a very important less-than-obvious case: consider a 2D array. 2D array in Java is an array of arrays, and arrays' equals is broken (or useless if you prefer), so Arrays.equals(_exprs) will not work as you expect on 2D arrays. Hope that helps.",
            "question_id": 8777257,
            "answer_id": 8777266
        },
        {
            "cleaned": "array1.equals(_exprs) is the same as array1 == array2 , i.e. is it the same array. As @alf points out it's not what most people expect. Arrays.equals(_exprs) compares the contents of the arrays. ",
            "question_id": 8777257,
            "answer_id": 8777279
        },
        {
            "cleaned": "The equals(_exprs) of arrays is inherited from Object , so it does not look at the contents of the arrrays, it only considers each array equal to itself. The Arrays.equals(_exprs) methods compare the arrays' contents. There's overloads for all primitive types, and the one for objects uses the objects' own equals(_exprs) methods.",
            "question_id": 8777257,
            "answer_id": 8777292
        },
        {
            "cleaned": "The Arrays.equals(_exprs) : check if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. The array1.equals(_exprs) : compare the object to another object and return true only if the reference of the two object are equal as in the Object.equals(_exprs)",
            "question_id": 8777257,
            "answer_id": 8777311
        },
        {
            "cleaned": "Arrays inherit equals(_exprs) from Object and hence compare only returns true if comparing an array against itself. On the other hand, Arrays.equals compares the elements of the arrays. This snippet elucidates the difference: #pre See also #a . Another static method there may also be of interest: #a .",
            "question_id": 8777257,
            "answer_id": 8777312
        },
        {
            "cleaned": "You are specifically asking about how they , so here you are:  #pre It basically reads value from memory, increments it and puts back to memory. This works in single thread but nowadays, in the era of multi-core, multi-CPU, multi-level caches it won't work correctly. First of all it introduces race condition (several threads can read the value at the same time), but also visibility problems. The value might only be stored in \" \" CPU memory (some cache) and not be visible for other CPUs/cores (and thus - threads). This is why many refer to of a variable in a thread. It is very unsafe. Consider this popular but broken thread-stopping code: #pre Add volatile to stopped variable and it works fine - if any other thread modifies stopped variable via pleaseStop(_exprs) method, you are guaranteed to see that change immediately in working thread's while(_exprs) loop. BTW this is not a good way to interrupt a thread either, see: #a and #a .  #pre The AtomicInteger class uses CAS ( #a ) low-level CPU operations (no synchronization needed!) They allow you to modify a particular variable only if the present value is equal to something else (and is returned successfully). So when you execute getAndIncrement(_exprs) it actually runs in a loop (simplified real implementation): #pre So basically: read; try to store incremented value; if not successful (the value is no longer equal to current ), read and try again. The compareAndSet(_exprs) is implemented in native code (assembly).  #pre This code is not correct. It fixes the visibility issue ( volatile makes sure other threads can see change made to counter ) but still has a race condition. This has been #a multiple times: pre/post-incrementation is not atomic. The only side effect of volatile is \" \" caches so that all other parties see the freshest version of the data. This is too strict in most situations; that is why volatile is not default.  #pre The same problem as above, but even worse because i is not private . The race condition is still present. Why is it a problem? If, say, two threads run this code simultaneously, the output might be + 5 or + 10 . However, you are guaranteed to see the change.  #pre Surprise, this code is incorrect as well. In fact, it is completely wrong. First of all you are synchronizing on i , which is about to be changed (moreover, i is a primitive, so I guess you are synchronizing on a temporary Integer created via autoboxing...) Completely flawed. You could also write: #pre No two threads can enter the same synchronized block . In this case (and similarly in your code) the lock object changes upon every execution, so synchronized effectively has no effect. Even if you have used a final variable (or this ) for synchronization, the code is still incorrect. Two threads can first read i to temp synchronously (having the same value locally in temp ), then the first assigns a new value to i (say, from 1 to 6) and the other one does the same thing (from 1 to 6). The synchronization must span from reading to assigning a value. Your first synchronization has no effect (reading an int is atomic) and the second as well. In my opinion, these are the correct forms: #pre",
            "question_id": 9749746,
            "answer_id": 9749864
        }
    ]
}