Question-18410035
Being somewhat new to the Java language I'm trying to familiarize myself with all the ways (or at least the non-pathological ones) that one might iterate through a list (or perhaps other collections) and the advantages or disadvantages of each. Given a List<T> list object, I know of the following ways to loop through all elements: Basic for loop (of course, there're equivalent while / do while loops as well) #pre Note: As @amarseillan pointed out, this form is a poor choice for iterating over List s because the actual implementation of the get method may not be as efficient as when using an Iterator . For example, LinkedList implementations must traverse all of the elements preceding i to get the i-th element. In the above example there's no way for the List implementation to "save its place" to make future iterations more efficient. For an ArrayList it doesn't really matter because the complexity/cost of get is constant time (O(1)) whereas for a LinkedList is it proportional to the size of the list (O(n)). For more information about the computational complexity of the built-in Collections implementations, check out this question . Enhanced for loop (nicely explained in this question ) #pre Iterator #pre EDIT: Added ListIterator ListIterator #pre EDIT: Added "functional-style" solution (thanks Dave Newton) Functional Java list.stream(args).map(args); // can apply a transformation function for e EDIT: Added map method from Java 8's Stream API (see @i_am_zero's answer) Iterable.forEach , Stream.forEach , ... In Java 8 collection classes that implement Iterable (for example all List s) now have a forEach method, which can be used instead of the for loop statement demonstrated above. (Here is another question that provides a good comparison.) #pre What other ways are there, if any? I feel like this has got to be a duplicate, but I haven't been able to find what I'm looking for, so I apologize for this question potentially being redundant. (BTW, my interest does not stem at all from a desire to optimize performance ; I just want to know what forms are available to me as a developer.) EDIT: Moved ListIterationExample.java to a suggested answer

Question-19431234
Java 8 has a completely new API for date and time. One of the most useful classes in this API is LocalDateTime , for holding a timezone-independent date-with-time value. There are probably millions of lines of code using the legacy class java.util.Date for this purpose. As such, when interfacing old and new code there will be a need for converting between the two. As there seems to be no direct methods for accomplishing this, how can it be done?

Question-20129762
In Java 8 we have the class Stream<T> , which curiously have a method Iterator<T> iterator(args) So you would expect it to implement interface Iterable<T> , which requires exactly this method, but that's not the case. When I want to iterate over a Stream using a foreach loop, I have to do something like #pre Am I missing something here?

Question-17828584
I was wondering what happens when you try to catch an StackOverflowError and came up with the following method: #pre Now my question: Why does this method print '4'? I thought maybe it was because System.out.println(args) needs 3 segments on the call stack, but I don't know where the number 3 comes from. When you look at the source code (and bytecode) of System.out.println(args) , it normally would lead to far more method invocations than 3 (so 3 segments on the call stack would not be sufficient). If it's because of optimizations the Hotspot VM applies (method inlining), I wonder if the result would be different on another VM. Edit : As the output seems to be highly JVM specific, I get the result 4 using Java(TM) SE Runtime Environment (build 1.6.0_41-b02) Java HotSpot(TM) 64-Bit Server VM (build 20.14-b01, mixed mode) Explanation why I think this question is different from Understanding java stack : My question is not about why there is a cnt > 0 (obviously because System.out.println(args) requires stack size and throws another StackOverflowError before something gets printed), but why it has the particular value of 4, respectively 0,3,8,55 or something else on other systems.

Question-18092160
Why were 181783497276652981 and 8682522807148012 chosen in Random.java ? Here's the relevant source code from Java SE JDK 1.7: #pre So, invoking new Random(args) without any seed parameter takes the current "seed uniquifier" and XORs it with System.nanoTime(args) . Then it uses 181783497276652981 to create another seed uniquifier to be stored for the next time new Random(args) is called. The literals 181783497276652981L and 8682522807148012L are not placed in constants, but they don't appear anywhere else. At first the comment gives me an easy lead. Searching online for that article yields the actual article . 8682522807148012 doesn't appear in the paper, but 181783497276652981 does appear -- as a substring of another number, 1181783497276652981 , which is 181783497276652981 with a 1 prepended. The paper claims that 1181783497276652981 is a number that yields good "merit" for a linear congruential generator. Was this number simply mis-copied into Java? Does 181783497276652981 have an acceptable merit? And why was 8682522807148012 chosen? Searching online for either number yields no explanation, only this page that also notices the dropped 1 in front of 181783497276652981 . Could other numbers have been chosen that would have worked as well as these two numbers? Why or why not?

Question-20358883
Is there a Utility method somewhere that can do this in 1 line? I can't find it anywhere in Collections , or List . #pre I don't want to re-invent the wheel unless I plan on putting fancy rims on it. Well... the type can be T , and not String . but you get the point. (with all the null checking, safety checks...etc)

Question-19235606
I am having trouble understanding the Stream interface in Java 8, especially where it has to do with the Spliterator and Collector interfaces. My problem is that I simply can't understand yet the Spliterator and the Collector interfaces, and as a result the Stream interface is still somewhat obscure to me. What exactly is a Spliterator and a Collector , and how can I use them? If I am willing to write my own Spliterator or Collector (and probably my own Stream in that process), what should I do and not do? I read some examples scattered around the web, but since everything here is stil new and subject to changes, examples and tutorials are still very sparse.

Question-18723596
String x = (String) null; Why there is no exception in this statement? #pre It prints null . But .toString(args) method should throw a null pointer exception.

Question-20331163
I have a string " 11/15/2013 08:00:00 ", I want to format it to " 11/15/2013 ", what is the correct DateTimeFormatter pattern? I've tried many and googled and still unable to find the correct pattern. edit: I am looking for Joda-Time DateTimeFormatter , not Java's SimpleDateFormat..

Question-18532488
In many other languages, eg. Haskell, it is easy to repeat a value or function multiple times, eg. to get a list of 8 copies of the value 1: take 8(args) but I haven't found this yet in Java 8. Is there such a function in Java 8's JDK? Or alternatively something equivalent to a range like [1..8] It would seem an obvious replacement for a verbose statement in Java like #pre to have something like Range.from(args).forEach(args) though this particular example doesn't look much more concise actually... but hopefully it's more readable.

Question-20001427, answer-20001866
Usually, one would call the reduce method using Math.max(args) as follows: #pre That requires a lot of syntax for just calling Math.max . That's where lambda expressions come into play. Since Java 8 it is allowed to do the same thing in a much shorter way: reduce(args); How does this work? The java compiler "detects", that you want to implement a method that accepts two int s and returns one int . This is equivalent to the formal parameters of the one and only method of interface IntBinaryOperator (the parameter of method reduce you want to call). So the compiler does the rest for you - it just assumes you want to implement IntBinaryOperator . But as Math.max(args) itself fulfills the formal requirements of IntBinaryOperator , it can be used directly. Because Java 7 does not have any syntax that allows a method itself to be passed as an argument (you can only pass method results, but never method references), the :: syntax was introduced in Java 8 to reference methods: reduce(args); Note that this will be interpreted by the compiler, not by the JVM at runtime! Although it produces different bytecodes for all three code snippets, they are semantically equal, so the last two can be considered to be short (and probably more efficient) versions of the IntBinaryOperator implementation above! (See also Translation of Lambda Expressions )

Question-20001427, answer-22245383
:: is called Method Reference. It is basically a reference to a single method. i.e. it refers to an existing method by name. Short Explanation : Below is an example of a reference to a static method: #pre square can be passed around just like object reference's and trigger when at need. In fact, it can be perfectly used as a reference to a normal method of an object and not just static ones. #pre Function above is a functional interface . Well to fully explain :: , it is important to understand Functional Interface. Plainly, Function interface is an interface with just one abstract method. For example: Runnable , Callable , ActionListener and so. Function above is a functional interface with just one method apply . It takes one argument and produces a result. The reason why :: are awesome is because: #blockquote i.e. Just like writing lambda body: Function<T> square = (Double x) -> x * x; You can simply do: Function<T> square = Hey::square; At runtime they behave exactly the same. The bytecode may/not be the same (For above case, it generates the same bytecode (compile above and check javap -c )) The only major criteria to satisfy is: the method you provide should have a similar signature to method of the FunctionalInterface you use as object reference. Below is illegal Supplier<T> p = Hey::square; //illegal square expects an argument and returns a double. get method in Supplier expects an argument but doesn't return anything. So it is an error. Method Reference refers to a method of the functional interface (As mentioned, functional interface can only have one method). Some more examples: accept method in Consumer takes an input but doesnt return anything. #pre Above getRandom takes no argument and returns a double. So any functional interface that satisfies the criteria of: take no argument and return double can be used. Another example: #pre In case of Parametrized Types : #pre Method Reference can be obtained in different styles, but fundamentally they all mean the same and can simply be visualized as a lambda: #li A static method ( ClassName::methName ) #li An instance method of a particular object ( instanceRef::methName ) #li A super method of a particular object ( super::methName ) #li An instance method of an arbitrary object of a particular type ( ClassName::methName ) #li A class constructor reference ( ClassName::new ) #li An array constructor reference ( TypeName[]::new ) For further reference: #a

Question-20363719, answer-25453317
If your key is NOT guaranteed to be unique for all elements in the list, you should convert it to a Map<String, List<T> instead of a Map<T> Map<T> result = choices.stream(args).collect(args);

Question-20363719, answer-34675066
I was trying to do this and found that, using the answers above, when using Functions.identity(args) for the key to the Map, then I had issues with using a local method like this::localMethodName to actually work because of typing issues. Functions.identity(args) actually does something to the typing in this case so the method would only work by returning Object and accepting a param of Object To solve this, I ended up ditching Functions.identity(args) and using s->s instead. So my code, in my case to list all directories inside a directory, and for each one use the name of the directory as the key to the map and then call a method with the directory name and return a collection of items, looks like: Map<T> items = Arrays.stream(args) .map(args) .collect(args);

Question-18571223, answer-18571348
The object your method decompressGZIP(args) needs is a byte[] . So the basic, technical answer to the question you have asked is: #pre However the problem you appear to be wrestling with is that this doesn't display very well. Calling toString(args) will just give you the default Object.toString(args) which is the class name + memory address. In your result [B@38ee9f13 , the [B means byte[] and 38ee9f13 is the memory address, separated by an @ . For display purposes you can use: Arrays.toString(args); But this will just display as a sequence of comma-separated integers, which may or may not be what you want. To get a readable String back from a byte[] , use: String string = new String(args); The reason the Charset version is favoured, is that all String objects in Java are stored internally as UTF-16. When converting to a byte[] you will get a different breakdown of bytes for the given glyphs of that String , depending upon the chosen charset.

Question-18571223, answer-18571352
You can use String.getBytes(args) which returns the byte[] array.

Question-18571223, answer-18571358
Try using String.getBytes(). It returns a byte[] representing string data. Example: #pre

Question-18571223, answer-20262456
You might wanna try return new String(args)

Question-18410035, answer-37409771
In Java 8 collection classes that implement Iterable (for example all lists) now have forEach method: Arrays.asList(args).forEach(args); The above example makes use of method-reference introduced in Java 8. We can also iterate over a list using Stream as: Arrays.asList(args).stream(args).forEach(args); The advantage with later option is that we can also make use of parallel streams wherever appropriate. If the objective is only to print the items irrespective of the order then we can use parallel stream as: Arrays.asList(args).parallelStream(args).forEach(args);

Question-19418427, answer-19418548
As per my research, all the final String are interned in Java. From one of the blog post: #blockquote So it means if you call String.intern(args) you can compare two strings using == operator. But here String.intern(args) is not necessary because in Java final String are internally interned. You can find more information String comparision using == operator and Javadoc for String.intern() method. Also refer this Stackoverflow post for more information.

Question-19418427, answer-19418553
If you take a look at this methods #pre and its decompiled with javap -c ClassWithTheseMethods versions you will see #pre and #pre So if Strings are not final compiler will have to use StringBuilder to concatenate str1 and str2 so String concat=str1+str2; will be compiled to String concat = new StringBuilder(args).append(args).toString(args); which means that concat will be created at runtime so will not come from String pool. Also if Strings are final then compiler can assume that they will never change so instead of using StringBuilder it can safely concatenate its values so String concat = str1 + str2; can be changed to String concat = StringLiteral + StringLiteral; and concatenated into String concat = StringLiteral; which means that concate will become sting literal which will be interned in string pool and then compared with same string literal from that pool in if statement.

Question-18777989, answer-18778228
You made a good summery of the practical differences in use and implementation but did not say anything about the difference in meaning. An interface is a description of the behaviour an implementing class will have. The implementing class ensures, that it will have these methods that can be used on it. It is basically a contract or a promise the class has to make. An abstract class is a basis for different subclasses that share behaviour which does not need to be repeatedly be created. Subclasses must complete the behaviour and have the option to override predefine behaviour (as long as it is not defined as final or private ). You will find good examples in the java.util package which includes interfaces like List and abstract classes like AbstractList which already implements the interface. The official documentation describes the AbstractList as follows: #blockquote

Question-18777989, answer-37905386
Many junior developers make the mistake of thinking of interfaces, abstract and concrete classes as slight variations of the same thing, and choose one of them purely on technical grounds: Do I need multiple inheritance? Do I need some place to put common methods? Do I need to bother with something other than just a concrete class? This is wrong, and hidden in these questions is the main problem: "I" . When you write code for yourself, by yourself, you rarely think of other present or future developers working on or with your code. Interfaces and abstract classes, although apparently similar from a technical point of view, have completely different meanings and purposes. Summary #li An interface defines a contract that some implementation will fulfill for you . #li An abstract class provides a default behavior that your implementation can reuse. These two points above is what I'm looking for when interviewing, and is a compact enough summary. Read on for more details. Alternative summary #li An interface is for defining public APIs #li An abstract class is for internal use, and for defining SPIs By example To put it differently: A concrete class does the actual work, in a very specific way. For example, an ArrayList uses a contiguous area of memory to store a list of objects in a compact manner which offers fast random access, iteration, and in-place changes, but is terrible at insertions, deletions, and occasionally even additions; meanwhile, a LinkedList uses double-linked nodes to store a list of objects, which instead offers fast iteration, in-place changes, and insertion/deletion/addition, but is terrible at random access. These two types of lists are optimized for different use cases, and it matters a lot how you're going to use them. When you're trying to squeeze performance out of a list that you're heavily interacting with, and when picking the type of list is up to you, you should carefully pick which one you're instantiating. On the other hand, high level users of a list don't really care how it is actually implemented, and they should be insulated from these details. Let's imagine that Java didn't expose the List interface, but only had a concrete List class that's actually what LinkedList is right now. All Java developers would have tailored their code to fit the implementation details: avoid random access, add a cache to speed up access, or just reimplement ArrayList on their own, although it would be incompatible with all the other code that actually works with List only. That would be terrible... But now imagine that the Java masters actually realize that a linked list is terrible for most actual use cases, and decided to switch over to an array list for their only List class available. This would affect the performance of every Java program in the world, and people wouldn't be happy about it. And the main culprit is that implementation details were available, and the developers assumed that those details are a permanent contract that they can rely on. This is why it's important to hide implementation details, and only define an abstract contract. This is the purpose of an interface: define what kind of input a method accepts, and what kind of output is expected, without exposing all the guts that would tempt programmers to tweak their code to fit the internal details that might change with any future update. An abstract class is in the middle between interfaces and concrete classes. It is supposed to help implementations share common or boring code. For example, AbstractCollection provides basic implementations for isEmpty based on size is 0, contains as iterate and compare, addAll as repeated add , and so on. This lets implementations focus on the crucial parts that differentiate between them: how to actually store and retrieve data. Another perspective: APIs versus SPIs Interfaces are low-cohesion gateways between different parts of code. They allow libraries to exist and evolve without breaking every library user when something changes internally. It's called Application Programming Interface Abstract classes are high-cohesion helpers to be used when implementing an interface, assuming some level of implementation details. Alternatively, abstract classes are used for defining SPIs, Service Provider Interfaces. The difference between an API and an SPI is subtle, but important: for an API, the focus is on who uses it, and for an SPI the focus is on who implements it. Adding methods to an API is easy, all existing users of the API will still compile. Adding methods to an SPI is hard, since every service provider (concrete implementation) will have to implement the new methods. If interfaces are used to define an SPI, a provider will have to release a new version whenever the SPI contract changes. If abstract classes are used instead, new methods could either be defined in terms of existing abstract methods, or as empty throw not implemented exception stubs, which will at least allow an older version of a service implementation to still compile and run. A note on Java 8 and default methods Although Java 8 introduced default methods for interfaces, which makes the line between interfaces and abstract classes even blurrier, this wasn't so that implementations can reuse code, but to make it easier to change interfaces that serve both as an API and as an SPI (or are wrongly used for defining SPIs instead of abstract classes). "Book knowledge" The technical details provided in the OP's answer are considered "book knowledge" because this is usually the approach used in school and in most technology books about a language: what a thing is, not how to use it in practice, especially in large scale applications. Here's an analogy: supposed the question was: #blockquote The technical answer sounds like: #blockquote That is all true, but completely misses the points that they are two completely different things, and both can be used at the same time for different purposes, and the "doing it" aspect is not the most important thing about either of the two options. The answer lacks perspective, it shows an immature way of thinking, while correctly presenting true "facts".

Question-19998454, answer-19998652
This is being described in this article . Think about forEach of Collections. List<T> list = … list.forEach(args); #blockquote

Question-19431234, answer-23526153
Everything is here : #a The answer with "round-tripping" is not exact : when you do LocalDateTime ldt = LocalDateTime.ofInstant(args); if your system timezone is not UTC/GMT, you change the time !

Question-19431234, answer-23884116
the following seems to work when converting from new API LocalDateTime into java.util.date: Date.from(args); the reverse conversion can be (hopefully) achieved similar way... hope it helps...

Question-19431234, answer-23885950
Short answer: #pre Explanation: (based on this question about LocalDate ) Despite its name, java.util.Date represents an instant on the time-line, not a "date". The actual data stored within the object is a long count of milliseconds since 1970-01-01T00:00Z (midnight at the start of 1970 GMT/UTC). The equivalent class to java.util.Date in JSR-310 is Instant , thus there are convenient methods to provide the conversion to and fro: #pre A java.util.Date instance has no concept of time-zone. This might seem strange if you call toString(args) on a java.util.Date , because the toString is relative to a time-zone. However that method actually uses Java's default time-zone on the fly to provide the string. The time-zone is not part of the actual state of java.util.Date . An Instant also does not contain any information about the time-zone. Thus, to convert from an Instant to a local date-time it is necessary to specify a time-zone. This might be the default zone - ZoneId.systemDefault(args) - or it might be a time-zone that your application controls, such as a time-zone from user preferences. LocalDateTime has a convenient factory method that takes both the instant and time-zone: #pre In reverse, the LocalDateTime the time-zone is specified by calling the atZone(args) method. The ZonedDateTime can then be converted directly to an Instant : #pre Note that the conversion from LocalDateTime to ZonedDateTime has the potential to introduce unexpected behaviour. This is because not every local date-time exists due to Daylight Saving Time. In autumn/fall, there is an overlap in the local time-line where the same local date-time occurs twice. In spring, there is a gap, where an hour disappears. See the Javadoc of atZone(ZoneId) for more the definition of what the conversion will do. Summary, if you round-trip a java.util.Date to a LocalDateTime and back to a java.util.Date you may end up with a different instant due to Daylight Saving Time.

Question-19431234, answer-30133063
Much more convenient way if you are sure you need a default timezone : Date d = java.sql.Timestamp.valueOf(args);

Question-20129762, answer-20130131
There are already people asked the same on the mailing list ☺. The main reason is Iterable also has a re-iterable semantic, while Stream is not. #blockquote

Question-20129762, answer-20130475
To convert a Stream to an Iterable , you can do #pre To pass a Stream to a method that expects Iterable , void foo(args) simply foo(args) however it probably looks funny; it might be better to be a little bit more explicit foo(args);

Question-20129762, answer-30548433
I would like to point out that StreamEx does implement Iterable (and Stream ), as well as a host of other immensely awesome functionality missing from Stream .

Question-18448671, answer-18448685
If you want to modify your List during traversal, then you need to use the Iterator . And then you can use iterator.remove(args) to remove the elements during traversal.

Question-18448671, answer-18448699
Use an Iterator and call remove() : #pre

Question-18448671, answer-26937769
Though one answer is accepted and this is an old one, I thought posting this answer as it does not use Iterator #pre

Question-17489250, answer-17489334
Text inside double quotes creates a literal String object. String myString = StringLiteral; The code above creates a String object, using double quotes.

Question-17489250, answer-17489376
String gets special treatment in the JLS: it's one of the two non-primitive types for which literals exist (the other is Class ) * . From the JLS : #blockquote * well, there's also the "null type" with it's "null literal" null , but most people don't think of the "null type" as a proper type.

Question-17489250, answer-17489394
It's a feature of the Java language. String literals in the source code is given special treatment. The language spec, here , simply says that a string literal is of String type

Question-17489250, answer-17489410
Java String is Special #blockquote For example #pre #img Note : String literals are stored in a common pool. This facilitates sharing of storage for strings with the same contents to conserve storage. String objects allocated via new operator are stored in the heap , and there is no sharing of storage for the same contents.

Question-17489250, answer-17489437
Java.lang.String is not just a class. It's an integral part of the core language. The compiler has syntactic sugar for it. For example, StringLiteral is like an abbreviation for new String(args) . When written StringLiteral the compiler optimizes identical strings to the same instance to save space. StringLiteral + 5 == StringLiteral ==> true The compiler has syntactic sugar for a lot of stuff, including not having to box/unbox between object versions and their native types, no parent means Object, default constructor, ...

Question-17489250, answer-17489453
Java treats String as a special class, you can initialize in both ways #li Directly assigning literal String a = StringLiteral; #li As other Objects using new keyword String a = new String(args); You need to take special care when you wants to compare with == sign: #pre That is because in first case the objects a and b are kept in something called literal pool and they both are referencing same object so they are equal in both ways. But in second case a and b references different objects like when we initialize any other objects. so they are unequal when compared with == operator whereas they are equal in values.

Question-17828584, answer-17832168
I think the number displayed is the number of time the System.out.println call throws the Stackoverflow exception. It probably depend on the implementation of the println and the number of stacking call it is made in it. As an illustration: The main(args) call trigger the Stackoverflow exception at call i. The i-1 call of main catch the exception and call println which trigger a second Stackoverflow . cnt get increment to 1. The i-2 call of main catch now the exception and call println . In println a method is called triggering a 3rd exception. cnt get increment to 2. this continue until println can make all its needed call and finally display the value of cnt . This is then dependent of the actual implementation of println . For the JDK7 either it detect cycling call and throws the exception earlier either it keep some stack resource and throw the exception before reaching the limit to give some room for remediation logic either the println implementation doesn't make calls either the ++ operation is done after the println call thus is by pass by the exception.

Question-17828584, answer-17836189
I think the others have done a good job at explaining why cnt > 0, but there's not enough details regarding why cnt = 4, and why cnt varies so widely among different settings. I will attempt to fill that void here. Let #li X be the total stack size #li M be the stack space used when we enter main the first time #li R be the stack space increase each time we enter into main #li P be the stack space necessary to run System.out.println When we first get into main, the space left over is X-M. Each recursive call takes up R more memory. So for 1 recursive call (1 more than original), the memory use is M + R. Suppose that StackOverflowError is thrown after C successful recursive calls, that is, M + C * R <= X and M + C * (R + 1) > X. At the time of the first StackOverflowError, there's X - M - C * R memory left. To be able to run System.out.prinln , we need P amount of space left on the stack. If it so happens that X - M - C * R >= P, then 0 will be printed. If P requires more space, then we remove frames from the stack, gaining R memory at the cost of cnt++. When println is finally able to run, X - M - (C - cnt) * R >= P. So if P is large for a particular system, then cnt will be large. Let's look at this with some examples. Example 1: Suppose #li X = 100 #li M = 1 #li R = 2 #li P = 1 Then C = floor((X-M)/R) = 49, and cnt = ceiling((P - (X - M - C*R))/R) = 0. Example 2: Suppose that #li X = 100 #li M = 1 #li R = 5 #li P = 12 Then C = 19, and cnt = 2. Example 3: Suppose that #li X = 101 #li M = 1 #li R = 5 #li P = 12 Then C = 20, and cnt = 3. Example 4: Suppose that #li X = 101 #li M = 2 #li R = 5 #li P = 12 Then C = 19, and cnt = 2. Thus, we see that both the system (M, R, and P) and the stack size (X) affects cnt. As a side note, it does not matter how much space catch requires to start. As long as there is not enough space for catch , then cnt will not increase, so there are no external effects. EDIT I take back what I said about catch . It does play a role. Suppose it requires T amount of space to start. cnt starts to increment when the leftover space is greater than T, and println runs when the leftover space is greater than T + P. This adds an extra step to the calculations and further muddies up the already muddy analysis. EDIT I finally found time to run some experiments to back up my theory. Unfortunately, the theory doesn't seem to match up with the experiments. What actually happens is very different. Experiment setup: Ubuntu 12.04 server with default java and default-jdk. Xss starting at 70,000 at 1 byte increments to 460,000. The results are available at: #a I've created another version where every repeated data point is removed. In other words, only points that are different from the previous are shown. This makes it easier to see anomalies. #a

Question-17828584, answer-17842210
After digging around for a while, I can't say that I find the answer, but I think it's quite close now. First, we need to know when a StackOverflowError will be thrown. In fact, the stack for a java thread stores frames, which containing all the data needed for invoking a method and resume. According to Java Language Specifications for JAVA 6 , when invoking a method, #blockquote Second, we should make it clear what is " there is not sufficient memory available to create such an activation frame ". According to Java Virtual Machine Specifications for JAVA 6 , #blockquote So, when a frame is created, there should be enough heap space to create a stack frame and enough stack space to store the new reference which point to the new stack frame if the frame is heap allocated. Now let's go back to the question. From the above, we can know that when a method is execute, it may just costs the same amount of stack space. And invoking System.out.println (may) needs 5 level of method invocation, so 5 frames need to be created. Then when StackOverflowError is thrown out, it has to go back 5 times to get enough stack space to store 5 frames' references. Hence 4 is print out. Why not 5? Because you use cnt++ . Change it to ++cnt , and then you will get 5. And you will notice that when the size of stack go to a high level, you will get 50 sometimes. That is because the amount of available heap space need to be taken into consideration then. When the stack's size is too large, maybe heap space will run out before stack. And (maybe) the actual size of stack frames of System.out.println is about 51 times of main , therefore it goes back 51 times and print 50.

Question-20375176, answer-20375622
A parallel stream has a much higher overhead compared to a sequential one. Coordinating the threads takes a significant amount of time. I would use sequential streams by default and only consider parallel ones if #li I have a massive amount of items to process (or the processing of each item takes time and is parallelizable) #li I have a performance problem in the first place #li I don't already run the process in a multi-thread environment (for example: in a web container, if I already have many requests to process in parallel, adding an additional layer of parallelism inside each request could have more negative than positive effects) In your example, the performance will anyway be driven by the synchronized access to System.out.println(args) , and making this process parallel will have no effect, or even a negative one. Moreover, remember that parallel streams don't magically solve all the synchronization problems. If a shared resource is used by the predicates and functions used in the process, you'll have to make sure that everything is thread-safe. In particular, side effects are tings you really have to worry about if you go parallel. In any case, measure, don't guess! Only a measurement will tell you if the parallelism is worth it or not.

Question-17781150, answer-17781168
The value you are looking for is Integer.MIN_VALUE . #blockquote That's off-topic for Stack Exchange. But you could do it starting from the definition of Java integers ( JLS 4.2 ) #blockquote and #blockquote and the definition of the Java unary '-' operator ( JLS 15.15.4 ): #blockquote

Question-17781150, answer-17781189
The only int value for which it works is Integer.MIN_VALUE . It's because integers are negated using the two's complement way . Using System.out.println(args); you see that Integer.MIN_VALUE is 10000000000000000000000000000000 Taking the negative value is done by first swapping 0 and 1 , which gives 01111111111111111111111111111111 and by adding 1 , which gives 10000000000000000000000000000000 As you can see in the link I gave, Wikipedia mentions the problem with the most negative numbers and specifies it's the sole exception : #blockquote Of course you have the same phenomenon for Long.Min_Value if you store it in a long variable. Note that this is only due to choices that were made regarding the binary storage of ints in Java . Another (bad) solution could for example have been to negate by simply changing the most significant bit and letting the other bits unchanged, this would have avoided this problem with MIN_VALUE but would have made 2 different 0 values and complicated binary arithmetic (how would you have incremented for example ?).

Question-17781150, answer-17781376
Like the others have mentioned, this is only fulfilled by Integer.MIN_VALUE . As for proof, let me offer an easier to understand explanation other than in binary (although it is still rooted in that). Note that Integer.MIN_VALUE is equal to -2^31 or -2147483648 and Integer.MAX_VALUE is equal to 2^31-1 or 2147483647 . -Integer.MIN_VALUE is 2^31 , which is now too large for an Integer (since it is past MAX_VALUE ) thus causing an Integer overflow, making it Integer.MIN_VALUE again. It's the only Integer that does this since MIN_VALUE is the only number with no negative equivalent aside from 0.

Question-20746429, answer-20765715
Such an operation ought to be possible with a Java 8 Stream , but it can't necessarily be done efficiently -- for example, you can't necessarily parallelize such an operation, as you have to look at elements in order. The API doesn't provide an easy way to do it, but what's probably the simplest way is to take Stream.iterator(args) , wrap the Iterator to have a "take-while" implementation, and then go back to a Spliterator and then a Stream . Or -- maybe -- wrap the Spliterator , though it can't really be split anymore in this implementation. Here's an untested implementation of takeWhile on a Spliterator : #pre

Question-20746429, answer-24531394
Here is a version done on ints - as asked in the question. Usage: StreamUtil.takeWhile(args); Here's code for StreamUtil: #pre

Question-19416644, answer-19416665
One simple way is to use Float.NaN : #pre #pre You can do the same with Double.NaN . From JLS §15.21.1. Numerical Equality Operators == and != : #blockquote

Question-19416644, answer-19775881
Create your own class System in tha same package with Condition . In this case your System class will hide java.lang.System class #pre Ideone DEMO

Question-20358883, answer-20358917
Very simply: Arrays.asList(args)

Question-20358883, answer-20358920
Fixed size List The easiest way, that I know of, is to create a fixed-size single element List with Arrays.asList(T...) like // Returns a List backed by a varargs T. return Arrays.asList(args); Variable size List If it needs vary in size you can construct an ArrayList and the fixed-size List like return new ArrayList<T>(args); and (in Java 7+) you can use the diamond operator <> to make it return new ArrayList<T>(args);

Question-20358883, answer-20358928
You can use the utility method Arrays.asList and feed that result into a new ArrayList . ArrayList<T> list = new ArrayList<T>(args); Other options: ArrayList<T> list = new ArrayList<T>(args); and ArrayList<T> list = new ArrayList<T>(args); #li ArrayList(Collection) constructor. #li Arrays.asList method. #li Collections.nCopies method. #li Collections.singletonList method.

Question-20358883, answer-29784337
The other answers all use Arrays.asList(args) , which returns an unmodifiable list (an UnsupportedOperationException is thrown if you try to add or remove an element). To get a mutable list you can wrap the returned list in a new ArrayList as a couple of answers point out, but a cleaner solution is to use Guava's Lists.newArrayList() (available since at least Guava 10 , released in 2011). For example: Lists.newArrayList(args);

Question-20358883, answer-31931870
Collections.singletonList(args)

Question-20358883, answer-31965160
With Java 8 Streams: Stream.of(args).collect(args) or if you need a set: Stream.of(args).collect(args)

Question-18636561, answer-18824858
Whenever a new keyword is used it Creates a Object at the Heap 1)StringBuilder sample = new StringBuilder(); 2) StringBuilder referToSample = sample; In 2) the Reference of referSample is created on same object sample thus referToSample = null; is Nulling Only the referSample Reference giving no effect to sample that's why you are not getting NULL Pointer Exception Thanks to Java's Garbage Collection

Question-19235606, answer-19235857
Spliterator basically means "splittable Iterator". Single thread can traverse/process the entire Spliterator itself, but the Spliterator also has a method trySplit(args) which will "split off" a section for someone else (typically, another thread) to process -- leaving the current spliterator with less work. Collector combines the specification of a reduce function (of map-reduce fame), with an initial value, and a value to combine two results (thus enabling results from Spliterated streams of work, to be combined.) For example, the most basic Collector would have an initial vaue of 0, add an integer onto an existing result, and would 'combine' two results by adding them. Thus summing a spliterated stream of integers. See: #li Spliterator.trySplit() #li Collector<T,A,R>

Question-19235606, answer-19235863
You should almost certainly never have to deal with Spliterator as a user; it should only be necessary if you're writing Collection types yourself and also intending to optimize parallelized operations on them. For what it's worth, a Spliterator is a way of operating over the elements of a collection in a way that it's easy to split off part of the collection, e.g. because you're parallelizing and want one thread to work on one part of the collection, one thread to work on another part, etc. You should essentially never be saving values of type Stream to a variable, either. Stream is sort of like an Iterator , in that it's a one-time-use object that you'll almost always use in a fluent chain, as in the Javadoc example: int sum = widgets.stream(args) .filter(args) .mapToInt(args) .sum(args); Collector is the most generalized, abstract possible version of a "reduce" operation a la map/reduce; in particular, it needs to support parallelization and finalization steps. Examples of Collector s include: #li summing, e.g. Collectors.reducing(args) #li StringBuilder appending, e.g. Collectors.of(args)

Question-18647214, answer-18647232
I would just do this. It basically takes the minimum between 100 (the max health) and what the health would be with 15 extra points. It ensures that the user's health does not exceed 100. #pre To ensure that hitpoints do not drop below zero, you can use a similar function: Math.max . #pre

Question-18723596, answer-18723651
Println(args) uses String.valueOf(args) #pre Print(args) does null check. #pre

Question-18723596, answer-18723666
You can cast null to any reference type without getting any exception. println method does not throw null pointer because it first checks whether the object is null or not. If null then it simply prints the string StringLiteral . Otherwise it will call the toString method of that object. Adding more details: Internally print methods call String.valueOf(args) method on the input object. And in valueOf method, this check helps to avoid null pointer excpeiton: return(args) ? StringLiteral : obj.toString(args); For rest of your confusion, calling any method on a null object should throw a null pointer exception, if not a special case.

Question-18723596, answer-18723704
You can cast null to any reference type. You can also call methods which handle a null as an argument, e.g. System.out.println(args) does, but you cannot reference a null value and call a method on it. BTW There is a tricky situation where it appears you can call static methods on null values. #pre

Question-20331163, answer-20331241
I have a very dumb but working option. if you have the String fullDate = "11/15/2013 08:00:00"; String finalDate = fullDate.split(args)[0]; That should work easy and fast. :)

Question-20331163, answer-20331243
Create a DateTimeFormatter using DateTimeFormat.forPattern(String) Using Joda time you would do it like this: #pre Also, if you wanted to use standard Java, you would do it like this: #pre

Question-20331163, answer-20331323
Another way of doing that is: String date = dateAndTime.substring(args); I'm not exactly certain, but I think this might be faster/use less memory than using the .split(args) method.

Question-18666710, answer-18792306
An important feature of parametric types is the ability to write polymorphic algorithms, i.e. algorithms that operate on a data structure regardless of its parameter value, such as Arrays.sort(args) . With generics, that's done with wildcard types: <E extends Comparable<T>> void sort(args); To be truly useful, wildcard types require wildcard capture, and that requires the notion of a type parameter. None of that was available at the time arrays were added to Java, and makings arrays of reference type covariant permitted a far simpler way to permit polymorphic algorithms: void sort(args); However, that simplicity opened a loophole in the static type system: #pre requiring a runtime check of every write access to an array of reference type. In a nutshell, the newer approach embodied by generics makes the type system more complex, but also more statically type safe, while the older approach was simpler, and less statically type safe. The designers of the language opted for the simpler approach, having more important things to do than closing a small loophole in the type system that rarely causes problems. Later, when Java was established, and the pressing needs taken care of, they had the resources to do it right for generics (but changing it for arrays would have broken existing Java programs).

Question-18263489, answer-29873100
It isn't pretty, but String.valueOf(args) allows you to use a null String in a switch. If it finds null , it converts it to StringLiteral , otherwise it just returns the same String you passed it. If you don't handle StringLiteral explicitly, then it will go to default . The only caveat is that there is no way of distinguishing between the String StringLiteral and an actual null String. #pre

Question-18987692, answer-18987738
You can use IsNull.nullValue() method: #pre

Question-18532488, answer-24296741
Here's another technique I ran across the other day: Collections.nCopies(args) .stream(args) .forEach(args); The Collections.nCopies call creates a List containing n copies of whatever value you provide. In this case it's the boxed Integer value 1. Of course it doesn't actually create a list with n elements; it creates a "virtualized" list that contains only the value and the length, and any call to get within range just returns the value. The nCopies method has been around since the Collections Framework was introduced way back in JDK 1.2. Of course, the ability to create a stream from its result was added in Java SE 8. Big deal, another way to do the same thing in about the same number of lines. However, this technique is faster than the IntStream.generate and IntStream.iterate approaches, and surprisingly, it's also faster than the IntStream.range approach. For iterate and generate the result is perhaps not too surprising. The streams framework (really, the Spliterators for these streams) is built on the assumption that the lambdas will potentially generate different values each time, and that they will generate an unbounded number of results. This makes parallel splitting particularly difficult. The iterate method is also problematic for this case because each call requires the result of the previous one. So the streams using generate and iterate don't do very well for generating repeated constants. The relatively poor performance of range is surprising. This too is virtualized, so the elements don't actually all exist in memory, and the size is known up front. This should make for a fast and easily parallelizable spliterator. But it surprisingly didn't do very well. Perhaps the reason is that range has to compute a value for each element of the range and then call a function on it. But this function just ignores its input and returns a constant, so I'm surprised this isn't inlined and killed. The Collections.nCopies technique has to do boxing/unboxing in order to handle the values, since there are no primitive specializations of List . Since the value is the same every time, it's basically boxed once and that box is shared by all n copies. I suspect boxing/unboxing is highly optimized, even intrinsified, and it can be inlined well. Here's the code: #pre And here are the JMH results: (2.8GHz Core2Duo) #pre There is a fair amount of variance in the ncopies version, but overall it seems comfortably 20x faster than the range version. (I'd be quite willing to believe that I've done something wrong, though.) I'm surprised at how well the nCopies technique works. Internally it doesn't do very much special, with the stream of the virtualized list simply being implemented using IntStream.range ! I had expected that it would be necessary to create a specialized spliterator to get this to go fast, but it already seems to be pretty good.

Question-18532488, answer-33142346
Once a repeat function is somewhere defined as #pre You can use it now and then this way, e.g.: repeat.accept(args); To get and equivalent to Haskell's take 8(args) You could write #pre

Question-19757300, answer-19759653
You can also propagate your static pain with lambdas, so the whole thing looks readable: s.filter(args) propagate here receives java.util.concurrent.Callable as a parameter and converts any exception caught during the call into RuntimeException . There is a similar conversion method Throwables#propagate(Throwable) in Guava. This method seems being essential for lambda method chaining, so I hope one day it will be added to one of the popular libs or this propagating behavior would be by default. #pre

Question-19757300, answer-35512247
Keeping this issue in mind I developed a small library for dealing with checked exceptions and lambdas. Custom adapters allow you to integrate with existing functional types: stream(args).map(args) //with a static import #a
