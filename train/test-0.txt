Question - 24603186 , answer - 24603187 The Javadocs for Collection . ( parallelS | s ) tream ( args ) and Stream itself don ' t answer the question , so it ' s off to the mailing lists for the rationale . I went through the lambda - libs - spec - observers archives and found one thread specifically about Collection . parallelStream ( ) and another thread that touched on whether java . util . Arrays should provide parallelStream ( ) to match ( or actually , whether it should be removed ) . There was no once - and - for - all conclusion , so perhaps I ' ve missed something from another list or the matter was settled in private discussion . ( Perhaps Brian Goetz , one of the principals of this discussion , can fill in anything missing . ) The participants made their points well , so this answer is mostly just an organization of the relevant quotes , with a few clarifications in [ brackets ] , presented in order of importance ( as I interpret it ) . parallelStream ( ) covers a very common case Brian Goetz in the first thread , explaining why Collections . parallelStream ( args ) is valuable enough to keep even after other parallel stream factory methods have been removed : # blockquote Brian Goetz stands by this position in the later discussion about Arrays . parallelStream ( args ) : # blockquote parallelStream ( ) is more performant Brian Goetz : # blockquote In response to Kevin Bourrillion ' s skepticism about whether the effect is significant , Brian again : # blockquote Doug Lea follows up , but hedges his position : # blockquote Indeed , the later discussion about Arrays . parallelStream ( args ) takes notice of lower Stream . parallel ( ) cost . stream ( ) . parallel ( ) statefulness complicates the future At the time of the discussion , switching a stream from sequential to parallel and back could be interleaved with other stream operations . Brian Goetz , on behalf of Doug Lea , explains why sequential / parallel mode switching may complicate future development of the Java platform : # blockquote This mode switching was removed after further discussion . In the current version of the library , a stream pipeline is either sequential or parallel ; last call to sequential ( args ) / parallel ( args ) wins . Besides side - stepping the statefulness problem , this change also improved the performance of using parallel ( args ) to set up a parallel pipeline from a sequential stream factory . exposing parallelStream ( ) as a first - class citizen improves programmer perception of the library , leading them to write better code Brian Goetz again , in response to Tim Peierls ' s argument that Stream . parallel ( args ) allows programmers to understand streams sequentially before going parallel : # blockquote

Question - 7488643 , answer - 7488669 Two steps : # li String [ ] items = commaSeparated . split ( args ) ; # li List < T > container = Arrays . asList ( args ) ;

Question - 29229373 I have the following sample code : # pre The output is as follows : # pre From here I see that in first case stream really behaves lazily - we use findFirst ( args ) so once we have first element our filtering lambda is not invoked . However , in second case which uses flatMaps we see that despite first element which fulfils the filter condition is found ( it ' s just any first element as lambda always returns true ) further contents of the stream are still being fed through filtering function . I am trying to understand why it behaves like this rather than giving up after first element is calculated as in the first case . Any helpful information would be appreciated .

Question - 10827872 What ' s the difference between java . lang . String ' s replace ( args ) and replaceAll ( args ) methods , other than later uses regex ? For simple substitutions like , replace . with / , is there any difference ?

Question - 4818699 , answer - 4818916 The primary use of AtomicInteger is when you are in a multithreaded context and you need to perform thread safe operations on an integer without using synchronized . The assignation and retrieval on the primitive type int are already atomic but AtomicInteger comes with many operations which are not atomic on int . The simplest are the getAndXXX or xXXAndGet . For instance getAndIncrement ( args ) is an atomic equivalent to i + + which is not atomic because it is actually a short cut for three operations : retrieval , addition and assignation . compareAndSet is very useful to implements semaphores , locks , latches , etc . Using the AtomicInteger is faster and more readable than performing the same using synchronization . A simple test : # pre On my PC with Java 1 . 6 the atomic test runs in 3 seconds while the synchronized one runs in about 5 . 5 seconds . The problem here is that the operation to synchronize ( notAtomic + + ) is really short . So the cost of the synchronization is really important compared to the operation . Beside atomicity AtomicInteger can be use as a mutable version of Integer for instance in Map s as values .

Question - 8894258 , answer - 8894384 This is just micro - optimisation that you shouldn ' t worry about . char [ ] chars = str . toCharArray ( args ) ; returns you a copy of str character arrays ( in JDK , it returns a copy of characters by calling System . arrayCopy ) . Other than that , str . charAt ( args ) only checks if the index is indeed in bounds and returns a character within the array index . The first one doesn ' t create additional memory in JVM .

Question - 6470651 , answer - 6780439 Here ' s a simple / sinister one via # a . # pre Because the substring refers to the internal representation of the original , much longer string , the original stays in memory . Thus , as long as you have a StringLeaker in play , you have the whole original string in memory , too , even though you might think you ' re just holding on to a single - character string . The way to avoid storing an unwanted reference to the original string is to do something like this : # pre For added badness , you might also . intern ( args ) the substring : # pre Doing so will keep both the original long string and the derived substring in memory even after the StringLeaker instance has been discarded .

Question - 31965179 , answer - 35427268 There ' s a long list of things that have been changed in Hibernate 5 : # li New bootstrap API so we can bootstrap a JPA environment programmatically without the need of a persistence . xml file . # li Starting in 5 . 0 Hibernate Spatial is part of the Hibernate project so we can handle GIS data too . # li The Java 8 Date and Time types are supported in domain model mappings . The mapping between the standard SQL Date / Time types and the supported Java 8 Date / Time class types looks as follows ; # li DATE : java . time . LocalDate # li TIME : java . time . LocalTime , java . time . OffsetTime # li TIMESTAMP : java . time . Instant , java . time . LocalDateTime , java . time . OffsetDateTime and java . time . ZonedDateTime # li The bytecode enhancement mechanism was redesigned from scratch , and Hibernate features both a Maven and a Gradle plugin . There are three main aspects which we can enhance with bytecode instrumentation : # li Lazy initialization : Fields can be declared as LAZY and they will be fetched only when being accessed for the first time . # li Dirty checking : Entities are enhanced so that they can keep track of all the properties that get changed after being loaded in a Persistence Context . # li Bidirectional associations : It ' s possible to synchronize both sides of a bidirectional association automatically , even if the developer only updates a single side . # li Hibernate ' s native APIs ( Session , etc ) have been updated to use generic typed . No need to cast when fetching entities . # li Hibernate 5 . 0 expends this to a broader set of types ( e . g . UUID ) . # li Second - level cache by reference . This feature enables direct storage of entity references into the second level cache for immutable entities . # li Starting with Hibernate 5 . 0 , we have a completely new User Guide that was written from scratch .

Question - 6667243 , answer - 6667354 Enum is just a little bit special class . Enums can store additional fields , implement methods etc . For example # pre Now you can say : System . out . println ( args ) and see output : a

Question - 16252269 , answer - 29652714 You can use Collections . sort ( args ) to sort list if your list contains Comparable elements . Otherwise I would recommend you to implement that interface like here : public class Circle implements Comparable < T > { } and of course provide your own realization of compareTo method like here : # pre And then you can again use Colection . sort ( args ) as now list contains objects of Comparable type and can be sorted . Order depends on compareTo method . Check this # a for more detailed information .

Question - 32623834 , answer - 32624143 You just changed the String of String constant pool Mario to Luigi which was referenced by multiple String s , so every referencing literal Mario is now Luigi . Field stringValue = String . class . getDeclaredField ( args ) ; You have fetched the char [ ] named value field from class String stringValue . setAccessible ( args ) ; Make it accessible . stringValue . set ( args ) ; You changed original String field to Luigi . But original is Mario the String literal and literal belongs to the String pool and all are interned . Which means all the literals which has same content refers to the same memory address . # pre Basically you have changed the Mario of String pool which got reflected in all the referencing fields . If you create String Object ( i . e . new String ( args ) ) instead of literal you will not face this behavior because than you will have two different Mario s .

Question - 32859038 I have a List < T > collection . I need to convert it into Map < T > The key of the map must be the index of the item in the collection . I can not figure it out how to do this with streams . Something like : items . stream ( args ) . collect ( args ) ; Any help ? As this question is identified as possible duplicate I need to add that my concrete problem was - how to get the position of the item in the list and put it as a key value

Question - 4818699 , answer - 4818783 The absolute simplest example I can think of is to make incrementing an atomic operation . With standard ints : # pre With AtomicInteger : # pre The latter is a very simple way to perform simple mutations effects ( especially counting , or unique - indexing ) , without having to resort to synchronizing all access . More complex synchronization - free logic can be employed by using compareAndSet ( args ) as a type of optimistic locking - get the current value , compute result based on this , set this result iff value is still the input used to do the calculation , else start again - but the counting examples are very useful , and I ' ll often use AtomicIntegers for counting and VM - wide unique generators if there ' s any hint of multiple threads being involved , because they ' re so easy to work with I ' d almost consider it premature optimisation to use plain ints . While you can almost always achieve the same synchronization guarantees with ints and appropriate synchronized declarations , the beauty of AtomicInteger is that the thread - safety is built into the actual object itself , rather than you needing to worry about the possible interleavings , and monitors held , of every method that happens to access the int value . It ' s much harder to accidentally violate threadsafety when calling getAndIncrement ( args ) than when returning i + + and remembering ( or not ) to acquire the correct set of monitors beforehand .

Question - 29922296 , answer - 29922831 Three questions : three - part answer : Is it okay from a design point of view ? Absolutely . Nothing wrong with it . If you need to do lots of iterating over your enum , the stream API is the clean way to go and hiding the boiler plate behind a little method is fine . Although I ’ d consider OldCumudgeon ’ s version even better . Is it okay from a performance point of view ? It most likely doesn ’ t matter . Most of the time , enums are not that big . Therefore , whatever overhead there is for one method or the other probably doesn ’ t matter in 99 . 9 % of the cases . Of course , there are the 0 . 1 % where it does . In that case : measure properly , with your real - world data and consumers . If I had to bet , I ’ d expect the for each loop to be faster , since it maps more directly to the memory model , but don ’ t guess when talking performance , and don ’ t tune before there is actual need for tuning . Write your code in a way that is correct first , easy to read second and only then worry about performance of code style . Why aren ’ t Enums properly integrated into the Stream API ? If you compare Java ’ s Stream API to the equivalent in many other languages , it appears seriously limited . There are various pieces that are missing ( reusable Streams and Optionals as Streams , for example ) . On the other hand , implementing the Stream API was certainly a huge change for the API . It was postponed multiple times for a reason . So I guess Oracle wanted to limit the changes to the most important use cases . Enums aren ’ t used that much anyway . Sure , every project has a couple of them , but they ’ re nothing compared to the number of Lists and other Collections . Even when you have an Enum , in many cases you won ’ t ever iterate over it . Lists and Sets , on the other hand , are probably iterated over almost every time . I assume that these were the reasons why the Enums didn ’ t get their own adapter to the Stream world . We ’ ll see whether more of this gets added in future versions . And until then you always can use Arrays . stream .

Question - 13291076 , answer - 13291109 It really depends on what you want to do with the returned value : # li If you need to get the exact name used to declare the enum constant , you should use name ( args ) as toString may have been overriden # li If you want to print the enum constant in a user friendly way , you should use toString which may have been overriden ( or not ! ) . When I feel that it might be confusing , I provide a more specific getXXX method , for example : # pre

Question - 6094575 , answer - 6094600 You can use Class . forName ( ) to get a Class object of the desired class . Then use getConstructor ( ) to find the desired Constructor object . Finally , call newInstance ( ) on that object to get your new instance . # pre

Question - 32676771 , answer - 32677400 Despite of the fact that there is no AtomicDouble or AtomicDoubleArray in java , you can easily create your own based on AtomicLongArray . # pre As you can see , I use Double . doubleToLongBits and Double . longBitsToDouble to store Doubles as Longs in AtomicLongArray . They both have the same size in bits , so precision is not lost ( except for - NaN , but I don ' t think it is important ) . In Java 8 the implementation of add can be even easier , as you can use accumulateAndGet method of AtomicLongArray that was added in java 1 . 8 . Upd : It appears that I virtually re - implemented guava ' s AtomicDoubleArray .

Question - 5263187 , answer - 5263201 System . out . println ( args ) ;

Question - 5778658 , answer - 10768914 You will need an intermediate class which will buffer between . Each time InputStream . read ( args ) is called , the buffering class will fill the passed in byte array with the next chunk passed in from OutputStream . write ( args ) . Since the sizes of the chunks may not be the same , the adapter class will need to store a certain amount until it has enough to fill the read buffer and / or be able to store up any buffer overflow . This article has a nice breakdown of a few different approaches to this problem : # a

Question - 16635398 Which of the following is better practice in Java 8 ? Java 8 : joins . forEach ( args ) ; Java 7 : # pre I have lots of for loops that could be " simplified " with lambdas , but is there really any advantage of using them including performance and readability ? EDIT I ' ll also extend this question to longer methods - I know that you cant return or break the parent function from a lambda and this should be mentioned to if they are compared , but is there anything else to be considered ?

Question - 23674624 I ' m looking at the docs for the IntStream , and I see an toArray method , but no way to go directly to a List < T > Surely there is a way to convert a Stream to a List ?

Question - 6416706 , answer - 6416800 With Guava you can use Lists . newArrayList ( Iterable ) or Sets . newHashSet ( Iterable ) , among other similar methods . This will of course copy all the elements in to memory . If that isn ' t acceptable , I think your code that works with these ought to take Iterable rather than Collection . Guava also happens to provide convenient methods for doing things you can do on a Collection using an Iterable ( such as Iterables . isEmpty ( args ) or Iterables . contains ( args ) ) , but the performance implications are more obvious .

Question - 9481865 , answer - 9481939 You can use java . net . InetAddress API . Try this : InetAddress . getLocalHost ( args ) . getHostAddress ( args ) ;

Question - 22463062 , answer - 22463063 Parsing date and time To create a LocalDateTime object from a string you can use the static LocalDateTime . parse ( ) method . It takes a string and a DateTimeFormatter as parameter . The DateTimeFormatter is used to specify the date / time pattern . # pre Formatting date and time To create a formatted string out a LocalDateTime object you can use the format ( args ) method . # pre Note that there are some commonly used date / time formats predefined as constants in DateTimeFormatter . For example : Using DateTimeFormatter . ISO _ DATE _ TIME to format the LocalDateTime instance from above would result in the string StringLiteral . The parse ( args ) and format ( args ) methods are available for all date / time related objects ( e . g . LocalDate or ZonedDateTime )

Question - 29691513 , answer - 29727412 The JLS describes a few special behaviors of what it calls constant variables , which are final variables ( whether static or not ) which are initialized with constant expressions of String or primitive type . Constant variables have a major difference with respect to binary compatibility : the values of constant variables become part of the class ' s API , as far as the compiler is concerned . An example : # pre Here , XFOO is a " constant variable " and YFOO is not , but they are otherwise equivalent . Class Z prints out each of them . Compile those classes , then disassemble them with javap - v X Y Z , and here is the output : Class X : # pre Class Y : # pre Class Z : # pre Things to notice in the disassembly , which tell you the differences between X and Y run deeper than syntactic sugar : # li XFOO has a ConstantValue attribute , signifying that its value is a compile - time constant . Whereas YFOO does not , and uses a static block with a putstatic instruction to initialize the value at runtime . # li The String constant StringLiteral has become part of class Z ' s constant pool , but StringLiteral has not . # li Z . main uses the ldc ( load constant ) instruction to load StringLiteral onto the stack directly from its own constant pool , but it uses a getstatic instruction to load the value of Y . YFOO . Other differences you will find : # li If you change the value of XFOO and recompile X . java but not Z . java , you have a problem : class Z is still using the old value . If you change the value of YFOO and recompile Y . java , class Z uses the new value whether you recompile Z . java or not . # li If you delete the X . class file entirely , class Z still runs correctly . Z has no runtime dependency on X . Whereas if you delete the Y . class file , class Z fails to initialize with a ClassNotFoundException : Y . # li If you generate documentation for the classes with javadoc , the " Constant Field Values " page will document the value of XFOO , but not the value of YFOO . The JLS describes the above effects constant variables have on compiled class files in § 13 . 1 . 3 : # blockquote And in § 13 . 4 . 9 : # blockquote The upshot is that if your public library exposes any constant variables , you must never change their values if your new library version is otherwise supposed to be compatible with code compiled against old versions of the library . It won ' t necessarily cause an error , but the existing code will probably malfunction since it will have outdated ideas about the values of constants . ( If your new library version needs for classes which use it to be recompiled anyway , then changing constants doesn ' t cause this problem . ) Thus , initializing a constant with a block gives you more freedom to change its value , because it prevents the compiler embedding the value into other classes .

Question - 32323081 , answer - 32323305 Any lambda which could be accepted as a Supplier < T > can also be accepted as a ThrowingSupplier < T > . The following compiles : # pre Given the above , you probably don ' t need this , but if foo must accept a non - throwing Supplier < T > , you can always wrap the Exception - throwing method in a method which launders it into an unchecked Exception : # pre

Question - 4812570 How can I get the e . printStackTrace ( args ) and store it into a String variable ? I want to use the string generated by e . printStackTrace ( args ) later in my program . I ' m still new to Java so I ' m not too familiar with StringWriter that I think will be the solution . Or if you have any other ideas please let me know . Thanks

Question - 31370403 I ' m currently in the process of writing a paint program in java , designed to have flexible and comprehensive functionalities . It stemmed from my final project , that I wrote overnight the day before . Because of that , it ' s got tons and tons of bugs , which I ' ve been tackling one by one ( e . g . I can only save files that will be empty , my rectangles don ' t draw right but my circles do . . . ) . This time , I ' ve been trying to add undo / redo functionality to my program . However , I can ' t " undo " something that I have done . Therefore , I got an idea to save copies of my BufferedImage each time a mouseReleased event was fired . However , with some of the images going to 1920x1080 resolution , I figured that this wouldn ' t be efficient : storing them would probably take gigabytes of memory . The reason for why I can ' t simply paint the same thing with the background colour to undo is because I have many different brushes , which paint based on Math . random ( args ) , and because there are many different layers ( in a single layer ) . Then , I ' ve considered cloning the Graphics objects that I use to paint to the BufferedImage . Like this : # pre I haven ' t done this before , so I have a couple questions : # li Would I still be wasting pointless memory by doing this , like cloning my BufferedImages ? # li Is there necessarily a different way I can do this ?

Question - 5982447 , answer - 5982478 Use the Set # toArray ( T [ ] ) method taking a typed array argument of the same size . String [ ] GPXFILES1 = myset . toArray ( args ) ; A different size can also , but that would force the toArray ( args ) method to create a new array to return instead of reusing the provided argument , which may end up to be less efficient . See also the source code of AbstractCollection # toArray ( ) .

Question - 12552863 , answer - 32302353 To concur with earlier comments : simplest is ( 2 ) to use Closeable resources and declare them in order in the try - with - resources clause . If you only have AutoCloseable , you can wrap them in another ( nested ) class that just checks that close is only called once ( Facade Pattern ) , e . g . by having private bool isClosed ; . In practice even Oracle just ( 1 ) chains the constructors and doesn ' t correctly handle exceptions partway through the chain . Alternatively , you can manually create a chained resource , using a static factory method ; this encapsulates the chain , and handle cleanup if it fails part - way : # pre The complexity comes from handling multiple exceptions ; otherwise it ' s just " close resources that you ' ve acquired so far " . A common practice seems to be to first initialize the variable that holds the object that holds the resource to null ( here fileWriter ) , and then include a null check in the cleanup , but that seems unnecessary : if the constructor fails , there ' s nothing to clean up , so we can just let that exception propagate , which simplifies the code a little . You could probably do this generically : # pre

Question - 7935858 , answer - 7935881 The documentation on split ( ) says : # blockquote ( Emphasis mine . ) A dot is a special character in regular expression syntax . Use Pattern . quote ( ) on the parameter to split ( ) if you want the split to be on a literal string pattern : String [ ] words = temp . split ( args ) ;

Question - 19757300 , answer - 35512247 Keeping this issue in mind I developed a small library for dealing with checked exceptions and lambdas . Custom adapters allow you to integrate with existing functional types : stream ( args ) . map ( args ) / / with a static import # a

Question - 22501230 , answer - 22511214 I don ' t like any of the solutions presented except for JAB ' s . None of the others make it easy to read the code and understand what is being computed . Here ' s how I would write this code - - I only know C # , not Java , but you get the picture : # pre Now it is much more clear what is being computed here : this emphasizes that we are computing who gets hit by what attack , and returning both results . However this could be even better ; that Boolean array is somewhat opaque . I like the table lookup approach but I would be inclined to write it in such a way that made it clear what the intended game semantics were . That is , rather than " an attack of zero and a defense of one results in no hit " , instead find a way to make the code more clearly imply " a low kick attack and a low block defense results in no hit " . Make the code reflect the business logic of the game .

Question - 15940234 I ' m relative new to the webservices world and my research seems to have confused me more than enlighten me , my problem is that I was given a library ( jar ) which I have to extend with some webservice functionality . This library will be shared to other developers , and among the classes in the jar will be classes that have a method which calls a webservice ( that essentially sets an attribute of the class , does some business logic , like storing the object in a db , etc and sends back the object with those modifications ) . I want to make the call to this service as simple as possible , hopefully as simple so that the developer using the class only need to do . # pre I have been studying JAX - WS to use on the server but seems to me that I don ' t need to create a wsimport in the server nor the wsimport on the client , since I know that both have the classes , I just need some interaction between classes shared in both the server and the client . How do you think makes sense to do the webservice and the call in the class ?

Question - 32356762 Is there a good reason that the Collections . list ( ) method in the java . utils package returns an ArrayList < T > instead of List < T > ? Obviously an ArrayList is a List , but I ' m under the impression that it ' s generally good practice to return the interface type instead of implementation type .

Question - 28276423 , answer - 28276497 No , the topmost level Stream or reader will ensure that all underlying streams / readers are closed . Check the close ( args ) method implementation of your topmost level stream .

Question - 26548660 , answer - 26548894 You can use a Callback to get onSuccess and onError events . Just add a new Callback to your request like so : Picasso . with ( args ) . load ( args ) . into ( args ) ; Then you can perform any alterations and modifications in the onSuccess callback .

Question - 23079003 , answer - 23079174 You can use the overloaded version of toArray , as the following : # pre The purpose of the IntFunction < T > generator is to convert an integer , the size of the array , to a new array . Example code : # pre Prints : # pre Another option is to use a method reference to the string array constructor , this one is a bit more tricky . Usage is easy : String [ ] stringArray = streamString . toArray ( args ) ; What it does , is find a method that takes in an integer ( the size ) as argument , and returns a String [ ] , which is exactly what ( one of the overloads of ) new String [ ] does .

Question - 10786042 , answer - 25735202 You need to first create a URI like : # pre Then convert that Uri to ASCII string : urlStr = uri . toASCIIString ( args ) ; Now your url string is completely encoded first we did simple url encoding and then we converted it to ASCII String to make sure no character outside US - ASCII are remaining in string . This is exactly how browsers do .

Question - 29140402 , answer - 36771568 In Eclipse , Go to your class , Right click - > source - > Generate toString ( ) ; It will override the toString ( ) method and print the object of that class .

Question - 28818506 , answer - 32653133 This is looks like a good fit for pattern matching and a more traditional Option interface with Some and None implementations ( such as those in Javaslang , FunctionalJava ) or a lazy Maybe implementation in cyclops - react . I ' m the author of this library . With cyclops - react you can also use structural pattern matching on JDK types . For Optional you can match on the present and absent cases via the visitor pattern . it would look something like this - # pre

Question - 8725387 , answer - 8727998 Another point is the time complexity of insert operations . For a list insert , one expects a complexity of O ( 1 ) . But this could not be guaranteed with a sorted list . And the most important point is that lists assume nothing about their elements . For example , you can make lists of things that do not implement equals or compare .

Question - 18410035 Being somewhat new to the Java language I ' m trying to familiarize myself with all the ways ( or at least the non - pathological ones ) that one might iterate through a list ( or perhaps other collections ) and the advantages or disadvantages of each . Given a List < T > list object , I know of the following ways to loop through all elements : Basic for loop ( of course , there ' re equivalent while / do while loops as well ) # pre Note : As @ amarseillan pointed out , this form is a poor choice for iterating over List s because the actual implementation of the get method may not be as efficient as when using an Iterator . For example , LinkedList implementations must traverse all of the elements preceding i to get the i - th element . In the above example there ' s no way for the List implementation to " save its place " to make future iterations more efficient . For an ArrayList it doesn ' t really matter because the complexity / cost of get is constant time ( O ( 1 ) ) whereas for a LinkedList is it proportional to the size of the list ( O ( n ) ) . For more information about the computational complexity of the built - in Collections implementations , check out this question . Enhanced for loop ( nicely explained in this question ) # pre Iterator # pre EDIT : Added ListIterator ListIterator # pre EDIT : Added " functional - style " solution ( thanks Dave Newton ) Functional Java list . stream ( args ) . map ( args ) ; / / can apply a transformation function for e EDIT : Added map method from Java 8 ' s Stream API ( see @ i _ am _ zero ' s answer ) Iterable . forEach , Stream . forEach , . . . In Java 8 collection classes that implement Iterable ( for example all List s ) now have a forEach method , which can be used instead of the for loop statement demonstrated above . ( Here is another question that provides a good comparison . ) # pre What other ways are there , if any ? I feel like this has got to be a duplicate , but I haven ' t been able to find what I ' m looking for , so I apologize for this question potentially being redundant . ( BTW , my interest does not stem at all from a desire to optimize performance ; I just want to know what forms are available to me as a developer . ) EDIT : Moved ListIterationExample . java to a suggested answer

Question - 28319064 , answer - 28319148 I prefer the second way . When you use the first way , if you decide to use a parallel stream to improve performance , you ' ll have no control over the order in which the elements will be added to the output list by forEach . When you use toList , the Streams API will preserve the order even if you use a parallel stream .

Question - 29922296 , answer - 29923793 I think the shortest code to get a Stream of enum constants is Stream . of ( args ) . It ' s not as nice as Letter . values ( args ) . stream ( args ) but that ' s an issue with arrays , not specifically enums . # blockquote You are right that the nicest possible call would be Letter . stream ( args ) . Unfortunately a class cannot have two methods with the same signature , so it would not be possible to implicitly add a static method stream ( args ) to every enum ( in the same way that every enum has an implicitly added static method values ( args ) ) as this would break every existing enum that already has a static or instance method without parameters called stream ( args ) . # blockquote I think so . The drawback is that stream is a static method , so there is no way to avoid code duplication ; it would have to be added to every enum separately .

Question - 16635398 , answer - 20177092 The better practice is to use for - each . Besides violating the Keep It Simple , Stupid principle , the new - fangled forEach ( args ) has at least the following deficiencies : # li Can ' t use non - final variables . So , code like the following can ' t be turned into a forEach lambda : # blockquote # li Can ' t handle checked exceptions . Lambdas aren ' t actually forbidden from throwing checked exceptions , but common functional interfaces like Consumer don ' t declare any . Therefore , any code that throws checked exceptions must wrap them in try - catch or Throwables . propagate ( args ) . But even if you do that , it ' s not always clear what happens to the thrown exception . It could get swallowed somewhere in the guts of forEach ( args ) # li Limited flow - control . A return in a lambda equals a continue in a for - each , but there is no equivalent to a break . It ' s also difficult to do things like return values , short circuit , or set flags ( which would have alleviated things a bit , if it wasn ' t a violation of the no non - final variables rule ) . " This is not just an optimization , but critical when you consider that some sequences ( like reading the lines in a file ) may have side - effects , or you may have an infinite sequence . " # li Might execute in parallel , which is a horrible , horrible thing for all but the 0 . 1 % of your code that needs to be optimized . Any parallel code has to be thought through ( even if it doesn ' t use locks , volatiles , and other particularly nasty aspects of traditional multi - threaded execution ) . Any bug will be tough to find . # li Might hurt performance , because the JIT can ' t optimize forEach ( ) + lambda to the same extent as plain loops , especially now that lambdas are new . By " optimization " I do not mean the overhead of calling lambdas ( which is small ) , but to the sophisticated analysis and transformation that the modern JIT compiler performs on running code . # li If you do need parallelism , it is probably much faster and not much more difficult to use an ExecutorService . Streams are both automagical ( read : don ' t know much about your problem ) and use a specialized ( read : inefficient for the general case ) parallelization strategy ( fork - join recursive decomposition ) . # li Makes debugging more confusing , because of the nested call hierarchy and , god forbid , parallel execution . The debugger may have issues displaying variables from the surrounding code , and things like step - through may not work as expected . # li Streams in general are more difficult to code , read , and debug . Actually , this is true of complex " fluent " APIs in general . The combination of complex single statements , heavy use of generics , and lack of intermediate variables conspire to produce confusing error messages and frustrate debugging . Instead of " this method doesn ' t have an overload for type X " you get an error message closer to " somewhere you messed up the types , but we don ' t know where or how . " Similarly , you can ' t step through and examine things in a debugger as easily as when the code is broken into multiple statements , and intermediate values are saved to variables . Finally , reading the code and understanding the types and behavior at each stage of execution may be non - trivial . # li Sticks out like a sore thumb . The Java language already has the for - each statement . Why replace it with a function call ? Why encourage hiding side - effects somewhere in expressions ? Why encourage unwieldy one - liners ? Mixing regular for - each and new forEach willy - nilly is bad style . Code should speak in idioms ( patterns that are quick to comprehend due to their repetition ) , and the fewer idioms are used the clearer the code is and less time is spent deciding which idiom to use ( a big time - drain for perfectionists like myself ! ) . As you can see , I ' m not a big fan of the forEach ( ) except in cases when it makes sense . Particularly offensive to me is the fact that Stream does not implement Iterable ( despite actually having method iterator ) and cannot be used in a for - each , only with a forEach ( ) . I recommend casting Streams into Iterables with ( Iterable < T > ) stream : : iterator . A better alternative is to use StreamEx which fixes a number of Stream API problems , including implementing Iterable . That said , forEach ( args ) is useful for the following : # li Atomically iterating over a synchronized list . Prior to this , a list generated with Collections . synchronizedList ( args ) was atomic with respect to things like get or set , but was not thread - safe when iterating . # li Parallel execution ( using an appropriate parallel stream ) . This saves you a few lines of code vs using an ExecutorService , if your problem matches the performance assumptions built into Streams and Spliterators . # li Specific containers which , like the synchronized list , benefit from being in control of iteration ( although this is largely theoretical unless people can bring up more examples ) # li Calling a single function more cleanly by using forEach ( args ) and a method reference argument ( ie , list . forEach ( args ) ) . However , keep in mind the points on checked exceptions , more difficult debugging , and reducing the number of idioms you use when writing code . Articles I used for reference : # li Everything about Java 8 # li Iteration Inside and Out ( as pointed out by another poster ) EDIT : Looks like some of the original proposals for lambdas ( such as # a ) solved some of the issues I mentioned ( while adding their own complications , of course ) .

Question - 24914525 , answer - 24914586 std : : list in C + + is a linked list , whereas java . util . ArrayList is an array . Try replacing std : : list by std : : vector . Also , be sure to compile with optimization turned on .

Question - 15655012 , answer - 15656208 This is favorite interview question . Interviewer tries to find out here , how much you understand about behavior of objects with respect to constructors , methods , class variables ( static variables ) , instance variables . # pre In above case we have defined Test constructor and setFoo method . About constructor : Constructor can be invoked only one time per object creation by using new keyword . Programmer cannot invoke constructor many times because constructor are designed so . About method : Method can be invoked as many time as programmer wants and compiler knows it programmer may invoke method zero or multiple time . Scenario 1 private final List foo ; / / 1 foo is an instance variable . When we create Test class ' object then instance variable foo will be copied inside object of Test class . If we assign foo inside constructor then compiler know that Constructor will be invoked only one time . so there is no problem to assign it inside constructor . If we assign foo inside method then compiler knows that method may be invoked multiple time . So value will have to be changed multiple time which is not allowed for final variable . You can assign value to the final variable only one time . So compiler decides constructor is good choice ! Scenario 2 private static final List foo = new ArrayList ( args ) ; foo is now static variable . When we create object of Test class then foo will not be copied to the object of Test class because foo is static . Now foo is not the property of each object . This is the property of Test class . But foo can be seen by many objects and if every object which is created by using new keyword which ultimately invoke Test constructor then value will be changed at the time of multiple object creation ( Remember static foo is not copied in every object now but is shared between multiple objects . ) Scenario 3 t . foo . add ( args ) ; / / Modification - 2 Above Modification - 2 is from your question . In above case you are not changing first referenced object but you are adding contents inside foo which is allowed . Compiler complains if you try to assign new ArrayList ( args ) object to the foo reference variable . Rule is that if you have initialized object to final reference variable then you cannot change it to refer different ArrayList object . ( in this case ArrayList ) final class cannot be subclassed final methods cannot be overridden . ( This method is in superclass ) final methods can override . ( Read this in grammatical way . This method is in subclass )

Question - 26684562 In Java 8 , what ' s the difference between Stream . map and Stream . flatMap methods ?

Question - 29095967 , answer - 29098447 The solution is to use Stream . collect . To create a Collector using its builder pattern is already given as solution . The alternative is the other overloaded collect being a tiny bit more primitive . # pre As one sees , I make a list of string lists , where there always is at least one last ( empty ) string list . # li The first function creates a starting list of string lists . It specifies the result ( typed ) object . # li The second function is called to process each element . It is an action on the partial result and an element . # li The third is not really used , it comes into play on parallelising the processing , when partial results must be combined . A solution with an accumulator : As @ StuartMarks points out , the combiner does not fullfill the contract for parallelism . Due to the comment of @ ArnaudDenoyelle a version using reduce . # pre # li The first parameter is the accumulated object . # li The second function accumulates . # li The third is the aforementioned combiner .

Question - 17489250 , answer - 17489376 String gets special treatment in the JLS : it ' s one of the two non - primitive types for which literals exist ( the other is Class ) * . From the JLS : # blockquote * well , there ' s also the " null type " with it ' s " null literal " null , but most people don ' t think of the " null type " as a proper type .

Question - 22036885 , answer - 22037068 As said in API # blockquote It ' s because of cannot represent double value exactly . So you have to use BigDecimal bigDecimal = BigDecimal . valueOf ( args ) ; instead of BigDecimal bigDecimal = new BigDecimal ( args ) ;

Question - 27504925 , answer - 27505121 I ' d like to point out this article . It seems as though arrays and objects follow different opcodes . I can ' t honestly summarize it more than that however it seems , arrays are simply not treated as Objects like we ' re normally used to so they don ' t inherit Object methods . Full credits to the author of that post as it ' s a very interesting read , both short & detailed . Upon further digging into the topic via multiple sources I ' ve decided to give a more elaborate version of my previous answer . The first thing to note that instantiation of Objects and Arrays are very different within the JVM , their follow their respective bytecode . Object : Object instantiation follows a simple Opcode new which is a combination of two operands - indexbyte1 & indexbyte2 . Once instantiated the JVM pushes the reference to this object onto the stack . This occurs for all objects irrespective of their types . Arrays : Array Opcodes ( regarding instantiation of an array ) however are divided into three different codes . # blockquote newarray opcode is used when creating arrays that involve primitive datatypes ( byte short char int long float double boolean ) rather than object references . # blockquote anewarray opcode is used when creating arrays of object references # blockquote multianewarray instruction is used when allocating multi - dimensional arrays Object can be a class instance or an array . Take from Oracle Docs # blockquote BUT # blockquote This goes hand in hand with the information regarding the opcodes . Arrays are simply not developed to be class interfaces but are instead explicitly created by array creation expression thus naturally wouldn ' t implicitly be able to inherit and / or override Object . As we have seen , it has nothing to do with the fact that arrays may hold primitive datatypes . After giving it some thought though , it isn ' t very common to come across situations where one might want to toString ( args ) or equals ( args ) however was still a very interesting question to try and answer . Resources : Oracle - Docs chapter 4 . 3 . 1 Oracle - Docs chapter 15 . 10 . 1 Artima - UnderTheHood

Question - 7707556 , answer - 15870428 There is a subtle issue here that is a bit of a gotcha . The toString ( args ) method has a base implementation in Object . CharSequence is an interface ; and although the toString ( args ) method appears as part of that interface , there is nothing at compile - time that will force you to override it and honor the additional constraints that the CharSequence toString ( args ) method ' s javadoc puts on the toString ( args ) method ; ie that it should return a string containing the characters in the order returned by charAt ( args ) . Your IDE won ' t even help you out by reminding that you that you probably should override toString ( args ) . For example , in intellij , this is what you ' ll see if you create a new CharSequence implementation : # a . Note the absence of toString ( args ) . If you rely on toString ( args ) on an arbitrary CharSequence , it should work provided the CharSequence implementer did their job properly . But if you want to avoid any uncertainty altogether , you should use a StringBuilder and append ( args ) , like so : # pre

Question - 32475166 , answer - 32475290 The chief difference is that an if else block is a statement whereas the ternary ( more often known as the conditional operator in Java ) is an expression . A statement can do things like return to the caller on some of the control paths . An expression can be used in an assignment : int n = condition ? 3 : 2 ; So the two expressions in the ternary after the condition need to be coercable to the same type . This can cause some odd effects in Java particularly with auto - boxing and automatic reference casting - this is what the comment in your posted code is referring to . The coercion of the expressions in your case would be to a java . lang . reflect . Executable type ( as that ' s the most specialised type ) and that does not exist in older versions of Java . Stylistically you should use an if else block if the code is statement - like , and a ternary if it ' s expression - like . Of course , you can make an if else block behave like an expression if you use a lambda function .

Question - 21163108 , answer - 34930831 To measure the actual number of used threads , you can check Thread . activeCount ( args ) : # pre This can produce on a 4 - core CPU an output like : # pre Without . parallel ( args ) it gives : # pre

Question - 17781150 , answer - 17781189 The only int value for which it works is Integer . MIN _ VALUE . It ' s because integers are negated using the two ' s complement way . Using System . out . println ( args ) ; you see that Integer . MIN _ VALUE is 10000000000000000000000000000000 Taking the negative value is done by first swapping 0 and 1 , which gives 01111111111111111111111111111111 and by adding 1 , which gives 10000000000000000000000000000000 As you can see in the link I gave , Wikipedia mentions the problem with the most negative numbers and specifies it ' s the sole exception : # blockquote Of course you have the same phenomenon for Long . Min _ Value if you store it in a long variable . Note that this is only due to choices that were made regarding the binary storage of ints in Java . Another ( bad ) solution could for example have been to negate by simply changing the most significant bit and letting the other bits unchanged , this would have avoided this problem with MIN _ VALUE but would have made 2 different 0 values and complicated binary arithmetic ( how would you have incremented for example ? ) .

Question - 13195797 I want to delete all files inside ABC directory . When I tried with FileUtils . deleteDirectory ( args ) ; it also deletes folder ABC . Is there a one liner solution where I can delete files inside directory but not directory ?

Question - 8172420 , answer - 32174377 We have various ways to convert a char to String . One way is to make use of static method toString ( args ) in Character class : # pre Actually this toString method internally makes use of valueOf method from String class which makes use of char array : # pre So second way is to use this directly : String str2 = String . valueOf ( args ) ; This valueOf method in String class makes use of char array : # pre So the third way is to make use of an anonymous array to wrap a single character and then passing it to String constructor : String str4 = new String ( args ) ; The fourth way is to make use of concatenation : String str3 = StringLiteral + ch ; This will actually make use of append method from StringBuilder class which is actually preferred when we are doing concatenation in a loop .

Question - 7032070 , answer - 7032180 The clear ( args ) method removes all the elements of a single ArrayList . It ' s a fast operation , as it just sets some array elements to null . The removeAll ( args ) method , which is inherited from AbstractCollection , removes all the elements that are in the argument collection from the collection you call the method on . It ' s a relatively slow operation , as it has to search through one of the collections involved .

Question - 9324933 I looked at the default Zip library that comes with the JDK and the Apache compression libs and I am unhappy with them for 3 reasons : # li They are bloated and have bad API design . I have to write 50 lines of boiler plate byte array output , zip input , file out streams and close relevant streams and catch exceptions and move byte buffers on my own ? Why can ' t I have a simple API that looks like this Zipper . unzip ( args ) and Zipper . zip ( args ) that just works ? # li It seems zipping unzipping destroys file meta - data and password handling is broken . # li Also , all the libraries I tried were 2 - 3x slow compared to the command line zip tools I get with UNIX ? For me ( 2 ) and ( 3 ) are minor points but I really want a good tested library with a one - line interface .

Question - 6608795 , answer - 22327270 I tried reading from input1 . txt which was inside one of my packages together with the class which was trying to read it . The following works : # pre The most important part was to call getPath ( args ) if you want the correct path name in String format . DO NOT USE toString ( args ) because it will add some extra formatting text which will TOTALLY MESS UP the fileName ( you can try it and see the print out ) . Spent 2 hours debugging this . . . : (

Question - 6470651 , answer - 6540248 Below there will be a non - obvious case where Java leaks , besides the standard case of forgotten listeners , static references , bogus / modifiable keys in hashmaps , or just threads stuck without any chance to end their life - cycle . # li File . deleteOnExit ( args ) - always leaks the string , if the string is a substring , the leak is even worse ( the underlying char [ ] is also leaked ) - in Java 7 substring also copies the char [ ] , so the later doesn ' t apply ; @ Daniel , no needs for votes , though . I ' ll concentrate on threads to show the danger of unmanaged threads mostly , don ' t wish to even touch swing . # li Runtime . addShutdownHook and not remove . . . and then even with removeShutdownHook due to a bug in ThreadGroup class regarding unstarted threads it may not get collected , effectively leak the ThreadGroup . JGroup has the leak in GossipRouter . # li Creating , but not starting , a Thread goes into the same category as above . # li Creating a thread inherits the ContextClassLoader and AccessControlContext , plus the ThreadGroup and any InheritedThreadLocal , all those references are potential leaks , along with the entire classes loaded by the classloader and all static references , and ja - ja . The effect is especially visible with the entire j . u . c . Executor framework that features a super simple ThreadFactory interface , yet most developers have no clue of the lurking danger . Also a lot of libraries do start threads upon request ( way too many industry popular libraries ) . # li ThreadLocal caches ; those are evil in many cases . I am sure everyone has seen quite a bit of simple caches based on ThreadLocal , well the bad news : if the thread keeps going more than expected the life the context ClassLoader , it is a pure nice little leak . Do not use ThreadLocal caches unless really needed . # li Calling ThreadGroup . destroy ( args ) when the ThreadGroup has no threads itself , but it still keeps child ThreadGroups . A bad leak that will prevent the ThreadGroup to remove from its parent , but all the children become un - enumerateable . # li Using WeakHashMap and the value ( in ) directly references the key . This is a hard one to find without a heap dump . That applies to all extended Weak / SoftReference that might keep a hard reference back to the guarded object . # li Using java . net . URL with the HTTP ( S ) protocol and loading the resource from ( ! ) . This one is special , the KeepAliveCache creates a new thread in the system ThreadGroup which leaks the current thread ' s context classloader . The thread is created upon the first request when no alive thread exists , so either you may get lucky or just leak . The leak is already fixed in Java 7 and the code that creates thread properly removes the context classloader . There are few more cases ( like ImageFetcher , also fixed ) of creating similar threads . # li Using InflaterInputStream passing new java . util . zip . Inflater ( args ) in the constructor ( PNGImageDecoder for instance ) and not calling end ( args ) of the inflater . Well , if you pass in the constructor with just new , no chance . . . And yes , calling close ( args ) on the stream does not close the inflater if it ' s manually passed as constructor parameter . This is not a true leak since it ' d be released by the finalizer . . . when it deems it necessary . Till that moment it eats native memory so badly it can cause Linux oom _ killer to kill the process with impunity . The main issue is that finalization in Java is very unreliable and G1 made it worse till 7 . 0 . 2 . Moral of the story : release native resources as soon as you can ; the finalizer is just too poor . # li The same case with java . util . zip . Deflater . This one is far worse since Deflater is memory hungry in Java , i . e . always uses 15 bits ( max ) and 8 memory levels ( 9 is max ) allocating several hundreds KB of native memory . Fortunately , Deflater is not widely used and to my knowledge JDK contains no misuses . Always call end ( args ) if you manually create a Deflater or Inflater . The best part of the last two : you can ' t find them via normal profiling tools available . ( I can add some more time wasters I have encountered upon request . ) Good luck and stay safe ; leaks are evil !

Question - 5585779 , answer - 5585876 For example , here are two ways : # pre There is a slight difference between these methods : # li valueOf returns a new or cached instance of java . lang . Integer # li parseInt returns primitive int . The same is for all cases : Short . valueOf / parseShort , Long . valueOf / parseLong , etc .

Question - 5585779 , answer - 36394016 Whenever there is the slightest possibility that the given String does not contain an Integer , you have to handle this special case . Sadly , the standard Java methods Integer : : parseInt and Integer : : valueOf throw a NumberFormatException to signal this special case . Thus , you have to use exceptions for flow control , which is generally considered bad coding style . In my opinion , this special case should be handled by returning an Optional < T > . Since Java does not offer such a method , I use the following wrapper : # pre Usage : # pre While this is still using exceptions for flow control internally , the usage code becomes very clean .

Question - 14491966 , answer - 14563808 It is very unlikely that random number generation performance would be an issue for any use - case you came up with unless accessing a single Random instance from multiple threads ( because Random is synchronized ) . However , if that really is the case and you need lots of random numbers fast , your solution is far too unreliable . Sometimes it gives good results , sometimes it gives horrible results ( based on the initial settings ) . If you want the same numbers that the Random class gives you , only faster , you could get rid of the synchronization in there : # pre I simply took the java . util . Random code and removed the synchronization which results in twice the performance compared to the original on my Oracle HotSpot JVM 7u9 . It is still slower than your QuickRandom , but it gives much more consistent results . To be precise , for the same seed values and single threaded applications , it gives the same pseudo - random numbers as the original Random class would . This code is based on the current java . util . Random in OpenJDK 7u which is licensed under GNU GPL v2 . EDIT 10 months later : I just discovered that you don ' t even have to use my code above to get an unsynchronized Random instance . There ' s one in the JDK , too ! Look at Java 7 ' s ThreadLocalRandom class . The code inside it is almost identical to my code above . The class is simply a local - thread - isolated Random version suitable for generating random numbers quickly . The only downside I can think of is that you can ' t set its seed manually . Example usage : Random random = ThreadLocalRandom . current ( args ) ;

Question - 32693704 , answer - 32752970 I will try to summarize three moreless reasonable versions which were proposed in comments . @ Holger says : # blockquote This is the most easy thing to test . Let ' s compile such program : # pre Run it with java - verbose : class HashMapTest . This will print the class loading events as they occur . With JDK 1 . 8 . 0 _ 60 I see more than 400 classes loaded : # pre As you can see , HashMap is loaded long before application code and Arrays is loaded only 14 classes after HashMap . The HashMap load is triggered by sun . reflect . Reflection initialization as it has HashMap static fields . The Arrays load is likely to be triggered by WeakHashMap load which actually has Arrays . fill in the clear ( args ) method . The WeakHashMap load is triggered by java . lang . ClassValue $ ClassValueMap which extends WeakHashMap . The ClassValueMap is present in every java . lang . Class instance . So to me seems that without Arrays class the JDK cannot be initialized at all . Also the Arrays static initializer is very short , it only initializes the assertion mechanism . This mechanism is used in many other classes ( including , for example , java . lang . Throwable which is loaded very early ) . No other static initialization steps are performed in java . util . Arrays . Thus @ Holger version seems incorrect to me . Here we also found very interesting thing . The WeakHashMap . clear ( args ) still uses Arrays . fill . It ' s interesting when it appeared there , but unfortunately this goes to prehistoric times ( it was already there in the very first public OpenJDK repository ) . Next , @ MarcoTopolnik says : # blockquote It was actually surprising for me that Arrays . fill is not directly intrinsified ( see intrinsic list generated by @ apangin ) . Seems that such loop can be recognized and vectorized by JVM without explicit intrinsic handling . So it ' s true that extra call can be not inlined in very specific cases ( for example if MaxInlineLevel limit is reached ) . On the other hand it ' s very rare situation and it ' s only a single call , it ' s not a call inside loop , and it ' s a static , not virtual / interface call , thus the performance improvement could be only marginal and only in some specific scenarios . Not the thing the JVM developers usually care . Also it should be noted that even C1 ' client ' compiler ( tier 1 - 3 ) is capable to inline Arrays . fill called , for example , in WeakHashMap . clear ( args ) , as inlining log ( - XX : + UnlockDiagnosticVMOptions - XX : + PrintCompilation - XX : + PrintInlining ) says : # pre Of course , it ' s also easily inlined by smart and powerful C2 ' server ' compiler . Thus I see no problems here . Seems that @ Marco version is incorrect either . Finally we have a couple of comments from @ StuartMarks ( who is JDK developer , thus some official voice ) : # blockquote Indeed the HashMap . clear ( args ) contained the loop many years , was replaced with Arrays . fill on Apr 10th , 2013 and stayed less one half - a - year until Sept 4th when the discussed commit was introduced . The discussed commit was actually a major rewrite of the HashMap internals to fix JDK - 8023463 issue . It was a long story about possibility to poison the HashMap with keys having duplicating hashcodes reducing HashMap search speed to linear making it vulnerable to DoS - attacks . The attempts to solve this were performed in JDK - 7 including some randomization of String hashCode . So seems that the HashMap implementation was forked from the earlier commit , developed independently , then merged into the master branch overwriting several changes introduced in - between . We may support this hypothesis performing a diff . Take the version where Arrays . fill was removed ( 2013 - 09 - 04 ) and compare it with previous version ( 2013 - 07 - 30 ) . The diff - U0 output has 4341 lines . Now let ' s diff against the version prior to one when Arrays . fill was added ( 2013 - 04 - 01 ) . Now diff - U0 contains only 2680 lines . Thus the newer version actually more similar to the older than to immediate parent . Conclusion So to conclude I would agree with Stuart Marks . There were no concrete reason to remove Arrays . fill , it ' s just because the in - between change was overwritten by mistake . Using Arrays . fill is perfectly fine both in JDK code and in user applications and used , for example , in WeakHashMap . The Arrays class is loaded anyways pretty early during the JDK initialization , has very simple static initializer and Arrays . fill method can be easily inlined even by client compiler , so no performance drawback should be noted .

Question - 26318569 I am getting following exception while running the tests . I am using Mockito for mocking . The hints mentioned by Mockito library are not helping . # pre Test Code from DomainTestFactory . When I run the following test , I see the exception # pre

Question - 20746429 , answer - 24531394 Here is a version done on ints - as asked in the question . Usage : StreamUtil . takeWhile ( args ) ; Here ' s code for StreamUtil : # pre

Question - 6841333 , answer - 20906129 As explained by others , there ' s a time discontinuity there . There are two possible timezone offsets for 1927 - 12 - 31 23 : 54 : 08 at Asia / Shanghai , but only one offset for 1927 - 12 - 31 23 : 54 : 07 . So , depending on which offset is used , there ' s either a one second difference or a 5 minutes and 53 seconds difference . This slight shift of offsets , instead of the usual one - hour daylight savings ( summer time ) we are used to , obscures the problem a bit . Note that the 2013a update of the timezone database moved this discontinuity a few seconds earlier , but the effect would still be observable . The new java . time package on Java 8 let use see this more clearly , and provide tools to handle it . Given : # pre Then durationAtEarlierOffset will be one second , while durationAtLaterOffset will be five minutes and 53 seconds . Also , these two offsets are the same : # pre But these two are different : # pre You can see the same problem comparing 1927 - 12 - 31 23 : 59 : 59 with 1928 - 01 - 01 00 : 00 : 00 , though , in this case , it is the earlier offset that produce the longer divergence , and it is the earlier date that has two possible offsets . Another way to approach this is to check whether there ' s a transition going on . We can do this like this : # pre You can check whether the transition is an overlap - in which case there ' s more than one valid offset for that date / time - or a gap - in which case that date / time is not valid for that zone id - by using the isOverlap ( args ) and isGap ( args ) methods on zot4 . I hope this helps people handle this sort of issue once Java 8 becomes widely available , or to those using Java 7 who adopt the JSR 310 backport .

Question - 18666710 , answer - 18792306 An important feature of parametric types is the ability to write polymorphic algorithms , i . e . algorithms that operate on a data structure regardless of its parameter value , such as Arrays . sort ( args ) . With generics , that ' s done with wildcard types : < E extends Comparable < T > > void sort ( args ) ; To be truly useful , wildcard types require wildcard capture , and that requires the notion of a type parameter . None of that was available at the time arrays were added to Java , and makings arrays of reference type covariant permitted a far simpler way to permit polymorphic algorithms : void sort ( args ) ; However , that simplicity opened a loophole in the static type system : # pre requiring a runtime check of every write access to an array of reference type . In a nutshell , the newer approach embodied by generics makes the type system more complex , but also more statically type safe , while the older approach was simpler , and less statically type safe . The designers of the language opted for the simpler approach , having more important things to do than closing a small loophole in the type system that rarely causes problems . Later , when Java was established , and the pressing needs taken care of , they had the resources to do it right for generics ( but changing it for arrays would have broken existing Java programs ) .

Question - 6667243 , answer - 6667307 mode1 . name ( args ) or String . valueOf ( args ) . It doesn ' t get better than that , I ' m afraid

Question - 7488643 , answer - 7488710 Arrays . asList returns a fixed - size List backed by the array . If you want a normal mutable java . util . ArrayList you need to do this : List < T > list = new ArrayList < T > ( args ) ; Or , using Guava : List < T > list = Lists . newArrayList ( args ) ; Using a Splitter gives you more flexibility in how you split the string and gives you the ability to , for example , skip empty strings in the results and trim results . It also has less weird behavior than String . split as well as not requiring you to split by regex ( that ' s just one option ) .

Question - 19431234 , answer - 23884116 the following seems to work when converting from new API LocalDateTime into java . util . date : Date . from ( args ) ; the reverse conversion can be ( hopefully ) achieved similar way . . . hope it helps . . .

Question - 18448671 , answer - 18448685 If you want to modify your List during traversal , then you need to use the Iterator . And then you can use iterator . remove ( args ) to remove the elements during traversal .

Question - 17828584 , answer - 17832168 I think the number displayed is the number of time the System . out . println call throws the Stackoverflow exception . It probably depend on the implementation of the println and the number of stacking call it is made in it . As an illustration : The main ( args ) call trigger the Stackoverflow exception at call i . The i - 1 call of main catch the exception and call println which trigger a second Stackoverflow . cnt get increment to 1 . The i - 2 call of main catch now the exception and call println . In println a method is called triggering a 3rd exception . cnt get increment to 2 . this continue until println can make all its needed call and finally display the value of cnt . This is then dependent of the actual implementation of println . For the JDK7 either it detect cycling call and throws the exception earlier either it keep some stack resource and throw the exception before reaching the limit to give some room for remediation logic either the println implementation doesn ' t make calls either the + + operation is done after the println call thus is by pass by the exception .

Question - 28584669 , answer - 28584954 Because thats the standard . Infinity represents a number greater than or less than Double . MAX _ VALUE / - Double . MAX _ VALUE . NaN represents the outcome of an operation that didn ' t make sense . That is , the operation didn ' t possibly come out with a number . I would guess the logic is once a number gets big enough ( infinity ) and because of the limitation of floating point numbers , adding numbers to it won ' t change the outcome , so its ' like ' infinity . So if you want to compare to really big numbers , at some point you might just say those two big numbers are close enough for all intents and purposes . But if you want to compare two things that both aren ' t numbers , you can ' t compare them so its false . At least you couldn ' t compare them as a primitive .

Question - 19431234 , answer - 30133063 Much more convenient way if you are sure you need a default timezone : Date d = java . sql . Timestamp . valueOf ( args ) ;

Question - 4772425 , answer - 4772461 Use LocalDateTime # parse ( ) ( or ZonedDateTime # parse ( ) if the string happens to contain a time zone part ) to parse a String in a certain pattern into a LocalDateTime . # pre Use LocalDateTime # format ( ) ( or ZonedDateTime # format ( ) ) to format a LocalDateTime into a String in a certain pattern . # pre Or , when you ' re not on Java 8 yet , use SimpleDateFormat # parse ( ) to parse a String in a certain pattern into a Date . # pre Use SimpleDateFormat # format ( ) to format a Date into a String in a certain pattern . # pre See also : # li Java string to date conversion Update : as per your failed attempt : the patterns are case sensitive . Read the java . text . SimpleDateFormat javadoc what the individual parts stands for . So stands for example M for months and m for minutes . Also , years exist of four digits yyyy , not five yyyyy . Look closer at the code snippets I posted here above .

Question - 30384955 , answer - 30385343 This happens because of the way capture conversion works : # blockquote Note the end bit . So , what this means is that , given a type like this : # pre Only " outside " wildcards are captured . The Map key wildcard is captured , but the List element wildcard is not . This is why , for example , we can add to a List < T > , but not a List < T > . The placement of the wildcard is what matters . Carrying this over to TbinList , if we have an ArrayList < T > , the wildcard is in a place where it does not get captured , but if we have a TbinList < T > , the wildcard is in a place where it gets captured . As I alluded to in the comments , one very interesting test is this : ArrayList < T > test3 = new TbinList < T > ( args ) ; We get this error : # pre So there ' s no way to make it work as - is . One of the class declarations needs to be changed . Additionally , think about it this way . Suppose we had : # pre And since a wildcard allows subtyping , we can do this : TbinList < T > test4 = new TbinList < T > ( args ) ; Should we be able to add a Tbin < T > to test4 ? No , this would be heap pollution . We might end up with Derived2 s floating around in a TbinList < T > .

Question - 28459498 , answer - 28459604 Background While the question appears simple , the actual answer requires some background to make sense . If you want to skip to the conclusion , scroll down . . . Pick your comparison point - Basic functionality Using basic concepts , C # ' s IEnumerable concept is more closely related to Java ' s Iterable , which is able to create as many Iterators as you want . IEnumerables create IEnumerators . Java ' s Iterable create Iterators The history of each concept is similar , in that both IEnumerable and Iterable have a basic motivation to allow ' for - each ' style looping over the members of data collections . That ' s an oversimplification as they both allow more than just that , and they also arrived at that stage via different progressions , but it is a significant common feature regardless . Let ' s compare that feature : in both languages , if a class implements the IEnumerable / Iterable , then that class must implement at least a single method ( for C # , it ' s GetEnumerator and for Java it ' s iterator ( args ) ) . In each case , the instance returned from that ( IEnumerator / Iterator ) allows you to access the current and subsequent members of the data . This feature is used in the for - each language syntax . Pick your comparison point - Enhanced functionality IEnumerable in C # has been extended to allow a number of other language features ( mostly related to Linq ) . Features added include selections , projections , aggregations , etc . These extensions have a strong motivation from use in set - theory , similar to SQL and Relational Database concepts . Java 8 has also had functionality added to enable a degree of functional programming using Streams and Lambdas . Note that Java 8 streams are not primarily motivated by set theory , but by functional programming . Regardless , there are a lot of parallels . So , this is the second point . The enhancements made to C # were implemented as an enhancement to the IEnumerable concept . In Java , though , the enhancements made were implemented by creating new base concepts of Lambdas and Streams , and then also creating a relatively trivial way to convert from Iterators and Iterables to Streams , and visa - versa . So , comparing IEnumerable to Java ' s Stream concept is incomplete . You need to compare it to the combined Streams and Collections API ' s in Java . In Java , Streams are not the same as Iterables , or Iterators Streams are not designed to solve problems the same way that iterators are : # li Iterators are a way of describing the sequence of data . # li Streams are a way of describing a sequence of data transformations . With an Iterator , you get a data value , process it , and then get another data value . With Streams , you chain a sequence of functions together , then you feed an input value to the stream , and get the output value from the combined sequence . Note , in Java terms , each function is encapsulated in a single Stream instance . The Streams API allows you to link a sequence of Stream instances in a way that chains a sequence of transformation expressions . In order to complete the Stream concept , you need a source of data to feed the stream , and a terminal function that consumes the stream . The way you feed values in to the stream may in fact be from an Iterable , but the Stream sequence itself is not an Iterable , it is a compound function . A Stream is also intended to be lazy , in the sense that it only does work when you request a value from it . Note these significant assumptions and features of Streams : # li A Stream in Java is a transformation engine , it transforms a data item in one state , to being in another state . # li streams have no concept of the data order or position , the simply transform whatever they are asked to . # li streams can be supplied with data from many sources , including other streams , Iterators , Iterables , Collections , # li you cannot " reset " a stream , that would be like " reprogramming the transformation " . Resetting the data source is probably what you want . # li there is logically only 1 data item ' in flight ' in the stream at any time ( unless the stream is a parallel stream , at which point , there is 1 item per thread ) . This is independent of the data source which may have more than the current items ' ready ' to be supplied to the stream , or the stream collector which may need to aggregate and reduce multiple values . # li Streams can be unbound ( infinite ) , limited only by the data source , or collector ( which can be infinite too ) . # li Streams are ' chainable ' , the output of filtering one stream , is another stream . Values input to and transformed by a stream can in turn be supplied to another stream which does a different transformation . The data , in its transformed state flows from one stream to the next . You do not need to intervene and pull the data from one stream and plug it in to the next . C # Comparison When you consider that a Java Stream is just a part of a supply , stream , and collect system , and that Streams and Iterators are often used together with Collections , then it is no wonder that it is hard to relate to the same concepts which are almost all embedded in to a single IEnumerable concept in C # . Parts of IEnumerable ( and close related concepts ) are apparent in all of the Java Iterator , Iterable , Lambda , and Stream concepts . There are small things that the Java concepts can do that are harder in IEnumerable , and visa - versa . Conclusion # li There ' s no design problem here , just a problem in matching concepts between the languages . # li Streams solve problems in a different way # li Streams add functionality to Java ( they add a different way of doing things , they do not take functionality away ) Adding Streams gives you more choices when solving problems , which is fair to classify as ' enhancing power ' , not ' reducing ' , ' taking away ' , or ' restricting ' it . Why are Java Streams once - off ? This question is misguided , because streams are function sequences , not data . Depending on the data source that feeds the stream , you can reset the data source , and feed the same , or different stream . Unlike C # ' s IEnumerable , where an execution pipeline can be executed as many times as we want , in Java a stream can be ' iterated ' only once . Comparing an IEnumerable to a Stream is misguided . The context you are using to say IEnumerable can be executed as many times as you want , is best compared to Java Iterables , which can be iterated as many times as you want . A Java Stream represents a subset of the IEnumerable concept , and not the subset that supplies data , and thus cannot be ' rerun ' . Any call to a terminal operation closes the stream , rendering it unusable . This ' feature ' takes away a lot of power . The first statement is true , in a sense . The ' takes away power ' statement is not . You are still comparing Streams it IEnumerables . The terminal operation in the stream is like a ' break ' clause in a for loop . You are always free to have another stream , if you want , and if you can re - supply the data you need . Again , if you consider the IEnumerable to be more like an Iterable , for this statement , Java does it just fine . I imagine the reason for this is not technical . What were the design considerations behind this strange restriction ? The reason is technical , and for the simple reason that a Stream a subset of what think it is . The stream subset does not control the data supply , so you should reset the supply , not the stream . In that context , it is not so strange . QuickSort example Your quicksort example has the signature : IEnumerable < T > QuickSort ( args ) You are treating the input IEnumerable as a data source : IEnumerable < T > lt = ints . Where ( args ) ; Additionally , return value is IEnumerable too , which is a supply of data , and since this is a Sort operation , the order of that supply is significant . If you consider the Java Iterable class to be the appropriate match for this , specifically the List specialization of Iterable , since List is a supply of data which has a guaranteed order or iteration , then the equivalent Java code to your code would be : # pre Note there is a bug ( which I have reproduced ) , in that the sort does not handle duplicate values gracefully , it is a ' unique value ' sort . Also note how the Java code uses data source ( List ) , and stream concepts at different point , and that in C # those two ' personalities ' can be expressed in just IEnumerable . Also , although I have use List as the base type , I could have used the more general Collection , and with a small iterator - to - Stream conversion , I could have used the even more general Iterable

Question - 5694385 , answer - 5694473 Create a File object , passing the directory path to the constructor . Use the listFiles ( args ) to retrieve an array of File objects for each file in the directory , and then call the getName ( args ) method to get the filename . # pre

Question - 23308193 , answer - 32566745 This is possible for forEach ( args ) . The solution is not nice , but it is possible . WARNING : You should not use it for controlling business logic , but purely for handling an exceptional situation which occurs during the execution of the forEach ( args ) . Such as a resource suddenly stops being accessible , one of the processed objects is violating a contract ( e . g . contract says that all the elements in the stream must not be null but suddenly and unexpectedly one of them is null ) etc . According to the documentation for Iterable . forEach ( ) : # blockquote So you throw an exception which will immediately break the internal loop . The code will be something like this - I cannot say I like it but it works . You create your own class BreakException which extends RuntimeException . # pre Notice that the try . . . catch is not around the lambda expression , but rather around the whole forEach ( args ) method . To make it more visible , see the following transcription of the code which shows it more clearly : # pre

Question - 4645020 It is supposed to be generally preferable to use a StringBuilder for string concatenation in Java . Is this always the case ? What I mean is this : Is the overhead of creating a StringBuilder object , calling the append ( args ) method and finally toString ( args ) already smaller then concatenating existing strings with the + operator for two strings , or is it only advisable for more ( than two ) strings ? If there is such a threshold , what does it depend on ( perhaps the string length , but in which way ) ? And finally , would you trade the readability and conciseness of the + concatenation for the performance of the StringBuilder in smaller cases like two , three or four strings ? EDIT Explicit use of StringBuilder for regular concatenations is being mentioned as obsolete at obsolete java optimization tips as well as at java urban myths .

Question - 32693704 , answer - 32852619 Because it ' s much faster ! I ran some thorough benchmarking tests on cut down versions of the two methods : # pre operating on arrays of various sizes containing random values . Here are the ( typical ) results : # pre And here are the results when operating over an array filled with nulls ( so garbage collection issues are eradicated ) : # pre The numbers are in nanoseconds , ( sd ) is 1 standard deviation expressed as a percentage of the result ( fyi , a " normally distributed " population has an SD of 68 ) , vs is the JDK 8 timing relative to JDK 7 . It is interesting that not only is it significantly faster , but the deviation is also slightly narrower , which means that the JDK 8 implementation gives slightly more consistent performance . The tests were run on jdk 1 . 8 . 0 _ 45 over a large ( millions ) number of times on arrays populated with random Integer objects . To remove out - lying numbers , on each set of results the fastest and slowest 3 % of timings were discarded . Garbage collection was requested and the thread yielded and slept just prior to running each invocation of the method . JVM warm up was done on the first 20 % of work and those results were discarded .

Question - 6684665 , answer - 12685471 The kind of output you are seeing from your byte array ( [ B @ 405217f8 ) is also an output for a zero length byte array ( ie new byte [ 0 ] ) . It looks like this string is a reference to the array rather than a description of the contents of the array like we might expect from a regular collection ' s toString ( args ) method . As with other respondents , I would point you to the String constructors that accept a byte [ ] parameter to construct a string from the contents of a byte array . You should be able to read raw bytes from a socket ' s InputStream if you want to obtain bytes from a TCP connection . If you have already read those bytes as a String ( using an InputStreamReader ) , then , the string can be converted to bytes using the getBytes ( args ) function . Be sure to pass in your desired character set to both the String constructor and getBytes ( args ) functions , and this will only work if the byte data can be converted to characters by the InputStreamReader . If you want to deal with raw bytes you should really avoid using this stream reader layer .

Question - 28276423 , answer - 28276469 It will be fine if you only close the last stream - the close call will be send to the underlying streams , too .

Question - 5192512 , answer - 5193094 There are basically two alternatives , using setLength ( args ) to reset the StringBuilder or creating a new one in each iteration . Both can have pros and cons depending on the usage . If you know the expected capacity of the StringBuilder beforehand , creating a new one each time should be just as fast as setting a new length . It will also help the garbage collector , since each StringBuilder will be relatively short - lived and the gc is optimized for that . When you don ' t know the capacity , reusing the same StringBuilder might be faster . Each time you exceed the capacity when appending , a new backing array has to be allocated and the previous content has to be copied . By reusing the same StringBuilder , it will reach the needed capacity after some iterations and there won ' t be any copying thereafter .

Question - 4871051 , answer - 4871135 Current working directory is defined differently in different Java implementations For certain prior to Java 7 there was no consistent way to get the working directory . You could work around this by launching Java with - D and defining a variable to hold the info Something like java - Dcom . mycompany . workingDir = StringLiteral That ' s not quite right , but you get the idea . Then System . getProperty ( args ) . . .

Question - 15182496 , answer - 15182578 The other answers explain why , but here is how : new Random ( args ) . nextInt ( args ) The first 6 numbers that the above random generates are : # pre and the first 6 numbers that new Random ( args ) . nextInt ( args ) generates are : # pre Then just add those numbers to the integer representation of the character ` ( which is 96 ) : # pre

Question - 12552863 , answer - 12619799 I would say don ' t use ARM and go on with Closeable . Use method like , # pre Also you should consider calling close of BufferedWriter as it is not just delegating the close to FileWriter , but it does some cleanup like flushBuffer .

Question - 12552863 The Java 7 try - with - resources syntax ( also known as ARM block ( Automatic Resource Management ) ) is nice , short and straightforward when using only one AutoCloseable resource . However , I am not sure what is the correct idiom when I need to declare multiple resources that are dependent on each other , for example a FileWriter and a BufferedWriter that wraps it . Of course , this question concerns any case when some AutoCloseable resources are wrapped , not only these two specific classes . I came up with the three following alternatives : 1 ) The naive idiom I have seen is to declare only the top - level wrapper in the ARM - managed variable : # pre This is nice and short , but it is broken . Because the underlying FileWriter is not declared in a variable , it will never be closed directly in the generated finally block . It will be closed only through the close method of the wrapping BufferedWriter . The problem is , that if an exception is thrown from the bw ' s constructor , it ' s close will not be called and therefore the underlying FileWriter will not be closed . 2 ) # pre Here , both the underlying and the wrapping resource are declared in the ARM - managed variables , so both of them will be certainly closed , so certainly that the underlying fw . close ( args ) will be called twice , first directly and for the second time through the wrapping bw . close ( args ) . This should not be a problem for these two specific classes that both implement Closeable ( which is a subtype of AutoCloseable ) , whose contract states that multiple calls to close are permitted : # blockquote However , in a general case , I can have resources that do implement only AutoCloseable ( and not Closeable ) , which doesn ' t guarantee that the close can be called multiple times : # blockquote 3 ) # pre This version should be theoretically correct , because only the fw represents a real resource that needs to be cleaned up . The bw does ' t itself hold any resource , it only delegates to the fw , so it should be sufficient to only close the underlying fw . On the other hand , the syntax is a bit irregular and also , Eclipse issues a warning , which I believe is a false alarm , but it is still a warning that one has to deal with : # blockquote So , which approach to go for ? Or have I missed some other idiom that is the correct one ?

Question - 32356762 , answer - 32357149 Disclaimer : I am not a JDK author . I agree that it ' s correct to write your own code to interfaces , but if you ' re going return a mutable collection to a third party , it ' s important to let the third party know what sort of List they ' re getting back . LinkedList and ArrayList are very different , performance wise , for various operations . For example , removing the first element of an ArrayList is O ( args ) , but removing the first element of a LinkedList is O ( args ) . By fully specifying the return type , the JDK authors are communicating extra information , in unambiguous code , about what sort of object they ' re giving back to you , so you can write your code to use this method properly . If you really need a LinkedList , you know that you have to specify one here . Finally , the main reason to code to an interface over an implementation is if you think that the implementation will change . The JDK authors probably figure they are never going to change this method ; it ' s never going to return a LinkedList or a Collections . UnmodifiableList . However , in most cases , you would probably still do : List < T > list = Collections . list ( args ) ;

Question - 14534767 , answer - 14534798 It should be r . append ( args ) ; But I recommend you to do as below , r . append ( args ) ; System . getProperty ( args ) gives you system - dependent newline in java . Also from Java 7 there ' s a method that returns the value directly : System . lineSeparator ( )

Question - 32334319 I am using JDK - 8 ( x64 ) . For Arrays . sort I found the following in the Java documentation : # blockquote For Collections . sort I found this : # blockquote If Collections . sort uses an array , why doesn ' t it just call Arrays . sort or use dual - pivot QuickSort ? Why use Mergesort ?

Question - 11359187 For the first time in my life I find myself in a position where I ' m writing a Java API that will be open sourced . Hopefully to be included in many other projects . For logging I ( and indeed the people I work with ) have always used JUL ( java . util . logging ) and never had any issues with it . However now I need to understand in more detail what I should do for my API development . I ' ve done some research on this and with the information I ' ve got I just get more confused . Hence this post . Since I come from JUL I ' m biased on that . My knowledge of the rest is not that big . From the research I ' ve done I ' ve come up with these reasons why people do not like JUL : # li " I started developing in Java long before Sun released JUL and it was just easier for me to continue with logging - framework - X rather than to learn something new " . Hmm . I ' m not kidding , this is actually what people say . With this argument we could all be doing COBOL . ( however I can certainly relate to this being a lazy dude myself ) # li " I don ' t like the names of the logging levels in JUL " . Ok , seriously , this is just not enough of a reason to introduce a new dependency . # li " I don ' t like the standard format of the output from JUL " . Hmm . This is just configuration . You do not even have to do anything code - wise . ( true , back in old days you may have had to create your own Formatter class to get it right ) . # li " I use other libraries that also use logging - framework - X so I thought it easier just to use that one " . This is a cyclic argument , isn ' t ? Why does ' everybody ' use logging - framework - X and not JUL ? # li " Everybody else is using logging - framework - X " . This to me is just a special case of the above . Majority is not always right . So the real big question is why not JUL ? . What is it I have missed ? The raison d ' ê tre for logging facades ( SLF4J , JCL ) is that multiple logging implementations have existed historically and the reason for that really goes back to the era before JUL as I see it . If JUL was perfect then logging facades wouldn ' t exist , or what ? Rather than embracing them shouldn ' t we question why they were necessary in the first place ? ( and see if those reasons still exist ) Ok , my research so far has led to a couple of things that I can see may be real issues with JUL : # li Performance . Some say that performance in SLF4J is superior to the rest . This seems to me to be a case of premature optimization . If you need to log hundreds of megabytes per second then I ' m not sure you are on the right path anyway . JUL has also evolved and the tests you did on Java 1 . 4 may no longer be true . You can read about it here and this fix has made it into Java 7 . Many also talk about the overhead of string concatenation in logging methods . However template based logging avoids this cost and it exist also in JUL . Personally I never really write template based logging . Too lazy for that . For example if I do this with JUL : log . finest ( args ) ) ; my IDE will warn me and ask permission that it should change it to : log . log ( args ) ; . . which I will of course accept . Permission granted ! Thank you for your help . So I don ' t actually write such statements myself , that is done by the IDE . In conclusion on the issue of performance I haven ' t found anything that would suggest that JUL ' s performance is not ok compared to the competition . # li Configuration from classpath . Out - of - the - box JUL cannot load a configuration file from the classpath . It is a few lines of code to make it do so . I can see why this may be annoying but the solution is short and simple . # li Availability of output handlers . JUL comes with 5 output handlers out - of - the - box : console , file stream , socket and memory . These can be extended or new ones can be written . This may for example be writing to UNIX / Linux Syslog and Windows Event Log . I have personally never had this requirement nor have I seen it used but I can certainly relate to why it may be a useful feature . Logback comes with an appender for Syslog for example . Still I would argue that # li 99 . 5 % of the needs for output destinations are covered by what is in JUL out - of - the - box . # li Special needs could be catered for by custom handlers on top of JUL rather than on top of something else . There ' s nothing to me that suggests that it takes more time to write a Syslog output handler for JUL than it does for another logging framework . I ' m really concerned that there ' s something I ' ve overlooked . The use of logging facades and logging implementations other than JUL is so widespread that I have to come to the conclusion that it ' s me who just doesn ' t understand . That wouldn ' t be the first time , I ' m afraid . : - ) So what should I do with my API ? I want it to become successful . I can of course just " go with the flow " and implement SLF4J ( which seems the most popular these days ) but for my own sake I still need to understand exactly what is wrong with the JUL of today that warrants all the fuzz ? Will I sabotage myself by choosing JUL for my library ? Testing performance ( section added by nolan600 on 07 - JUL - 2012 ) There ' s a reference below from Ceki about SLF4J ' s parametrization being 10 times or more faster than JUL ' s . So I ' ve started doing some simple tests . At first glance the claim is certainly correct . Here are the preliminary results ( but read on ! ) : # li Execution time SLF4J , backend Logback : 1515 # li Execution time SLF4J , backend JUL : 12938 # li Execution time JUL : 16911 The numbers above are msecs so less is better . So 10 times performance difference is by first actually pretty close . My initial reaction : That is a lot ! Here is the core of the test . As can be seen an integer and a string is construted in a loop which is then used in the log statement : # pre ( I wanted the log statement to have both a primitive data type ( in this case an int ) and a more complex data type ( in this case a String ) . Not sure it matters but there you have it . ) The log statement for SLF4J : logger . info ( args ) ; The log statement for JUL : logger . log ( args ) ; The JVM was ' warmed up ' with the same test executed once before the actual measurement was done . Java 1 . 7 . 03 was used on Windows 7 . Latest versions of SLF4J ( v1 . 6 . 6 ) and Logback ( v1 . 0 . 6 ) was used . Stdout and stderr was redirected to null device . However , careful now , it turns out JUL is spending most of its time in getSourceClassName ( args ) because JUL by default prints the source class name in the output , while Logback doesn ' t . So we are comparing apples and oranges . I have to do the test again and configure the logging implementations in a similar manner so that they actually output the same stuff . I do however suspect that SLF4J + Logback will still come out on top but far from the initial numbers as given above . Stay tuned . Btw : The test was first time I ' ve actually worked with SLF4J or Logback . A pleasant experience . JUL is certainly a lot less welcoming when you are starting out . Testing performance ( part 2 ) ( section added by nolan600 on 08 - JUL - 2012 ) As it turns out it doesn ' t really matter for performance how you configure your pattern in JUL , i . e . whether or not it includes the source name or not . I tried with a very simple pattern : java . util . logging . SimpleFormatter . format = StringLiteral and that did not change the above timings at all . My profiler revealed that the logger still spent a lot of time in calls to getSourceClassName ( args ) even if this was not part of my pattern . The pattern doesn ' t matter . I ' m therefore concluding on the issue of performance that at least for the tested template based log statement there seems to be roughly a factor of 10 in real performance difference between JUL ( slow ) and SLF4J + Logback ( quick ) . Just like Ceki said . I can also see another thing namely that SLF4J ' s getLogger ( args ) call is a lot more expensive than JUL ' s ditto . ( 95 ms vs 0 . 3 ms if my profiler is accurate ) . This makes sense . SLF4J has to do some time on the binding of the underlying logging implementation . This doesn ' t scare me . These calls should be somewhat rare in the lifetime of an application . The fastness should be in the actual log calls . Final conclusion ( section added by nolan600 on 08 - JUL - 2012 ) Thank you for all your answers . Contrary to what I initially thought I ' ve ended up deciding to use SLF4J for my API . This is based on a number of things and your input : # li It gives flexibility to choose log implementation at deployment time . # li Issues with lack of flexibility of JUL ' s configuration when run inside an application server . # li SLF4J is certainly a lot faster as detailed above in particular if you couple it with Logback . Even if this was just a rough test I have reason to believe that a lot more effort has gone into optimization on SLF4J + Logback than on JUL . # li Documentation . The documentation for SLF4J is simply a lot more comprehensive and precise . # li Pattern flexibility . As I did the tests I set out to have JUL mimic the default pattern from Logback . This pattern includes the name of the thread . It turns out JUL cannot do this out of the box . Ok , I haven ' t missed it until now , but I don ' t think it is a thing that should be missing from a log framework . Period ! # li Most ( or many ) Java projects today use Maven so adding a dependency is not that big a thing especially if that dependency is rather stable , i . e . doesn ' t constantly change its API . This seems to be true for SLF4J . Also the SLF4J jar and friends are small in size . So the strange thing that happened was that I actually got quite upset with JUL after having worked a bit with SLF4J . I still regret that it has to be this way with JUL . JUL is far from perfect but kind of does the job . Just not quite well enough . The same can be said about Properties as an example but we do not think about abstracting that so people can plug in their own configuration library and what have you . I think the reason is that Properties comes in just above the bar while the opposite is true for JUL of today . . . and in the past it came in at zero because it didn ' t exist .

Question - 8098953 , answer - 8103083 The first thing to keep in mind is that Java ternary operators have a " type " , and that this is what the compiler will determine and consider no matter what the actual / real types of the second or third parameter are . Depending on several factors the ternary operator type is determined in different ways as illustrated in the Java Language Specification 15 . 26 In the question above we should consider the last case : # blockquote This is by far the most complex case once you take a look at applying capture conversion ( § 5 . 1 . 10 ) and most of all at lub ( T1 , T2 ) . In plain English and after an extreme simplification we can describe the process as calculating the " Least Common Superclass " ( yes , think of the LCM ) of the second and third parameters . This will give us the ternary operator " type " . Again , what I just said is an extreme simplification ( consider classes that implement multiple common interfaces ) . For example , if you try the following : # pre You ' ll notice that resulting type of the conditional expression is java . util . Date since it ' s the " Least Common Superclass " for the Timestamp / Time pair . Since null can be autoboxed to anything , the " Least Common Superclass " is the Integer class and this will be the return type of the conditional expression ( ternary operator ) above . The return value will then be a null pointer of type Integer and that is what will be returned by the ternary operator . At runtime , when the Java Virtual Machine unboxes the Integer a NullPointerException is thrown . This happens because the JVM attempts to invoke the function null . intValue ( args ) , where null is the result of autoboxing . In my opinion ( and since my opinion is not in the Java Language Specification many people will find it wrong anyway ) the compiler does a poor job in evaluating the expression in your question . Given that you wrote true ? param1 : param2 the compiler should determine right away that the first parameter - null - will be returned and it should generate a compiler error . This is somewhat similar to when you write while ( args ) { } etc . . . and the compiler complains about the code underneath the loop and flags it with Unreachable Statements . Your second case is pretty straightforward and this answer is already too long . . . ; ) CORRECTION : After another analysis I believe that I was wrong to say that a null value can be boxed / autoboxed to anything . Talking about the class Integer , explicit boxing consists in invoking the new Integer ( args ) constructor or maybe the Integer . valueOf ( args ) ; ( I found this version somewhere ) . The former would throw a NumberFormatException ( and this does not happen ) while the second would just not make sense since an int cannot be null . . .

Question - 34250207 , answer - 34250231 Technically , it ' s 10 , not zero , if you admit for a lazy initialisation of the backing array . See : # pre where / * * * Default initial capacity . * / private static final int DEFAULT _ CAPACITY = 10 ; What you ' re referring to is just the zero - sized initial array object that is shared among all initially empty ArrayList objects . I . e . the capacity of 10 is guaranteed lazily , an optimisation that is present also in Java 7 . Admittedly , the constructor contract is not entirely accurate . Perhaps this is the source of confusion here . Background Here ' s an E - Mail by Mike Duigou # blockquote

Question - 31170459 , answer - 31170506 No , you appear to have a legit bug . The bug presents in JDK7 but fixed in JDK8 . Your values are correctly representable as BigDecimal s , and should behave correctly , but don ' t . Tracing through the source code of BigDecimal , on line 2585 , this . precision ( args ) is 1 , and this . scale is - 2147483647 . this . precision ( args ) - this . scale therefore overflows , and the following overflow is not handled correctly . This bug has been fixed in JDK8 by doing the subtraction in long arithmetic .

Question - 16232833 I ' m using Spring MVC for a simple JSON API , with @ ResponseBody based approach like the following . ( I already have a service layer producing JSON directly . ) # pre Question is , in the given scenario , what is the simplest , cleanest way to respond with a HTTP 400 error ? I did come across approaches like : return new ResponseEntity ( args ) ; . . . but I can ' t use it here since my method ' s return type is String , not ResponseEntity .

Question - 14491966 , answer - 14492043 ' Random ' is more than just about getting numbers . . . . what you have is pseudo - random If pseudo - random is good enough for your purposes , then sure , it ' s way faster ( and XOR + Bitshift will be faster than what you have ) Rolf Edit : OK , after being too hasty in this answer , let me answer the real reason why your code is faster : From the JavaDoc for Math . Random ( ) # blockquote This is likely why your code is faster .

Question - 14534767 I have a StringBuilder object , # pre Now I want to append a newline character to the StringBuilder . How can I do it ? result . append ( args ) ; Does not work . So , I was thinking about writing a newline using Unicode . Will this help ? If so , how can I add one ?

Question - 29333689 The following is taken from a job interview : # blockquote I thought about using an HashSet , but it might complicate everything . . . Any ideas of a simple solution ?

Question - 30384955 , answer - 30385298 Replacing the definition of TbinList with class TbinList < T > extends ArrayList < T > { } and defining test2 with TbinList < T > test2 = new TbinList < T > ( args ) ; instead would solve the issue . With your definition you ' re ending up with an ArrayList < T > where T is any fixed class extending Base .

Question - 20129762 , answer - 20130475 To convert a Stream to an Iterable , you can do # pre To pass a Stream to a method that expects Iterable , void foo ( args ) simply foo ( args ) however it probably looks funny ; it might be better to be a little bit more explicit foo ( args ) ;

Question - 4709175 , answer - 4709284 # blockquote You can use an Enum to represent a smallish fixed set of constants or an internal class mode while increasing readability . Also , Enums can enforce a certain rigidity when used in method parameters . They offer the interesting possibility of passing information to a constructor like in the Planets example on Oracle ' s site and , as you ' ve discovered , also allow a simple way to create a singleton pattern . ex : Locale . setDefault ( args ) reads better than Locale . setDefault ( args ) and enforces the use of fixed set of values shown in an IDE when you add the . separator instead of all integers .

Question - 32356762 , answer - 32357142 When returning List , you ' ll be promoting program to an interface , which is a very good practice . However , this approach has its limitation . For example , you cannot use some methods that are defined for ArrayList and don ' t exist in the List interface - See this answer for details . I ' m quoting the API Design from the The Java ™ Tutorials : # blockquote Since ArrayList is essentially an array , they are my first choice when I need to have a " collection - array " . So if I want to convert enumeration to a list , my choice would be an array list . In any other cases , it ' s still valid to write : List < T > list = Collections . list ( args ) ;

Question - 8189466 , answer - 23592535 I had that same problem but in case that I was adding en element into iterated list . I made it this way # pre Now everything goes fine because you don ' t create any iterator over your list , you iterate over it " manually " . And condition i < integerList . size ( args ) will never fool you because when you remove / add something into List size of the List decrement / increment . . Hope it helps , for me that was solution .

Question - 31993377 , answer - 31993533 The reason is that hasNext ( args ) checks if there are any more non - whitespace characters available . hasNextLine ( args ) checks to see if there is another line of text available . Your text file probably has a newline at the end of it so it has another line but no more characters that are not whitespace . Many text editors automatically add a newline to the end of a file if there isn ' t one already . In other words , your input file is not this ( the numbers are line numbers ) : # pre It is actually this : # pre

Question - 31993377 , answer - 31993534 You have a single extra newline at the end of your file . # li hasNextLine ( ) checks to see if there is another linePattern in the buffer . # li hasNext ( ) checks to see if there is a parseable token in the buffer , as separated by the scanner ' s delimiter . Since the scanner ' s delimiter is whitespace , and the linePattern is also white space , it is possible for there to be a linePattern in the buffer but no parseable tokens . Typically , the most common way to deal with this issue by always calling nextLine ( args ) after parsing all the tokens ( e . g . numbers ) in each line of your text . You need to do this when using Scanner when reading a user ' s input too from System . in . To advance the scanner past this whitespace delimiter , you must use scanner . nextLine ( args ) to clear the line delimiter . See : Using scanner . nextLine ( ) Appendix : LinePattern is defined to be a Pattern that matches this : # pre The default token delimiter is this Pattern : private static Pattern WHITESPACE _ PATTERN = Pattern . compile ( args ) ;

Question - 29183904 , answer - 29972028 Use enum when you need its features . Don ' t avoid it strictly . Java enum is more powerful , but if you don ' t need its features , use constants , they occupy less space and they can be primitive itself . When to use enum : # li type checking - you can accept only listed values , and they are not continuous ( see below what I call continuous here ) # li method overloading - every enum constant has its own implementation of a method # pre # li more data - your one constant contains more than one information that cannot be put in one variable # li complicated data - your constant need methods to operate on the data When not to use enum : # li you can accept all values of one type , and your constants contain only these most used # li you can accept continuous data # pre # li for names ( like in your example ) # li for everything other that really doesn ' t need an enum Enum occupies more space # li a single reference to an enum constant occupy 4 bytes # li every enum constant occupy space that is a sum of its fields ' sizes aligned to 8 bytes + overhead of the object # li the enum class itself occupy some space Constant occupies less space # li a constant doesn ' t have a reference so it ' s a pure data ( even if it ' s a reference , then enum instance would be a reference to another reference ) # li constants may be added to existing class - it ' s not necessary to add another class # li constants may be inlined ; it brings extended compile - time features ( such as null checking , finding dead code etc . )

Question - 11359187 , answer - 11359320 # li java . util . logging was introduced in Java 1 . 4 . There were uses for logging before that , that ' s why many other logging APIs exist . Those APIs where used heavily before Java 1 . 4 and thus had a great marketshare that didn ' t just drop to 0 when 1 . 4 was release . # li JUL didn ' t start out all that great , many of the things you mentioned where a lot worse in 1 . 4 and only got better in 1 . 5 ( and I guess in 6 as well , but I ' m not too sure ) . # li JUL isn ' t well suited for multiple applications with different configurations in the same JVM ( think multiple web applications that should not interact ) . Tomcat needs to jump through some hoops to get that working ( effectively re - implementing JUL if I understood that correctly ) . # li You can ' t always influence what logging framework your libraries use . Therefore using SLF4J ( which is actually just a very thin API layer above other libraries ) helps keeping a somewhat consistent picture of the entire logging world ( so you can decide the underlying logging framework while still having library logging in the same system ) . # li Libraries can ' t easily change . If a previous version of a library used to use logging - library - X it can ' t easily switch to logging - library - Y ( for example JUL ) , even if the latter is clearly superious : any user of that library would need to learn the new logging framework and ( at least ) reconfigure their logging . That ' s a big no - no , especially when it brings no apparent gain to most people . Having said all that I think JUL is at least a valid alternative to other logging frameworks these days .

Question - 5694385 , answer - 5694464 Rather than spoon - feed you code , here ' s how to look in the documentation . First , you ' re dealing with IO , so look in the java . io package . There are two classes that look interesting : FileFilter and FileNameFilter . When I clicked on the first , it showed me that there was a a listFiles ( args ) method in the File class . And the documentation for that method says : # blockquote Scrolling up in the File JavaDoc , I see the constructors . And that ' s really all I need to be able to create a File instance and call listFiles ( args ) on it . Scrolling still further , I can see some information about how files are named in different operating systems .

Question - 5439529 , answer - 5439600 As an alternative to trying to parse the string and catching NumberFormatException , you could use a regex ; e . g . # pre This is likely to be faster , especially if you precompile and reuse the regex . However , the catch is that Integer . parseInt ( args ) will still fail if str represents a number that is outside range of legal int values .

Question - 15336477 , answer - 15336606 It got deprecated in version 4 . 3 - alpha1 which you use because of the LATEST version specification . If you take a look at the javadoc of the class , it tells you what to use instead : HttpClientBuilder . In the latest stable version ( 4 . 2 . 3 ) the DefaultHttpClient is not deprecated yet .

Question - 20331163 I have a string " 11 / 15 / 2013 08 : 00 : 00 " , I want to format it to " 11 / 15 / 2013 " , what is the correct DateTimeFormatter pattern ? I ' ve tried many and googled and still unable to find the correct pattern . edit : I am looking for Joda - Time DateTimeFormatter , not Java ' s SimpleDateFormat . .

Question - 33477695 , answer - 33477803 The java . time API in general does have nanosecond precision . For example : # pre Output : 2015 - 11 - 02T12 : 38 : 00 , 123456789 + 0000 However , it ' s the clock value returned by OffsetDateTime . now ( args ) which is returning a value which only has milliseconds . From Clock implementation in Java 8 : # blockquote So there ' s nothing inherently imprecise here - just the default implementation of Clock using System . currentTimeMillis ( args ) . You could potentially create your own more precise subclass . However , you should note that adding more precision without adding more accuracy probably isn ' t terribly useful . ( There are times when it might be , admittedly . . . )

Question - 12732422 I ' m trying to add header for my request using HttpUrlConnection but the method setRequestProperty ( args ) doesn ' t seem working . The server side doesn ' t receive any request with my header . Can anyone help me ? Thanks in advance . # pre

Question - 14833008 , answer - 14833098 " . " is a special character in java . You have to use " \ . " to escape this character : final String extensionRemoved = filename . split ( args ) [ 0 ] ; I hope this helps

Question - 22725537 , answer - 22735184 You cannot do it more concise as you are already doing . You claim that you do not want . filter ( args ) and . map ( args ) . This has been resolved by the method @ StuartMarks describes , however as a result you now map it to an Optional < T > , so now you need to use . flatMap ( args ) and a get ( args ) in the end . So it still consists of two statements and you can now get exceptions with the new method ! Because , what if every optional is empty ? Then the findFirst ( args ) will return an empty optional and your get ( args ) will fail ! So what you have : things . stream ( args ) . map ( args ) . filter ( args ) . map ( args ) . findFirst ( args ) ; is actually the best way to accomplish what you want , and that is you want to save the result as a T , not as an Optional < T > . I took the liberty of creating a CustomOptional < T > class that wraps the Optional < T > and provides an extra method , flatStream ( args ) . Note that you cannot extend Optional < T > : # pre You will see that I added flatStream ( args ) , as here : # pre Used as : String result = Stream . of ( args ) . map ( args ) . flatMap ( args ) . findFirst ( args ) . get ( args ) ; You still will need to return a Stream < T > here , as you cannot return T , because if ! optional . isPresent ( args ) , then T = = null if you declare it such , but then your . flatMap ( args ) would attempt to add null to a stream and that is not possible . As example : # pre Used as : String result = Stream . of ( args ) . map ( args ) . map ( args ) . findFirst ( args ) . get ( args ) ; Will now throw a NullPointerException inside the stream operations . Conclusion The method you used , is actually the best method .

Question - 11411022 , answer - 34052602 The best way is the clearest way : * Thread . currentThread ( args ) = = Looper . getMainLooper ( args ) . getThread ( args ) Or , if the runtime platform is API level 23 ( Marshmallow 6 . 0 ) or higher : Looper . getMainLooper ( args ) . isCurrentThread ( args ) See the Looper API . Note that calling Looper . getMainLooper ( args ) involves synchonization ( see the source ) . You might want to avoid the overhead by storing the return value and reusing it . * credit greg7gkb

Question - 13291076 , answer - 13291166 name ( args ) is a " built - in " method of enum . It is final and you cannot change its implementation . It returns the name of enum constant as it is written , e . g . in upper case , without spaces etc . Compare MOBILE _ PHONE _ NUMBER and Mobile phone number . Which version is more readable ? I believe the second one . This is the difference : name ( args ) always returns MOBILE _ PHONE _ NUMBER , toString ( args ) may be overriden to return Mobile phone number .

Question - 25222811 , answer - 26676046 To begin with ( and unrelated ) , instantiating the Application class by yourself does not seem to be its intended use . From what one can read from its source , you are rather expected to use the static instance returned by getApplication ( args ) . Now let ' s get to the error Eclipse reports . I ' ve ran into a similar issue recently : Access restriction : The method . . . is not API ( args ) . I called the method in question as a method of an object which inherited that method from a super class . All I had to do was to add the package the super class was in to the packages imported by my plugin . However , there is a lot of different causes for errors based on " restriction on required project / library " . Similar to the problem described above , the type you are using might have dependencies to packages that are not exported by the library or might not be exported itself . In that case you can try to track down the missing packages and export them my yourself , as suggested here , or try Access Rules . Other possible scenarios include : # li Eclipse wants to keep you from using available packages that are not part of the public Java API ( solution 1 , 2 ) # li Dependencies are satisfied by multiple sources , versions are conflicting etc . ( solution 1 , 2 , 3 ) # li Eclipse is using a JRE where a JDK is necessary ( which might be the case here , from what your errors say ; solution ) or JRE / JDK version in project build path is not the right one This ended up as more like a medley of restriction - related issues than an actual answer . But since restriction on required projects is such a versatile error to be reported , the perfect recipe is probably still to be found .

Question - 6416706 , answer - 6416788 As soon as you call contains , containsAll , equals , hashCode , remove , retainAll , size or toArray , you ' d have to traverse the elements anyway . If you ' re occasionally only calling methods such as isEmpty or clear I suppose you ' d be better of by creating the collection lazily . You could for instance have a backing ArrayList for storing previously iterated elements . I don ' t know of any such class in any library , but it should be a fairly simple exercise to write up .

Question - 6252678 , answer - 6252802 You need a DateTimeFormatter appropriate to the format you ' re using . Take a look at the docs for instructions on how to build one . Off the cuff , I think you need format = DateTimeFormat . forPattern ( args )

Question - 7520432 , answer - 27478241 = = can be used in many object types but you can use Object . equals for any type , especially Strings and Google Map Markers .

Question - 27949213 , answer - 27949367 The strategy they describe is to simply reuse the internal character array of one String in possibly many equal Strings . There ' s no need for each String to have its own copy if they are equal . In order to more quickly determine if 2 strings are equal , the hash code is used as a first step , as it is a fast way to determine if Strings may be equal . Hence their statement : # blockquote This is to make a certain ( but slower ) comparison for equality once possible equality has been determined using the hash code . In the end , equal Strings will share a single underlying char array . Java has had String . intern ( args ) for a long time , to do more or less the same ( i . e . save memory by deduplicating equal Strings ) . What ' s novel about this is that it happens during garbage collection time and can be externally controlled .

Question - 29333689 , answer - 29337734 My intuition in Python is to use the collections . Counter as a multiset : # pre So we have a list of integers from 0 - 99 twice except for 66 . # pre Which gets the least common ( last item ) from a list sorted by frequency . Such a function would be : # pre And usage : # pre This is a generalized solution that works for any number of items .

Question - 7032070 Assuming that arraylist is defined as ArrayList < T > arraylist , is arraylist . removeAll ( arraylist ) equivalent to arraylist . clear ( ) ? If so , can I assume that the clear ( args ) method is more efficient for emptying the array list ? Are there any caveats in using arraylist . removeAll ( args ) instead of arraylist . clear ( args ) ?

Question - 28724850 Running the following stream example in Java8 : System . out . println ( args ) ; yields : / a / b / c / d / e / f Which is - of course - no surprise . Due to # a it shouldn ' t matter whether the stream is executed sequentially or parallel : # blockquote AFAIK reduce ( args ) is deterministic and ( s1 , s2 ) - > s1 + StringLiteral + s2 is associative , so that adding parallel ( args ) should yield the same result : System . out . println ( args ) ; However the result on my machine is : / a / / b / / c / / d / / e / / f What ' s wrong here ? BTW : using ( the preferred ) . collect ( args ) instead of reduce ( args ) yields the same result a / b / c / d / e / f for sequential and parallel execution . JVM details : # pre

Question - 8579657 , answer - 8641412 Thread . start ( args ) code registers the Thread with scheduler and the scheduler calls the run ( args ) method . Also , Thread is class while Runnable is an interface .

Question - 23756966 While investigating for a little debate w . r . t . using StringLiteral + n and Integer . toString ( int ) to convert an integer primitive to a string I wrote this JMH microbenchmark : # pre I ran it with the default JMH options with both Java VMs that exist on my Linux machine ( up - to - date Mageia 4 64 - bit , Intel i7 - 3770 CPU , 32GB RAM ) . The first JVM was the one supplied with Oracle JDK 8u5 64 - bit : # pre With this JVM I got pretty much what I expected : # pre I . e . using the StringBuilder class is slower due to the additional overhead of creating the StringBuilder object and appending an empty string . Using String . format ( args ) is even slower , by an order of magnitude or so . The distribution - provided compiler , on the other hand , is based on OpenJDK 1 . 7 : # pre The results here were interesting : # pre Why does StringBuilder . append ( args ) appear so much faster with this JVM ? Looking at the StringBuilder class source code revealed nothing particularly interesting - the method in question is almost identical to Integer # toString ( args ) . Interestingly enough , appending the result of Integer . toString ( args ) ( the stringBuilder2 microbenchmark ) does not appear to be faster . Is this performance discrepancy an issue with the testing harness ? Or does my OpenJDK JVM contain optimizations that would affect this particular code ( anti ) - pattern ? EDIT : For a more straight - forward comparison , I installed Oracle JDK 1 . 7u55 : # pre The results are similar to those of OpenJDK : # pre It seems that this is a more general Java 7 vs Java 8 issue . Perhaps Java 7 had more aggressive string optimizations ? EDIT 2 : For completeness , here are the string - related VM options for both of these JVMs : For Oracle JDK 8u5 : # pre For OpenJDK 1 . 7 : # pre The UseStringCache option was removed in Java 8 with no replacement , so I doubt that makes any difference . The rest of the options appear to have the same settings . EDIT 3 : A side - by - side comparison of the source code of the AbstractStringBuilder , StringBuilder and Integer classes from the src . zip file of reveals nothing noteworty . Apart from a whole lot of cosmetic and documentation changes , Integer now has some support for unsigned integers and StringBuilder has been slightly refactored to share more code with StringBuffer . None of these changes seem to affect the code paths used by StringBuilder # append ( args ) , although I may have missed something . A comparison of the assembly code generated for IntStr # integerToString ( args ) and IntStr # stringBuilder0 ( args ) is far more interesting . The basic layout of the code generated for IntStr # integerToString ( args ) was similar for both JVMs , although Oracle JDK 8u5 seemed to be more aggressive w . r . t . inlining some calls within the Integer # toString ( args ) code . There was a clear correspondence with the Java source code , even for someone with minimal assembly experience . The assembly code for IntStr # stringBuilder0 ( args ) , however , was radically different . The code generated by Oracle JDK 8u5 was once again directly related to the Java source code - I could easily recognise the same layout . On the contrary , the code generated by OpenJDK 7 was almost unrecognisable to the untrained eye ( like mine ) . The new StringBuilder ( args ) call was seemingly removed , as was the creation of the array in the StringBuilder constructor . Additionaly , the disassembler plugin was not able to provide as many references to the source code as it did in JDK 8 . I assume that this is either the result of a much more aggressive optimization pass in OpenJDK 7 , or more probably the result of inserting hand - written low - level code for certain StringBuilder operations . I am unsure why this optimization does not happen in my JVM 8 implementation or why the same optimizations were not implemented for Integer # toString ( args ) in JVM 7 . I guess someone familiar with the related parts of the JRE source code would have to answer these questions . . .

Question - 27908213 , answer - 27908294 The Oracle documentation about Enum says ( first line ) : # blockquote If this is true then , yes , your enum1 . name ( args ) = = enum2 . name ( args ) is guaranteed to be true if the names are the same . Also , in the method name ( args ) javadoc : # blockquote For example , if you had two enums , Days and MyDays , where SUNDAY is a common value , = = between the enum object values , SUNDAY will return true as you are comparing two strings - see the working example in # a . # pre

Question - 6271417 , answer - 6271520 Try using this . getClass ( args ) . getCanonicalName ( args ) or this . getClass ( args ) . getSimpleName ( args ) . If it ' s an anonymous class , use this . getClass . getSuperclass . getName ( args )

Question - 27949213 Since String in Java ( like other languages ) consumes a lot of memory because each character consumes two bytes , Java 8 has introduced a new feature called String Deduplication which takes advantage of the fact that the char arrays are internal to strings and final , so the JVM can mess around with them . I have read this example so far but since I am not a pro java coder , I am having a hard time grasping the concept . Here is what it says , # blockquote My First question , There is still a lack of resources on this topic since it is recently added in Java 8 update 20 , could anyone here share some practical examples on how it help in reducing the memory consumed by String in Java ? Edit : The above link says , # blockquote My 2nd question , If hash code of two String are same then the Strings are already the same , then why compare them char by char once it is found that the two String have same hash code ?

Question - 22182669 , answer - 22222274 StackOverflowError occurs due to an application recurses too deeply ( This is not an answer you are expecting ) . Now other things to happen to StackOverflowError is keep calling methods from methods till you get StackOverflowError , but nobody can program to get StackOverflowError and even if those programmer are doing so then they are not following coding standards for cyclomatic complixity that every programmer has to understand while programming . Such reason for ' StackOverflowError ' will require much time to rectify it . But unknowingly coding one line or two line which causes StackOverflowError is understandable and JVM throws that and we can rectify it instantly . Here is my answer with picture for some other question .

Question - 22725537 The new Java 8 stream framework and friends make for some very concise java code , but I have come across a seemingly - simple situation that is tricky to do concisely . Consider a List < T > things and method Optional < T > resolve ( args ) . I want to map the Thing s to Optional < T > s and get the first Other . The obvious solution would be to use things . stream ( args ) . flatMap ( args ) . findFirst ( args ) , but flatMap requires that you return a stream , and Optional doesn ' t have a stream ( args ) method ( or is it a Collection or provide a method to convert it to or view it as a Collection ) . The best I can come up with is this : things . stream ( args ) . map ( args ) . filter ( args ) . map ( args ) . findFirst ( args ) ; But that seems awfully long - winded for what seems like a very common case . Anyone have a better idea ?

Question - 20129762 , answer - 30548433 I would like to point out that StreamEx does implement Iterable ( and Stream ) , as well as a host of other immensely awesome functionality missing from Stream .

Question - 12576156 , answer - 12576308 Have you considered @ Autowired ing the constructor or a setter and String . split ( args ) ing in the body ? # pre I tend to prefer doing my autowiring in one of these ways to enhance the testability of my code .

Question - 17489250 , answer - 17489394 It ' s a feature of the Java language . String literals in the source code is given special treatment . The language spec , here , simply says that a string literal is of String type

Question - 12146298 I would like to know what is the cleanest and best way to perform form validation of user inputs . I have seen some developers implement org . springframework . validation . Validator . A question about that : I saw it validates a class . Does the class have to be filled manually with the values from the user input , and then passed to the validator ? I am confused about the cleanest and best way to validate the user input . I know about the traditional method of using request . getParameter ( args ) and then manually checking for nulls , but I don ' t want to do all the validation in my Controller . Some good advice on this area will be greatly appreciated . I am not using Hibernate in this application .

Question - 13744450 The interviewer asked me : # blockquote I wasn ' t aware of these terms . So , when I came back to home , then I started looking into Google about Observer and Observable and found some point from different resources : # blockquote I found this example : # pre But I ' m still unable to figure out why do we need Observer and Observable ? What are the setChanged ( args ) and notifyObservers ( args ) methods for ?

Question - 20918650 , answer - 20918709 A subsequent post by the same user in the same conversation : # blockquote ( This was in response to a statement by another user , namely that " it seems in some situations ' new T ' would be better " , the idea being that new T ( args ) is impossible due to type erasure . ( This is debatable — even if T were available at runtime , it could be an abstract class or interface , or it could be Void , or it could lack a no - arg constructor , or its no - arg constructor could be private ( e . g . , because it ' s supposed to be a singleton class ) , or its no - arg constructor could specify a checked exception that the generic method does not catch or specify — but that was the premise . Regardless , it ' s true that without erasure you could at least write T . class . newInstance ( args ) , which handles those issues . ) ) This view , that types are isomorphic to propositions , suggests that the user has a background in formal type theory . ( S ) he very likely does not like " dynamic types " or " runtime - types " and would prefer a Java without downcasts and instanceof and reflection and so on . ( Think of a language like Standard ML , which has a very rich ( static ) type system and whose dynamic semantics do not depend on any type information whatsoever . ) It ' s worth keeping in mind , by the way , that the user is trolling : while ( s ) he likely sincerely prefers ( statically ) typed languages , ( s ) he is not sincerely trying to persuade others of that view . Rather , the main purpose of the original tweet was to mock those who disagree , and after some of those disagree - ers chimed in , the user posted follow - up tweets such as " the reason java has type erasure is that Wadler et al know what they are doing , unlike users of java " . Unfortunately , this makes it hard to find out what ( s ) he ' s actually thinking ; but fortunately , it also likely means that it ' s not very important to do so . People with actual depth to their views don ' t generally resort to trolls that are quite this content - free .

Question - 21488056 , answer - 36242382 You can use Predicates from Eclipse Collections # pre If you can ' t change the strings from List : # pre If you only need a negation of String . isEmpty ( args ) you can also use StringPredicates . notEmpty ( args ) . Note : I am a contributor to Eclipse Collections .

Question - 29095967 , answer - 29111023 Although there are several answers already , and an accepted answer , there are still a couple points missing from this topic . First , the consensus seems to be that solving this problem using streams is merely an exercise , and that the conventional for - loop approach is preferable . Second , the answers given thus far have overlooked an approach using array or vector - style techniques that I think improves the streams solution considerably . First , here ' s a conventional solution , for purposes of discussion and analysis : # pre This is mostly straightforward but there ' s a bit of subtlety . One point is that a pending sublist from prev to cur is always open . When we encounter null we close it , add it to the result list , and advance prev . After the loop we close the sublist unconditionally . Another observation is that this is a loop over indexes , not over the values themselves , thus we use an arithmetic for - loop instead of the enhanced " for - each " loop . But it suggests that we can stream using the indexes to generate subranges instead of streaming over values and putting the logic into the collector ( as was done by Joop Eggen ' s proposed solution ) . Once we ' ve realized that , we can see that each position of null in the input is the delimiter for a sublist : it ' s the right end of the sublist to the left , and it ( plus one ) is the left end of the sublist to the right . If we can handle the edge cases , it leads to an approach where we find the indexes at which null elements occur , map them to sublists , and collect the sublists . The resulting code is as follows : # pre Getting the indexes at which null occurs is pretty easy . The stumbling block is adding - 1 at the left and size at the right end . I ' ve opted to use Stream . of to do the appending and then flatMapToInt to flatten them out . ( I tried several other approaches but this one seemed like the cleanest . ) It ' s a bit more convenient to use arrays for the indexes here . First , the notation for accessing an array is nicer than for a List : indexes [ i ] vs . indexes . get ( args ) . Second , using an array avoids boxing . At this point , each index value in the array ( except for the last ) is one less than the beginning position of a sublist . The index to its immediate right is the end of the sublist . We simply stream over the array and map each pair of indexes into a sublist and collect the output . Discussion The streams approach is slightly shorter than the for - loop version , but it ' s denser . The for - loop version is familiar , because we do this stuff in Java all the time , but if you ' re not already aware of what this loop is supposed to be doing , it ' s not obvious . You might have to simulate a few loop executions before you figure out what prev is doing and why the open sublist has to be closed after the end of the loop . ( I initially forgot to have it , but I caught this in testing . ) The streams approach is , I think , easier to conceptualize what ' s going on : get a list ( or an array ) that indicates the boundaries between sublists . That ' s an easy streams two - liner . The difficulty , as I mentioned above , is finding a way to tack the edge values onto the ends . If there were a better syntax for doing this , e . g . , / / Java plus pidgin Scala int [ ] indexes = [ - 1 ] + + IntStream . range ( args ) . filter ( args ) + + [ input . size ( args ) ] ; it would make things a lot less cluttered . ( What we really need is array or list comprehension . ) Once you have the indexes , it ' s a simple matter to map them into actual sublists and collect them into the result list . And of course this is safe when run in parallel . UPDATE 2016 - 02 - 06 Here ' s a nicer way to create the array of sublist indexes . It ' s based on the same principles , but it adjusts the index range and adds some conditions to the filter to avoid having to concatenate and flatmap the indexes . # pre

Question - 16159203 , answer - 18258659 You have ordinary memory , the ' currentpos ' reference and the Point object and its fields behind it , shared between 2 threads , without synchronisation . Thus , there is no defined ordering between the writes that happen to this memory in the main thread and the reads in the created thread ( call it T ) . Main thread is doing the following writes ( ignoring the initial setup of point , will result in p . x and p . y having default values ) : # li to p . x # li to p . y # li to currentpos Because there is nothing special about these writes in terms of synchronisation / barriers , the runtime is free to allow the T thread see them occur in any order ( the main thread of course always sees writes and reads ordered according to programme order ) , and occur at any point between the reads in T . So T is doing : # li reads currentpos to p # li read p . x and p . y ( in either order ) # li compare , and take the branch # li read p . x and p . y ( either order ) and call System . out . println Given there ' s no ordering relationships between the writes in main , and the reads in T , there are clearly several ways this can produce your result , as T may see main ' s write to currentpos before the writes to currentpos . y or currentpos . x : # li It reads currentpos . x first , before the x write has occurred - gets 0 , then reads currentpos . y before the y write has occurred - gets 0 . Compare evals to true . The writes become visible to T . System . out . println is called . # li It reads currentpos . x first , after the x write has occurred , then reads currentpos . y before the y write has occurred - gets 0 . Compare evals to true . Writes become visible to T . . . etc . # li It reads currentpos . y first , before the y write has occurred ( 0 ) , then reads currentpos . x after the x write , evals to true . etc . and so on . . . There are a number of data races here . I suspect the flawed assumption here is thinking that the writes that result from this line are made visible across all the threads in the programme order of the thread executing it : currentPos = new Point ( args ) ; Java makes no such guarantee ( it ' d be terrible for performance ) . Something more must be added if your programme needs a guaranteed ordering of the writes relative to reads in other threads . Others have suggested making the x , y fields final , or alternatively making currentpos volatile . # li If you make the x , y fields final , then Java guarantees that the writes of their values will be seen to occur before the constructor returns , in all threads . Thus , as the assignment to currentpos is after the constructor , the T thread is guaranteed to see the writes in the correct order . # li If you make currentpos volatile , then Java guarantees that that this is a synchronisation point which will be total - ordered wrt other synchronisation points . As in main the writes to x and y must happen before the write to currentpos , then any read of currentpos in another thread must see also the writes of x , y that happened before . Using final has the advantage that it makes the fields immutable , and thus allows the values to be cached . Using volatile leads to synchronisation on every write and read of currentpos , which might hurt performance . See chapter 17 of the Java Language Spec for the gory details : # a ( Initial answer assumed a weaker memory model , as I was not sure the JLS guaranteed volatile was sufficient . Answer edited to reflect comment from assylias , pointing out the Java model is stronger - happens - before is transitive - and so volatile on currentpos also suffices ) .

Question - 10631715 , answer - 32362691 For completeness , using the Guava library , you ' d do : Splitter . on ( args ) . split ( args ) Another example : # pre Splitter . split ( args ) returns an Iterable , so if you need a List , wrap it in Lists . newArrayList ( args ) as above . Otherwise just go with the Iterable , for example : # pre Note how trimResults ( args ) handles all your trimming needs without having to tweak regexes for corner cases , as with String . split ( args ) . If your project uses Guava already , this should be your preferred solution . See Splitter documentation in Guava User Guide or the javadocs for more configuration options .

Question - 27845223 , answer - 27846417 Pavel Horal ' s answer is nice . As he says , the word " file " has totally different ( practically unrelated ) meanings in URL # getFile vs java . io . File - may be that ' s part of the confusion . Just to add : # li A resource in Java is an abstract concept , a source of data that can be read . The location ( or address ) of a resource is represented in Java by a URL object . # li A resource can correspond to a regular file in the local filesystem ( specifically , when its URL begins with file : / / ) . But a resource is more general ( it can be also some file stored in a jar , or some data to be read from the network , or from memory , or . . . ) . And it ' s also more limited , because a File ( besides being other things than a regular file : a directory , a link ) can also be created and writen to . # li Remember in Java a File object does not really represents " a file " but the location ( the full name , with path ) of a file . So , a File object allows you to locate ( and open ) a file , as a URL allows you to access ( and open ) a resource . ( There is no Resource class in Java to represent a resource , but neither there is one to represent a file ! once more : File is not a file , it ' s the path of a file ) .

Question - 32294367 , answer - 32294898 # blockquote Let me ask a counterquestion : why do you think Thread . stop ( args ) has been deprecated for more than a decade ? The reason why is precisely the negation of your statement above . To give two specific examples : you stop ( args ) a thread while it ' s executing something as innocuous - sounding as System . out . println ( args ) or Math . random ( args ) . Result : those two features are now broken for the entire JVM . The same pertains to any other synchronized code your application may execute . # blockquote The application may theoretically be coded such that absolutely no shared resource protected by locks is ever used ; however that will only help to point out the exact extent to which Java threads are codependent . And the " independence " achieved will only pertain to the request - processing threads , not to all threads in such an application .

Question - 7935858 I have prepared a simple code snippet in order to separate the erroneous portion from my web application . # pre I have tested it while building a web application JSF . I just want to know why in the above code temp . split ( args ) does not work . The statement , System . out . println ( args ) ; displays nothing on the console means that it doesn ' t go through the loop . When I change the argument of the temp . split ( args ) method to other characters , It works just fine as usual . What might be the problem ?

Question - 27504925 The Java language specification specifies that # blockquote So , considering arrays are objects — why did the Java designers make the decision not to allow inherit and override from it , for example , toString ( ) or equals ( args ) ? The current syntax wouldn ' t allow creating anonymous classes with an array as the base class , but I don ' t think that was the reason for their decision .

Question - 22382453 , answer - 22384113 Made up example Imagine that you want to create the following sequence : 1 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 4 etc . ( in other words : 1x1 , 2x2 , 3x3 etc . ) With flatMap it could look like : # pre where : # li IntStream . rangeClosed ( args ) creates a stream of int from 1 to 4 , inclusive # li IntStream . iterate ( args ) . limit ( args ) creates a stream of length i of int i - so applied to i = 4 it creates a stream : 4 , 4 , 4 , 4 # li flatMap " flattens " the stream and " concatenates " it to the original stream With Java < 8 you would need two nested loops : # pre Real world example Let ' s say I have a List < T > where each TimeSeries is essentially a Map < T > . I want to get a list of all dates for which at least one of the time series has a value . flatMap to the rescue : list . stream ( args ) . parallel ( args ) . flatMap ( args ) / / for each TS , stream dates and flatmap . distinct ( args ) / / remove duplicates . sorted ( args ) / / sort ascending . collect ( args ) ; Not only is it readable , but if you suddenly need to process 100k elements , simply adding parallel ( args ) will improve performance without you writing any concurrent code .

Question - 10977992 # pre We can use Iterator to traverse a Set or a List or a Map . But ListIterator can only be used to traverse a List , it can ' t traverse a Set . Why ? I know that the main difference is that with iterator we can travel in only one direction but with ListIterator we can travel both directions . Are there any other differences ? And any advantages of ListIterator over Iterator ?

Question - 6470651 , answer - 6470695 A simple thing to do is to use a HashSet with an incorrect ( or non - existent ) hashCode ( args ) or equals ( args ) , and then keep adding " duplicates " . Instead of ignoring duplicates as it should , the set will only ever grow and you won ' t be able to remove them . If you want these bad keys / elements to hang around you can use a static field like # pre

Question - 15655012 , answer - 24895623 First of all , the place in your code where you are initializing ( i . e . assigning for the first time ) foo is here : foo = new ArrayList ( args ) ; foo is an object ( with type List ) so it is a reference type , not a value type ( like int ) . As such , it holds a reference to a memory location ( e . g . 0xA7D2A834 ) where your List elements are stored . Lines like this foo . add ( args ) ; / / Modification - 1 do not change the value of foo ( which , again , is just a reference to a memory location ) . Instead , they just add elements into that referenced memory location . To violate the final keyword , you would have to try to re - assign foo as follows again : foo = new ArrayList ( args ) ; That would give you a compilation error . Now , with that out of the way , think about what happens when you add the static keyword . When you do NOT have the static keyword , each object that instantiates the class has its own copy of foo . Therefore , the constructor assigns a value to a blank , fresh copy of the foo variable , which is perfectly fine . However , when you DO have the static keyword , only one foo exists in memory that is associated with the class . If you were to create two or more objects , the constructor would be attempting to re - assign that one foo each time , violating the final keyword .

Question - 31922866 I ' ve read on many Web sites Optional should be used as a return type only , and not used in method arguments . I ' m struggling to find a logical reason why . For example I have a piece of logic which has 2 optional parameters . Therefore I think it would make sense to write my method signature like this ( solution 1 ) : # pre Many web pages specify Optional should not be used as method arguments . With this in mind I could use the following method signature and add a clear Javadoc comment specifying the arguments maybe null hoping future future maintainers will read the javadoc and therefore always carry out null checks prior to using the arguments ( solution 2 ) : # pre Alternatively I could replace my method with 4 public methods to provide a nicer interface and make it more obvious p1 and p2 are optional ( solution 3 ) : # pre Now I try writing the code of the class which invokes this piece of logic for each approach . I first retrieve the 2 input parameters from another object which returns optionals and then I invoke calculateSomething . Therefore if solution 1 is used the calling code would look like this : # pre if solution 2 is used the calling code would look like this : # pre if solution 3 is used I could use the code above or I could use the following ( but its a significant amount more code ) : # pre So my question is why is it considered bad practice to use Optionals as method arguments as in solution 1 ? It looks like the most readable solution to me and makes it most obvious that the parameters could be empty / null to future maintainers . ( I ' m aware the designers of Optional intended it to only be used as a return type , but I can ' t find any logical reasons not to use it in this scenario )

Question - 8725387 , answer - 8725518 Because the concept of a List is incompatible with the concept of an automatically sorted collection . The point of a List is that after calling list . add ( args ) , a call to list . get ( args ) will return elem . With an auto - sorted list , the element could end up in an arbitrary position .

Question - 5839359 , answer - 5839392 You ' re essentially running out of memory to run the process smoothly . Options that come to mind : # li Specify more memory like you mentioned , try something in between like - Xmx512m first # li Work with smaller batches of HashMap objects to process at once if possible # li If you have a lot of duplicate strings , use String . intern ( ) on them before putting them into the HashMap # li Use the HashMap ( int initialCapacity , float loadFactor ) constructor to tune for your case

Question - 34509566 , answer - 34529067 Keep in mind that Java holds a pool of all string literals found in program , used for matching purposes among others , so any different string literal concatenation above will lead to the same object , to the same string literal . You can check out this useful article for more . On the other hand , the concatenation of a String object and a literal ( case c + StringLiteral ) will lead to the creation of a as StringBuilder object at runtime , different to the literals found in pool .

Question - 18723596 String x = ( String ) null ; Why there is no exception in this statement ? # pre It prints null . But . toString ( args ) method should throw a null pointer exception .

Question - 23114015 I am wondering why the Iterable interface does not provide the stream ( args ) and parallelStream ( args ) methods . Consider the following class : # pre It is an implementation of a Hand as you can have cards in your hand while playing a Trading Card Game . Essentially it wraps a List < T > , ensures a maximum capacity and offers some other useful features . It is better as implementing it directly as a List < T > . Now , for convienience I thought it would be nice to implement Iterable < T > , such that you can use enhanced for - loops if you want to loop over it . ( My Hand class also provides a get ( args ) method , hence the Iterable < T > is justified in my opinion . ) The Iterable interface provides the following ( left out javadoc ) : # pre Now can you obtain a stream with : Stream < T > stream = StreamSupport . stream ( args ) ; So onto the real question : # li Why does Iterable < T > not provide a default methods that implement stream ( args ) and parallelStream ( args ) , I see nothing that would make this impossible or unwanted ? A related question I found is the following though : Why does Stream < T > not implement Iterable < T > ? Which is oddly enough suggesting it to do it somewhat the other way around .

Question - 10786042 , answer - 10786112 URLEncoder should be the way to go . You only need to keep in mind to encode only the individual query string parameter name and / or value , not the entire URL , for sure not the query string parameter separator character & nor the parameter name - value separator character = . # pre Note that spaces in query parameters are represented by + , not % 20 , which is legitimately valid . The % 20 is usually to be used to represent spaces in URI itself ( the part before the URI - query string separator character ? ) , not in query string ( the part after ? ) . Also note that there are two encode ( args ) methods . One without charset argument and another with . The one without charset argument is deprecated . Never use it and always specify the charset argument . The javadoc even explicitly recommends to use the UTF - 8 encoding , as mandated by RFC3986 and W3C . # blockquote See also : # li What every web developer must know about URL encoding

Question - 24630963 , answer - 32648397 I wrote a Collector which , unlike the default java one , does not crash when you have null values : # pre Just replace your Collectors . toMap ( args ) call to a call to this function and it ' ll fix the problem .

Question - 14636178 I am trying to use the org . springframework . orm . jdo . TransactionAwarePersistenceManagerFactoryProxy in my Spring project , but I am not sure how to use it or whether it ' s exactly what I am looking for . I realize it can help make my DAOs work with a plain JDO PersistenceManagerFactory . Another question is : what happens if the proxy doesn ' t get made properly ? Can I still use it to access my factory to create a transaction aware persistence manager ? If the object managed by the factory is a singleton , does this change things ? Why not just access the PersistenceManagerFactory directly ? Perhaps PersistenceManagerFactoryUtils . getPersistenceManager would be more suited to my needs ? Can getObject return null ?

Question - 7520432 , answer - 7520464 In general , the answer to your question is " yes " , but . . . # li equals will only compare what it is written to compare , no more , no less . # li if a class does not override the equals method , then it defaults to the equals ( args ) method of the closest parent class that has overridden this method . # li If no parent classes have provided an override , then it defaults to the method from the ultimate parent class , Object , and so you ' re left with the Object # equals ( args ) method . Per the Object API this is the same as = = ; that is , it returns true if and only if both variables refer to the same object , if their references are one and the same . Thus you will be testing for object equality and not functional equality . # li Always remember to override hashCode if you override equals so as not to " break the contract " . As per the API , the result returned from the hashCode ( args ) method for two objects must be the same if their equals methods shows that they are equivalent . The converse is not necessarily true .

Question - 19431234 Java 8 has a completely new API for date and time . One of the most useful classes in this API is LocalDateTime , for holding a timezone - independent date - with - time value . There are probably millions of lines of code using the legacy class java . util . Date for this purpose . As such , when interfacing old and new code there will be a need for converting between the two . As there seems to be no direct methods for accomplishing this , how can it be done ?

Question - 27683759 I just studied about generic programming , the List < T > interface , and ArrayList , so I can understand the statement below . ArrayList < T > list = new ArrayList < T > ( args ) ; But I don ' t understand the next statement which I saw while surfing the web . List < T > list2 = Collections . < String > emptyList ( args ) ; # li What is Collections ? Why isn ' t it Collections < T > or Collections < T > ? # li Why is < String > placed before the method name emptyList ? ( Isn ' t emptyList < T > ( args ) correct for Generic ? ) # li What does the statement mean ?

Question - 14376807 , answer - 22092971 For those looking for a general strategy for reading and writing a string to file : First , get a file object You ' ll need the storage path . For the internal storage , use : File path = context . getFilesDir ( args ) ; For the external storage ( SD card ) , use : File path = context . getExternalFilesDir ( args ) ; Then create your file object : File file = new File ( args ) ; Write a string to the file # pre Or with Google Guava Files . write ( args ) ; Read the file to a string # pre Or if you are using Google Guava String contents = Files . toString ( args ) ; For completeness I ' ll mention String contents = new Scanner ( args ) . useDelimiter ( args ) . next ( args ) ; which requires no libraries , but benchmarks 50 % - 400 % slower than the other options ( in various tests on my Nexus 5 ) . Notes For each of these strategies , you ' ll be asked to catch an IOException . The default character encoding on Android is UTF - 8 . If you are using external storage , you ' ll need to add to your manifest either : < uses - permission android : name = StringLiteral / > or < uses - permission android : name = StringLiteral / > Write permission implies read permission , so you don ' t need both .

Question - 26791441 , answer - 26796725 Swapping Only One Occurrence If there is only one occurrence of each of the swapable strings in the input , you can do the following : Before proceeding to any replace , get the indices of the occurrences of the words . After that we only replace the word found at these indexes , and not all occurrences . This solution uses StringBuilder and does not produce intermediate String s like String . replace ( args ) . One thing to note : if the swapable words have different lengths , after the first replace the second index might change ( if the 1st word occurs before the 2nd ) exactly with the difference of the 2 lengths . So aligning the second index will ensure this works even if we ' re swapping words with different lengths . # pre Swapping Arbitrary Number of Occurrences Analogous to the previous case we will first collect the indexes ( occurrences ) of the words , but in this case it will a list of integers for each word , not just one int . For this we will use the following utility method : # pre And using this we will replace the words with the other one by decreasing index ( which might require to alternate between the 2 swapable words ) so that we won ' t even have to correct the indices after a replace : # pre

Question - 22409102 , answer - 33501556 Double . equals distinguishes ± 0 . 0 in Java . ( There ' s also Float . equals . ) I ' m a bit surprised no - one has mentioned these , as they seem to me clearer than any method given so far !

Question - 4576352 , answer - 11325546 You can use str = str . replace ( args ) ; as mentioned before and you will be fine . For your information CharLiteral is not an empty ( or a valid ) character but CharLiteral is . So you could use str = str . replace ( args ) ; instead .

Question - 16148575 , answer - 16148619 use int as Object not as primitive type HashMap < T > myMap = new HashMap < T > ( args ) ;

Question - 5243754 What is the difference between getAttribute ( args ) and getParameter ( args ) methods within HttpServletRequest class ?

Question - 31471444 , answer - 31471530 You should not . The INTEGER _ ONE name is no more meaningful than 1 . If however this value has some other meaning ( for example , month in the year ) , then using a constant ( like Calendar . FEBRUARY ) will make your code clearer . I can guess that this constant in Commons Math library was created in Java 1 . 4 when there were no Integer cache and autoboxing , so it had sense in terms that you may reuse the same Integer object ( not primitive int ) in different places to save memory . So it was added for performance reasons , not for code clarity . Now it ' s obsolete : even if you need an Integer object , you can use Integer . valueOf ( args ) or implicit autoboxing and get the cached one .

Question - 7520432 , answer - 35399386 The String pool ( aka interning ) and Integer pool blur the difference further , and may allow you to use = = for objects in some cases instead of . equals This can give you greater performance ( ? ) , at the cost of greater complexity . E . g . : # pre Complexity tradeoff : the following may surprise you : # pre I advise you to stay away from such micro - optimization , and always use . equals for objects , and = = for primitives : # pre

Question - 8172420 , answer - 8172439 You can use Character . toString ( char ) . Note that this method simply returns a call to String . valueOf ( char ) , which also works . As others have noted , string concatenation works as a shortcut as well : String s = StringLiteral + CharLiteral ; But this compiles down to : String s = new StringBuilder ( args ) . append ( args ) . append ( args ) . toString ( args ) ; which is less efficient because the StringBuilder is backed by a char [ ] ( over - allocated by StringBuilder ( ) to 16 ) , only for that array to be defensively copied by the resulting String . String . valueOf ( args ) " gets in the back door " by wrapping the char in a single - element array and passing it to the package private constructor String ( char [ ] , boolean ) , which avoids the array copy .

Question - 4576352 I can use this : # pre Is there a way to remove all occurrences of character X from a String in Java ? I tried this and is not what I want : str . replace ( args ) ; / / replace with space

Question - 21488056 , answer - 30506585 Predicate has methods and , or and negate . However , String : : isEmpty is not a Predicate . It could as well be Function < T > or MyProprietaryClass . The type information is inferred from the variable or the call . So , you need to cast a method reference explicitly ( as @ axtavt mentioned ) : ( ( Predicate < T > ) String : : isEmpty ) . negate ( args ) But it ' s absolutely ugly and Predicate seems to use lambdas under the hood anyway . So I think you are better off writing a lambda or even your own not ( args ) method ( e . g . in utility , static import ) .

Question - 4576352 , answer - 4576367 using public String replaceAll ( args ) will work usage would be str . replace ( args ) ; executing StringLiteral . replaceAll ( args ) ; returns : lakjsdf xx

Question - 20358883 , answer - 20358917 Very simply : Arrays . asList ( args )

Question - 25168062 Why is i + + not atomic in Java ? To get a bit deeper in Java I tried to count how often the loop in threads are executed . So I used a private static int total = 0 ; in the main class . I have two threads . # li Thread 1 : Prints System . out . println ( args ) ; # li Thread 2 : Prints System . out . println ( args ) ; And I count the lines printed by thread 1 and thread 2 . But the lines of thread 1 + lines of thread 2 don ' t match the total number of lines printed out . Here is my code : # pre

Question - 6992608 , answer - 6992643 There ' s no built in type for ConcurrentHashSet because you can always derive a set from a map . Since there are many types of maps , you use a method to produce a set from a given map ( or map class ) . Prior to Java 8 , you produce a concurrent hash set backed by a concurrent hash map , by using Collections . newSetFromMap ( map ) In Java 8 ( pointed out by @ Matt ) , you can get a concurrent hash set view via ConcurrentHashMap . newKeySet ( ) . This is a bit simpler than the old newSetFromMap which required you to pass in an empty map object . But it is specific to ConcurrentHashMap . Anyway , the Java designers could have created a new set interface every time a new map interface was created , but that pattern would be impossible to enforce when third parties create their own maps . It is better to have the static methods that derive new sets ; that approach always works , even when you create your own map implementations .

Question - 27430092 , answer - 27430172 A possible use case is in testing primality of a given number ( at test which in itself has many uses ) . The isProbablePrime algorithm will run much faster than an exact algorithm , so if the number fails isProbablePrime , then one need not go to the expense of running the more expensive algorithm .

Question - 15182496 The following print statement would print " hello world " . Could anyone explain this ? System . out . println ( args ) ; And randomString ( args ) looks like this : # pre

