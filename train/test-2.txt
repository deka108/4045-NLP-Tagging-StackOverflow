Question - 6667243 What is the best way to use the values stored in an Enum as String literals ? For example : # pre Then later I could use Mode . mode1 to return its string representation as mode1 . Without having to keep calling Mode . model . toString ( args ) .

Question - 27908213 , answer - 27908302 With strings you ' re going to want to use the equals method of Strings . That aside , you already have the enum that you could compare with the equality operator . Under what scenario would this arise ? That being said , yes , the . equals method will return true if they are the same . I ' m not sure about equality operator , and without looking it up , I can tell you that it ' s poor programming to use it if it is .

Question - 6802483 , answer - 6802523 There is no direct way to do this - Java has no Map literals ( yet - I think they were proposed for Java 8 ) . Some people like this : # pre This creates an anonymous subclass of HashMap , whose instance initializer puts these values . ( By the way , a map can ' t contain twice the same value , your second put will overwrite the first one . I ' ll use different values for the next examples . ) The normal way would be this ( for a local variable ) : # pre If your test map is an instance variable , put the initialization in a constructor or instance initializer : # pre If your test map is a class variable , put the initialization in a static initializer : # pre If you want your map to never change , you should after the initialization wrap your map by Collections . unmodifiableMap ( args ) . You can do this in a static initializer too : # pre ( I ' m not sure if you can now make test final . . . try it out and report here . )

Question - 29922296 , answer - 29922469 My guess is that enums are limited in size ( i . e the size is not limited by language but limited by usage ) and thus they don ' t need a native stream api . Streams are very good when you have to manipulate transform and recollect the elements in a stream ; these are not common uses case for Enum ( usually you iterate over enum values , but rarely you need to transform , map and collect them ) . If you need only to do an action over each elements perhaps you should expose only a forEach method # pre

Question - 23699371 , answer - 34731808 You can use the distinct ( args ) method in Eclipse Collections . # pre If you can refactor persons to implement an Eclipse Collections interface , you can call the method directly on the list . # pre HashingStrategy is simply a strategy interface that allows you to define custom implementations of equals and hashcode . # pre Note : I am a committer for Eclipse Collections .

Question - 12544479 I am looking for the easiest and simplest way to bind and convert data in Spring MVC . If possible , without doing any xml configuration . So far I ' ve been using PropertyEditors like so : # pre and # pre It is simple : both conversion are defined in the same class , and the binding is straightforward . If I wanted to do a general binding across all my controllers , I could still add 3 lines in my xml config . But Spring 3 . x introduced a new way to do it , using Converters : # blockquote So let ' s say I want to use Converters because it is " the latest alternative " . I would have to create two converters : # pre First drawback : I have to make two classes . Benefit : no need to cast thanks to genericity . Then , how do I simply data bind the converters ? Second drawback : I haven ' t found any simple way ( annotations or other programmatic facilities ) to do it in a controller : nothing like someSpringObject . registerCustomConverter ( args ) ; . The only ways I ' ve found would be tedious , not simple , and only about general cross - controller binding : # li XML config : # pre # li Java config ( only in Spring 3 . 1 + ) : # pre With all these drawbacks , why using Converters ? Am I missing something ? Are there other tricks that I am not aware of ? I am tempted to go on using PropertyEditors . . . Binding is much easier and quicker .

Question - 24885223 , answer - 29841832 Thanks to @ marmor , I updated my answer . I think it ' s a good solution to handle the onClick ( ) in the ViewHolder class constructor and pass it to the parent class via OnItemClickListener interface . MyAdapter . java # pre Usage of adapter in other classes : MyFragment . java # pre

Question - 8157755 , answer - 8157791 If you want the value you are assigning in the constructor , you need to add a method in the enum definition to return that value . If you want a unique number that represent the enum value , you can use ordinal ( args ) .

Question - 17489250 , answer - 17489334 Text inside double quotes creates a literal String object . String myString = StringLiteral ; The code above creates a String object , using double quotes .

Question - 12317668 , answer - 12375312 Here we are faced with a bug in the JIT - compiler . Compiler determines that the allocated array is filled after allocation in Arrays . fill ( args ) , but the check for uses between the allocation and the fill is faulty . So , compiler performs an illegal optimization - it skips zeroing of allocated array . This bug is placed in Oracle bug tracker ( bug id 7196857 ) . Unfortunately , I did not wait for any clarifications from Oracle about the following points . As I see , this bug is OS - specific : it absolutely reproducible on 64 - bit Linux and Mac , but , as I see from comments , it reproduces not regularly on Windows ( for similar versions of JDK ) . Additionally it would be nice to know when this bug will be fixed . There is only advice at the moment : do not use JDK1 . 7 . 0 _ 04 or later if you depend on JLS for newly declared arrays . Update at October 5 : In the new Build 10 of the JDK 7u10 ( early access ) released at October 04 , 2012 , this bug was fixed at least for Linux OS ( I did not test for other ) . Thanks to @ Makoto , who found that this bug is no longer available for public access in Oracle bug database . Unfortunately , I do not know for the reasons Oracle removed it from public access , but it is available in Google cache . Also , this bug has caught the attention of Redhat : the CVE identifiers CVE - 2012 - 4420 ( bugzilla ) and CVE - 2012 - 4416 ( bugzilla ) were assigned to this flaw .

Question - 6684665 , answer - 6684852 What Arrays . toString ( args ) does is create a string representation of each individual byte in your byteArray . Please check the API documentation Arrays API To convert your response string back to the original byte array , you have to use split ( args ) or something and convert it into a collection and then convert each individual item in there to a byte to recreate your byte array .

Question - 23699371 , answer - 23733628 The easiest way to implement this is to jump on the sort feature as it already provides an optional Comparator which can be created using an element ’ s property . Then you have to filter duplicates out which can be done using a statefull Predicate which uses the fact that for a sorted stream all equal elements are adjacent : # pre Of course , a statefull Predicate is not thread - safe , however if that ’ s your need you can move this logic into a Collector and let the stream take care of the thread - safety when using your Collector . This depends on what you want to do with the stream of distinct elements which you didn ’ t tell us in your question .

Question - 6271417 , answer - 6271668 I ' m assuming this is happening for an anonymous class . When you create an anonymous class you actually create a class that extends the class whose name you got . The " cleaner " way to get the name you want is : If your class is an anonymous inner class , getSuperClass ( args ) should give you the class that it was created from . If you created it from an interface than you ' re sort of SOL because the best you can do is getInterfaces ( args ) which might give you more than one interface . The " hacky " way is to just get the name with getClassName ( args ) and use a regex to drop the $ 1 .

Question - 33804394 , answer - 33814549 In this sort of situation I would write # pre Interestingly you say that the " try statement will never fail " , but you still took the trouble to write a statement e . printStackTrace ( args ) ; that you claim will never be executed . Why ? Perhaps your belief is not that firmly held . That is good ( in my opinion ) , since your belief is not based on the code you wrote , but rather on the expectation that your client will not violate the precondition . Better to program public methods defensively . By the way , your code won ' t compile for me . You can ' t call a . clone ( args ) even if the type of a is Cloneable . At least Eclipse ' s compiler says so . Expression a . clone ( args ) gives error # blockquote What I would do for your specific case is # pre Where PubliclyCloneable is defined by # pre Or , if you absolutely need the parameter type to be Cloneable , the following at least compiles . # pre

Question - 7935858 , answer - 7935873 java . lang . String . split splits on regular expressions , and . in a regular expression means " any character " . Try temp . split ( args ) .

Question - 32164385 , answer - 32167166 # blockquote I must agree with other answers that there is no direct way to determine that method will modify your object or not and yes to make sure that method can not modify your Object you all have to do it is from your side . # blockquote Here the method name comes to the scene . Moving ahead with the naming convention of method we have to take a look at some method declarations which clearly convince you that your Object will not be changed at all . For example , You know that Arrays . copyOf will not change your actual array , System . out . println ( args ) will not change your boo Method names are real weapons to provide as much information as possible to the method user . ( Yes ! it ' s always not possible but quite a good practice to follow . ) Let ' s consider it in your case that say printBoo will only print , copyBoo will only copy , clearBoo will reset all attributes , checkAndCreateNewBoo will check your boo Object and create new if required . So , ultimately if we can use them in a proper way caller can be assured with the fact that Object will remain the same after calling the method .

Question - 5175728 , answer - 5175900 It depends on what form of date / time you want : # li If you want the date / time as a single numeric value , then System . currentTimeMillis ( args ) gives you that , expressed as the number of milliseconds after the UNIX epoch ( as a Java long ) . This value is a delta from a UTC time - point , and is independent of the local time - zone . . . assuming that the system clock has been set correctly . # li If you want the date / time in a form that allows you to access the components ( year , month , etc ) numerically , you could use one of the following : # li new Date ( args ) gives you a Date object initialized with the current date / time . The problem is that the Date API methods are mostly flawed . . . and deprecated . # li Calendar . getInstance ( args ) gives you a Calendar object initialized with the current date / time , using the default Locale and TimeZone . Other overloads allow you to use a specific Locale and / or TimeZone . Calendar works . . . but the APIs are still cumbersome . # li new org . joda . time . DateTime ( args ) gives you a Joda - time object initialized with the current date / time , using the default time zone and chronology . There are lots of other Joda alternatives . . . too many to describe here . # li in Java 8 , calling LocalDateTime . now ( args ) and ZonedDateTime . now ( args ) will give you representations for the current date / time . Prior to Java 8 , most people who know about these things recommended Joda - time as having ( by far ) the best Java APIs for doing things involving time point and duration calculations . With Java 8 , this is no longer true . However , if you are already using Joda time in your codebase , there is no strong reason to migrate .

Question - 21242110 , answer - 27378709 Better way is : # pre Advantages of this version : # li works regardless the input is an instance of java . util . Date or it ' s subclass java . sql . Date ( unlike @ JodaStephen ' s way ) . This is common with JDBC originated data . java . sql . Date . toInstant ( args ) always throws an exception . # li it ' s the same for JDK8 and JDK7 with JSR - 310 backport I personally use an utility class ( but this is not backport - compatible ) : # pre The asLocalDate ( args ) method here is null - safe , uses toLocalDate ( args ) , if input is java . sql . Date ( it may be overriden by the JDBC driver to avoid timezone problems or unnecessary calculations ) , otherwise uses the abovementioned method .

Question - 8725387 , answer - 8725470 List iterators guarantee first and foremost that you get the list ' s elements in the internal order of the list ( aka . insertion order ) . More specifically it is in the order you ' ve inserted the elements or on how you ' ve manipulated the list . Sorting can be seen as a manipulation of the data structure , and there are several ways to sort the list . I ' ll order the ways in the order of usefulness as I personally see it : 1 . Consider using Set or Bag collections instead NOTE : I put this option at the top because this is what you normally want to do anyway . A sorted set automatically sorts the collection at insertion , meaning that it does the sorting while you add elements into the collection . It also means you don ' t need to manually sort it . Furthermore if you are sure that you don ' t need to worry about ( or have ) duplicate elements then you can use the TreeSet < T > instead . It implements SortedSet and NavigableSet interfaces and works as you ' d probably expect from a list : # pre If you don ' t want the natural ordering you can use the constructor parameter that takes a Comparator < T > . Alternatively you can use Multisets ( also known as Bags ) , that is a Set that allows duplicate elements , instead and there are third party implementations of them . Most notably from the Guava libraries there is a TreeMultiset , that works a lot like the TreeSet . 2 . Sort your list with Collections . sort ( args ) As mentioned above , sorting of List s is an manipulation of the data structure . So for situations where you need " one source of truth " that will be sorted in a variety of ways then sorting it manually is the way to go . You can sort your list with the java . util . Collections . sort ( ) method . Here is a code sample on how : # pre Using comparators One clear benefit is that you may use Comparator in the sort method . Java also provides some implementations for the Comparator such as the Collator which is useful for locale sensitive sorting strings . Here is one example : # pre Sorting in concurrent environments Do note though that using the sort method is not friendly in concurrent environments , since the collection instance will be manipulated , and you should consider using immutable collections instead . This is something Guava provides in the Ordering class and is a simple one - liner : List < T > sorted = Ordering . natural ( args ) . sortedCopy ( args ) ; 3 . Wrap your list with java . util . PriorityQueue Though there is no sorted list in Java there is however a sorted queue which would probably work just as well for you . It is the java . util . PriorityQueue class . Nico Haase linked in the comments to a related question that also answers this . In a sorted collection you most likely don ' t want to manipulate the internal data structure which is why PriorityQueue doesn ' t implement the List interface ( because that would give you direct access to it ' s elements ) . Caveat on the PriorityQueue iterator The PriorityQueue class implements the Iterable < T > and Collection < T > interfaces so it can be iterated as usual . However the iterator is not guaranteed to return elements in the sorted order . Instead ( as Alderath points out in the comments ) you need to poll ( args ) the queue until empty . Note that you can convert a list to a priority queue via the constructor that takes any collection : # pre 4 . Write your own SortedList class NOTE : You shouldn ' t have to do this . You can write your own List class that sorts each time you add a new element . This can get rather computation heavy depending on your implementation and is pointless , unless you want to do it as an exercise , because of two main reasons : # li It breaks the contract that List < T > interface has , because the add methods should ensure that the element will reside in the index that the user specifies . # li Why reinvent the wheel ? You should be using the TreeSet or Multisets instead as pointed out in the first point above . However if you want to do it as an exercise here is a code sample to get you started , it uses the AbstractList abstract class : # pre Note that if you haven ' t overridden the methods you need , then the default implementations from AbstractList will throw UnsupportedOperationException s .

Question - 32323081 , answer - 32323641 First of all , you don ' have to overload : D - overloading is never a necessity ; use 2 different method names , e . g . foo and fooX Secondly , I don ' t see why you need 2 methods here . If you want to handle checked and unchecked exceptions differently , it can be done at runtime . To achieve " exception transparency " , you can do # pre Finally , disambiguity can be achieved throw lambda return type ; the compiler uses the return type as if using an argument type for choosing the most specific method . This gives us the idea to wrap the value together with the exception type , as Result < T > , a " monad " as they say . # pre

Question - 5778658 , answer - 5778863 An OutputStream is one where you write data to . If some module exposes an OutputStream , the expectation is that there is something at the other end that is reading . Something that exposes an InputStream on the other hand is indicating that you will need to listen to this stream , and there will be data that you can read . So it is possible to connect an InputStream to an OutputStream InputStream - - - - read - - - > intermediateBytes [ n ] - - - - write - - - - > OutputStream As someone metioned , this is what the copy ( args ) method from IOUtils lets you do . It does not make sense to go the other way . . . hopefully this makes some sense UPDATE : Of course the more I think of this , the more I can see how this actually would be a requirement . I know some of the comments mentioned Piped input / ouput streams , but there is another possibility . If the output stream that is exposed is a ByteArrayOutputStream , then you can always get the full contents by calling the toByteArray ( args ) method . Then you can create an input stream wrapper by using the ByteArrayInputStream sub - class . These two are pseudo - streams , they both basically just wrap an array of bytes . Using the streams this way , therefore , is technically possible , but to me it is still very strange . . .

Question - 22740464 I can add streams or extra elements , like this : Stream stream = Stream . concat ( stream1 , Stream . concat ( args ) ; And I can add new stuff as I go , like this : Stream stream = Stream . concat ( args ) . filter ( args ) ; But this is ugly , because concat is static . If concat were an instance method , the above examples would be much easier to read : Stream stream = stream1 . concat ( args ) . concat ( args ) ; And Stream stream = stream1 . filter ( args ) . concat ( args ) . filter ( args ) . concat ( args ) . filter ( args ) ; My question is : 1 ) Is there any good reason why concat is static ? Or is there some equivalent instance method I ' m missing ? 2 ) In any case , is there a better way of doing this ?

Question - 25903137 , answer - 25903190 # pre It ' s not quite as nice as the list code . You can ' t construct new Map . Entry s in a map ( args ) call so the work is mixed into the collect ( args ) call .

Question - 16159203 , answer - 16323196 # blockquote currentPos = new Point ( args ) ; does a few things , including writing default values to x and y ( 0 ) and then writing their initial values in the constructor . Since your object is not safely published those 4 write operations can be freely reordered by the compiler / JVM . So from the perspective of the reading thread , it is a legal execution to read x with its new value but y with its default value of 0 for example . By the time you reach the println statement ( which by the way is synchronized and therefore does influence the read operations ) , the variables have their initial values and the program prints the expected values . Marking currentPos as volatile will ensure safe publication since your object is effectively immutable - if in your real use case the object is mutated after construction , volatile guarantees won ' t be enough and you could see an inconsistent object again . Alternatively , you can make the Point immutable which will also ensure safe publication , even without using volatile . To achieve immutability , you simply need to mark x and y final . As a side note and as already mentioned , synchronized ( args ) { } can be treated as a no - op by the JVM ( I understand you included it to reproduce the behaviour ) .

Question - 5374311 , answer - 17909839 The correct way to do this is : String [ ] stockArr = stock _ list . toArray ( args ) ; I ' d like to add to the other great answers here and explain how you could have used the Javadocs to answer your question . The Javadoc for toArray ( args ) ( no arguments ) is here . As you can see , this method returns an Object [ ] and not String [ ] which is an array of the runtime type of your list : # blockquote Right below that method , though , is the Javadoc for toArray ( args ) . As you can see , this method returns a T [ ] where T is the type of the array you pass in . At first this seems like what you ' re looking for , but it ' s unclear exactly why you ' re passing in an array ( are you adding to it , using it for just the type , etc ) . The documentation makes it clear that the purpose of the passed array is essentially to define the type of array to return ( which is exactly your use case ) : # blockquote Of course , an understanding of generics ( as described in the other answers ) is required to really understand the difference between these two methods . Nevertheless , if you first go to the Javadocs , you will usually find your answer and then see for yourself what else you need to learn ( if you really do ) . Also note that reading the Javadocs here helps you to understand what the structure of the array you pass in should be . Though it may not really practically matter , you should not pass in an empty array like this : String [ ] stockArr = stockList . toArray ( args ) ; Because , from the doc , this implementation checks if the array is large enough to contain the collection ; if not , it allocates a new array of the correct size and type ( using reflection ) . There ' s no need for the extra overhead in creating a new array when you could easily pass in the size . As is usually the case , the Javadocs provide you with a wealth of information and direction . Hey wait a minute , what ' s reflection ?

Question - 31922866 , answer - 31923105 Oh , those coding styles are to be taken with a bit of salt . # li ( + ) Passing an Option result to another method , without any semantic analysis ; leaving that to the method , is quite alright . # li ( - ) Using Optional parameters causing conditional logic inside the methods is literally contra - productive . # li ( - ) Needing to pack an argument in an Optional , is suboptimal for the compiler , and does an unnecessary wrapping . # li ( - ) In comparison to nullable parameters Optional is more costly . In general : Optional unifies two states , which have to be unraveled . Hence better suited for result than input , for the complexity of the data flow .

Question - 20877086 , answer - 20877161 Integer objects caches between - 128 and 127 of 256 Integer You should not compare object references with = = or ! = . You should use . equals ( . . ) instead , or better - use the primitive int rather than Integer . parseInt : Parses the string argument as a signed decimal integer . The characters in the string must all be decimal digits , except that the first character may be an ASCII minus sign ' - ' ( ' \ u002D ' ) to indicate a negative value . The resulting integer value is returned , exactly as if the argument and the radix 10 were given as arguments to the parseInt ( java . lang . String , int ) method . valueOf Returns an Integer object holding the value extracted from the specified String when parsed with the radix given by the second argument . The first argument is interpreted as representing a signed integer in the radix specified by the second argument , exactly as if the arguments were given to the parseInt ( java . lang . String , int ) method . The result is an Integer object that represents the integer value specified by the string . equivalent to new Integer ( args ) radix - the radix to be used in interpreting s so if you equal Integer . valueOf ( args ) for the integer inbetween - 128 to 127 it returns true in your condition for lesser than - 128 and greater than 127 it gives false

Question - 29140402 I have a class defined as follows : # pre I tried to print an instance of my class : System . out . println ( args ) ; but I got the following output : com . foo . Person @ 2f92e0f4 . A similar thing happened when I tried to print an array of Person objects : # pre I got the output : [ Lcom . foo . Person ; @ 28a418fc What does this output mean ? How do I change this output so it contains the name of my person ? And how do I print collections of my objects ? Note : this is intended as a canonical Q & A about this subject .

Question - 24547673 , answer - 24547831 It ' s a curious omission . You would have to mark the field as transient and provide your own custom writeObject ( args ) method that wrote the get ( args ) result itself , and a readObject ( args ) method that restored the Optional by reading that result from the stream . Not forgetting to call defaultWriteObject ( args ) and defaultReadObject ( args ) respectively .

Question - 6667243 , answer - 25575077 You could override the toString ( args ) method for each enum value . Example : # pre Usage : # pre

Question - 26791441 , answer - 26791826 Search for the first word to be replaced . If it ' s in the string , recurse on the the part of the string before the occurrence , and on the part of the string after the occurrence . Otherwise , continue with the next word to be replaced . A naive implementation might look like this # pre Sample usage : # pre Output : Once upon a foo , there was a bar and a baz . A less - naive version : # pre Unfortunately , Java ' s String has no indexOf ( args ) method . I ' ve omitted the implementation of indexOf here as I ' m not certain it ' s correct , but it can be found on ideone , along with some rough timings of various solutions posted here .

Question - 15336477 All I ' m trying to do is download some JSON and deserialize it into an object . I haven ' t got as far as downloading the JSON yet . Almost every single HttpClient example I can find , including those on the apache site looks something like . . . # pre However , Netbeans tells me that DefaultHttpClient is deprecated . I ' ve tried googling for DefaultHttpClient deprecated and as many other variations as I can think of and can ' t find any useful results , so I ' m obviously missing something . What is the correct Java7 way to download the contents of a webpage ? Is there really no decent Http Client as part of the language ? I find that hard to believe . My Maven dependency for this is . . . # pre

Question - 5554217 , answer - 17300003 Another way is to use an array as a type , e . g . : MyClass [ ] mcArray = gson . fromJson ( args ) ; This way you avoid all the hassle with the Type object , and if you really need a list you can always convert the array to a list by : List < T > mcList = Arrays . asList ( args ) ; IMHO this is much more readable . And to make it be an actual list ( that can be modified , see limitations of Arrays . asList ( args ) ) then just do the following : List < T > mcList = new ArrayList < T > ( args ) ;

Question - 10796160 , answer - 10796174 You need test . split ( args ) ; split uses regular expression and in regex | is metacharacter representing OR operator . You need to escape that character using \ ( written in String as StringLiteral since \ is also metacharacter in String literals and require another \ to escape it ) . You can also use test . split ( args ) ; and let Pattern . quote create escaped version of regex representing | .

Question - 11821801 , answer - 36827191 From oracle documentation page about ReentrantLock : # blockquote # li A ReentrantLock is owned by the thread last successfully locking , but not yet unlocking it . A thread invoking lock will return , successfully acquiring the lock , when the lock is not owned by another thread . The method will return immediately if the current thread already owns the lock . # li The constructor for this class accepts an optional fairness parameter . When set true , under contention , locks favor granting access to the longest - waiting thread . Otherwise this lock does not guarantee any particular access order . ReentrantLock key features as per this article # li Ability to lock interruptibly . # li Ability to timeout while waiting for lock . # li Power to create fair lock . # li API to get list of waiting thread for lock . # li Flexibility to try for lock without blocking . You can use ReentrantReadWriteLock . ReadLock , ReentrantReadWriteLock . WriteLock to further acquire control on granular locking on read and write operations . Have a look at this article by Benjamen on usage of different type of ReentrantLocks

Question - 16148575 , answer - 32866218 The main reason with HashMap not allowing primitive as keys is that HashMap is designed in such a way that for comparing the keys , it makes use of equals ( ) method , and a method can be called only on an object not on a primitive . Thus when int is autoboxed to Integer , Hashmap can call equals ( ) method on Integer object . That is why , you should use Integer instead of int . I mean hashmap throws an error while putting int as a key ( Don ' t know the meaning of the error that is thrown ) And if you think that , you can make Map performance faster by making a primitive as a key , there is a library called FastUtil which contains a Map implementation with int type as a key . Because of this , it is much faster than Hashmap

Question - 24676877 , answer - 24679745 The answer is , as always , " it depends " . It depends on how big the returned collection will be . It depends on whether the result changes over time , and how important consistency of the returned result is . And it depends very much on how the user is likely to use the answer . First , note that you can always get a Collection from a Stream , and vice versa : / / If API returns Collection , convert with stream ( args ) getFoo ( args ) . stream ( args ) . . . / / If API returns Stream , use collect ( args ) Collection < T > c = getFooStream ( args ) . collect ( args ) ; So the question is , which is more useful to your callers . If your result might be infinite , there ' s only one choice : Stream . If your result might be very large , you probably prefer Stream , since there may not be any value in materializing it all at once , and doing so could create significant heap pressure . If all the caller is going to do is iterate through it ( search , filter , aggregate ) , you should prefer Stream , since Stream has these built - in already and there ' s no need to materialize a collection ( especially if the user might not process the whole result . ) This is a very common case . Even if you know that the user will iterate it multiple times or otherwise keep it around , you still may want to return a Stream instead , for the simple fact that whatever Collection you choose to put it in ( e . g . , ArrayList ) may not be the form they want , and then the caller has to copy it anyway . if you return a stream , they can do collect ( args ) and get it in exactly the form they want . The above " prefer Stream " cases mostly derive from the fact that Stream is more flexible ; you can late - bind to how you use it without incurring the costs and constraints of materializing it to a Collection . The one case where you must return a Collection is when there are strong consistency requirements , and you have to produce a consistent snapshot of a moving target . Then , you will want put the elements into a collection that will not change . So I would say that most of the time , Stream is the right answer - - it is more flexible , it doesn ' t impose usually - unnecessary materialization costs , and can be easily turned into the Collection of your choice if needed . But sometimes , you may have to return a Collection ( say , due to strong consistency requirements ) , or you may want to return Collection because you know how the user will be using it and know this is the most convenient thing for them .

Question - 26791441 , answer - 26826286 It ' s easy to write a method to do this using String . regionMatches : # pre Testing : # pre Output : # blockquote It is not immediately obvious , but a function like this can still be dependent on the order in which the replacements are specified . Consider : # pre Output : # blockquote But reverse the replacements : truth + = StringLiteral + simultaneousReplace ( args ) ; Output : # blockquote Oops ! : ) Therefore it is sometimes useful to make sure to look for the longest match ( as PHP ' s strtr function does , for example ) . This version of the method will do that : # pre Note that the above methods are case - sensitive . If you need a case - insensitive version it is easy to modify the above because String . regionMatches can take an ignoreCase parameter .

Question - 16252269 , answer - 30210459 Collections . sort allows you to pass an instance of a Comparator which defines the sorting logic . So instead of sorting the list in natural order and then reversing it , one can simply pass Collections . reverseOrder ( args ) to sort in order to sort the list in reverse order : # pre As mentioned by @ Marco13 , apart from being more idiomatic ( and possibly more efficient ) , using the reverse order comparator makes sure that the sort is stable ( meaning that the order of elements will not be changed when they are equal according to the comparator , whereas reversing will change the order )

Question - 27482579 , answer - 27483288 # blockquote No . It will never throw a compilation error . This is much similar to what a simple getter and setter does or a copy constructor does . Remember we can access private members using this . # pre Your testPrivate method accepts an instance of MyClass . Since testPrivate is a method inside MyClass , it will have access to private properties . # pre Methods defined inside the class will always have access to it ' s private members , through this . and instance variable . But if you define testPrivate outside of MyClass then , you won ' t have access to private members . There you will have to use a method or a setter or a getter .

Question - 16148575 , answer - 16148593 Use Integer instead . HashMap < T > myMap = new HashMap < T > ( args ) ; Java will automatically autobox your int primitive values to Integer objects . Read more about autoboxing from Oracle Java documentations .

Question - 8777257 , answer - 8777292 The equals ( args ) of arrays is inherited from Object , so it does not look at the contents of the arrrays , it only considers each array equal to itself . The Arrays . equals ( args ) methods do compare the arrays ' contents . There ' s overloads for all primitive types , and the one for objects uses the objects ' own equals ( args ) methods .

Question - 28818506 , answer - 38560612 This is part of JDK 9 in the form of or , which takes a Supplier < T > . Your example would then be : return serviceA ( args ) . or ( args ) . or ( args ) ; For details see the ( preliminary ) Javadoc or this post I wrote .

Question - 21163108 , answer - 21172732 The parallel streams use the default ForkJoinPool which by default has one less threads as you have processors , as returned by Runtime . getRuntime ( args ) . availableProcessors ( args ) ( so parallel streams use all your processors because they also use the main thread ) : # blockquote To change the way parallel streams are executed , you can either # li submit the parallel stream execution to your own ForkJoinPool : yourFJP . submit ( args ) ; or # li you can change the size of the common pool using system properties : System . setProperty ( args ) for a target parallelism of 20 threads . Example of the latter on my machine which has 8 processors . If I run the following program : # pre The output is : # blockquote So you can see that the parallel stream processes 8 items at a time , i . e . it uses 8 threads . However if I uncomment the commented line , the output is : # blockquote This time the parallel stream has used 20 threads and all 20 elements in the stream have been processed comcurrently .

Question - 13291076 , answer - 31886637 name ( ) is literally the textual name in the java code of the enum . That means it is limited to strings that can actually appear in your java code , but not all desirable strings are expressible in code . For example , you may need a string that begins with a number . name ( ) will never be able to obtain that string for you .

Question - 17828584 , answer - 17842210 After digging around for a while , I can ' t say that I find the answer , but I think it ' s quite close now . First , we need to know when a StackOverflowError will be thrown . In fact , the stack for a java thread stores frames , which containing all the data needed for invoking a method and resume . According to Java Language Specifications for JAVA 6 , when invoking a method , # blockquote Second , we should make it clear what is " there is not sufficient memory available to create such an activation frame " . According to Java Virtual Machine Specifications for JAVA 6 , # blockquote So , when a frame is created , there should be enough heap space to create a stack frame and enough stack space to store the new reference which point to the new stack frame if the frame is heap allocated . Now let ' s go back to the question . From the above , we can know that when a method is execute , it may just costs the same amount of stack space . And invoking System . out . println ( may ) needs 5 level of method invocation , so 5 frames need to be created . Then when StackOverflowError is thrown out , it has to go back 5 times to get enough stack space to store 5 frames ' references . Hence 4 is print out . Why not 5 ? Because you use cnt + + . Change it to + + cnt , and then you will get 5 . And you will notice that when the size of stack go to a high level , you will get 50 sometimes . That is because the amount of available heap space need to be taken into consideration then . When the stack ' s size is too large , maybe heap space will run out before stack . And ( maybe ) the actual size of stack frames of System . out . println is about 51 times of main , therefore it goes back 51 times and print 50 .

Question - 31316581 , answer - 31327420 If type inference produces a single upper bound for a type variable , typically the upper bound is chosen as the solution . For example , if T < < Number , the solution is T = Number . Although Integer , Float etc . could also satisfy the constraint , there ' s no good reason to choose them over Number . That was also the case for throws T in java 5 - 7 : T < < Throwable = > T = Throwable . ( Sneaky throw solutions all had explicit < RuntimeException > type arguments , otherwise < Throwable > is inferred . ) In java8 , with the introduction of lambda , this becomes problematic . Consider this case # pre If we invoke with an empty lambda , what would T be inferred as ? invoke ( args ) ; The only constraint on T is an upper bound Throwable . In earlier stage of java8 , T = Throwable would be inferred . See this report I filed . But that is pretty silly , to infer Throwable , a checked exception , out of an empty block . A solution was proposed in the report ( which is apparently adopted by JLS ) - # pre i . e . if the upper bound is Exception or Throwable , choose RuntimeException as the solution . In this case , there is a good reason to choose a particular subtype of the upper bound .

Question - 5439529 , answer - 5439543 You can use Integer . parseInt ( args ) or Integer . valueOf ( args ) to get the integer from the string , and catch the exception if it is not a parsable int . You want to be sure to catch the NumberFormatException it can throw . It may be helpful to note that valueOf ( ) will return an Integer object , not the primitive int .

Question - 32356762 , answer - 32370677 There is a small overhead in calling methods var an interface rather than directly on an object . This overhead is often no more than 1 or 2 processor instructions . The overhead of calling a method is even lower if the JIT knows that the method is final . This is not measurable for most code you and me right , but for the low level methods in java . utils may be used in some code where it is an issue . Also as has been pointed out in other answers , the concrete type of the object that is return ( even when hidden behind an interface ) effects the performance of code that uses it . This change in performance can be very great , so such an extent that the calling software fails to work . Clearly the authors of java . utils have no way to know what all the software that calls Collections . list ( ) does with the result and no way to re - test this software if they change the implantation of Collections . list ( ) . Therefore they are not going to change the implantation of Collections . list ( ) to return a different type of List , even if the type system allowed it ! When writing your own software , you ( hopefully ) have automated test that cover all your code and a good understand of how your code interrelates include know where performance is an issue . Being able to make a change to a method , without having to change the callers is of great value while the design of the software is changing . Therefore the two set of trade offs are very different .

Question - 16635398 , answer - 25855691 TL ; DR : List . stream ( args ) . forEach ( args ) was the fastest . I felt I should add my results from benchmarking iteration . I took a very simple approach ( no benchmarking frameworks ) and benchmarked 5 different methods : # li classic for # li classic foreach # li List . forEach ( args ) # li List . stream ( args ) . forEach ( args ) # li List . parallelStream ( args ) . forEach the testing procedure and parameters # pre The list in this class shall be iterated over and have some doIt ( args ) applied to all it ' s members , each time via a different method . in the Main class I run the tested method three times to warm up the JVM . I then run the test method 1000 times summing the time it takes for each iteration method ( using System . nanoTime ( args ) ) . After that ' s done i divide that sum by 1000 and that ' s the result , average time . example : # pre I ran this on a i5 4 core CPU , with java version 1 . 8 . 0 _ 05 classic for # pre execution time : 4 . 21 ms classic foreach # pre execution time : 5 . 95 ms List . forEach ( args ) list . forEach ( args ) ; execution time : 3 . 11 ms List . stream ( args ) . forEach ( args ) list . stream ( args ) . forEach ( args ) ; execution time : 2 . 79 ms List . parallelStream ( args ) . forEach list . parallelStream ( args ) . forEach ( args ) ; execution time : 3 . 6 ms

Question - 14846920 What are some of the situations where I can use Collections . emptyMap ( args ) ? The Documentation says I can use this method if I want my collection to be immutable . Why would I want an immutable empty collection ? What is the point ?

Question - 32175145 , answer - 32177563 The other answers have already answered your question - no , this is not possible with the Java ' s primitive wrapper classes . I ' ll try to address the " question behind the question " : Is this possible with other classes ? # blockquote This is actually a good question , and the answer is : Yes , it is possible to create such a situation , and yes , it would make Aristotle angry . Actually , I don ' t know if it would make Aristotle angry , not having known him , but it will certainly cause a lot of grief for whoever has to work with the code . The thing is : There is a contract associated with Object . equals ( args ) : # blockquote Javadocs for Object . equals Yes , when creating your own class , you can violate this contract . There is ( unfortunately ) nothing in the compiler or runtime stopping you . However , a lot of code relies on this contract , so if you violate it , any code that uses equals will probably fail in mysterious ways . One example : Java ' s own Collection classes ( java . util . Collection and friends ) rely on equals . If an instance of a class that does not correctly implement equals is put into a collection , weird things happen , such as the collection sometimes containing the instance and sometimes not .

Question - 28681737 , answer - 28684917 The short answer is : it ' s safe if you use them safely : ) The snarky answer : tell me what you mean by traits , and maybe I ' ll give you a better answer : ) In all seriousness , the term " trait " is not well - defined . Many Java developers are most familiar with traits as they are expressed in Scala , but Scala is far from the first language to have traits , either in name or in effect . For example , in Scala , traits are stateful ( can have var variables ) ; in Fortress they are pure behavior . Java ' s interfaces with default methods are stateless ; does this mean they are not traits ? ( Hint : that was a trick question . ) Again , in Scala , traits are composed through linearization ; if class A extends traits X and Y , then the order in which X and Y are mixed in determines how conflicts between X and Y are resolved . In Java , this linearization mechanism is not present ( it was rejected , in part , because it was too " un - Java - like " . ) The proximate reason for adding default methods to interfaces was to support interface evolution , but we were well aware that we were going beyond that . Whether you consider that to be " interface evolution + + " or " traits - - " is a matter of personal interpretation . So , to answer your question about safety . . . so long as you stick to what the mechanism actually supports , rather than trying to wishfully stretch it to something it does not support , you should be fine . A key design goal was that , from the perspective of the client of an interface , default methods should be indistinguishable from " regular " interface methods . The default - ness of a method , therefore , is only interesting to the designer and implementor of the interface . Here are some use cases that are well within the design goals : # li Interface evolution . Here , we are adding a new method to an existing interface , which has a sensible default implementation in terms of existing methods on that interface . An example would be adding the forEach method to Collection , where the default implementation is written in terms of the iterator ( args ) method . # li " Optional " methods . Here , the designer of an interface is saying " Implementors need not implement this method if they are willing to live with the limitations in functionality that entails " . For example , Iterator . remove was given a default which throws UnsupportedOperationException ; since the vast majority of implementations of Iterator have this behavior anyway , the default makes this method essentially optional . ( If the behavior from AbstractCollection were expressed as defaults on Collection , we might do the same for the mutative methods . ) # li Convenience methods . These are methods that are strictly for convenience , again generally implemented in terms of non - default methods on the class . The logger ( args ) method in your first example is a reasonable illustration of this . # li Combinators . These are compositional methods that instantiate new instances of the interface based on the current instance . For example , the methods Predicate . and ( args ) or Comparator . thenComparing ( args ) are examples of combinators . If you provide a default implementation , you should also provide some specification for the default ( in the JDK , we use the @ implSpec javadoc tag for this ) to aid implementors in understanding whether they want to override the method or not . Some defaults , like convenience methods and combinators , are almost never overridden ; others , like optional methods , are often overridden . You need to provide enough specification ( not just documentation ) about what the default promises to do , so the implementor can make a sensible decision about whether they need to override it .

Question - 28459498 , answer - 28513908 I have some recollections from the early design of the Streams API that might shed some light on the design rationale . Back in 2012 , we were adding lambdas to the language , and we wanted a collections - oriented or " bulk data " set of operations , programmed using lambdas , that would facilitate parallelism . The idea of lazily chaining operations together was well established by this point . We also didn ' t want the intermediate operations to store results . The main issues we needed to decide were what the objects in the chain looked like in the API and how they hooked up to data sources . The sources were often collections , but we also wanted to support data coming from a file or the network , or data generated on - the - fly , e . g . , from a random number generator . There were many influences of existing work on the design . Among the more influential were Google ' s Guava library and the Scala collections library . ( If anybody is surprised about the influence from Guava , note that Kevin Bourrillion , Guava lead developer , was on the JSR - 335 Lambda expert group . ) On Scala collections , we found this talk by Martin Odersky to be of particular interest : Future - Proofing Scala Collections : from Mutable to Persistent to Parallel . ( Stanford EE380 , 2011 June 1 . ) Our prototype design at the time was based around Iterable . The familiar operations filter , map , and so forth were extension ( default ) methods on Iterable . Calling one added an operation to the chain and returned another Iterable . A terminal operation like count would call iterator ( args ) up the chain to the source , and the operations were implemented within each stage ' s Iterator . Since these are Iterables , you can call the iterator ( args ) method more than once . What should happen then ? If the source is a collection , this mostly works fine . Collections are Iterable , and each call to iterator ( args ) produces a distinct Iterator instance that is independent of any other active instances , and each traverses the collection independently . Great . Now what if the source is one - shot , like reading lines from a file ? Maybe the first Iterator should get all the values but the second and subsequent ones should be empty . Maybe the values should be interleaved among the Iterators . Or maybe each Iterator should get all the same values . Then , what if you have two iterators and one gets farther ahead of the other ? Somebody will have to buffer up the values in the second Iterator until they ' re read . Worse , what if you get one Iterator and read all the values , and only then get a second Iterator . Where do the values come from now ? Is there a requirement for them all to be buffered up just in case somebody wants a second Iterator ? Clearly , allowing multiple Iterators over a one - shot source raises a lot of questions . We didn ' t have good answers for them . We wanted consistent , predictable behavior for what happens if you call iterator ( args ) twice . This pushed us toward disallowing multiple traversals , making the pipelines one - shot . We also observed others bumping into these issues . In the JDK , most Iterables are collections or collection - like objects , which allow multiple traversal . It isn ' t specified anywhere , but there seemed to be an unwritten expectation that Iterables allow multiple traversal . A notable exception is the NIO DirectoryStream interface . Its specification includes this interesting warning : # blockquote [ bold in original ] This seemed unusual and unpleasant enough that we didn ' t want to create a whole bunch of new Iterables that might be once - only . This pushed us away from using Iterable . About this time , an article by Bruce Eckel appeared that described a spot of trouble he ' d had with Scala . He ' d written this code : # pre It ' s pretty straightforward . It parses lines of text into Registrant objects and prints them out twice . Except that it actually only prints them out once . It turns out that he thought that registrants was a collection , when in fact it ' s an iterator . The second call to foreach encounters an empty iterator , from which all values have been exhausted , so it prints nothing . This kind of experience convinced us that it was very important to have clearly predictable results if multiple traversal is attempted . It also highlighted the importance of distinguishing between lazy pipeline - like structures from actual collections that store data . This in turn drove the separation of the lazy pipeline operations into the new Stream interface and keeping only eager , mutative operations directly on Collections . Brian Goetz has explained the rationale for that . What about allowing multiple traversal for collection - based pipelines but disallowing it for non - collection - based pipelines ? It ' s inconsistent , but it ' s sensible . If you ' re reading values from the network , of course you can ' t traverse them again . If you want to traverse them multiple times , you have to pull them into a collection explicitly . But let ' s explore allowing multiple traversal from collections - based pipelines . Let ' s say you did this : # pre ( The into operation is now spelled collect ( args ) . ) If source is a collection , then the first into ( args ) call will create a chain of Iterators back to the source , execute the pipeline operations , and send the results into the destination . The second call to into ( args ) will create another chain of Iterators , and execute the pipeline operations again . This isn ' t obviously wrong but it does have the effect of performing all the filter and map operations a second time for each element . I think many programmers would have been surprised by this behavior . As I mentioned above , we had been talking to the Guava developers . One of the cool things they have is an Idea Graveyard where they describe features that they decided not to implement along with the reasons . The idea of lazy collections sounds pretty cool , but here ' s what they have to say about it . Consider a List . filter ( args ) operation that returns a List : # blockquote To take a specific example , what ' s the cost of get ( args ) or size ( args ) on a List ? For commonly used classes like ArrayList , they ' re O ( 1 ) . But if you call one of these on a lazily - filtered list , it has to run the filter over the backing list , and all of a sudden these operations are O ( n ) . Worse , it has to traverse the backing list on every operation . This seemed to us to be too much laziness . It ' s one thing to set up some operations and defer actual execution until you so " Go " . It ' s another to set things up in such a way that hides a potentially large amount of recomputation . In proposing to disallow non - linear or " no - reuse " streams , Paul Sandoz described the potential consequences of allowing them as giving rise to " unexpected or confusing results . " He also mentioned that parallel execution would make things even trickier . Finally , I ' d add that a pipeline operation with side effects would lead to difficult and obscure bugs if the operation were unexpectedly executed multiple times , or at least a different number of times than the programmer expected . ( But Java programmers don ' t write lambda expressions with side effects , do they ? DO THEY ? ? ) So that ' s the basic rationale for the Java 8 Streams API design that allows one - shot traversal and that requires a strictly linear ( no branching ) pipeline . It provides consistent behavior across multiple different stream sources , it clearly separates lazy from eager operations , and it provides a straightforward execution model . With regard to IEnumerable , I am far from an expert on C # and . NET , so I would appreciate being corrected ( gently ) if I draw any incorrect conclusions . It does appear , however , that IEnumerable permits multiple traversal to behave differently with different sources ; and it permits a branching structure of nested IEnumerable operations , which may result in some significant recomputation . While I appreciate that different systems make different tradeoffs , these are two characteristics that we sought to avoid in the design of the Java 8 Streams API . The quicksort example given by the OP is interesting , puzzling , and I ' m sorry to say , somewhat horrifying . Calling QuickSort takes an IEnumerable and returns an IEnumerable , so no sorting is actually done until the final IEnumerable is traversed . What the call seems to do , though , is build up a tree structure of IEnumerables that reflects the partitioning that quicksort would do , without actually doing it . ( This is lazy computation , after all . ) If the source has N elements , the tree will be N elements wide at its widest , and it will be lg ( N ) levels deep . It seems to me - - and once again , I ' m not a C # or . NET expert - - that this will cause certain innocuous - looking calls , such as pivot selection via ints . First ( args ) , to be more expensive than they look . At the first level , of course , it ' s O ( 1 ) . But consider a partition deep in the tree , at the right - hand edge . To compute the first element of this partition , the entire source has to be traversed , an O ( N ) operation . But since the partitions above are lazy , they must be recomputed , requiring O ( lg N ) comparisons . So selecting the pivot would be an O ( N lg N ) operation , which is as expensive as an entire sort . But we don ' t actually sort until we traverse the returned IEnumerable . In the standard quicksort algorithm , each level of partitioning doubles the number of partitions . Each partition is only half the size , so each level remains at O ( N ) complexity . The tree of partitions is O ( lg N ) high , so the total work is O ( N lg N ) . With the tree of lazy IEnumerables , at the bottom of the tree there are N partitions . Computing each partition requires a traversal of N elements , each of which requires lg ( N ) comparisons up the tree . To compute all the partitions at the bottom of the tree , then , requires O ( N ^ 2 lg N ) comparisons . ( Is this right ? I can hardly believe this . Somebody please check this for me . ) In any case , it is indeed cool that IEnumerable can be used this way to build up complicated structures of computation . But if it does increase the computational complexity as much as I think it does , it would seem that programming this way is something that should be avoided unless one is extremely careful .

Question - 10827872 , answer - 30749407 replace ( args ) method doesn ' t uses regex pattern whereas replaceAll ( args ) method uses regex pattern . So replace ( args ) performs faster than replaceAll ( args ) .

Question - 29140402 , answer - 29141638 Every class in java has toString ( args ) method in it by default , which is called by System . out . println ( args ) if you pass some object of a class to it . When you try to print object of a class , the System . out . println ( args ) method will call toString ( args ) of the class which returns the className @ hashcode of that object . # pre You can override the toString method of a class to get different output . See this example # pre

Question - 10786042 , answer - 16226168 I would not use URLEncoder . Besides being incorrectly named ( URLEncoder has nothing to do with URLs ) , inefficient ( it uses a StringBuffer instead of Builder and does a couple of other things that are slow ) Its also way too easy to screw it up . Instead I would use URIBuilder or Spring ' s URIUtils or Commons Apache HttpClient . The reason being you have to escape the query parameters name ( ie BalusC ' s answer q ) differently than the parameter value . The only downside to the above ( that I found out painfully ) is that URL ' s are not a true subset of URI ' s . Since I ' m just linking to other answers I marked this as a community wiki . Feel free to edit .

Question - 7348711 , answer - 7800008 Strictly speaking - you have no choice but calling either hostname ( args ) or - on Unix gethostname ( args ) . This is the name of your computer . Any attempt to determine the hostname by an IP address like this InetAddress . getLocalHost ( args ) . getHostName ( args ) is bound to fail in some circumstances : # li The IP address might not resolve into any name . Bad DNS setup , bad system setup or bad provider setup may be the reason for this . # li A name in DNS can have many aliases called CNAMEs . These can only be resolved in one direction properly : name to address . The reverse direction is ambiguous . Which one is the " official " name ? # li A host can have many different IP addresses - and each address can have many different names . Two common cases are : One ethernet port has several " logical " IP addresses or the computer has several ethernet ports . It is configurable whether they share an IP or have different IPs . This is called " multihomed " . # li One Name in DNS can resolve to several IP Addresses . And not all of those addresses must be located on the same computer ! ( Usecase : A simple form of load - balancing ) # li Let ' s not even start talking about dynamic IP addresses . Also don ' t confuse the name of an IP - address with the name of the host ( hostname ) . A metaphor might make it clearer : # blockquote This illustrates it pretty much I think . The good news is : The real hostname is usually not necessary . In most cases any name which resolves into an IP address on this host will do . ( The stranger might enter the city by Northgate , but helpful locals translate the " 2nd left " part . ) If the remaining corner cases you must use the definitive source of this configuration setting - which is the C function gethostname ( args ) . That function is also called by the program hostname .

Question - 23674624 , answer - 23674719 IntStream . boxed turns an IntStream into a Stream < T > , which you can then collect into a list : theIntStream . boxed ( args ) . collect ( args )

Question - 21375659 , answer - 21375818 This isn ' t strictly an answer to your question , but if behind your question is a wish to have mutable strings that you can manipulate , you should check out the StringBuilder class , which implements many of the exact same methods that String has but also adds methods to change the current contents . Once you ' ve built your string in such a way that you ' re content with it , you simply call toString ( args ) on it in order to convert it to an ordinary String that you can pass to library routines and other functions that only take String s . Also , both StringBuilder and String implements the CharSequence interface , so if you want to write functions in your own code that can use both mutable and immutable strings , you can declare them to take any CharSequence object .

Question - 22694884 , answer - 22695031 Technically there ' s an ugly ' workaround ' that involves peek ( args ) and an AtomicInteger , but really you shouldn ' t be using that . What I do in these cases is just collecting it in a list , like this : # pre I am not aware of a way to do this in the API , meanwhile I will work on another example involving a custom element . Update , You should create your own Collector for this : # pre What it does is : # li It mimicks the Collectors . toList ( args ) collector . # li It applies an extra finisher at the end , that throws an exception , or if no exception , returns the first element of the list . Used as : User resultUser = users . stream ( args ) . filter ( args ) . collect ( args ) ; You can then customize this singletonCollector as much as you want , for example give the exception as argument in the constructor , tweak it to allow two values , and more . New update , I revised my old answer once more for singletonCollector ( args ) , it can actually be obtained like this : # pre

Question - 21488056 , answer - 35074360 I have written a complete utility class ( inspired by Askar ' s proposal ) that can take Java 8 lambda expression and turn them ( if applicable ) into any typed standard Java 8 lambda defined in the package java . util . function . You can for example do : # li asPredicate ( args ) . negate ( args ) # li asBiPredicate ( args ) . negate ( args ) Because there would be numerous ambiguities if all the static methods would be named just as ( args ) , I opted to call the method " as " followed by the returned type . This gives us full control of the lambda interpretation . Below is the first part of the ( somewhat large ) utility class revealing the pattern used . Have a look at the complete class here ( at gist ) . # pre

Question - 12576156 , answer - 12576394 By specifying the the my . list . of . strings = ABC , CDE , EFG in . properties file and using @ Value ( args ) private String [ ] myString ; You can get the arrays of strings . And using CollectionUtils . addAll ( args ) , you can get the list of strings .

Question - 14491966 , answer - 14492320 Your QuickRandom implementation hasn ' t really an uniform distribution . The frequencies are generally higher at the lower values while Math . random ( args ) has a more uniform distribution . Here ' s a SSCCE which shows that : # pre The average result looks like this : # pre If you repeat the test , you ' ll see that the QR distribution varies heavily , depending on the initial seeds , while the MR distribution is stable . Sometimes it reaches the desired uniform distribution , but more than often it doesn ' t . Here ' s one of the more extreme examples , it ' s even beyond the borders of the graph : # pre

Question - 32820722 , answer - 32821016 If you look at IntFunction it might become clearer : IntFunction < T > is a FunctionalInterface . It represents a function that takes an int and returns a value of type R . In this case , the return type R is also a FunctionalInterface , namely an IntUnaryOperator . So the first ( outer ) function itself returns a function . In this case : When applied to an int , curriedAdd is supposed to return a function that again takes an int ( and returns again int , because that ' s what IntUnaryOperator does ) . In functional programming it is common to write the type of a function as param - > return _ value and you see exactly that here . So the type of curriedAdd is int - > int - > int ( or int - > ( int - > int ) if you like that better ) . Java 8 ' s lambda syntax goes along with this . To define such a function , you write a - > b - > a + b which is very much similar to actual lambda calculus : λ a λ b a + b λ b a + b is a function that takes a single parameter b and returns a value ( the sum ) . λ a λ b a + b is a function that accepts a single parameter a and returns another function of a single parameter . λ a λ b a + b returns λ b a + b with a set to the parameter value .

Question - 7438612 , answer - 7438613 Replace will replace all instances of a letter . All you need to do is use substring ( ) : # pre

Question - 29494800 , answer - 29502668 # blockquote It ' s checking simple equality ( likely for the purpose of a micro - optimization , but more on that later ) . The unusual casting is necessary because Class < T > ( the type of Object [ ] . class ) and Class < T > are incomparable types . Basically , for an equality comparison with = = to compile , one of the sides has to be a subtype or supertype of the other . I . e . we can ' t do : # pre The rules for generic types are a bit more complicated and there are a few cases where a comparison doesn ' t compile , but it may still evaluate to true . The reason Class < T > is not a supertype of Class < T > , despite Object [ ] being a supertype of all object array types , is that Java generics are invariant without the presence of a wildcard . Another way to do the comparison would be : ( newType = = ( Class < T > ) Object [ ] . class ) # blockquote # li new Object [ . . . ] creates an array the normal way , of a type that is statically known . Remember , the code has just checked that T [ ] is Object [ ] . # li Array . newInstance ( args ) uses reflection to dynamically create an array of the Class type passed in . # blockquote An operation using reflection is generally slower than its non - reflective counterpart . The reflection tutorial says : # blockquote Java SE is filled with micro - optimization like this . The writers of SE try to squeeze everything they can out of it . But I wouldn ' t be worried about a performance hit in this case : newInstance and copyOf are HotSpot intrinsics . This means that ideally calls to these methods get replaced with machine - specific assembly . Anecdotally , I ran some tests and found the difference between new Object [ . . . ] and Array . newInstance ( args ) to be negligible . The code in the question is probably a relic , although it may still be useful on less well - equipped JVMs . Reflection can also be disabled in certain contexts with strict security ( such as an applet ) , but not typically for a normal desktop application . # blockquote In general , you will probably never use this overload . This overload is only useful if you want to change the type of the array . # li Widening : # pre # li Narrowing : # pre It ' s more typical to use Arrays . copyOf ( T [ ] , int ) .

Question - 31922866 , answer - 31924845 There are almost no good reasons for not using Optional as parameters . The arguments against this rely on arguments from authority ( see Brian Goetz - his argument is we can ' t enforce non null optionals ) or that the Optional arguments may be null ( essentially the same argument ) . Of course , any reference in Java can be null , we need to encourage rules being enforced by the compiler , not programmers memory ( which is problematic and does not scale ) . Functional programming languages encourage Optional parameters . One of the best ways of using this is to have multiple optional parameters and using liftM2 to use a function assuming the parameters are not empty and returning an optional ( see # a ) . Java 8 has unfortunately implemented a very limited library supporting optional . As Java programmers we should only be using null to interact with legacy libraries .

Question - 21524642 , answer - 21524694 Or . . Pattern # quote : String [ ] value _ split = rat _ values . split ( args ) ; This is happening because String # split accepts a regex : | has a special meaning in regex . quote will return a String representation for the regex .

Question - 25850328 , answer - 25850622 a . I have always seen them as a design pattern and nothing JVM - Special I have used that pattern in several situations . c . I beleive that using Annotations to mark something is a better solution then using marker interfaces . Simply because Interfaces are in the first place aimed to define common interfaces of Types / Classes . They are part of the class - hierachy . Annotations are aimed to provide Meta - Informations to Code , and I think that marker are meta - informations . So they are exactly for that use - case .

Question - 32693704 , answer - 32749756 I ' m going to shoot in the dark here . . . My guess is that it might have been changed in order to prepare the ground for Specialization ( aka generics over primitive types ) . Maybe ( and I insist on maybe ) , this change is meant to make transition to Java 10 easier , in the event of specialization being part of the JDK . If you look at the State of the Specialization document , Language restrictions section , it says the following : # blockquote ( Emphasis is mine ) . And ahead in the Specializer transformations section , it says : # blockquote Later on , near the end of the document , in the Further investigation section , it says : # blockquote Now , regarding the change . . . If the Arrays . fill ( args ) method is going to be specialized , then its signature should change to Arrays . fill ( args ) . However this case is specifically listed in the ( already mentioned ) Language restrictions section ( it would violate the emphasized items ) . So maybe someone decided that it would be better to not use it from the HashMap . clear ( args ) method , especially if value is null .

Question - 29333689 , answer - 29341981 The best answer is already given ( XOR - ing the elements ) , this is to provide an alternative , more general way . If the input array would be sorted ( we can make it sorted ) , we could simply iterate over the elements in pairs ( stepping by 2 ) and if the elements of the " pair " are different , we ' re done : # pre Note : This solution sorts the input array ; if this is unwanted or not allowed , it can be cloned first : arr = arr . clone ( args ) ; If input array is sorted , the Arrays . sort ( args ) call can be left out of course . Generalization The advantage of this solution is that it can be applied to all types which are comparable and therefore can be sorted ( types which implement Comparable ) , for example String or Date . The XOR solution is limited to numbers only . Here is a slightly modified version which takes an input array of any element type which is comparable : # pre Note : In most cases you could also use arr [ i ] . equals ( args ) to compare elements instead of using Comparable . compareTo ( ) . For details read the linked javadoc . Quoting the relevant part : # blockquote Now you can call this with a String [ ] for example : System . out . println ( args ) ; Output : 2 Final notes : Starting from the problem statement it is not checked whether there are more than 2 occurrences of the elements , and neither is whether the array length is odd . Also the second example doesn ' t check for null values , these are to be added if necessary .

Question - 23932061 , answer - 23936723 There ' s a much better answer than using spliteratorUnknownSize directly , which is both easier and gets a better result . Iterable has a spliterator ( args ) method , so you should just use that to get your spliterator . In the worst case , its the same code ( the default implementation uses spliteratorUnknownSize ) , but in the more common case , where your Iterable is already a collection , you ' ll get a better spliterator , and therefore better stream performance ( maybe even good parallelism . ) Its also less code : StreamSupport . stream ( args ) . filter ( args ) . moreStreamOps ( args ) ; As you can see , getting a stream from an Iterable ( see Why does Iterable < T > not provide stream ( ) and parallelStream ( ) methods ? ) is not very painful .

Question - 29922296 , answer - 29926133 I ' d go for EnumSet . Because forEach ( args ) is also defined on Iterable , you can avoid creating the stream altogether : EnumSet . allOf ( args ) . forEach ( args ) ; Or with a method reference : EnumSet . allOf ( args ) . forEach ( args ) ; Still , the oldschool for - loop feels a bit simpler : # pre

Question - 28671903 , answer - 28672583 The behaviour is ( somewhat ) documented in the javadoc : # blockquote What this means in practice , when you call source . removeAll ( args ) ; : # li if the removals collection is of a smaller size than source , the remove method of HashSet is called , which is fast . # li if the removals collection is of equal or larger size than the source , then removals . contains is called , which is slow for an ArrayList . Quick fix : Collection < T > removals = new HashSet < T > ( args ) ; Note that there is an open bug that is very similar to what you describe . The bottom line seems to be that it is probably a poor choice but can ' t be changed because it is documented in the javadoc . For reference , this is the code of removeAll ( in Java 8 - haven ' t checked other versions ) : # pre

Question - 28671903 I have a set – a HashSet I want to remove some items from it … none of the items in the " removals " collection will be in the original set . I specify the size of the " source " set and the size of the " removals " collection on the command line , and build both of them . The source set contains only non - negative integers ; the removals set contains only negative integers . I measure how long it takes to remove all the elements using System . currentTimeMillis ( ) , which isn ’ t the world most accurate stopwatch but is more than adequate in this case , as you ’ ll see . Here ’ s the code : # pre Let ’ s start off by giving it an easy job : a source set of 100 items , and 100 to remove : # pre Okay , That ' s fast as I expected . Next i tried source of one million items and 300 , 000 items to remove ? # pre That still seems pretty speedy . Now make it a bit easier – 300 , 000 source items and 300 , 000 removals : # pre Nearly three minutes ? Really confused ! ! can some one explain why this is happening .

Question - 19418427 , answer - 19418548 As per my research , all the final String are interned in Java . From one of the blog post : # blockquote So it means if you call String . intern ( args ) you can compare two strings using = = operator . But here String . intern ( args ) is not necessary because in Java final String are internally interned . You can find more information String comparision using = = operator and Javadoc for String . intern ( ) method . Also refer this Stackoverflow post for more information .

Question - 16232833 , answer - 16250729 change your return type to ResponseEntity < T > , then you can use below for 400 return new ResponseEntity < T > ( args ) ; and for correct request return new ResponseEntity < T > ( args ) ; UPDATE 1 after spring 4 . 1 there are helper methods in ResponseEntity could be used as return ResponseEntity . status ( args ) . body ( args ) ; and return ResponseEntity . ok ( args ) ;

Question - 34509566 , answer - 34509659 Four things are going on : # li ( You clearly know this , but for lurkers ) = = tests to see if the variables point to the same String object , not equivalent strings . So even if x is StringLiteral and y is also StringLiteral , x = = y may be true or false , depending on whether x and y refer to the same String object or different ones . That ' s why we use equals , not = = , to compare strings for equivalence . All of the following is just meant to explain why = = is sometimes true , it ' s not a suggestion to use = = to compare strings . : - ) # li Equivalent string constants ( strings the compiler knows are constants according to various rules in the JLS ) within the same class are made to refer to the same string by the compiler ( which also lists them in the class ' s " constant pool " ) . That ' s why a = = b is true . # li When the class is loaded , each of its string constants is automatically interned — the JVM ' s string pool is checked for an equivalent string and if one is found , that String object is used ( if not , the new String object for the new constant is added to the pool ) . So even if x is a string constant initialized in class Foo and y is a string constant initialized in class Bar , they ' ll be = = each other . Points 2 and 3 above are covered in part by JLS § 3 . 10 . 5 . ( The bit about the class constant pool is a bit of an implementation detail , hence the link to the JVM spec earlier ; the JLS just speaks of interning . ) # li The compiler does string concatenation if it ' s dealing with constant values , so String d = StringLiteral + StringLiteral ; is compiled to String d = StringLiteral ; and StringLiteral is a string constant the compiler and JVM apply points 2 and 3 above to . E . g . , no StringBuilder is used , the concatenation happens at compile - time , not runtime . This is covered in JLS § 15 . 28 - Constant Expressions . So a = = d is true for the same reason a = = b is true : They refer to the same constant string , so the compiler ensured they were referring to the same string in the class ' s constant pool . The compiler can ' t do that when any of the operands is not a constant , so it can ' t do that with : String e = c + StringLiteral ; . . . even though code analysis could easily show that the value of c will definitely be StringLiteral and thus e will definitely be StringLiteral . The specification only has the compiler do the concatenation with constant values , specifically . So since the compiler can ' t do it , it outputs the StringBuilder code you referred to and that work is done at runtime , creating a new String object . That string isn ' t automatically interned , so e ends up referring to a different String object than a does , and so a = = e is false . Note that as Vinod said , if you declared c as final : final String c = StringLiteral ; Then it would be a constant variable ( yes , they ' re really called that ) and so § 15 . 28 would apply and the compiler would turn String e = c + StringLiteral ; into String e = StringLiteral ; and a = = e would also be true . Just to reiterate : None of which means we should use = = to compare strings for equivalence . : - ) That ' s what equals is for .

Question - 4759570 , answer - 19459145 This works on Windows with Cygwin installed : System . getenv ( args )

Question - 14833008 , answer - 14833048 You need to escape the dot if you want to split on a literal dot : String extensionRemoved = filename . split ( args ) [ 0 ] ; Otherwise you are splitting on the regex . , which means " any character " . Note the double backslash needed to create a single backslash in the regex . You ' re getting an ArrayIndexOutOfBoundsException because your input string is just a dot , ie StringLiteral , which is an edge case that produces an empty array when split on dot ; split ( regex ) removes all trailing blanks from the result , but since splitting a dot on a dot leaves only two blanks , after trailing blanks are removed you ' re left with an empty array . To avoid getting an ArrayIndexOutOfBoundsException for this edge case , use the overloaded version of split ( regex , limit ) , which has a second parameter that is the size limit for the resulting array . When limit is negative , the behaviour of removing trailing blanks from the resulting array is disabled : StringLiteral . split ( args ) / / returns an array of two blanks , ie [ StringLiteral , StringLiteral ] ie , when filename is just a dot StringLiteral , calling filename . split ( args ) [ 0 ] will return a blank , but calling filename . split ( args ) [ 0 ] will throw an ArrayIndexOutOfBoundsException .

Question - 24631909 , answer - 24635657 Common features a ) Both libraries use immutable types . Joda - Time also offers additional mutable types like MutableDateTime . b ) Furthermore : Both libraries are inspired by the design study " TimeAndMoney " from Eric Evans or ideas from Martin Fowler about domain driven style so they strive more or less for a fluent programming style ( although not always perfect ; - ) ) . c ) With both libraries we get a real calendar date type ( called LocalDate ) , a real wall time type ( called LocalTime ) and the composition ( called LocalDateTime ) . That is a very big win compared with old java . util . Calendar and java . util . Date . d ) Both libraries use a method - centric approach meaning they encourage the user to use getDayOfYear ( args ) instead of get ( args ) . This causes a lot of extra methods compared with java . util . Calendar ( although latter is not type - safe at all due to excessive use of ints ) . Performance See the other answer by @ OO7 pointing to the analysis of Mikhail Vorontsov although point 3 ( exception catching ) is probably obsolete - see this JDK - bug . The different performance ( which is in general favour of JSR - 310 ) is mainly due to the fact that the internal implementation of Joda - Time always use a machine - time - like long - primitive ( in milliseconds ) . Null Joda - Time often use NULL as default for system timezone , default locale , current timestamp etc . while JSR - 310 almost always rejects NULL values . Precision JSR - 310 handles nanosecond precision while Joda - Time is limited to millisecond precision . Supported fields : An overview about supported fields in Java - 8 ( JSR - 310 ) is given by some classes in the temporal - package ( for example ChronoField and WeekFields ) while Joda - Time is rather weak on this area - see DateTimeFieldType . The biggest lack of Joda - Time is here the absence of localized week - related fields . A common feature of both field implementation design is that both are based on values of type long ( no other types , not even enums ) . Enum JSR - 310 offers enums like DayOfWeek or Month while Joda - Time does not offer this because it was mainly developed in years 2002 - 2004 before Java 5 . Zone API a ) JSR - 310 offers more timezone features than Joda - Time . Latter is not able to yield a programmatical access to the history of timezone offset transitions while JSR - 310 is capable to do this . b ) For your information : JSR - 310 has moved its internal timezone repository to a new location and a different format . The old library folder lib / zi does not exist any more . Adjuster vs . Property JSR - 310 has introduced the TemporalAdjuster - interface as a formalized way to externalize temporal calculations and manipulations , especially for library or framework - writers this is a nice and relative easy way to embed new extensions of JSR - 310 ( a kind of equivalent to static helper classes for former java . util . Date ) . For most users however , this feature has very limited value because the burden to write code is still with the user . Built - in solutions based on the new TemporalAdjuster - concept are not so many , there is currently only the helper class TemporalAdjusters with a limited set of manipulations ( and the enums Month or other temporal types ) . Joda - Time offers a field - package but practice has shown evidence that new field implementations are very hard to code . On the other side Joda - Time offers so - called properties which make some manipulations much easier and more elegant than in JSR - 310 , for example property . withMaximumValue ( ) . Calendar systems JSR - 310 offers 4 extra calendar systems . The most interesting one is Umalqura ( used in Saudi Arabia ) . The other 3 are : Minguo ( Taiwan ) , Japanese ( only the modern calendar since 1871 ! ) and ThaiBuddhist ( only correct after 1940 ) . Joda - Time offers an Islamic calendar based on calculatory base - not a sighting - based calendar like Umalqura . Thai - Buddhist is also offered by Joda - Time in a similar form , Minguo and the japanese one not . Otherwise Joda - Time offers coptic and ethiopic calendar , too ( but without any support for internationalization ) . More interesting for Europeans : Joda - Time also offers a Gregorian , Julian and mixed - gregorian - julian calendar . However , the practical value for real historical calculations is limited because important features like different year starts in date history are not supported at all ( the same criticism is valid for old java . util . GregorianCalendar ) . Other calendars like Hebrew or Persian or Hindu are completely missing in both libraries . Epoch days JSR - 310 has the class JulianFields while Joda - Time ( version 2 . 0 ) offers some helper methods in the class DateTimeUtils . Clocks JSR - 310 has no interface ( a design mistake ) but an abstract class java . time . Clock which can be used for any clock dependency injection . Joda - Time offers the interface MillisProvider and some helper methods in DateTimeUtils instead . So this way Joda - Time is also capable of supporting test - driven models with different clocks ( mocking etc . ) . Duration arithmetic Both libraries support the calculation of time distances in one or more temporal units . However , when handling single - unit - durations the JSR - 310 - style is obviously nicer ( and long - based instead of using int ) : JSR - 310 = > long days = ChronoUnit . DAYS . between ( args ) ; Joda - Time = > int days = DAYS . daysBetween ( args ) . getDays ( args ) ; Handling of multiple - unit - durations are also different . Even the calculation results can differ - see this closed Joda - Time issue . While JSR - 310 use a very simple and limited approach to use just the classes Period ( duration based on years , months and days ) and Duration ( based on seconds and nanoseconds ) , Joda - Time uses a more sophisticated way using the class PeriodType in order to control in which units a duration ( Joda - Time call it " Period " ) shall be expressed . While the PeriodType - API is somehow awkward to use a similar way is not offered by JSR - 310 at all . Especially it is not yet possible in JSR - 310 to define mixed date and time durations ( based on days and hours for example ) . So be warned if it comes to migration from one library to another . The libraries in discussion are incompatible - despite of partially same class names . Intervals JSR - 310 does not support this feature while Joda - Time has limited support . See also this SO - answer . Formatting and Parsing Best way to compare both libraries is to view the equal - named classes DateTimeFormatterBuilder ( JSR - 310 ) and DateTimeFormatterBuilder ( Joda - Time ) . The JSR - 310 - variant is a little bit more powerful ( can also handle any kind of TemporalField provided the field implementor has managed to code some extension points like resolve ( ) ) . Most important difference is however - in my opinion : JSR - 310 can much better parse timezone names ( format pattern symbol z ) while Joda - Time could not do this at all in its earlier versions and now only in a very limited way . Another advantage of JSR - 310 is support for standalone month names which is important in languages like Russian or Polish etc . Joda - Time has no access to such resources - not even on Java - 8 platforms . The pattern syntax in JSR - 310 is also more flexible than in Joda - Time , allows for optional sections ( using square brackets ) , is more orientated towards CLDR - standard and offers padding ( letter symbol p ) and more fields . Otherwise it should be noted that Joda - Time can format durations using PeriodFormatter . JSR - 310 cannot do this . Hope this overview helps . All the gathered information is mainly there due to my efforts and investigations how to design and implement a better date - and - time library ( nothing is perfect ) . Update from 2015 - 06 - 24 : Meanwhile I have found the time to write and publish a tabular overview for different time libraries in Java . The tables also contain a comparison between Joda - Time v2 . 8 . 1 and Java - 8 ( JSR - 310 ) . It is more detailed than this post .

Question - 29494800 I have trouble understanding the source code of Arrays . copyOf . # pre # li what is this line checking ? ( Object ) newType = = ( Object ) Object [ ] . class # li What are the differences between ( T [ ] ) new Object [ newLength ] and ( T [ ] ) Array . newInstance ( args ) . why Array . newInstance not good enough for both cases ? # li This following line compiles , but crashes at run time ( as expected ) . When should I use this method ? Integer [ ] nums = Arrays . copyOf ( args )

Question - 7348711 , answer - 7353205 InetAddress . getLocalHost ( args ) . getHostName ( args ) is the more portable way . exec ( args ) actually calls out to the operating system to execute the hostname command . Here are a couple other related answers on SO : # li Java current machine name and logged in user ? # li Get DNS name of local machine as seen by a remote machine EDIT : You should take a look at A . H . ' s answer or Arnout Engelen ' s answer for details on why this might not work as expected , depending on your situation . As an answer for this person who specifically requested portable , I still think getHostName ( args ) is fine , but they bring up some good points that should be considered .

Question - 31188231 , answer - 31190722 We can draw a parallel with abstract class . An abstract class is intended to be subclassed so that the abstract methods can be implemented . The abstract class itself contains concrete methods that invoke the abstract methods . The abstract class is free to evolve by adding more concrete methods ; and this practice may break subclasses . Therefore the exact problem you described existed even before Java8 . The problem is much more manifested on Collection APIs because there are a lot of subclasses out in the wild . While the leading motivation of default method was to add some useful methods to existing Collection APIs without breaking subclasses , they had to exercise great self - control of doing it too much , for fear of breaking subclasses . A default method is added only if it ' s absolutely necessary . The real question here is , why List . sort is considered absolutely necessary . I think that is debatable . Regardless of why default method was introduced in the 1st place , it is now a great tool for API designers , and we ought to treat it the same as concrete methods in abstract classes - they need to be designed carefully up front ; and new ones must be introduced with great caution .

Question - 6271417 , answer - 29938300 Use this method , but be careful to make an object in your main . public static void setName ( args ) { Class setClass = obj . getClass ( args ) ; String className = setClass . getName ( args ) ; System . out . println ( args ) ; }

Question - 13102045 , answer - 15046253 It does that because input . nextInt ( args ) ; doesn ' t capture the newline . you could do like the others proposed by adding an input . nextLine ( args ) ; underneath . Alternatively you can do it C # style and parse a nextLine to an integer like so : int number = Integer . parseInt ( args ) ; Doing this works just as well , and it saves you a line of code .

Question - 5868369 , answer - 5868454 You need to use the readLine ( args ) method in class BufferedReader . Create a new object from that class and operate this method on him and save it to a string . BufferReader API

Question - 13291076 If you look in the enum api at the method name ( args ) it says that : # blockquote Why is better to use toString ( args ) ? I mean toString may be overridden when name ( ) is already final . So if you use toString and someone overrides it to return a hard - coded value your whole application is down . . . Also if you look in the sources the toString ( ) method returns exactly and just the name . It ' s the same thing .

Question - 32334319 , answer - 32334651 The API guarantees a stable sorting which Quicksort doesn ’ t offer . However , when sorting primitive values by their natural order you won ’ t notice a difference as primitive values have no identity . Therefore , Quicksort is used for primitive arrays as it is slightly more efficient . For objects you may notice , when objects which are deemed equal according to their equals implementation or the provided Comparator change their order . Therefore , Quicksort is not an option . So a variant of MergeSort is used , the current Java versions use TimSort . This applies to both , Arrays . sort and Collections . sort , though with Java 8 , the List itself may override the sort algorithms .

Question - 4772425 , answer - 18953213 remove one y form SimpleDateFormat dt1 = new SimpleDateFormat ( args ) ; should be SimpleDateFormat dt1 = new SimpleDateFormat ( args ) ;

Question - 18448671 , answer - 18448699 Use an Iterator and call remove ( ) : # pre

Question - 7520432 , answer - 36875991 Basically , = = compares if two objects have the same reference on the heap , so unless two references are linked to the same object , this comparison will be false . equals ( args ) is a method inherited from Object class . This method by default compares if two objects have the same referece . It means : object1 . equals ( args ) < = > object1 = = object2 However , if you want to establish equality between two objects of the same class you should override this method . It is also very important to override the method hashCode ( args ) if you have overriden equals ( args ) . Implement hashCode ( args ) when establishing equality is part of the Java Object Contract . If you are working with collections , and you haven ' t implemented hashCode ( args ) , Strange Bad Things could happen : # pre null will be printed after executing the previous code if you haven ' t implemented hashCode ( args ) .

Question - 20001427 , answer - 22245383 : : is called Method Reference . It is basically a reference to a single method . i . e . it refers to an existing method by name . Short Explanation : Below is an example of a reference to a static method : # pre square can be passed around just like object reference ' s and trigger when at need . In fact , it can be perfectly used as a reference to a normal method of an object and not just static ones . # pre Function above is a functional interface . Well to fully explain : : , it is important to understand Functional Interface . Plainly , Function interface is an interface with just one abstract method . For example : Runnable , Callable , ActionListener and so . Function above is a functional interface with just one method apply . It takes one argument and produces a result . The reason why : : are awesome is because : # blockquote i . e . Just like writing lambda body : Function < T > square = ( Double x ) - > x * x ; You can simply do : Function < T > square = Hey : : square ; At runtime they behave exactly the same . The bytecode may / not be the same ( For above case , it generates the same bytecode ( compile above and check javap - c ) ) The only major criteria to satisfy is : the method you provide should have a similar signature to method of the FunctionalInterface you use as object reference . Below is illegal Supplier < T > p = Hey : : square ; / / illegal square expects an argument and returns a double . get method in Supplier expects an argument but doesn ' t return anything . So it is an error . Method Reference refers to a method of the functional interface ( As mentioned , functional interface can only have one method ) . Some more examples : accept method in Consumer takes an input but doesnt return anything . # pre Above getRandom takes no argument and returns a double . So any functional interface that satisfies the criteria of : take no argument and return double can be used . Another example : # pre In case of Parametrized Types : # pre Method Reference can be obtained in different styles , but fundamentally they all mean the same and can simply be visualized as a lambda : # li A static method ( ClassName : : methName ) # li An instance method of a particular object ( instanceRef : : methName ) # li A super method of a particular object ( super : : methName ) # li An instance method of an arbitrary object of a particular type ( ClassName : : methName ) # li A class constructor reference ( ClassName : : new ) # li An array constructor reference ( TypeName [ ] : : new ) For further reference : # a

Question - 14846920 , answer - 14846943 It is , in my personal experience admittedly , very useful in cases where an API requires a collection of parameters , but you have nothing to provide . For example you may have an API that looks something like this , and does not allow null references : public ResultSet executeQuery ( args ) ; If you have a query that doesn ' t take any parameters , it ' s certainly a bit wasteful to create a HashMap , which involves allocating an array , when you could just pass in the ' Empty Map ' which is effectively a constant , the way it ' s implemented in java . util . Collections .

Question - 16324831 Why do Double . parseDouble ( null ) and Integer . parseInt ( null ) throw different exceptions ? Is this a historical accident or intentional ? The documentation clearly states two types of exceptions for Double . parseDouble ( . . . ) and one for Integer . parseInt ( ) , but it seems inconsistent : Integer . parseInt ( args ) ; / / throws java . lang . NumberFormatException : null However Double . parseDouble ( args ) ; / / throws java . lang . NullPointerException

Question - 20945049 , answer - 20945268 In Java , if two string primitive variables are initialized to the same literal , it assigns the same reference to both variables : # pre # blockquote That is the reason the comparison returns true . The third string is created using substring ( args ) which makes a new string instead of pointing to the same . # blockquote When you access a string using reflection , you get the actual pointer : # pre So change to this will change the string holding a pointer to it , but as s3 is created with a new string due to substring ( args ) it would not change . # blockquote

Question - 32714194 , answer - 32714537 While currently most of Java compilers using StringBuilder chain , it ' s not specified that it should be always in this way . In particular there ' s a proposal to change this drastically in Java - 9 replacing with single invokedynamic call and introduce new metafactory which will generate an appropriate MethodHandle in runtime to perform concatenation .

Question - 8579657 , answer - 33375616 Most of these answers miss the big picture , which is that , as far as the Java language is concerned , there is no more difference between t . start ( args ) and r . run ( args ) than there is between any other two methods . They ' re both just methods . They both run in the thread that called them . They both do whatever they were coded to do , and then they both return , still in the same thread , to their callers . The biggest difference is that most of the code for t . start ( args ) is native code while , in most cases , the code for r . run ( args ) is going to be pure Java . But that ' s not much of a difference . Code is code . Native code is harder to find , and harder to understand when you find it , but it ' s still just code that tells the computer what to do . So , what does t . start ( args ) do ? It creates a new native thread , it arranges for that thread to call t . run ( args ) , and then it tells the OS to let the new thread run . Then it returns . And what does r . run ( args ) do ? The funny thing is , the person asking this question is the person who wrote it . r . run ( args ) does whatever you ( i . e . , the developer who wrote it ) designed it to do . t . start ( args ) is the method that the library provides for your code to call when you want a new thread . r . run ( args ) is the method that you provide for the library to call in the new thread .

Question - 6094575 , answer - 6094602 Yes , something like : # pre That will only work for a single string parameter of course , but you can modify it pretty easily . Note that the class name has to be a fully - qualified one , i . e . including the namespace . For nested classes , you need to use a dollar ( as that ' s what the compiler uses ) . For example : # pre To obtain the Class object for that , you ' d need Class . forName ( args ) .

Question - 22694884 , answer - 39385411 As Collectors . toMap ( args ) uses a throwing merger to handle multiple entries with the same key it is easy : # pre You will get a IllegalStateException for duplicate keys . But at the end I am not sure if the code would not be even more readable using an if .

Question - 26791441 , answer - 26886202 You are performing multiple search - replace operations on the input . This will produce undesired results when the replacement strings contain search strings . Consider the foo - > bar , bar - foo example , here are the results for each iteration : # li Once upon a time , there was a foo and a bar . ( input ) # li Once upon a time , there was a bar and a bar . ( foo - > bar ) # li Once upon a time , there was a foo and a foo . ( bar - > foo , output ) You need to perform the replacement in one iteration without going back . A brute - force solution is as follows : # li Search the input from current position to end for multiple search strings until a match is found # li Replace the matched search string with corresponding replace string # li Set current position to the next character after the replaced string # li Repeat A function such as String . indexOfAny ( args ) - > int [ ] { index , whichString } would be useful . Here is an example ( not the most efficient one ) : # pre Some tests : # pre Demo on IDEONE Demo on IDEONE , alternate code

Question - 25056607 , answer - 25056821 Documentation : For : System . out . println ( args ) ; # blockquote It will simply return the entire string that ' s why it returns 1 . For the second case , String . split will discard the , so the result will be empty . String . split silently discards trailing separators see guava StringsExplained too

Question - 20746429 , answer - 20765715 Such an operation ought to be possible with a Java 8 Stream , but it can ' t necessarily be done efficiently - - for example , you can ' t necessarily parallelize such an operation , as you have to look at elements in order . The API doesn ' t provide an easy way to do it , but what ' s probably the simplest way is to take Stream . iterator ( args ) , wrap the Iterator to have a " take - while " implementation , and then go back to a Spliterator and then a Stream . Or - - maybe - - wrap the Spliterator , though it can ' t really be split anymore in this implementation . Here ' s an untested implementation of takeWhile on a Spliterator : # pre

Question - 31419029 , answer - 31419077 If you look at the implementation of HashMap , the constructor looks like : # pre And init ( args ) looks like : # pre So initialCapacity doesn ' t actually get used to create an array . Where does it get used ? Look at the put ( args ) method . # pre When doing a put , the array is actually created . I didn ' t show inflateTable ( args ) but it does some math and initializes the array .

Question - 8172420 , answer - 8172444 Try this : Character . toString ( args ) or just this : aChar + StringLiteral

Question - 29095967 , answer - 29099896 This is a very interesting problem . I came up with a one line solution . It might not very performant but it works . # pre It is a similar idea that @ Rohit Jain came up with . I ' m grouping the space between the null values . If you really want a List < T > you may append : List < T > ll = cl . stream ( args ) . collect ( args ) ;

Question - 27482579 How is the compiler not complaining when I write the following code ? # pre Even though it is an instance of the same class in which testPrivate is written , shouldn ' t it give a compilation error at System . out . println ( args ) ? After all , I am trying to access a private variable directly . The code even runs fine .

Question - 22182669 , answer - 22223113 The most common cause of StackOverFlowError is excessively deep or infinite recursion . For instance : # pre In Java : There are two areas in memory the heap and stack . The stack memory is used to store local variables and function call , while heap memory is used to store objects in Java . If there is no memory left in stack for storing function call or local variable , JVM will throw java . lang . StackOverFlowError while if there is no more heap space for creating object , JVM will throw java . lang . OutOfMemoryError

Question - 5455794 I have a string like this : mysz = StringLiteral ; I want to remove the whitespaces in the string . I tried trim ( args ) but this removes only whitespaces before and after the whole string . I also tried replaceAll ( args ) but then the = also gets removed . How can I achieve a string with : mysz2 = StringLiteral

Question - 22561614 , answer - 22561690 Comparator is a functional interface , and Integer : : max complies with that interface ( after autoboxing / unboxing is taken into consideration ) . It takes two int values and returns an int - just as you ' d expect a Comparator < T > to ( again , squinting to ignore the Integer / int difference ) . However , I wouldn ' t expect it to do the right thing , given that Integer . max doesn ' t comply with the semantics of Comparator . compare . And indeed it doesn ' t really work in general . For example , make one small change : # pre . . . and now the max value is - 20 and the min value is - 1 . Instead , both calls should use Integer : : compare : # pre

Question - 14491966 , answer - 14513598 java . util . Random is not much different , a basic LCG described by Knuth . However it has main 2 main advantages / differences : # li thread safe - each update is a CAS which is more expensive than a simple write and needs a branch ( even if perfectly predicted single threaded ) . Depending on the CPU it could be significant difference . # li undisclosed internal state - this is very important for anything non - trivial . You wish the random numbers not to be predictable . Below it ' s the main routine generating ' random ' integers in java . util . Random . # pre If you remove the AtomicLong and the undisclosed sate ( i . e . using all bits of the long ) , you ' d get more performance than the double multiplication / modulo . Last note : Math . random should not be used for anything but simple tests , it ' s prone to contention and if you have even a couple of threads calling it concurrently the performance degrades . One little known historical feature of it is the introduction of CAS in java - to beat an infamous benchmark ( first by IBM via intrinsics and then Sun made " CAS from Java " )

Question - 10631715 , answer - 30270403 There is a function called replaceAll ( args ) that can remove all whitespaces by replacing them with whatever you want . As an example # pre will give you : First : 15 . 94 , Second : 16 . 01

Question - 4818699 , answer - 4818753 There are two main uses of AtomicInteger : # li As an atomic counter ( incrementAndGet ( args ) , etc ) that can be used by many threads concurrently # li As a primitive that supports compare - and - swap instruction ( compareAndSet ( args ) ) to implement non - blocking algorithms . Here is an example of non - blocking random number generator from Brian G ö etz ' s Java Concurrency In Practice : # pre As you can see , it basically works almost the same way as incrementAndGet ( args ) , but performs arbitrary calculation ( calculateNext ( args ) ) instead of increment ( and processes the result before return ) .

Question - 8881291 In Swing , the password field has a getPassword ( args ) ( returns char [ ] ) method instead of the usual getText ( args ) ( returns String ) method . Similarly , I have come across a suggestion not to use String to handle passwords . Why does String pose a threat to security when it comes to passwords ? It feels inconvenient to use char [ ] .

Question - 32820722 , answer - 32820984 Let ' s rewrite that lambda expression with parentheses to make it more clear : IntFunction < T > curriedAdd = a - > ( b - > ( a + b ) ) ; So we are declaring a function taking an int which returns a Function . More specifically , the function returned takes an int and returns an int ( the sum of the two elements ) : this can be represented as an IntUnaryOperator . Therefore , curriedAdd is a function taking an int and returning an IntUnaryOperator , so it can be represented as IntFunction < IntUnaryOperator > .

Question - 6608795 , answer - 20069798 All these answers around here , as well as the answers in this question , suggest that loading absolute URLs , like " / foo / bar . properties " treated the same by class . getResourceAsStream ( args ) and class . getClassLoader ( args ) . getResourceAsStream ( args ) . This is NOT the case , at least not in my Tomcat configuration / version ( currently 7 . 0 . 40 ) . # pre Sorry , I have absolutely no satisfying explanation , but I guess that tomcat does dirty tricks and his black magic with the classloaders and cause the difference . I always used class . getResourceAsStream ( args ) in the past and haven ' t had any problems . PS : I also posted this over here

Question - 20375176 , answer - 20375622 A parallel stream has a much higher overhead compared to a sequential one . Coordinating the threads takes a significant amount of time . I would use sequential streams by default and only consider parallel ones if # li I have a massive amount of items to process ( or the processing of each item takes time and is parallelizable ) # li I have a performance problem in the first place # li I don ' t already run the process in a multi - thread environment ( for example : in a web container , if I already have many requests to process in parallel , adding an additional layer of parallelism inside each request could have more negative than positive effects ) In your example , the performance will anyway be driven by the synchronized access to System . out . println ( args ) , and making this process parallel will have no effect , or even a negative one . Moreover , remember that parallel streams don ' t magically solve all the synchronization problems . If a shared resource is used by the predicates and functions used in the process , you ' ll have to make sure that everything is thread - safe . In particular , side effects are tings you really have to worry about if you go parallel . In any case , measure , don ' t guess ! Only a measurement will tell you if the parallelism is worth it or not .

Question - 24649842 , answer - 24649939 Try adding a Thread . sleep ( args ) ; call within your run ( args ) method . . . Basically it ' s the difference between scheduling something based on when the previous execution ends and when it ( logically ) starts . For example , suppose I schedule an alarm to go off with a fixed rate of once an hour , and every time it goes off , I have a cup of coffee , which takes 10 minutes . Suppose that starts at midnight , I ' d have : # pre If I schedule with a fixed delay of one hour , I ' d have : # pre Which one you want depends on your task .

Question - 27625611 , answer - 27625722 Because nextDouble works like this : ( source ) # pre next ( args ) makes x random bits . Now why does this matter ? Because about half the numbers generated by the first part ( before the division ) are less than 1L < < 52 , and therefore their significand doesn ' t entirely fill the 53 bits that it could fill , meaning the least significant bit of the significand is always zero for those . Because of the amount of attention this is receiving , here ' s some extra explanation of what a double in Java ( and many other languages ) really looks like and why it mattered in this question . Basically , a double looks like this : ( source ) # img A very important detail not visible in this picture is that numbers are " normalized " 1 such that the 53 bit fraction starts with a 1 ( by choosing the exponent such that it is so ) , that 1 is then omitted . That is why the picture shows 52 bits for the fraction ( significand ) but there are effectively 53 bits in it . The normalization means that if in the code for nextDouble the 53rd bit is set , that bit is the implicit leading 1 and it goes away , and the other 52 bits are copied literally to the significand of the resulting double . If that bit is not set however , the remaining bits must be shifted left until it becomes set . On average , half the generated numbers fall into the case where the significand was not shifted left at all ( and about half those have a 0 as their least significant bit ) , and the other half is shifted by at least 1 ( or is just completely zero ) so their least significant bit is always 0 . 1 : not always , clearly it cannot be done for zero , which has no highest 1 . These numbers are called denormal or subnormal numbers , see wikipedia : denormal number .

Question - 24651403 , answer - 24651855 OK , first of all , your setExits ( args ) method will not work as intended , chained if - elseif will maximally execute 1 branch of code , for example : # pre Even if e contains both N and W , only bexits [ 0 ] will be set . Also this method will only add exits ( for example calling setExits ( args ) will not delete any existing exits . I would change that method to : # pre Also , i definetly wouldn ' t remember that north is on index 0 , west in on 1 , . . . so a common practice is to name your indexes using final static constants : # pre Then you can write in your setExits method : # pre ( much more readible ) Finally , if you want your code even more well - arranged , you can make a Exits class representing avaliable exits , and backed by boolean array . Then on place where you create your String , you could create this class instead and save yourself work with generating and then parsing a string . EDIT : as @ gexicide answers , there is a really handy class EnumSet which would be probably better for representing the exits than bollean array .

Question - 19757300 , answer - 19759653 You can also propagate your static pain with lambdas , so the whole thing looks readable : s . filter ( args ) propagate here receives java . util . concurrent . Callable as a parameter and converts any exception caught during the call into RuntimeException . There is a similar conversion method Throwables # propagate ( Throwable ) in Guava . This method seems being essential for lambda method chaining , so I hope one day it will be added to one of the popular libs or this propagating behavior would be by default . # pre

Question - 11821801 , answer - 11821900 A ReentrantLock is unstructured , unlike synchronized constructs - - i . e . you don ' t need to use a block structure for locking and can even hold a lock across methods . An example : # pre Such flow is impossible to represent via a single monitor in a synchronized construct . Aside from that , ReentrantLock supports lock polling and interruptible lock waits that support time - out . ReentrantLock also has support for configurable fairness policy , allowing more flexible thread scheduling . # blockquote ReentrantLock may also be more scalable , performing much better under higher contention . You can read more about this here . This claim has been contested , however ; see the following comment : # blockquote When should you use ReentrantLock s ? According to that developerWorks article . . . # blockquote

Question - 15336477 , answer - 32364785 Examples from Apache ( link ) use this : HttpClient httpclient = HttpClients . createDefault ( args ) ; The class org . apache . http . impl . client . HttpClients is there since version 4 . 3 . The code for HttpClients . createDefault ( args ) is the same as the accepted answer in here .

Question - 5868369 , answer - 20593147 In Java 8 , you could do : # pre Some notes : The stream returned by Files . lines ( unlike most streams ) needs to be closed . For the reasons mentioned here I avoid using forEach ( args ) . The strange code ( Iterable < T > ) lines : : iterator casts a Stream to an Iterable .

Question - 31202946 Why was the Thread class implemented as a regular class and not an abstract class with run ( args ) method being abstract . Will it possibly introduce any problems ? Or does it have any use in being this way ? Also , the Thread . start ( args ) method is supposed to be a very specific method whose functionality cannot be implemented by any other class ( If I am not wrong ) . And hence I guess the final keyword would be apt for this more than any other method . But I am able to override this method and use it as I like , # pre It obviously only printed , # blockquote Is there any use in overriding other than confusing the engineer replacing you ? If not , why was the method not declared final in Thread class ?

Question - 6684665 , answer - 6684935 If you want to convert the string back into a byte array you will need to use String . getBytes ( args ) ( or equivalent Python function ) and this will allow you print out the original byte array .

Question - 16148575 , answer - 18481387 If you code in Android , there is SparseArray , mapping integer to object .

Question - 18723596 , answer - 18723651 Println ( args ) uses String . valueOf ( args ) # pre Print ( args ) does null check . # pre

Question - 5243754 , answer - 5243798 # li getParameter ( args ) returns http request parameters . Those passed from the client to the server . For example http : / / example . com / servlet ? parameter = 1 . Can only return String # li getAttribute ( args ) is for server - side usage only - you fill the request with attributes that you can use within the same request . For example - you set an attribute in a servlet , and read it from a JSP . Can be used for any object , not just string .

Question - 19431234 , answer - 23885950 Short answer : # pre Explanation : ( based on this question about LocalDate ) Despite its name , java . util . Date represents an instant on the time - line , not a " date " . The actual data stored within the object is a long count of milliseconds since 1970 - 01 - 01T00 : 00Z ( midnight at the start of 1970 GMT / UTC ) . The equivalent class to java . util . Date in JSR - 310 is Instant , thus there are convenient methods to provide the conversion to and fro : # pre A java . util . Date instance has no concept of time - zone . This might seem strange if you call toString ( args ) on a java . util . Date , because the toString is relative to a time - zone . However that method actually uses Java ' s default time - zone on the fly to provide the string . The time - zone is not part of the actual state of java . util . Date . An Instant also does not contain any information about the time - zone . Thus , to convert from an Instant to a local date - time it is necessary to specify a time - zone . This might be the default zone - ZoneId . systemDefault ( args ) - or it might be a time - zone that your application controls , such as a time - zone from user preferences . LocalDateTime has a convenient factory method that takes both the instant and time - zone : # pre In reverse , the LocalDateTime the time - zone is specified by calling the atZone ( args ) method . The ZonedDateTime can then be converted directly to an Instant : # pre Note that the conversion from LocalDateTime to ZonedDateTime has the potential to introduce unexpected behaviour . This is because not every local date - time exists due to Daylight Saving Time . In autumn / fall , there is an overlap in the local time - line where the same local date - time occurs twice . In spring , there is a gap , where an hour disappears . See the Javadoc of atZone ( ZoneId ) for more the definition of what the conversion will do . Summary , if you round - trip a java . util . Date to a LocalDateTime and back to a java . util . Date you may end up with a different instant due to Daylight Saving Time .

Question - 28319064 , answer - 28323553 One of the main benefits of using streams is that it gives the ability to process data in a declarative way , that is , using a functional style of programming . It also gives multi - threading capability for free meaning there is no need to write any extra multi - threaded code to make your stream concurrent . Assuming the reason you are exploring this style of programming is that you want to exploit these benefits then your first code sample is potentially not functional since the foreach method is classed as being terminal ( meaning that it can produce side - effects ) . The second way is preferred from functional programming point of view since the map function can accept stateless lambda functions . More explicitly , the lambda passed to the map function should be # li Non - interfering , meaning that the function should not alter the source of the stream if it is non - concurrent ( e . g . ArrayList ) . # li Stateless to avoid unexpected results when doing parallel processing ( caused by thread scheduling differences ) . Another benefit with the second approach is if the stream is parallel and the collector is concurrent and unordered then these characteristics can provide useful hints to the reduction operation to do the collecting concurrently .

Question - 18532488 In many other languages , eg . Haskell , it is easy to repeat a value or function multiple times , eg . to get a list of 8 copies of the value 1 : take 8 ( args ) but I haven ' t found this yet in Java 8 . Is there such a function in Java 8 ' s JDK ? Or alternatively something equivalent to a range like [ 1 . . 8 ] It would seem an obvious replacement for a verbose statement in Java like # pre to have something like Range . from ( args ) . forEach ( args ) though this particular example doesn ' t look much more concise actually . . . but hopefully it ' s more readable .

Question - 24630963 The Java 8 Collectors . toMap throws a NullPointerException if one of the values is ' null ' . I don ' t understand this behaviour , maps can contain null pointers as value without any problems . Is there a good reason why values cannot be null for Collectors . toMap ? Also , is there a nice Java 8 way of fixing this , or should I revert to plain old for loop ? An example of my problem : # pre Stacktrace : # pre

Question - 33147339 , answer - 33148103 Looking at the code : int newCapacity = oldCapacity + ( oldCapacity > > 1 ) ; If oldCapacity is quite large , this will overflow , and newCapacity will be a negative number . A comparison like newCapacity < oldCapacity will incorrectly evaluate true and the ArrayList will fail to grow . Instead , the code as written ( newCapacity - minCapacity < 0 returns false ) will allow the negative value of newCapacity to be further evaluated in the next line , resulting in recalculating newCapacity by invoking hugeCapacity ( newCapacity = hugeCapacity ( args ) ; ) to allow for the ArrayList to grow up to MAX _ ARRAY _ SIZE . This is what the / / overflow - conscious code comment is trying to communicate , though rather obliquely . So , bottom line , the new comparison protects against allocating an ArrayList larger than the predefined MAX _ ARRAY _ SIZE while allowing it to grow right up to that limit if needed .

Question - 22435833 , answer - 22497858 The answer from skiwi covered many of the major points already . I ' ll fill in a bit more background . The design of any API is a series of tradeoffs . In Java , one of the difficult issues is dealing with design decisions that were made long ago . Primitives have been in Java since 1 . 0 . They make Java an " impure " object - oriented language , since the primitives are not objects . The addition of primitives was , I believe , a pragmatic decision to improve performance at the expense of object - oriented purity . This is a tradeoff we ' re still living with today , nearly 20 years later . The autoboxing feature added in Java 5 mostly eliminated the need to clutter source code with boxing and unboxing method calls , but the overhead is still there . In many cases it ' s not noticeable . However , if you were to perform boxing or unboxing within an inner loop , you ' d see that it can impose significant CPU and garbage collection overhead . When designing the Streams API , it was clear that we had to support primitives . The boxing / unboxing overhead would kill any performance benefit from parallelism . We didn ' t want to support all of the primitives , though , since that would have added a huge amount of clutter to the API . ( Can you really see a use for a ShortStream ? ) " All " or " none " are comfortable places for a design to be , yet neither was acceptable . So we had to find a reasonable value of " some " . We ended up with primitive specializations for int , long , and double . ( Personally I would have left out int but that ' s just me . ) For CharSequence . chars ( args ) we considered returning Stream < T > ( an early prototype might have implemented this ) but it was rejected because of boxing overhead . Considering that a String has char values as primitives , it would seem to be a mistake to impose boxing unconditionally when the caller would probably just do a bit of processing on the value and unbox it right back into a string . We also considered a CharStream primitive specialization , but its use would seem to be quite narrow compared to the amount of bulk it would add to the API . It didn ' t seem worthwhile to add it . The penalty this imposes on callers is that they have to know that the IntStream contains char values represented as ints and that casting must be done at the proper place . This is doubly confusing because there are overloaded API calls like PrintStream . print ( args ) and PrintStream . print ( args ) that differ markedly in their behavior . An additional point of confusion possibly arises because the codePoints ( args ) call also returns an IntStream but the values it contains are quite different . So , this boils down to choosing pragmatically among several alternatives : # li We could provide no primitive specializations , resulting in a simple , elegant , consistent API , but which imposes a high performance and GC overhead ; # li we could provide a complete set of primitive specializations , at the cost of cluttering up the API and imposing a maintenance burden on JDK developers ; or # li we could provide a subset of primitive specializations , giving a moderately sized , high performing API that imposes a relatively small burden on callers in a fairly narrow range of use cases ( char processing ) . We chose the last one .

Question - 10827872 , answer - 10827900 In java . lang . String , the replace method either takes a pair of char ' s or a pair of CharSequence ' s ( of which String is a subclass , so it ' ll happily take a pair of String ' s ) . The replace method will replace all occurrences of a char or CharSequence . On the other hand , both String arguments to replaceFirst and replaceAll are regular expressions ( regex ) . Using the wrong function can lead to subtle bugs .

Question - 6840803 , answer - 6840856 SimpleDateFormat stores intermediate results in instance fields . So if one instance is used by two threads they can mess each other ' s results . Looking at the source code reveals that there is a Calendar instance field , which is used by operations on DateFormat / SimpleDateFormat For example parse ( args ) calls calendar . clear ( args ) initially and then calendar . add ( args ) . If another thread invokes parse ( args ) before the completion of the first invocation , it will clear the calendar , but the other invocation will expect it to be populated with intermediate results of the calculation . One way to reuse date formats without trading thread - safety is to put them in a ThreadLocal - some libraries do that . That ' s if you need to use the same format multiple times within one thread . But in case you are using a servlet container ( that has a thread pool ) , remember to clean the thread - local after you finish . To be honest , I don ' t understand why they need the instance field , but that ' s the way it is . You can also use joda - time DateTimeFormat which is threadsafe .

Question - 23114015 , answer - 23177907 This was not an omission ; there was detailed discussion on the EG list in June of 2013 . The definitive discussion of the Expert Group is rooted at this thread . While it seemed " obvious " ( even to the Expert Group , initially ) that stream ( args ) seemed to make sense on Iterable , the fact that Iterable was so general became a problem , because the obvious signature : Stream < T > stream ( args ) was not always what you were going to want . Some things that were Iterable < T > would rather have their stream method return an IntStream , for example . But putting the stream ( args ) method this high up in the hierarchy would make that impossible . So instead , we made it really easy to make a Stream from an Iterable , by providing a spliterator ( args ) method . The implementation of stream ( args ) in Collection is just : # pre Any client can get the stream they want from an Iterable with : Stream s = StreamSupport . stream ( args ) ; In the end we concluded that adding stream ( args ) to Iterable would be a mistake .

Question - 15156857 , answer - 15157021 You must use doThrow ( args ) . when ( args ) . methodReturningVoid ( args ) ; and not doThrow ( args ) . when ( args ) ; This is explained in the documentation

Question - 27888429 , answer - 27888447 You can use Arrays . stream E . g . Arrays . stream ( args ) ; You can also use Stream . of as mentioned by @ fge , which looks like # pre But note Stream . of ( args ) will return Stream < T > whereas Arrays . stream ( args ) will return IntStream providing you pass an array of type int [ ] . So in a nutshell for primitives type you can observe the difference between 2 methods E . g . # pre When you pass primitive array to Arrays . stream , the following code is invoked # pre and when you pass primitive array to Stream . of the following code is invoked # pre Hence you get different results . Updated : As mentioned by Stuart Marks comment The subrange overload of Arrays . stream is preferable to using Stream . of ( args ) . skip ( args ) . limit ( args ) because the former results in a SIZED stream whereas the latter does not . The reason is that limit ( args ) doesn ' t know whether the size is m or less than m , whereas Arrays . stream does range checks and knows the exact size of the stream You can read the source code for stream implementation returned by Arrays . stream ( args ) here , whereas for stream implementation returned by Stream . of ( args ) . skip ( args ) . limit ( args ) is within this method .

Question - 32859038 , answer - 32859065 You can create a Stream of the indices using an IntStream and then convert them to a Map : Map < T > map = IntStream . range ( args ) . boxed ( args ) . collect ( args ) ;

Question - 8579657 , answer - 35931153 If you directly call run ( args ) method , you are not using multi - threading feature since run ( args ) method is executed as part of caller thread . If you call start ( args ) method on Thread , the Java Virtual Machine will call run ( ) method and two threads will run concurrently - Current Thread ( main ( args ) in your example ) and Other Thread ( Runnable r1 in your example ) . Have a look at source code of start ( args ) method in Thread class # pre In above code , you can ' t see invocation to run ( args ) method . private native void start0 ( args ) is responsible for calling run ( args ) method . JVM executes this native method .

Question - 23932061 , answer - 23932216 You can easily create a Stream out of an Iterable or Iterator : # pre

Question - 8579657 , answer - 19629304 If you do run ( args ) in main method , the thread of main method will invoke the run method instead of the thread you require to run . The start ( args ) method creates new thread and for which the run ( args ) method has to be done

Question - 5785745 , answer - 34845194 You can also use Arrays . copyOfRange . Example : # pre This method is similar to Arrays . copyOf , but it ' s more flexible . Both of them use System . arraycopy under the hood . See : # li # a # li # a # li # a

Question - 27747562 In the following code , a dowcast to an apparently incompatible type passes compilation : # pre Item and List < T > are disparate types so the cast can never succeed . Why did the compiler allow this ?

Question - 32632364 , answer - 32633199 It shouldn ' t have compiled , according to JLS 7 . int can be compared to boxed numeric types , i . e . Byte , Short , Character , Integer , Long , Float , Double . But that is all . And if comparison is between int and say Float , Float will be unboxed first , so that the comparison is between float and int . It ' ll make no sense to do the other way around - box int then examine the identity of the Integer ( with a Float no less ) .

Question - 31993377 , answer - 31993478 You are consuming the value of next ( args ) , but asking for hasNext ( args ) and hasNextLine ( args ) . next ( args ) , per default , returns everything to the next whitespace ( args ) . So you are iterating through all whitespace seperated strings , and after each of them you are asking about the nextLine ( args ) . i 1 1 - > hasNextLine ( args ) ? True . hasNext ( args ) ? Also true . 1 1 - > hasNextLine ( args ) ? True . hasNext ( args ) ? Also true ( still a whitespace left ) 1 - > hasNextLine ( args ) ? True ( Line Seperator , probably ) . haxNext ? False , no whitespace anymore .

Question - 31270759 , answer - 31273726 What if every functional interface provided by java . util . function was allowed to throw an exception ? # pre We could use some default methods to provide the behavior you want . # li You could fallback to some default value or action # li Or you could try to perform another action which may throw an exception I ' ve written a library which redefines most of the interfaces in java . util . function this way . I even provide a ThrowingStream which let ' s you use these new interfaces with the same API as a regular Stream . # pre ( Nothing is a RuntimeException that can never be thrown . ) Your original example would become # pre

Question - 5439529 I ' m trying to determine if a particular item in an Array of strings is an integer or not . I am . split ( args ) ' ing an infix expression in String form , and then trying to split the resultant array into two arrays ; one for integers , one for operators , whilst discarding parentheses , and other miscellaneous items . What would be the best way to accomplish this ? I thought I might be able to find a Integer . isInteger ( args ) method or something , but no such luck .

Question - 16098046 , answer - 16098086 You could use printf ( args ) with % f : # pre This will print dexp : 12345678 . 000000 . If you don ' t want the fractional part , use System . out . printf ( args ) ; This uses the format specifier language explained in the documentation . The default toString ( args ) format used in your original code is spelled out here .

Question - 9510125 , answer - 9511880 validate ( args ) : In Swing when you create Component , it is not valid i . e . it ' s valid property is false . A component is said to be valid , when it ' s width , height , location and stuff has been determined . This is usually done by calling their validate ( args ) method , directly or indirectly . When we call validate ( args ) on containers , it will validate the container ( if it is invalid ) by calling its doLayout ( args ) method , which typically will invoke the LayoutManager . Now each child placed on this container will be validated recursively , so that the entire tree will be laid out and will become valid . revalidate ( args ) : revalidate ( args ) is to be called when you change an attribute that would affect their width / height and call repaint ( ) when you change an attribute that would affect their appearance . For Example , If your JFrame contains a JPanel , now at certain point of time you removed that JPanel and inserted a new one in it ' s place , depending on the contents of the newly placed JPanel , the size of the components inside the JPanel as well as The CONTAINER itself ( by virtue of the layout manager used by it ) , changes . Which pushes it to the invalidate state . So in order to validate this change , you have to explicitly call revalidate ( args ) . invalidate ( args ) : This thing is something , I had never used , so might be not much of the info I can give . But seems like the scenario presented above , can give a bit of hint , as to what happens in invalidate ( args ) .

Question - 32714194 , answer - 32714222 + is implemented in java compilers . The compiler replaces String + String with either compile time constants or StringBuilder code . Note that this applies to primitives too . i . e , int i = 1 + 2 could get directly replaced to int i = 3 during compilation itself .

Question - 23653778 , answer - 25564062 Try OnStart ( args ) method and just use View view = getView ( args ) . findViewById ( args ) ; or Declare any View using getView ( args ) . findViewById method in onStart ( args ) Declare click listener on view by anyView . setOnClickListener ( args ) ;

Question - 19416644 , answer - 19775881 Create your own class System in tha same package with Condition . In this case your System class will hide java . lang . System class # pre Ideone DEMO

Question - 4871051 , answer - 21274808 Use CodeSource # getLocation ( ) . This works fine in JAR files as well . You can obtain CodeSource by ProtectionDomain # getCodeSource ( ) and the ProtectionDomain in turn can be obtained by Class # getProtectionDomain ( ) . # pre

Question - 27888429 , answer - 27888481 Stream . of ( args ) Or , if you are already have an array , you can also do Stream . of ( args ) For primitive types use IntStream . of or LongStream . of etc .

Question - 18571223 , answer - 18571358 Try using String . getBytes ( ) . It returns a byte [ ] representing string data . Example : # pre

Question - 7348711 Which of the following is the best and most portable way to get the hostname of the current computer in Java ? Runtime . getRuntime ( args ) . exec ( args ) vs InetAddress . getLocalHost ( args ) . getHostName ( args )

Question - 19431234 , answer - 23526153 Everything is here : # a The answer with " round - tripping " is not exact : when you do LocalDateTime ldt = LocalDateTime . ofInstant ( args ) ; if your system timezone is not UTC / GMT , you change the time !

Question - 14846920 , answer - 14846963 # blockquote For the same reason you ' d use Collections . unmodifiableMap ( ) at some point . You want to return a Map instance that throws an exception if the user attempts to modify it . It ' s just a special case : the empty Map .

Question - 34172978 , answer - 34173040 Since there are only 4 elements that pass the filter , limit ( args ) never reaches 10 elements , so the Stream pipeline keeps generating new elements and feeding them to the filter , trying to reach 10 elements that pass the filter , but since only the first 4 elements pass the filter , the processing never ends ( at least until i overflows ) . The Stream pipeline is not smart enough to know that no more elements can pass the filter , so it keeps processing new elements .

Question - 19235606 , answer - 19235863 You should almost certainly never have to deal with Spliterator as a user ; it should only be necessary if you ' re writing Collection types yourself and also intending to optimize parallelized operations on them . For what it ' s worth , a Spliterator is a way of operating over the elements of a collection in a way that it ' s easy to split off part of the collection , e . g . because you ' re parallelizing and want one thread to work on one part of the collection , one thread to work on another part , etc . You should essentially never be saving values of type Stream to a variable , either . Stream is sort of like an Iterator , in that it ' s a one - time - use object that you ' ll almost always use in a fluent chain , as in the Javadoc example : int sum = widgets . stream ( args ) . filter ( args ) . mapToInt ( args ) . sum ( args ) ; Collector is the most generalized , abstract possible version of a " reduce " operation a la map / reduce ; in particular , it needs to support parallelization and finalization steps . Examples of Collector s include : # li summing , e . g . Collectors . reducing ( args ) # li StringBuilder appending , e . g . Collectors . of ( args )

Question - 32294367 , answer - 32378895 # blockquote Yes and No . I explain : # li Referring to shared memory : Different threads in a Java process share the whole heap , therefore threads can interact in a huge number of planned and unplanned ways . However objects in the stack ( e . g . a context you pass down to called method ) or a ThreadLocal are their own thread ' s ( unless they start sharing references ) . # li Crashing : If a thread crashes in Java ( a Throwable is propagated into Thread . run ( args ) , or something gets looped or blocked ) , that mishap might not affect other threads ( e . g . a pool of connections in a server will continue to operate ) . However as different threads interact . Other threads will easily get stranded if one of them ends abnormally ( e . g . one thread trying to read from an empty pipe from another thread which did not close its end ) . So unless the developers are highly paranoid careful , it is very likely that side effects will occur . I doubt that any other paradigm intends threads to operate as totally independent islands . They must share information and coordinate somehow . And then there will be the chance to mess things up . It is just they will take a more defensive approach that " gives you less rope to hang yourself " ( same idiom as with pointers ) .

Question - 7520432 , answer - 7521675 Just remember that . equals ( args ) has to be implemented by the class you are trying to compare . Otherwise , there isn ' t much of a point ; the version of the method for the Object class does the same thing as the comparison operation : Object # equals . The only time you really want to use the comparison operator for objects is wen you are comparing Enums . This is because there is only one instance of an Enum value at a time . For instance , given the enum enum FooEnum { A , B , C } You will never have more than one instance of A at a time , and the same for B and C . This means that you can actually write a method like so : # pre And you will have no problems whatsoever .

Question - 19998454 , answer - 19998652 This is being described in this article . Think about forEach of Collections . List < T > list = … list . forEach ( args ) ; # blockquote

Question - 29095967 I have this list ( List < T > ) : [ StringLiteral , StringLiteral , null , StringLiteral , null , StringLiteral , StringLiteral ] And I ' d like something like this : [ [ StringLiteral , StringLiteral ] , [ StringLiteral ] , [ StringLiteral , StringLiteral ] ] In other words I want to split my list in sublists using the null value as separator , in order to obtain a list of lists ( List < T > ) . I ' m looking for a Java 8 solution . I ' ve tried with Collectors . partitioningBy but I ' m not sure it is what I ' m looking for . Thanks !

Question - 32623834 , answer - 32652449 Another related point : you can make use of the constant pool to improve the performance of string comparisons in some circumstances , by using the String . intern ( ) method . That method returns the instance of String with the same contents as the String on which it is invoked from the String constants pool , adding it it if is not yet present . In other words , after using intern ( args ) , all Strings with the same contents are guaranteed to be the same String instance as each other and as any String constants with those contents , meaning you can then use the equals operator ( = = ) on them . This is just an example which is not very useful on its own , but it illustrates the point : # pre This little trick isn ' t worth designing your code around , but it is worth keeping in mind for the day when you notice a little more speed could be eked out of some bit of performance sensitive code by using the = = operator on a string with judicious use of intern ( args ) .

Question - 27949213 , answer - 27949581 Imagine you have a phone book , which contains people , which have a String firstName and a String lastName . And it happens that in your phone book , 100 , 000 people have the same firstName = StringLiteral . Because you get the data from a database or a file those strings are not interned so your JVM memory contains the char array { CharLiteral , CharLiteral , CharLiteral , CharLiteral } 100 thousand times , one per John string . Each of these arrays takes , say , 20 bytes of memory so those 100k Johns take up 2 MB of memory . With deduplication , the JVM will realise that " John " is duplicated many times and make all those John strings point to the same underlying char array , decreasing the memory usage from 2MB to 20 bytes . You can find a more detailed explanation in the JEP . In particular : # blockquote

Question - 22435833 In Java 8 , there is a new method String . chars ( ) which returns a stream of int s ( IntStream ) that represent the character codes . I guess many people would expect a stream of char s here instead . What was the motivation to design the API this way ?

Question - 18571223 , answer - 20262456 You might wanna try return new String ( args )

Question - 25850328 , answer - 25853827 I would argue first - off that Serializable and Cloneable are bad examples of marker interfaces . Sure , they ' re interfaces with methods , but they imply methods , such as writeObject ( args ) . ( The compiler will create a writeObject ( args ) method for you if you don ' t override it , and all objects already have clone ( args ) , but the compiler will again create a real clone ( args ) method for you but with caveats . Both of these are weird edge cases that really aren ' t good design examples . ) Marker interfaces are generally used for one of two purposes : 1 ) As a shortcut to avoid an excessively long type , which can happen with lots of generics . For instance , say you have this method signature : public void doSomething ( args ) { . . . } That ' s messy and annoying to type , and more importantly , difficult to understand . Consider this instead : public interface Widget extends Foobar < T > { } Then your method looks like this : public void doSomething ( args ) { . . . } Not only is it clearer , but you can now Javadoc the Widget interface , and it ' s also easier to search for all occurrences in your code of Widget . 2 ) Marker interfaces can also be used as a way around Java ' s lack of intersection types . With a marker interface , you can require something to be of two different types , such as in a method signature . Say you have some interface Widget in your application , like we described above . If you have a method that requires a Widget that also happens to let you iterate over it ( it ' s contrived , but work with me here ) , your only good solution is to create a marker interface that extends both interfaces : public interface IterableWidget extends Iterable < T > , Widget { } And in your code : # pre

Question - 18647214 , answer - 18647232 I would just do this . It basically takes the minimum between 100 ( the max health ) and what the health would be with 15 extra points . It ensures that the user ' s health does not exceed 100 . # pre To ensure that hitpoints do not drop below zero , you can use a similar function : Math . max . # pre

Question - 29095967 , answer - 29096777 The only solution I come up with for the moment is by implementing your own custom collector . Before reading the solution , I want to add a few notes about this . I took this question more as a programming exercise , I ' m not sure if it can be done with a parallel stream . So you have to be aware that it ' ll silently break if the pipeline is run in parallel . This is not a desirable behavior and should be avoided . This is why I throw an exception in the combiner part ( instead of ( l1 , l2 ) - > { l1 . addAll ( args ) ; return l1 ; } ) , as it ' s used in parallel when combining the two lists , so that you have an exception instead of a wrong result . Also this is not very efficient due to list copying ( although it uses a native method to copy the underlying array ) . So here ' s the collector implementation : # pre and how to use it : List < T > ll = list . stream ( args ) . collect ( args ) ; Output : [ [ a , b ] , [ c ] , [ d , e ] ] As the answer of Joop Eggen is out , it appears that it can be done in parallel ( give him credit for that ! ) . With that it reduces the custom collector implementation to : # pre which let the paragraph about parallelism a bit obsolete , however I let it as it can be a good reminder . Note that the Stream API is not always a substitute . There are tasks that are easier and more suitable using the streams and there are tasks that are not . In your case , you could also create a utility method for that : # pre and call it like List < T > list = splitBySeparator ( args ) ; . It can be improved for checking edge - cases .

Question - 11774099 , answer - 11774137 iterate through the whole 65k chars and ask Character . isJavaIdentifierStart ( args ) . The answer is : " undertie " decimal 8255

Question - 31922866 , answer - 31922994 I think that is because you usually write your functions to manipulate data , and then lift it to Optional using map and similar functions . This adds the default Optional behavior to it . Of course , there might be cases , when it is necessary to write your own auxilary function that works on Optional .

Question - 20001427 , answer - 20001866 Usually , one would call the reduce method using Math . max ( args ) as follows : # pre That requires a lot of syntax for just calling Math . max . That ' s where lambda expressions come into play . Since Java 8 it is allowed to do the same thing in a much shorter way : reduce ( args ) ; How does this work ? The java compiler " detects " , that you want to implement a method that accepts two int s and returns one int . This is equivalent to the formal parameters of the one and only method of interface IntBinaryOperator ( the parameter of method reduce you want to call ) . So the compiler does the rest for you - it just assumes you want to implement IntBinaryOperator . But as Math . max ( args ) itself fulfills the formal requirements of IntBinaryOperator , it can be used directly . Because Java 7 does not have any syntax that allows a method itself to be passed as an argument ( you can only pass method results , but never method references ) , the : : syntax was introduced in Java 8 to reference methods : reduce ( args ) ; Note that this will be interpreted by the compiler , not by the JVM at runtime ! Although it produces different bytecodes for all three code snippets , they are semantically equal , so the last two can be considered to be short ( and probably more efficient ) versions of the IntBinaryOperator implementation above ! ( See also Translation of Lambda Expressions )

Question - 21947452 , answer - 29434641 I performed tests on Eclipse vs Netbeans 8 . 0 . 2 , both with Java version 1 . 8 ; I used System . nanoTime ( args ) for measurements . Eclipse : I got the same time on both cases - around 1 . 564 seconds . Netbeans : # li Using " # " : 1 . 536 seconds # li Using " B " : 44 . 164 seconds So , it looks like Netbeans has bad performance on print to console . After more research I realized that the problem is line - wrapping of the max buffer of Netbeans ( it ' s not restricted to System . out . println command ) , demonstrated by this code : # pre The time results are less then 1 millisecond every iteration except every fifth iteration , when the time result is around 225 millisecond . Something like ( in nanoseconds ) : # pre And so on . . Summary : # li Eclipse works perfectly with " B " # li Netbeans has a line - wrapping problem that can be solved ( because the problem does not occur in eclipse ) ( without adding space after B ( " B " ) ) .

Question - 7348711 , answer - 7353473 InetAddress . getLocalHost ( args ) . getHostName ( args ) is better ( as explained by Nick ) , but still not very good One host can be known under many different hostnames . Usually you ' ll be looking for the hostname your host has in a specific context . For example , in a web application , you might be looking for the hostname used by whoever issued the request you ' re currently handling . How to best find that one depends on which framework you ' re using for your web application . In some kind of other internet - facing service , you ' ll want the hostname your service is available through from the ' outside ' . Due to proxies , firewalls etc this might not even be a hostname on the machine your service is installed on - you might try to come up with a reasonable default , but you should definitely make this configurable for whoever installs this .

Question - 8777257 , answer - 8777279 array1 . equals ( args ) is the same as array1 = = array2 , i . e . is it the same array . As @ alf points out it ' s not what most people expect . Arrays . equals ( args ) compares the contents of the arrays . Similarly array . toString ( args ) may not be very useful and you need to use Arrays . toString ( args ) .

Question - 23218874 I understand that with . stream ( args ) , I can use chain operations like . filter ( args ) or use parallel stream . But what is difference between them if I need to execute small operations ( for example , printing the elements of the list ) ? # pre

Question - 30217236 , answer - 30217518 Presumably , you are not calling your generic method in a generic fashion , so it ' s treated like a call to x ( args ) . In this example : # pre The first call to x is not made generically so it compiles . The second call equates T to String , so it fails because 1 and 2 are not Strings . The third call compiles because it properly passes in Strings .

Question - 31922866 , answer - 31923214 This seems a bit silly to me , but the only reason I can think of is that object arguments in method parameters already are optional in a way - they can be null . Therefore forcing someone to take an existing object and wrap it in an optional is sort of pointless . That being said , chaining methods together that take / return optionals is a reasonable thing to do , e . g . Maybe monad .

