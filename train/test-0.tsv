Question	O
-	O
24603186	O
,	O
answer	O
-	O
24603187	O
The	O
Javadocs	O
for	O
Collection	B-api_mention
.	I-api_mention
(	I-api_mention
parallelS	I-api_mention
|	I-api_mention
s	I-api_mention
)	I-api_mention
tream	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
and	O
Stream	B-api_mention
itself	O
don	O
'	O
t	O
answer	O
the	O
question	O
,	O
so	O
it	O
'	O
s	O
off	O
to	O
the	O
mailing	O
lists	O
for	O
the	O
rationale	O
.	O
I	O
went	O
through	O
the	O
lambda	O
-	O
libs	O
-	O
spec	O
-	O
observers	O
archives	O
and	O
found	O
one	O
thread	O
specifically	O
about	O
Collection	B-api_mention
.	I-api_mention
parallelStream	I-api_mention
(	I-api_mention
)	I-api_mention
and	O
another	O
thread	O
that	O
touched	O
on	O
whether	O
java	B-api_mention
.	I-api_mention
util	I-api_mention
.	I-api_mention
Arrays	I-api_mention
should	O
provide	O
parallelStream	B-api_mention
(	I-api_mention
)	I-api_mention
to	O
match	O
(	O
or	O
actually	O
,	O
whether	O
it	O
should	O
be	O
removed	O
)	O
.	O
There	O
was	O
no	O
once	O
-	O
and	O
-	O
for	O
-	O
all	O
conclusion	O
,	O
so	O
perhaps	O
I	O
'	O
ve	O
missed	O
something	O
from	O
another	O
list	O
or	O
the	O
matter	O
was	O
settled	O
in	O
private	O
discussion	O
.	O
(	O
Perhaps	O
Brian	O
Goetz	O
,	O
one	O
of	O
the	O
principals	O
of	O
this	O
discussion	O
,	O
can	O
fill	O
in	O
anything	O
missing	O
.	O
)	O
The	O
participants	O
made	O
their	O
points	O
well	O
,	O
so	O
this	O
answer	O
is	O
mostly	O
just	O
an	O
organization	O
of	O
the	O
relevant	O
quotes	O
,	O
with	O
a	O
few	O
clarifications	O
in	O
[	O
brackets	O
]	O
,	O
presented	O
in	O
order	O
of	O
importance	O
(	O
as	O
I	O
interpret	O
it	O
)	O
.	O
parallelStream	B-api_mention
(	I-api_mention
)	I-api_mention
covers	O
a	O
very	O
common	O
case	O
Brian	O
Goetz	O
in	O
the	O
first	O
thread	O
,	O
explaining	O
why	O
Collections	B-api_mention
.	I-api_mention
parallelStream	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
is	O
valuable	O
enough	O
to	O
keep	O
even	O
after	O
other	O
parallel	O
stream	O
factory	O
methods	O
have	O
been	O
removed	O
:	O
#	O
blockquote	O
Brian	O
Goetz	O
stands	O
by	O
this	O
position	O
in	O
the	O
later	O
discussion	O
about	O
Arrays	B-api_mention
.	I-api_mention
parallelStream	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
:	O
#	O
blockquote	O
parallelStream	B-api_mention
(	I-api_mention
)	I-api_mention
is	O
more	O
performant	O
Brian	O
Goetz	O
:	O
#	O
blockquote	O
In	O
response	O
to	O
Kevin	O
Bourrillion	O
'	O
s	O
skepticism	O
about	O
whether	O
the	O
effect	O
is	O
significant	O
,	O
Brian	O
again	O
:	O
#	O
blockquote	O
Doug	O
Lea	O
follows	O
up	O
,	O
but	O
hedges	O
his	O
position	O
:	O
#	O
blockquote	O
Indeed	O
,	O
the	O
later	O
discussion	O
about	O
Arrays	B-api_mention
.	I-api_mention
parallelStream	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
takes	O
notice	O
of	O
lower	O
Stream	B-api_mention
.	I-api_mention
parallel	I-api_mention
(	I-api_mention
)	I-api_mention
cost	O
.	O
stream	B-api_mention
(	I-api_mention
)	I-api_mention
.	I-api_mention
parallel	I-api_mention
(	I-api_mention
)	I-api_mention
statefulness	O
complicates	O
the	O
future	O
At	O
the	O
time	O
of	O
the	O
discussion	O
,	O
switching	O
a	O
stream	O
from	O
sequential	O
to	O
parallel	O
and	O
back	O
could	O
be	O
interleaved	O
with	O
other	O
stream	O
operations	O
.	O
Brian	O
Goetz	O
,	O
on	O
behalf	O
of	O
Doug	O
Lea	O
,	O
explains	O
why	O
sequential	O
/	O
parallel	O
mode	O
switching	O
may	O
complicate	O
future	O
development	O
of	O
the	O
Java	O
platform	O
:	O
#	O
blockquote	O
This	O
mode	O
switching	O
was	O
removed	O
after	O
further	O
discussion	O
.	O
In	O
the	O
current	O
version	O
of	O
the	O
library	O
,	O
a	O
stream	O
pipeline	O
is	O
either	O
sequential	O
or	O
parallel	O
;	O
last	O
call	O
to	O
sequential	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
/	O
parallel	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
wins	O
.	O
Besides	O
side	O
-	O
stepping	O
the	O
statefulness	O
problem	O
,	O
this	O
change	O
also	O
improved	O
the	O
performance	O
of	O
using	O
parallel	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
to	O
set	O
up	O
a	O
parallel	O
pipeline	O
from	O
a	O
sequential	O
stream	O
factory	O
.	O
exposing	O
parallelStream	B-api_mention
(	I-api_mention
)	I-api_mention
as	O
a	O
first	O
-	O
class	O
citizen	O
improves	O
programmer	O
perception	O
of	O
the	O
library	O
,	O
leading	O
them	O
to	O
write	O
better	O
code	O
Brian	O
Goetz	O
again	O
,	O
in	O
response	O
to	O
Tim	O
Peierls	O
'	O
s	O
argument	O
that	O
Stream	B-api_mention
.	I-api_mention
parallel	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
allows	O
programmers	O
to	O
understand	O
streams	O
sequentially	O
before	O
going	O
parallel	O
:	O
#	O
blockquote	O
Question	O
-	O
7488643	O
,	O
answer	O
-	O
7488669	O
Two	O
steps	O
:	O
#	O
li	O
String	B-api_mention
[	O
]	O
items	O
=	O
commaSeparated	O
.	B-api_mention
split	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
#	O
li	O
List	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
container	O
=	O
Arrays	B-api_mention
.	I-api_mention
asList	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Question	O
-	O
29229373	O
I	O
have	O
the	O
following	O
sample	O
code	O
:	O
#	O
pre	O
The	O
output	O
is	O
as	O
follows	O
:	O
#	O
pre	O
From	O
here	O
I	O
see	O
that	O
in	O
first	O
case	O
stream	O
really	O
behaves	O
lazily	O
-	O
we	O
use	O
findFirst	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
so	O
once	O
we	O
have	O
first	O
element	O
our	O
filtering	O
lambda	O
is	O
not	O
invoked	O
.	O
However	O
,	O
in	O
second	O
case	O
which	O
uses	O
flatMaps	O
we	O
see	O
that	O
despite	O
first	O
element	O
which	O
fulfils	O
the	O
filter	O
condition	O
is	O
found	O
(	O
it	O
'	O
s	O
just	O
any	O
first	O
element	O
as	O
lambda	O
always	O
returns	O
true	O
)	O
further	O
contents	O
of	O
the	O
stream	O
are	O
still	O
being	O
fed	O
through	O
filtering	O
function	O
.	O
I	O
am	O
trying	O
to	O
understand	O
why	O
it	O
behaves	O
like	O
this	O
rather	O
than	O
giving	O
up	O
after	O
first	O
element	O
is	O
calculated	O
as	O
in	O
the	O
first	O
case	O
.	O
Any	O
helpful	O
information	O
would	O
be	O
appreciated	O
.	O
Question	O
-	O
10827872	O
What	O
'	O
s	O
the	O
difference	O
between	O
java	B-api_mention
.	I-api_mention
lang	I-api_mention
.	I-api_mention
String	I-api_mention
'	O
s	O
replace	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
and	O
replaceAll	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
methods	O
,	O
other	O
than	O
later	O
uses	O
regex	O
?	O
For	O
simple	O
substitutions	O
like	O
,	O
replace	O
.	O
with	O
/	O
,	O
is	O
there	O
any	O
difference	O
?	O
Question	O
-	O
4818699	O
,	O
answer	O
-	O
4818916	O
The	O
primary	O
use	O
of	O
AtomicInteger	B-api_mention
is	O
when	O
you	O
are	O
in	O
a	O
multithreaded	O
context	O
and	O
you	O
need	O
to	O
perform	O
thread	O
safe	O
operations	O
on	O
an	O
integer	O
without	O
using	O
synchronized	O
.	O
The	O
assignation	O
and	O
retrieval	O
on	O
the	O
primitive	O
type	O
int	O
are	O
already	O
atomic	O
but	O
AtomicInteger	B-api_mention
comes	O
with	O
many	O
operations	O
which	O
are	O
not	O
atomic	O
on	O
int	O
.	O
The	O
simplest	O
are	O
the	O
getAndXXX	O
or	O
xXXAndGet	O
.	O
For	O
instance	O
getAndIncrement	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
is	O
an	O
atomic	O
equivalent	O
to	O
i	O
+	O
+	O
which	O
is	O
not	O
atomic	O
because	O
it	O
is	O
actually	O
a	O
short	O
cut	O
for	O
three	O
operations	O
:	O
retrieval	O
,	O
addition	O
and	O
assignation	O
.	O
compareAndSet	B-api_mention
is	O
very	O
useful	O
to	O
implements	O
semaphores	O
,	O
locks	O
,	O
latches	O
,	O
etc	O
.	O
Using	O
the	O
AtomicInteger	B-api_mention
is	O
faster	O
and	O
more	O
readable	O
than	O
performing	O
the	O
same	O
using	O
synchronization	O
.	O
A	O
simple	O
test	O
:	O
#	O
pre	O
On	O
my	O
PC	O
with	O
Java	O
1	O
.	O
6	O
the	O
atomic	O
test	O
runs	O
in	O
3	O
seconds	O
while	O
the	O
synchronized	O
one	O
runs	O
in	O
about	O
5	O
.	O
5	O
seconds	O
.	O
The	O
problem	O
here	O
is	O
that	O
the	O
operation	O
to	O
synchronize	O
(	O
notAtomic	O
+	O
+	O
)	O
is	O
really	O
short	O
.	O
So	O
the	O
cost	O
of	O
the	O
synchronization	O
is	O
really	O
important	O
compared	O
to	O
the	O
operation	O
.	O
Beside	O
atomicity	O
AtomicInteger	B-api_mention
can	O
be	O
use	O
as	O
a	O
mutable	O
version	O
of	O
Integer	B-api_mention
for	O
instance	O
in	O
Map	B-api_mention
s	O
as	O
values	O
.	O
Question	O
-	O
8894258	O
,	O
answer	O
-	O
8894384	O
This	O
is	O
just	O
micro	O
-	O
optimisation	O
that	O
you	O
shouldn	O
'	O
t	O
worry	O
about	O
.	O
char	O
[	O
]	O
chars	O
=	O
str	B-api_mention
.	I-api_mention
toCharArray	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
returns	O
you	O
a	O
copy	O
of	O
str	O
character	O
arrays	O
(	O
in	O
JDK	O
,	O
it	O
returns	O
a	O
copy	O
of	O
characters	O
by	O
calling	O
System	O
.	O
arrayCopy	O
)	O
.	O
Other	O
than	O
that	O
,	O
str	B-api_mention
.	I-api_mention
charAt	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
only	O
checks	O
if	O
the	O
index	O
is	O
indeed	O
in	O
bounds	O
and	O
returns	O
a	O
character	O
within	O
the	O
array	O
index	O
.	O
The	O
first	O
one	O
doesn	O
'	O
t	O
create	O
additional	O
memory	O
in	O
JVM	O
.	O
Question	O
-	O
6470651	O
,	O
answer	O
-	O
6780439	O
Here	O
'	O
s	O
a	O
simple	O
/	O
sinister	O
one	O
via	O
#	O
a	O
.	O
#	O
pre	O
Because	O
the	O
substring	O
refers	O
to	O
the	O
internal	O
representation	O
of	O
the	O
original	O
,	O
much	O
longer	O
string	O
,	O
the	O
original	O
stays	O
in	O
memory	O
.	O
Thus	O
,	O
as	O
long	O
as	O
you	O
have	O
a	O
StringLeaker	B-api_mention
in	O
play	O
,	O
you	O
have	O
the	O
whole	O
original	O
string	O
in	O
memory	O
,	O
too	O
,	O
even	O
though	O
you	O
might	O
think	O
you	O
'	O
re	O
just	O
holding	O
on	O
to	O
a	O
single	O
-	O
character	O
string	O
.	O
The	O
way	O
to	O
avoid	O
storing	O
an	O
unwanted	O
reference	O
to	O
the	O
original	O
string	O
is	O
to	O
do	O
something	O
like	O
this	O
:	O
#	O
pre	O
For	O
added	O
badness	O
,	O
you	O
might	O
also	O
.	B-api_mention
intern	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
the	O
substring	O
:	O
#	O
pre	O
Doing	O
so	O
will	O
keep	O
both	O
the	O
original	O
long	O
string	O
and	O
the	O
derived	O
substring	O
in	O
memory	O
even	O
after	O
the	O
StringLeaker	B-api_mention
instance	O
has	O
been	O
discarded	O
.	O
Question	O
-	O
31965179	O
,	O
answer	O
-	O
35427268	O
There	O
'	O
s	O
a	O
long	O
list	O
of	O
things	O
that	O
have	O
been	O
changed	O
in	O
Hibernate	O
5	O
:	O
#	O
li	O
New	O
bootstrap	O
API	O
so	O
we	O
can	O
bootstrap	O
a	O
JPA	O
environment	O
programmatically	O
without	O
the	O
need	O
of	O
a	O
persistence	O
.	O
xml	O
file	O
.	O
#	O
li	O
Starting	O
in	O
5	O
.	O
0	O
Hibernate	O
Spatial	O
is	O
part	O
of	O
the	O
Hibernate	O
project	O
so	O
we	O
can	O
handle	O
GIS	O
data	O
too	O
.	O
#	O
li	O
The	O
Java	O
8	O
Date	B-api_mention
and	O
Time	B-api_mention
types	O
are	O
supported	O
in	O
domain	O
model	O
mappings	O
.	O
The	O
mapping	O
between	O
the	O
standard	O
SQL	O
Date	O
/	O
Time	O
types	O
and	O
the	O
supported	O
Java	O
8	O
Date	B-api_mention
/	O
Time	B-api_mention
class	O
types	O
looks	O
as	O
follows	O
;	O
#	O
li	O
DATE	O
:	O
java	O
.	O
time	O
.	O
LocalDate	O
#	O
li	O
TIME	O
:	O
java	O
.	O
time	O
.	O
LocalTime	O
,	O
java	O
.	O
time	O
.	O
OffsetTime	O
#	O
li	O
TIMESTAMP	O
:	O
java	O
.	O
time	O
.	O
Instant	O
,	O
java	O
.	O
time	O
.	O
LocalDateTime	O
,	O
java	O
.	O
time	O
.	O
OffsetDateTime	O
and	O
java	O
.	O
time	O
.	O
ZonedDateTime	O
#	O
li	O
The	O
bytecode	O
enhancement	O
mechanism	O
was	O
redesigned	O
from	O
scratch	O
,	O
and	O
Hibernate	O
features	O
both	O
a	O
Maven	O
and	O
a	O
Gradle	O
plugin	O
.	O
There	O
are	O
three	O
main	O
aspects	O
which	O
we	O
can	O
enhance	O
with	O
bytecode	O
instrumentation	O
:	O
#	O
li	O
Lazy	O
initialization	O
:	O
Fields	O
can	O
be	O
declared	O
as	O
LAZY	O
and	O
they	O
will	O
be	O
fetched	O
only	O
when	O
being	O
accessed	O
for	O
the	O
first	O
time	O
.	O
#	O
li	O
Dirty	O
checking	O
:	O
Entities	O
are	O
enhanced	O
so	O
that	O
they	O
can	O
keep	O
track	O
of	O
all	O
the	O
properties	O
that	O
get	O
changed	O
after	O
being	O
loaded	O
in	O
a	O
Persistence	O
Context	O
.	O
#	O
li	O
Bidirectional	O
associations	O
:	O
It	O
'	O
s	O
possible	O
to	O
synchronize	O
both	O
sides	O
of	O
a	O
bidirectional	O
association	O
automatically	O
,	O
even	O
if	O
the	O
developer	O
only	O
updates	O
a	O
single	O
side	O
.	O
#	O
li	O
Hibernate	O
'	O
s	O
native	O
APIs	O
(	O
Session	O
,	O
etc	O
)	O
have	O
been	O
updated	O
to	O
use	O
generic	O
typed	O
.	O
No	O
need	O
to	O
cast	O
when	O
fetching	O
entities	O
.	O
#	O
li	O
Hibernate	O
5	O
.	O
0	O
expends	O
this	O
to	O
a	O
broader	O
set	O
of	O
types	O
(	O
e	O
.	O
g	O
.	O
UUID	O
)	O
.	O
#	O
li	O
Second	O
-	O
level	O
cache	O
by	O
reference	O
.	O
This	O
feature	O
enables	O
direct	O
storage	O
of	O
entity	O
references	O
into	O
the	O
second	O
level	O
cache	O
for	O
immutable	O
entities	O
.	O
#	O
li	O
Starting	O
with	O
Hibernate	O
5	O
.	O
0	O
,	O
we	O
have	O
a	O
completely	O
new	O
User	O
Guide	O
that	O
was	O
written	O
from	O
scratch	O
.	O
Question	O
-	O
6667243	O
,	O
answer	O
-	O
6667354	O
Enum	O
is	O
just	O
a	O
little	O
bit	O
special	O
class	O
.	O
Enums	O
can	O
store	O
additional	O
fields	O
,	O
implement	O
methods	O
etc	O
.	O
For	O
example	O
#	O
pre	O
Now	O
you	O
can	O
say	O
:	O
System	B-api_mention
.	I-api_mention
out	I-api_mention
.	I-api_mention
println	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
and	O
see	O
output	O
:	O
a	O
Question	O
-	O
16252269	O
,	O
answer	O
-	O
29652714	O
You	O
can	O
use	O
Collections	B-api_mention
.	I-api_mention
sort	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
to	O
sort	O
list	O
if	O
your	O
list	O
contains	O
Comparable	B-api_mention
elements	O
.	O
Otherwise	O
I	O
would	O
recommend	O
you	O
to	O
implement	O
that	O
interface	O
like	O
here	O
:	O
public	O
class	O
Circle	O
implements	O
Comparable	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
{	O
}	O
and	O
of	O
course	O
provide	O
your	O
own	O
realization	O
of	O
compareTo	B-api_mention
method	O
like	O
here	O
:	O
#	O
pre	O
And	O
then	O
you	O
can	O
again	O
use	O
Colection	B-api_mention
.	I-api_mention
sort	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
as	O
now	O
list	O
contains	O
objects	O
of	O
Comparable	B-api_mention
type	O
and	O
can	O
be	O
sorted	O
.	O
Order	O
depends	O
on	O
compareTo	B-api_mention
method	O
.	O
Check	O
this	O
#	O
a	O
for	O
more	O
detailed	O
information	O
.	O
Question	O
-	O
32623834	O
,	O
answer	O
-	O
32624143	O
You	O
just	O
changed	O
the	O
String	B-api_mention
of	O
String	B-api_mention
constant	O
pool	O
Mario	O
to	O
Luigi	O
which	O
was	O
referenced	O
by	O
multiple	O
String	B-api_mention
s	O
,	O
so	O
every	O
referencing	O
literal	O
Mario	O
is	O
now	O
Luigi	O
.	O
Field	B-api_mention
stringValue	O
=	O
String	B-api_mention
.	I-api_mention
class	I-api_mention
.	I-api_mention
getDeclaredField	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
You	O
have	O
fetched	O
the	O
char	O
[	O
]	O
named	O
value	O
field	O
from	O
class	O
String	B-api_mention
stringValue	O
.	B-api_mention
setAccessible	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Make	O
it	O
accessible	O
.	O
stringValue	O
.	B-api_mention
set	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
You	O
changed	O
original	O
String	B-api_mention
field	O
to	O
Luigi	O
.	O
But	O
original	O
is	O
Mario	O
the	O
String	B-api_mention
literal	O
and	O
literal	O
belongs	O
to	O
the	O
String	B-api_mention
pool	O
and	O
all	O
are	O
interned	O
.	O
Which	O
means	O
all	O
the	O
literals	O
which	O
has	O
same	O
content	O
refers	O
to	O
the	O
same	O
memory	O
address	O
.	O
#	O
pre	O
Basically	O
you	O
have	O
changed	O
the	O
Mario	O
of	O
String	B-api_mention
pool	O
which	O
got	O
reflected	O
in	O
all	O
the	O
referencing	O
fields	O
.	O
If	O
you	O
create	O
String	B-api_mention
Object	O
(	O
i	O
.	O
e	O
.	O
new	O
String	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
)	O
instead	O
of	O
literal	O
you	O
will	O
not	O
face	O
this	O
behavior	O
because	O
than	O
you	O
will	O
have	O
two	O
different	O
Mario	O
s	O
.	O
Question	O
-	O
32859038	O
I	O
have	O
a	O
List	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
collection	O
.	O
I	O
need	O
to	O
convert	O
it	O
into	O
Map	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
The	O
key	O
of	O
the	O
map	O
must	O
be	O
the	O
index	O
of	O
the	O
item	O
in	O
the	O
collection	O
.	O
I	O
can	O
not	O
figure	O
it	O
out	O
how	O
to	O
do	O
this	O
with	O
streams	O
.	O
Something	O
like	O
:	O
items	O
.	B-api_mention
stream	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
collect	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Any	O
help	O
?	O
As	O
this	O
question	O
is	O
identified	O
as	O
possible	O
duplicate	O
I	O
need	O
to	O
add	O
that	O
my	O
concrete	O
problem	O
was	O
-	O
how	O
to	O
get	O
the	O
position	O
of	O
the	O
item	O
in	O
the	O
list	O
and	O
put	O
it	O
as	O
a	O
key	O
value	O
Question	O
-	O
4818699	O
,	O
answer	O
-	O
4818783	O
The	O
absolute	O
simplest	O
example	O
I	O
can	O
think	O
of	O
is	O
to	O
make	O
incrementing	O
an	O
atomic	O
operation	O
.	O
With	O
standard	O
ints	O
:	O
#	O
pre	O
With	O
AtomicInteger	B-api_mention
:	O
#	O
pre	O
The	O
latter	O
is	O
a	O
very	O
simple	O
way	O
to	O
perform	O
simple	O
mutations	O
effects	O
(	O
especially	O
counting	O
,	O
or	O
unique	O
-	O
indexing	O
)	O
,	O
without	O
having	O
to	O
resort	O
to	O
synchronizing	O
all	O
access	O
.	O
More	O
complex	O
synchronization	O
-	O
free	O
logic	O
can	O
be	O
employed	O
by	O
using	O
compareAndSet	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
as	O
a	O
type	O
of	O
optimistic	O
locking	O
-	O
get	O
the	O
current	O
value	O
,	O
compute	O
result	O
based	O
on	O
this	O
,	O
set	O
this	O
result	O
iff	O
value	O
is	O
still	O
the	O
input	O
used	O
to	O
do	O
the	O
calculation	O
,	O
else	O
start	O
again	O
-	O
but	O
the	O
counting	O
examples	O
are	O
very	O
useful	O
,	O
and	O
I	O
'	O
ll	O
often	O
use	O
AtomicIntegers	O
for	O
counting	O
and	O
VM	O
-	O
wide	O
unique	O
generators	O
if	O
there	O
'	O
s	O
any	O
hint	O
of	O
multiple	O
threads	O
being	O
involved	O
,	O
because	O
they	O
'	O
re	O
so	O
easy	O
to	O
work	O
with	O
I	O
'	O
d	O
almost	O
consider	O
it	O
premature	O
optimisation	O
to	O
use	O
plain	O
ints	O
.	O
While	O
you	O
can	O
almost	O
always	O
achieve	O
the	O
same	O
synchronization	O
guarantees	O
with	O
ints	O
and	O
appropriate	O
synchronized	O
declarations	O
,	O
the	O
beauty	O
of	O
AtomicInteger	B-api_mention
is	O
that	O
the	O
thread	O
-	O
safety	O
is	O
built	O
into	O
the	O
actual	O
object	O
itself	O
,	O
rather	O
than	O
you	O
needing	O
to	O
worry	O
about	O
the	O
possible	O
interleavings	O
,	O
and	O
monitors	O
held	O
,	O
of	O
every	O
method	O
that	O
happens	O
to	O
access	O
the	O
int	O
value	O
.	O
It	O
'	O
s	O
much	O
harder	O
to	O
accidentally	O
violate	O
threadsafety	O
when	O
calling	O
getAndIncrement	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
than	O
when	O
returning	O
i	O
+	O
+	O
and	O
remembering	O
(	O
or	O
not	O
)	O
to	O
acquire	O
the	O
correct	O
set	O
of	O
monitors	O
beforehand	O
.	O
Question	O
-	O
29922296	O
,	O
answer	O
-	O
29922831	O
Three	O
questions	O
:	O
three	O
-	O
part	O
answer	O
:	O
Is	O
it	O
okay	O
from	O
a	O
design	O
point	O
of	O
view	O
?	O
Absolutely	O
.	O
Nothing	O
wrong	O
with	O
it	O
.	O
If	O
you	O
need	O
to	O
do	O
lots	O
of	O
iterating	O
over	O
your	O
enum	O
,	O
the	O
stream	O
API	O
is	O
the	O
clean	O
way	O
to	O
go	O
and	O
hiding	O
the	O
boiler	O
plate	O
behind	O
a	O
little	O
method	O
is	O
fine	O
.	O
Although	O
I	O
’	O
d	O
consider	O
OldCumudgeon	O
’	O
s	O
version	O
even	O
better	O
.	O
Is	O
it	O
okay	O
from	O
a	O
performance	O
point	O
of	O
view	O
?	O
It	O
most	O
likely	O
doesn	O
’	O
t	O
matter	O
.	O
Most	O
of	O
the	O
time	O
,	O
enums	O
are	O
not	O
that	O
big	O
.	O
Therefore	O
,	O
whatever	O
overhead	O
there	O
is	O
for	O
one	O
method	O
or	O
the	O
other	O
probably	O
doesn	O
’	O
t	O
matter	O
in	O
99	O
.	O
9	O
%	O
of	O
the	O
cases	O
.	O
Of	O
course	O
,	O
there	O
are	O
the	O
0	O
.	O
1	O
%	O
where	O
it	O
does	O
.	O
In	O
that	O
case	O
:	O
measure	O
properly	O
,	O
with	O
your	O
real	O
-	O
world	O
data	O
and	O
consumers	O
.	O
If	O
I	O
had	O
to	O
bet	O
,	O
I	O
’	O
d	O
expect	O
the	O
for	O
each	O
loop	O
to	O
be	O
faster	O
,	O
since	O
it	O
maps	O
more	O
directly	O
to	O
the	O
memory	O
model	O
,	O
but	O
don	O
’	O
t	O
guess	O
when	O
talking	O
performance	O
,	O
and	O
don	O
’	O
t	O
tune	O
before	O
there	O
is	O
actual	O
need	O
for	O
tuning	O
.	O
Write	O
your	O
code	O
in	O
a	O
way	O
that	O
is	O
correct	O
first	O
,	O
easy	O
to	O
read	O
second	O
and	O
only	O
then	O
worry	O
about	O
performance	O
of	O
code	O
style	O
.	O
Why	O
aren	O
’	O
t	O
Enums	O
properly	O
integrated	O
into	O
the	O
Stream	B-api_mention
API	O
?	O
If	O
you	O
compare	O
Java	O
’	O
s	O
Stream	B-api_mention
API	O
to	O
the	O
equivalent	O
in	O
many	O
other	O
languages	O
,	O
it	O
appears	O
seriously	O
limited	O
.	O
There	O
are	O
various	O
pieces	O
that	O
are	O
missing	O
(	O
reusable	O
Streams	O
and	O
Optionals	O
as	O
Streams	O
,	O
for	O
example	O
)	O
.	O
On	O
the	O
other	O
hand	O
,	O
implementing	O
the	O
Stream	B-api_mention
API	O
was	O
certainly	O
a	O
huge	O
change	O
for	O
the	O
API	O
.	O
It	O
was	O
postponed	O
multiple	O
times	O
for	O
a	O
reason	O
.	O
So	O
I	O
guess	O
Oracle	O
wanted	O
to	O
limit	O
the	O
changes	O
to	O
the	O
most	O
important	O
use	O
cases	O
.	O
Enums	O
aren	O
’	O
t	O
used	O
that	O
much	O
anyway	O
.	O
Sure	O
,	O
every	O
project	O
has	O
a	O
couple	O
of	O
them	O
,	O
but	O
they	O
’	O
re	O
nothing	O
compared	O
to	O
the	O
number	O
of	O
Lists	O
and	O
other	O
Collections	B-api_mention
.	O
Even	O
when	O
you	O
have	O
an	O
Enum	O
,	O
in	O
many	O
cases	O
you	O
won	O
’	O
t	O
ever	O
iterate	O
over	O
it	O
.	O
Lists	O
and	O
Sets	O
,	O
on	O
the	O
other	O
hand	O
,	O
are	O
probably	O
iterated	O
over	O
almost	O
every	O
time	O
.	O
I	O
assume	O
that	O
these	O
were	O
the	O
reasons	O
why	O
the	O
Enums	O
didn	O
’	O
t	O
get	O
their	O
own	O
adapter	O
to	O
the	O
Stream	B-api_mention
world	O
.	O
We	O
’	O
ll	O
see	O
whether	O
more	O
of	O
this	O
gets	O
added	O
in	O
future	O
versions	O
.	O
And	O
until	O
then	O
you	O
always	O
can	O
use	O
Arrays	B-api_mention
.	I-api_mention
stream	I-api_mention
.	O
Question	O
-	O
13291076	O
,	O
answer	O
-	O
13291109	O
It	O
really	O
depends	O
on	O
what	O
you	O
want	O
to	O
do	O
with	O
the	O
returned	O
value	O
:	O
#	O
li	O
If	O
you	O
need	O
to	O
get	O
the	O
exact	O
name	O
used	O
to	O
declare	O
the	O
enum	O
constant	O
,	O
you	O
should	O
use	O
name	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
as	O
toString	B-api_mention
may	O
have	O
been	O
overriden	O
#	O
li	O
If	O
you	O
want	O
to	O
print	O
the	O
enum	O
constant	O
in	O
a	O
user	O
friendly	O
way	O
,	O
you	O
should	O
use	O
toString	B-api_mention
which	O
may	O
have	O
been	O
overriden	O
(	O
or	O
not	O
!	O
)	O
.	O
When	O
I	O
feel	O
that	O
it	O
might	O
be	O
confusing	O
,	O
I	O
provide	O
a	O
more	O
specific	O
getXXX	O
method	O
,	O
for	O
example	O
:	O
#	O
pre	O
Question	O
-	O
6094575	O
,	O
answer	O
-	O
6094600	O
You	O
can	O
use	O
Class	B-api_mention
.	I-api_mention
forName	I-api_mention
(	I-api_mention
)	I-api_mention
to	O
get	O
a	O
Class	B-api_mention
object	O
of	O
the	O
desired	O
class	O
.	O
Then	O
use	O
getConstructor	B-api_mention
(	I-api_mention
)	I-api_mention
to	O
find	O
the	O
desired	O
Constructor	B-api_mention
object	O
.	O
Finally	O
,	O
call	O
newInstance	B-api_mention
(	I-api_mention
)	I-api_mention
on	O
that	O
object	O
to	O
get	O
your	O
new	O
instance	O
.	O
#	O
pre	O
Question	O
-	O
32676771	O
,	O
answer	O
-	O
32677400	O
Despite	O
of	O
the	O
fact	O
that	O
there	O
is	O
no	O
AtomicDouble	O
or	O
AtomicDoubleArray	O
in	O
java	O
,	O
you	O
can	O
easily	O
create	O
your	O
own	O
based	O
on	O
AtomicLongArray	O
.	O
#	O
pre	O
As	O
you	O
can	O
see	O
,	O
I	O
use	O
Double	B-api_mention
.	I-api_mention
doubleToLongBits	I-api_mention
and	O
Double	B-api_mention
.	I-api_mention
longBitsToDouble	I-api_mention
to	O
store	O
Doubles	O
as	O
Longs	O
in	O
AtomicLongArray	O
.	O
They	O
both	O
have	O
the	O
same	O
size	O
in	O
bits	O
,	O
so	O
precision	O
is	O
not	O
lost	O
(	O
except	O
for	O
-	O
NaN	O
,	O
but	O
I	O
don	O
'	O
t	O
think	O
it	O
is	O
important	O
)	O
.	O
In	O
Java	O
8	O
the	O
implementation	O
of	O
add	O
can	O
be	O
even	O
easier	O
,	O
as	O
you	O
can	O
use	O
accumulateAndGet	O
method	O
of	O
AtomicLongArray	O
that	O
was	O
added	O
in	O
java	O
1	O
.	O
8	O
.	O
Upd	O
:	O
It	O
appears	O
that	O
I	O
virtually	O
re	O
-	O
implemented	O
guava	O
'	O
s	O
AtomicDoubleArray	O
.	O
Question	O
-	O
5263187	O
,	O
answer	O
-	O
5263201	O
System	B-api_mention
.	I-api_mention
out	I-api_mention
.	I-api_mention
println	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Question	O
-	O
5778658	O
,	O
answer	O
-	O
10768914	O
You	O
will	O
need	O
an	O
intermediate	O
class	O
which	O
will	O
buffer	O
between	O
.	O
Each	O
time	O
InputStream	B-api_mention
.	I-api_mention
read	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
is	O
called	O
,	O
the	O
buffering	O
class	O
will	O
fill	O
the	O
passed	O
in	O
byte	O
array	O
with	O
the	O
next	O
chunk	O
passed	O
in	O
from	O
OutputStream	B-api_mention
.	I-api_mention
write	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
Since	O
the	O
sizes	O
of	O
the	O
chunks	O
may	O
not	O
be	O
the	O
same	O
,	O
the	O
adapter	O
class	O
will	O
need	O
to	O
store	O
a	O
certain	O
amount	O
until	O
it	O
has	O
enough	O
to	O
fill	O
the	O
read	O
buffer	O
and	O
/	O
or	O
be	O
able	O
to	O
store	O
up	O
any	O
buffer	O
overflow	O
.	O
This	O
article	O
has	O
a	O
nice	O
breakdown	O
of	O
a	O
few	O
different	O
approaches	O
to	O
this	O
problem	O
:	O
#	O
a	O
Question	O
-	O
16635398	O
Which	O
of	O
the	O
following	O
is	O
better	O
practice	O
in	O
Java	O
8	O
?	O
Java	O
8	O
:	O
joins	B-api_mention
.	I-api_mention
forEach	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Java	O
7	O
:	O
#	O
pre	O
I	O
have	O
lots	O
of	O
for	O
loops	O
that	O
could	O
be	O
"	O
simplified	O
"	O
with	O
lambdas	O
,	O
but	O
is	O
there	O
really	O
any	O
advantage	O
of	O
using	O
them	O
including	O
performance	O
and	O
readability	O
?	O
EDIT	O
I	O
'	O
ll	O
also	O
extend	O
this	O
question	O
to	O
longer	O
methods	O
-	O
I	O
know	O
that	O
you	O
cant	O
return	O
or	O
break	O
the	O
parent	O
function	O
from	O
a	O
lambda	O
and	O
this	O
should	O
be	O
mentioned	O
to	O
if	O
they	O
are	O
compared	O
,	O
but	O
is	O
there	O
anything	O
else	O
to	O
be	O
considered	O
?	O
Question	O
-	O
23674624	O
I	O
'	O
m	O
looking	O
at	O
the	O
docs	O
for	O
the	O
IntStream	B-api_mention
,	O
and	O
I	O
see	O
an	O
toArray	B-api_mention
method	O
,	O
but	O
no	O
way	O
to	O
go	O
directly	O
to	O
a	O
List	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
Surely	O
there	O
is	O
a	O
way	O
to	O
convert	O
a	O
Stream	B-api_mention
to	O
a	O
List	B-api_mention
?	O
Question	O
-	O
6416706	O
,	O
answer	O
-	O
6416800	O
With	O
Guava	O
you	O
can	O
use	O
Lists	B-api_mention
.	I-api_mention
newArrayList	I-api_mention
(	I-api_mention
Iterable	I-api_mention
)	I-api_mention
or	O
Sets	B-api_mention
.	I-api_mention
newHashSet	I-api_mention
(	I-api_mention
Iterable	I-api_mention
)	I-api_mention
,	O
among	O
other	O
similar	O
methods	O
.	O
This	O
will	O
of	O
course	O
copy	O
all	O
the	O
elements	O
in	O
to	O
memory	O
.	O
If	O
that	O
isn	O
'	O
t	O
acceptable	O
,	O
I	O
think	O
your	O
code	O
that	O
works	O
with	O
these	O
ought	O
to	O
take	O
Iterable	B-api_mention
rather	O
than	O
Collection	B-api_mention
.	O
Guava	O
also	O
happens	O
to	O
provide	O
convenient	O
methods	O
for	O
doing	O
things	O
you	O
can	O
do	O
on	O
a	O
Collection	B-api_mention
using	O
an	O
Iterable	B-api_mention
(	O
such	O
as	O
Iterables	B-api_mention
.	I-api_mention
isEmpty	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
or	O
Iterables	B-api_mention
.	I-api_mention
contains	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
)	O
,	O
but	O
the	O
performance	O
implications	O
are	O
more	O
obvious	O
.	O
Question	O
-	O
9481865	O
,	O
answer	O
-	O
9481939	O
You	O
can	O
use	O
java	B-api_mention
.	I-api_mention
net	I-api_mention
.	I-api_mention
InetAddress	I-api_mention
API	O
.	O
Try	O
this	O
:	O
InetAddress	B-api_mention
.	I-api_mention
getLocalHost	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
getHostAddress	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Question	O
-	O
22463062	O
,	O
answer	O
-	O
22463063	O
Parsing	O
date	O
and	O
time	O
To	O
create	O
a	O
LocalDateTime	B-api_mention
object	O
from	O
a	O
string	O
you	O
can	O
use	O
the	O
static	O
LocalDateTime	B-api_mention
.	I-api_mention
parse	I-api_mention
(	I-api_mention
)	I-api_mention
method	O
.	O
It	O
takes	O
a	O
string	O
and	O
a	O
DateTimeFormatter	B-api_mention
as	O
parameter	O
.	O
The	O
DateTimeFormatter	B-api_mention
is	O
used	O
to	O
specify	O
the	O
date	O
/	O
time	O
pattern	O
.	O
#	O
pre	O
Formatting	O
date	O
and	O
time	O
To	O
create	O
a	O
formatted	O
string	O
out	O
a	O
LocalDateTime	B-api_mention
object	O
you	O
can	O
use	O
the	O
format	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
.	O
#	O
pre	O
Note	O
that	O
there	O
are	O
some	O
commonly	O
used	O
date	O
/	O
time	O
formats	O
predefined	O
as	O
constants	O
in	O
DateTimeFormatter	B-api_mention
.	O
For	O
example	O
:	O
Using	O
DateTimeFormatter	B-api_mention
.	I-api_mention
ISO	I-api_mention
_	I-api_mention
DATE	I-api_mention
_	I-api_mention
TIME	I-api_mention
to	O
format	O
the	O
LocalDateTime	B-api_mention
instance	O
from	O
above	O
would	O
result	O
in	O
the	O
string	O
StringLiteral	B-api_mention
.	O
The	O
parse	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
and	O
format	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
methods	O
are	O
available	O
for	O
all	O
date	O
/	O
time	O
related	O
objects	O
(	O
e	O
.	O
g	O
.	O
LocalDate	B-api_mention
or	O
ZonedDateTime	B-api_mention
)	O
Question	O
-	O
29691513	O
,	O
answer	O
-	O
29727412	O
The	O
JLS	O
describes	O
a	O
few	O
special	O
behaviors	O
of	O
what	O
it	O
calls	O
constant	O
variables	O
,	O
which	O
are	O
final	O
variables	O
(	O
whether	O
static	O
or	O
not	O
)	O
which	O
are	O
initialized	O
with	O
constant	O
expressions	O
of	O
String	B-api_mention
or	O
primitive	O
type	O
.	O
Constant	O
variables	O
have	O
a	O
major	O
difference	O
with	O
respect	O
to	O
binary	O
compatibility	O
:	O
the	O
values	O
of	O
constant	O
variables	O
become	O
part	O
of	O
the	O
class	O
'	O
s	O
API	O
,	O
as	O
far	O
as	O
the	O
compiler	O
is	O
concerned	O
.	O
An	O
example	O
:	O
#	O
pre	O
Here	O
,	O
XFOO	O
is	O
a	O
"	O
constant	O
variable	O
"	O
and	O
YFOO	O
is	O
not	O
,	O
but	O
they	O
are	O
otherwise	O
equivalent	O
.	O
Class	O
Z	O
prints	O
out	O
each	O
of	O
them	O
.	O
Compile	O
those	O
classes	O
,	O
then	O
disassemble	O
them	O
with	O
javap	O
-	O
v	O
X	O
Y	O
Z	O
,	O
and	O
here	O
is	O
the	O
output	O
:	O
Class	O
X	O
:	O
#	O
pre	O
Class	O
Y	O
:	O
#	O
pre	O
Class	O
Z	O
:	O
#	O
pre	O
Things	O
to	O
notice	O
in	O
the	O
disassembly	O
,	O
which	O
tell	O
you	O
the	O
differences	O
between	O
X	O
and	O
Y	O
run	O
deeper	O
than	O
syntactic	O
sugar	O
:	O
#	O
li	O
XFOO	O
has	O
a	O
ConstantValue	O
attribute	O
,	O
signifying	O
that	O
its	O
value	O
is	O
a	O
compile	O
-	O
time	O
constant	O
.	O
Whereas	O
YFOO	O
does	O
not	O
,	O
and	O
uses	O
a	O
static	O
block	O
with	O
a	O
putstatic	O
instruction	O
to	O
initialize	O
the	O
value	O
at	O
runtime	O
.	O
#	O
li	O
The	O
String	B-api_mention
constant	O
StringLiteral	O
has	O
become	O
part	O
of	O
class	O
Z	O
'	O
s	O
constant	O
pool	O
,	O
but	O
StringLiteral	O
has	O
not	O
.	O
#	O
li	O
Z	O
.	O
main	O
uses	O
the	O
ldc	O
(	O
load	O
constant	O
)	O
instruction	O
to	O
load	O
StringLiteral	O
onto	O
the	O
stack	O
directly	O
from	O
its	O
own	O
constant	O
pool	O
,	O
but	O
it	O
uses	O
a	O
getstatic	O
instruction	O
to	O
load	O
the	O
value	O
of	O
Y	O
.	O
YFOO	O
.	O
Other	O
differences	O
you	O
will	O
find	O
:	O
#	O
li	O
If	O
you	O
change	O
the	O
value	O
of	O
XFOO	O
and	O
recompile	O
X	O
.	O
java	O
but	O
not	O
Z	O
.	O
java	O
,	O
you	O
have	O
a	O
problem	O
:	O
class	O
Z	O
is	O
still	O
using	O
the	O
old	O
value	O
.	O
If	O
you	O
change	O
the	O
value	O
of	O
YFOO	O
and	O
recompile	O
Y	O
.	O
java	O
,	O
class	O
Z	O
uses	O
the	O
new	O
value	O
whether	O
you	O
recompile	O
Z	O
.	O
java	O
or	O
not	O
.	O
#	O
li	O
If	O
you	O
delete	O
the	O
X	O
.	O
class	O
file	O
entirely	O
,	O
class	O
Z	O
still	O
runs	O
correctly	O
.	O
Z	O
has	O
no	O
runtime	O
dependency	O
on	O
X	O
.	O
Whereas	O
if	O
you	O
delete	O
the	O
Y	O
.	O
class	O
file	O
,	O
class	O
Z	O
fails	O
to	O
initialize	O
with	O
a	O
ClassNotFoundException	O
:	O
Y	O
.	O
#	O
li	O
If	O
you	O
generate	O
documentation	O
for	O
the	O
classes	O
with	O
javadoc	O
,	O
the	O
"	O
Constant	O
Field	O
Values	O
"	O
page	O
will	O
document	O
the	O
value	O
of	O
XFOO	O
,	O
but	O
not	O
the	O
value	O
of	O
YFOO	O
.	O
The	O
JLS	O
describes	O
the	O
above	O
effects	O
constant	O
variables	O
have	O
on	O
compiled	O
class	O
files	O
in	O
§	O
13	O
.	O
1	O
.	O
3	O
:	O
#	O
blockquote	O
And	O
in	O
§	O
13	O
.	O
4	O
.	O
9	O
:	O
#	O
blockquote	O
The	O
upshot	O
is	O
that	O
if	O
your	O
public	O
library	O
exposes	O
any	O
constant	O
variables	O
,	O
you	O
must	O
never	O
change	O
their	O
values	O
if	O
your	O
new	O
library	O
version	O
is	O
otherwise	O
supposed	O
to	O
be	O
compatible	O
with	O
code	O
compiled	O
against	O
old	O
versions	O
of	O
the	O
library	O
.	O
It	O
won	O
'	O
t	O
necessarily	O
cause	O
an	O
error	O
,	O
but	O
the	O
existing	O
code	O
will	O
probably	O
malfunction	O
since	O
it	O
will	O
have	O
outdated	O
ideas	O
about	O
the	O
values	O
of	O
constants	O
.	O
(	O
If	O
your	O
new	O
library	O
version	O
needs	O
for	O
classes	O
which	O
use	O
it	O
to	O
be	O
recompiled	O
anyway	O
,	O
then	O
changing	O
constants	O
doesn	O
'	O
t	O
cause	O
this	O
problem	O
.	O
)	O
Thus	O
,	O
initializing	O
a	O
constant	O
with	O
a	O
block	O
gives	O
you	O
more	O
freedom	O
to	O
change	O
its	O
value	O
,	O
because	O
it	O
prevents	O
the	O
compiler	O
embedding	O
the	O
value	O
into	O
other	O
classes	O
.	O
Question	O
-	O
32323081	O
,	O
answer	O
-	O
32323305	O
Any	O
lambda	O
which	O
could	O
be	O
accepted	O
as	O
a	O
Supplier	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
can	O
also	O
be	O
accepted	O
as	O
a	O
ThrowingSupplier	O
<	O
T	O
>	O
.	O
The	O
following	O
compiles	O
:	O
#	O
pre	O
Given	O
the	O
above	O
,	O
you	O
probably	O
don	O
'	O
t	O
need	O
this	O
,	O
but	O
if	O
foo	O
must	O
accept	O
a	O
non	O
-	O
throwing	O
Supplier	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
,	O
you	O
can	O
always	O
wrap	O
the	O
Exception	O
-	O
throwing	O
method	O
in	O
a	O
method	O
which	O
launders	O
it	O
into	O
an	O
unchecked	O
Exception	O
:	O
#	O
pre	O
Question	O
-	O
4812570	O
How	O
can	O
I	O
get	O
the	O
e	O
.	B-api_mention
printStackTrace	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
and	O
store	O
it	O
into	O
a	O
String	B-api_mention
variable	O
?	O
I	O
want	O
to	O
use	O
the	O
string	O
generated	O
by	O
e	O
.	B-api_mention
printStackTrace	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
later	O
in	O
my	O
program	O
.	O
I	O
'	O
m	O
still	O
new	O
to	O
Java	O
so	O
I	O
'	O
m	O
not	O
too	O
familiar	O
with	O
StringWriter	B-api_mention
that	O
I	O
think	O
will	O
be	O
the	O
solution	O
.	O
Or	O
if	O
you	O
have	O
any	O
other	O
ideas	O
please	O
let	O
me	O
know	O
.	O
Thanks	O
Question	O
-	O
31370403	O
I	O
'	O
m	O
currently	O
in	O
the	O
process	O
of	O
writing	O
a	O
paint	O
program	O
in	O
java	O
,	O
designed	O
to	O
have	O
flexible	O
and	O
comprehensive	O
functionalities	O
.	O
It	O
stemmed	O
from	O
my	O
final	O
project	O
,	O
that	O
I	O
wrote	O
overnight	O
the	O
day	O
before	O
.	O
Because	O
of	O
that	O
,	O
it	O
'	O
s	O
got	O
tons	O
and	O
tons	O
of	O
bugs	O
,	O
which	O
I	O
'	O
ve	O
been	O
tackling	O
one	O
by	O
one	O
(	O
e	O
.	O
g	O
.	O
I	O
can	O
only	O
save	O
files	O
that	O
will	O
be	O
empty	O
,	O
my	O
rectangles	O
don	O
'	O
t	O
draw	O
right	O
but	O
my	O
circles	O
do	O
.	O
.	O
.	O
)	O
.	O
This	O
time	O
,	O
I	O
'	O
ve	O
been	O
trying	O
to	O
add	O
undo	O
/	O
redo	O
functionality	O
to	O
my	O
program	O
.	O
However	O
,	O
I	O
can	O
'	O
t	O
"	O
undo	O
"	O
something	O
that	O
I	O
have	O
done	O
.	O
Therefore	O
,	O
I	O
got	O
an	O
idea	O
to	O
save	O
copies	O
of	O
my	O
BufferedImage	O
each	O
time	O
a	O
mouseReleased	O
event	O
was	O
fired	O
.	O
However	O
,	O
with	O
some	O
of	O
the	O
images	O
going	O
to	O
1920x1080	O
resolution	O
,	O
I	O
figured	O
that	O
this	O
wouldn	O
'	O
t	O
be	O
efficient	O
:	O
storing	O
them	O
would	O
probably	O
take	O
gigabytes	O
of	O
memory	O
.	O
The	O
reason	O
for	O
why	O
I	O
can	O
'	O
t	O
simply	O
paint	O
the	O
same	O
thing	O
with	O
the	O
background	O
colour	O
to	O
undo	O
is	O
because	O
I	O
have	O
many	O
different	O
brushes	O
,	O
which	O
paint	O
based	O
on	O
Math	B-api_mention
.	I-api_mention
random	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
,	O
and	O
because	O
there	O
are	O
many	O
different	O
layers	O
(	O
in	O
a	O
single	O
layer	O
)	O
.	O
Then	O
,	O
I	O
'	O
ve	O
considered	O
cloning	O
the	O
Graphics	O
objects	O
that	O
I	O
use	O
to	O
paint	O
to	O
the	O
BufferedImage	O
.	O
Like	O
this	O
:	O
#	O
pre	O
I	O
haven	O
'	O
t	O
done	O
this	O
before	O
,	O
so	O
I	O
have	O
a	O
couple	O
questions	O
:	O
#	O
li	O
Would	O
I	O
still	O
be	O
wasting	O
pointless	O
memory	O
by	O
doing	O
this	O
,	O
like	O
cloning	O
my	O
BufferedImages	O
?	O
#	O
li	O
Is	O
there	O
necessarily	O
a	O
different	O
way	O
I	O
can	O
do	O
this	O
?	O
Question	O
-	O
5982447	O
,	O
answer	O
-	O
5982478	O
Use	O
the	O
Set	B-api_mention
#	I-api_mention
toArray	I-api_mention
(	I-api_mention
T	I-api_mention
[	I-api_mention
]	I-api_mention
)	I-api_mention
method	O
taking	O
a	O
typed	O
array	O
argument	O
of	O
the	O
same	O
size	O
.	O
String	B-api_mention
[	O
]	O
GPXFILES1	O
=	O
myset	O
.	B-api_mention
toArray	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
A	O
different	O
size	O
can	O
also	O
,	O
but	O
that	O
would	O
force	O
the	O
toArray	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
to	O
create	O
a	O
new	O
array	O
to	O
return	O
instead	O
of	O
reusing	O
the	O
provided	O
argument	O
,	O
which	O
may	O
end	O
up	O
to	O
be	O
less	O
efficient	O
.	O
See	O
also	O
the	O
source	O
code	O
of	O
AbstractCollection	B-api_mention
#	I-api_mention
toArray	I-api_mention
(	I-api_mention
)	I-api_mention
.	O
Question	O
-	O
12552863	O
,	O
answer	O
-	O
32302353	O
To	O
concur	O
with	O
earlier	O
comments	O
:	O
simplest	O
is	O
(	O
2	O
)	O
to	O
use	O
Closeable	B-api_mention
resources	O
and	O
declare	O
them	O
in	O
order	O
in	O
the	O
try	O
-	O
with	O
-	O
resources	O
clause	O
.	O
If	O
you	O
only	O
have	O
AutoCloseable	B-api_mention
,	O
you	O
can	O
wrap	O
them	O
in	O
another	O
(	O
nested	O
)	O
class	O
that	O
just	O
checks	O
that	O
close	B-api_mention
is	O
only	O
called	O
once	O
(	O
Facade	O
Pattern	O
)	O
,	O
e	O
.	O
g	O
.	O
by	O
having	O
private	O
bool	O
isClosed	O
;	O
.	O
In	O
practice	O
even	O
Oracle	O
just	O
(	O
1	O
)	O
chains	O
the	O
constructors	O
and	O
doesn	O
'	O
t	O
correctly	O
handle	O
exceptions	O
partway	O
through	O
the	O
chain	O
.	O
Alternatively	O
,	O
you	O
can	O
manually	O
create	O
a	O
chained	O
resource	O
,	O
using	O
a	O
static	O
factory	O
method	O
;	O
this	O
encapsulates	O
the	O
chain	O
,	O
and	O
handle	O
cleanup	O
if	O
it	O
fails	O
part	O
-	O
way	O
:	O
#	O
pre	O
The	O
complexity	O
comes	O
from	O
handling	O
multiple	O
exceptions	O
;	O
otherwise	O
it	O
'	O
s	O
just	O
"	O
close	O
resources	O
that	O
you	O
'	O
ve	O
acquired	O
so	O
far	O
"	O
.	O
A	O
common	O
practice	O
seems	O
to	O
be	O
to	O
first	O
initialize	O
the	O
variable	O
that	O
holds	O
the	O
object	O
that	O
holds	O
the	O
resource	O
to	O
null	O
(	O
here	O
fileWriter	B-api_mention
)	O
,	O
and	O
then	O
include	O
a	O
null	O
check	O
in	O
the	O
cleanup	O
,	O
but	O
that	O
seems	O
unnecessary	O
:	O
if	O
the	O
constructor	O
fails	O
,	O
there	O
'	O
s	O
nothing	O
to	O
clean	O
up	O
,	O
so	O
we	O
can	O
just	O
let	O
that	O
exception	O
propagate	O
,	O
which	O
simplifies	O
the	O
code	O
a	O
little	O
.	O
You	O
could	O
probably	O
do	O
this	O
generically	O
:	O
#	O
pre	O
Question	O
-	O
7935858	O
,	O
answer	O
-	O
7935881	O
The	O
documentation	O
on	O
split	B-api_mention
(	I-api_mention
)	I-api_mention
says	O
:	O
#	O
blockquote	O
(	O
Emphasis	O
mine	O
.	O
)	O
A	O
dot	O
is	O
a	O
special	O
character	O
in	O
regular	O
expression	O
syntax	O
.	O
Use	O
Pattern	B-api_mention
.	I-api_mention
quote	I-api_mention
(	I-api_mention
)	I-api_mention
on	O
the	O
parameter	O
to	O
split	B-api_mention
(	I-api_mention
)	I-api_mention
if	O
you	O
want	O
the	O
split	O
to	O
be	O
on	O
a	O
literal	O
string	O
pattern	O
:	O
String	B-api_mention
[	O
]	O
words	O
=	O
temp	O
.	B-api_mention
split	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Question	O
-	O
19757300	O
,	O
answer	O
-	O
35512247	O
Keeping	O
this	O
issue	O
in	O
mind	O
I	O
developed	O
a	O
small	O
library	O
for	O
dealing	O
with	O
checked	O
exceptions	O
and	O
lambdas	O
.	O
Custom	O
adapters	O
allow	O
you	O
to	O
integrate	O
with	O
existing	O
functional	O
types	O
:	O
stream	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
map	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
/	O
/	O
with	O
a	O
static	O
import	O
#	O
a	O
Question	O
-	O
22501230	O
,	O
answer	O
-	O
22511214	O
I	O
don	O
'	O
t	O
like	O
any	O
of	O
the	O
solutions	O
presented	O
except	O
for	O
JAB	O
'	O
s	O
.	O
None	O
of	O
the	O
others	O
make	O
it	O
easy	O
to	O
read	O
the	O
code	O
and	O
understand	O
what	O
is	O
being	O
computed	O
.	O
Here	O
'	O
s	O
how	O
I	O
would	O
write	O
this	O
code	O
-	O
-	O
I	O
only	O
know	O
C	O
#	O
,	O
not	O
Java	O
,	O
but	O
you	O
get	O
the	O
picture	O
:	O
#	O
pre	O
Now	O
it	O
is	O
much	O
more	O
clear	O
what	O
is	O
being	O
computed	O
here	O
:	O
this	O
emphasizes	O
that	O
we	O
are	O
computing	O
who	O
gets	O
hit	O
by	O
what	O
attack	O
,	O
and	O
returning	O
both	O
results	O
.	O
However	O
this	O
could	O
be	O
even	O
better	O
;	O
that	O
Boolean	B-api_mention
array	O
is	O
somewhat	O
opaque	O
.	O
I	O
like	O
the	O
table	O
lookup	O
approach	O
but	O
I	O
would	O
be	O
inclined	O
to	O
write	O
it	O
in	O
such	O
a	O
way	O
that	O
made	O
it	O
clear	O
what	O
the	O
intended	O
game	O
semantics	O
were	O
.	O
That	O
is	O
,	O
rather	O
than	O
"	O
an	O
attack	O
of	O
zero	O
and	O
a	O
defense	O
of	O
one	O
results	O
in	O
no	O
hit	O
"	O
,	O
instead	O
find	O
a	O
way	O
to	O
make	O
the	O
code	O
more	O
clearly	O
imply	O
"	O
a	O
low	O
kick	O
attack	O
and	O
a	O
low	O
block	O
defense	O
results	O
in	O
no	O
hit	O
"	O
.	O
Make	O
the	O
code	O
reflect	O
the	O
business	O
logic	O
of	O
the	O
game	O
.	O
Question	O
-	O
15940234	O
I	O
'	O
m	O
relative	O
new	O
to	O
the	O
webservices	O
world	O
and	O
my	O
research	O
seems	O
to	O
have	O
confused	O
me	O
more	O
than	O
enlighten	O
me	O
,	O
my	O
problem	O
is	O
that	O
I	O
was	O
given	O
a	O
library	O
(	O
jar	O
)	O
which	O
I	O
have	O
to	O
extend	O
with	O
some	O
webservice	O
functionality	O
.	O
This	O
library	O
will	O
be	O
shared	O
to	O
other	O
developers	O
,	O
and	O
among	O
the	O
classes	O
in	O
the	O
jar	O
will	O
be	O
classes	O
that	O
have	O
a	O
method	O
which	O
calls	O
a	O
webservice	O
(	O
that	O
essentially	O
sets	O
an	O
attribute	O
of	O
the	O
class	O
,	O
does	O
some	O
business	O
logic	O
,	O
like	O
storing	O
the	O
object	O
in	O
a	O
db	O
,	O
etc	O
and	O
sends	O
back	O
the	O
object	O
with	O
those	O
modifications	O
)	O
.	O
I	O
want	O
to	O
make	O
the	O
call	O
to	O
this	O
service	O
as	O
simple	O
as	O
possible	O
,	O
hopefully	O
as	O
simple	O
so	O
that	O
the	O
developer	O
using	O
the	O
class	O
only	O
need	O
to	O
do	O
.	O
#	O
pre	O
I	O
have	O
been	O
studying	O
JAX	O
-	O
WS	O
to	O
use	O
on	O
the	O
server	O
but	O
seems	O
to	O
me	O
that	O
I	O
don	O
'	O
t	O
need	O
to	O
create	O
a	O
wsimport	O
in	O
the	O
server	O
nor	O
the	O
wsimport	O
on	O
the	O
client	O
,	O
since	O
I	O
know	O
that	O
both	O
have	O
the	O
classes	O
,	O
I	O
just	O
need	O
some	O
interaction	O
between	O
classes	O
shared	O
in	O
both	O
the	O
server	O
and	O
the	O
client	O
.	O
How	O
do	O
you	O
think	O
makes	O
sense	O
to	O
do	O
the	O
webservice	O
and	O
the	O
call	O
in	O
the	O
class	O
?	O
Question	O
-	O
32356762	O
Is	O
there	O
a	O
good	O
reason	O
that	O
the	O
Collections	B-api_mention
.	I-api_mention
list	I-api_mention
(	I-api_mention
)	I-api_mention
method	O
in	O
the	O
java	O
.	O
utils	O
package	O
returns	O
an	O
ArrayList	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
instead	O
of	O
List	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
?	O
Obviously	O
an	O
ArrayList	B-api_mention
is	O
a	O
List	B-api_mention
,	O
but	O
I	O
'	O
m	O
under	O
the	O
impression	O
that	O
it	O
'	O
s	O
generally	O
good	O
practice	O
to	O
return	O
the	O
interface	O
type	O
instead	O
of	O
implementation	O
type	O
.	O
Question	O
-	O
28276423	O
,	O
answer	O
-	O
28276497	O
No	O
,	O
the	O
topmost	O
level	O
Stream	B-api_mention
or	O
reader	O
will	O
ensure	O
that	O
all	O
underlying	O
streams	O
/	O
readers	O
are	O
closed	O
.	O
Check	O
the	O
close	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
implementation	O
of	O
your	O
topmost	O
level	O
stream	O
.	O
Question	O
-	O
26548660	O
,	O
answer	O
-	O
26548894	O
You	O
can	O
use	O
a	O
Callback	B-api_mention
to	O
get	O
onSuccess	B-api_mention
and	O
onError	B-api_mention
events	O
.	O
Just	O
add	O
a	O
new	O
Callback	B-api_mention
to	O
your	O
request	O
like	O
so	O
:	O
Picasso	B-api_mention
.	I-api_mention
with	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
load	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
into	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Then	O
you	O
can	O
perform	O
any	O
alterations	O
and	O
modifications	O
in	O
the	O
onSuccess	B-api_mention
callback	O
.	O
Question	O
-	O
23079003	O
,	O
answer	O
-	O
23079174	O
You	O
can	O
use	O
the	O
overloaded	O
version	O
of	O
toArray	B-api_mention
,	O
as	O
the	O
following	O
:	O
#	O
pre	O
The	O
purpose	O
of	O
the	O
IntFunction	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
generator	O
is	O
to	O
convert	O
an	O
integer	O
,	O
the	O
size	O
of	O
the	O
array	O
,	O
to	O
a	O
new	O
array	O
.	O
Example	O
code	O
:	O
#	O
pre	O
Prints	O
:	O
#	O
pre	O
Another	O
option	O
is	O
to	O
use	O
a	O
method	O
reference	O
to	O
the	O
string	O
array	O
constructor	O
,	O
this	O
one	O
is	O
a	O
bit	O
more	O
tricky	O
.	O
Usage	O
is	O
easy	O
:	O
String	B-api_mention
[	O
]	O
stringArray	O
=	O
streamString	O
.	B-api_mention
toArray	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
What	O
it	O
does	O
,	O
is	O
find	O
a	O
method	O
that	O
takes	O
in	O
an	O
integer	O
(	O
the	O
size	O
)	O
as	O
argument	O
,	O
and	O
returns	O
a	O
String	B-api_mention
[	O
]	O
,	O
which	O
is	O
exactly	O
what	O
(	O
one	O
of	O
the	O
overloads	O
of	O
)	O
new	O
String	B-api_mention
[	O
]	O
does	O
.	O
Question	O
-	O
10786042	O
,	O
answer	O
-	O
25735202	O
You	O
need	O
to	O
first	O
create	O
a	O
URI	O
like	O
:	O
#	O
pre	O
Then	O
convert	O
that	O
Uri	O
to	O
ASCII	O
string	O
:	O
urlStr	O
=	O
uri	B-api_mention
.	I-api_mention
toASCIIString	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Now	O
your	O
url	O
string	O
is	O
completely	O
encoded	O
first	O
we	O
did	O
simple	O
url	O
encoding	O
and	O
then	O
we	O
converted	O
it	O
to	O
ASCII	O
String	O
to	O
make	O
sure	O
no	O
character	O
outside	O
US	O
-	O
ASCII	O
are	O
remaining	O
in	O
string	O
.	O
This	O
is	O
exactly	O
how	O
browsers	O
do	O
.	O
Question	O
-	O
29140402	O
,	O
answer	O
-	O
36771568	O
In	O
Eclipse	O
,	O
Go	O
to	O
your	O
class	O
,	O
Right	O
click	O
-	O
>	O
source	O
-	O
>	O
Generate	O
toString	B-api_mention
(	I-api_mention
)	I-api_mention
;	O
It	O
will	O
override	O
the	O
toString	B-api_mention
(	I-api_mention
)	I-api_mention
method	O
and	O
print	O
the	O
object	O
of	O
that	O
class	O
.	O
Question	O
-	O
28818506	O
,	O
answer	O
-	O
32653133	O
This	O
is	O
looks	O
like	O
a	O
good	O
fit	O
for	O
pattern	O
matching	O
and	O
a	O
more	O
traditional	O
Option	O
interface	O
with	O
Some	O
and	O
None	O
implementations	O
(	O
such	O
as	O
those	O
in	O
Javaslang	O
,	O
FunctionalJava	O
)	O
or	O
a	O
lazy	O
Maybe	O
implementation	O
in	O
cyclops	O
-	O
react	O
.	O
I	O
'	O
m	O
the	O
author	O
of	O
this	O
library	O
.	O
With	O
cyclops	O
-	O
react	O
you	O
can	O
also	O
use	O
structural	O
pattern	O
matching	O
on	O
JDK	O
types	O
.	O
For	O
Optional	B-api_mention
you	O
can	O
match	O
on	O
the	O
present	O
and	O
absent	O
cases	O
via	O
the	O
visitor	O
pattern	O
.	O
it	O
would	O
look	O
something	O
like	O
this	O
-	O
#	O
pre	O
Question	O
-	O
8725387	O
,	O
answer	O
-	O
8727998	O
Another	O
point	O
is	O
the	O
time	O
complexity	O
of	O
insert	O
operations	O
.	O
For	O
a	O
list	O
insert	O
,	O
one	O
expects	O
a	O
complexity	O
of	O
O	O
(	O
1	O
)	O
.	O
But	O
this	O
could	O
not	O
be	O
guaranteed	O
with	O
a	O
sorted	O
list	O
.	O
And	O
the	O
most	O
important	O
point	O
is	O
that	O
lists	O
assume	O
nothing	O
about	O
their	O
elements	O
.	O
For	O
example	O
,	O
you	O
can	O
make	O
lists	O
of	O
things	O
that	O
do	O
not	O
implement	O
equals	B-api_mention
or	O
compare	B-api_mention
.	O
Question	O
-	O
18410035	O
Being	O
somewhat	O
new	O
to	O
the	O
Java	O
language	O
I	O
'	O
m	O
trying	O
to	O
familiarize	O
myself	O
with	O
all	O
the	O
ways	O
(	O
or	O
at	O
least	O
the	O
non	O
-	O
pathological	O
ones	O
)	O
that	O
one	O
might	O
iterate	O
through	O
a	O
list	O
(	O
or	O
perhaps	O
other	O
collections	O
)	O
and	O
the	O
advantages	O
or	O
disadvantages	O
of	O
each	O
.	O
Given	O
a	O
List	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
list	O
object	O
,	O
I	O
know	O
of	O
the	O
following	O
ways	O
to	O
loop	O
through	O
all	O
elements	O
:	O
Basic	O
for	O
loop	O
(	O
of	O
course	O
,	O
there	O
'	O
re	O
equivalent	O
while	O
/	O
do	O
while	O
loops	O
as	O
well	O
)	O
#	O
pre	O
Note	O
:	O
As	O
@	O
amarseillan	O
pointed	O
out	O
,	O
this	O
form	O
is	O
a	O
poor	O
choice	O
for	O
iterating	O
over	O
List	B-api_mention
s	O
because	O
the	O
actual	O
implementation	O
of	O
the	O
get	O
method	O
may	O
not	O
be	O
as	O
efficient	O
as	O
when	O
using	O
an	O
Iterator	B-api_mention
.	O
For	O
example	O
,	O
LinkedList	B-api_mention
implementations	O
must	O
traverse	O
all	O
of	O
the	O
elements	O
preceding	O
i	O
to	O
get	O
the	O
i	O
-	O
th	O
element	O
.	O
In	O
the	O
above	O
example	O
there	O
'	O
s	O
no	O
way	O
for	O
the	O
List	B-api_mention
implementation	O
to	O
"	O
save	O
its	O
place	O
"	O
to	O
make	O
future	O
iterations	O
more	O
efficient	O
.	O
For	O
an	O
ArrayList	B-api_mention
it	O
doesn	O
'	O
t	O
really	O
matter	O
because	O
the	O
complexity	O
/	O
cost	O
of	O
get	O
is	O
constant	O
time	O
(	O
O	O
(	O
1	O
)	O
)	O
whereas	O
for	O
a	O
LinkedList	B-api_mention
is	O
it	O
proportional	O
to	O
the	O
size	O
of	O
the	O
list	O
(	O
O	O
(	O
n	O
)	O
)	O
.	O
For	O
more	O
information	O
about	O
the	O
computational	O
complexity	O
of	O
the	O
built	O
-	O
in	O
Collections	B-api_mention
implementations	O
,	O
check	O
out	O
this	O
question	O
.	O
Enhanced	O
for	O
loop	O
(	O
nicely	O
explained	O
in	O
this	O
question	O
)	O
#	O
pre	O
Iterator	B-api_mention
#	O
pre	O
EDIT	O
:	O
Added	O
ListIterator	B-api_mention
ListIterator	I-api_mention
#	O
pre	O
EDIT	O
:	O
Added	O
"	O
functional	O
-	O
style	O
"	O
solution	O
(	O
thanks	O
Dave	O
Newton	O
)	O
Functional	O
Java	O
list	O
.	B-api_mention
stream	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
map	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
/	O
/	O
can	O
apply	O
a	O
transformation	O
function	O
for	O
e	O
EDIT	O
:	O
Added	O
map	O
method	O
from	O
Java	O
8	O
'	O
s	O
Stream	O
API	O
(	O
see	O
@	O
i	O
_	O
am	O
_	O
zero	O
'	O
s	O
answer	O
)	O
Iterable	B-api_mention
.	I-api_mention
forEach	I-api_mention
,	O
Stream	B-api_mention
.	I-api_mention
forEach	I-api_mention
,	O
.	O
.	O
.	O
In	O
Java	O
8	O
collection	O
classes	O
that	O
implement	O
Iterable	B-api_mention
(	O
for	O
example	O
all	O
List	B-api_mention
s	O
)	O
now	O
have	O
a	O
forEach	B-api_mention
method	O
,	O
which	O
can	O
be	O
used	O
instead	O
of	O
the	O
for	O
loop	O
statement	O
demonstrated	O
above	O
.	O
(	O
Here	O
is	O
another	O
question	O
that	O
provides	O
a	O
good	O
comparison	O
.	O
)	O
#	O
pre	O
What	O
other	O
ways	O
are	O
there	O
,	O
if	O
any	O
?	O
I	O
feel	O
like	O
this	O
has	O
got	O
to	O
be	O
a	O
duplicate	O
,	O
but	O
I	O
haven	O
'	O
t	O
been	O
able	O
to	O
find	O
what	O
I	O
'	O
m	O
looking	O
for	O
,	O
so	O
I	O
apologize	O
for	O
this	O
question	O
potentially	O
being	O
redundant	O
.	O
(	O
BTW	O
,	O
my	O
interest	O
does	O
not	O
stem	O
at	O
all	O
from	O
a	O
desire	O
to	O
optimize	O
performance	O
;	O
I	O
just	O
want	O
to	O
know	O
what	O
forms	O
are	O
available	O
to	O
me	O
as	O
a	O
developer	O
.	O
)	O
EDIT	O
:	O
Moved	O
ListIterationExample	O
.	O
java	O
to	O
a	O
suggested	O
answer	O
Question	O
-	O
28319064	O
,	O
answer	O
-	O
28319148	O
I	O
prefer	O
the	O
second	O
way	O
.	O
When	O
you	O
use	O
the	O
first	O
way	O
,	O
if	O
you	O
decide	O
to	O
use	O
a	O
parallel	O
stream	O
to	O
improve	O
performance	O
,	O
you	O
'	O
ll	O
have	O
no	O
control	O
over	O
the	O
order	O
in	O
which	O
the	O
elements	O
will	O
be	O
added	O
to	O
the	O
output	O
list	O
by	O
forEach	B-api_mention
.	O
When	O
you	O
use	O
toList	B-api_mention
,	O
the	O
Streams	O
API	O
will	O
preserve	O
the	O
order	O
even	O
if	O
you	O
use	O
a	O
parallel	O
stream	O
.	O
Question	O
-	O
29922296	O
,	O
answer	O
-	O
29923793	O
I	O
think	O
the	O
shortest	O
code	O
to	O
get	O
a	O
Stream	B-api_mention
of	O
enum	O
constants	O
is	O
Stream	B-api_mention
.	I-api_mention
of	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
It	O
'	O
s	O
not	O
as	O
nice	O
as	O
Letter	O
.	B-api_mention
values	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
stream	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
but	O
that	O
'	O
s	O
an	O
issue	O
with	O
arrays	O
,	O
not	O
specifically	O
enums	O
.	O
#	O
blockquote	O
You	O
are	O
right	O
that	O
the	O
nicest	O
possible	O
call	O
would	O
be	O
Letter	O
.	B-api_mention
stream	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
Unfortunately	O
a	O
class	O
cannot	O
have	O
two	O
methods	O
with	O
the	O
same	O
signature	O
,	O
so	O
it	O
would	O
not	O
be	O
possible	O
to	O
implicitly	O
add	O
a	O
static	O
method	O
stream	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
to	O
every	O
enum	O
(	O
in	O
the	O
same	O
way	O
that	O
every	O
enum	O
has	O
an	O
implicitly	O
added	O
static	O
method	O
values	O
(	O
args	O
)	O
)	O
as	O
this	O
would	O
break	O
every	O
existing	O
enum	O
that	O
already	O
has	O
a	O
static	O
or	O
instance	O
method	O
without	O
parameters	O
called	O
stream	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
#	O
blockquote	O
I	O
think	O
so	O
.	O
The	O
drawback	O
is	O
that	O
stream	O
is	O
a	O
static	O
method	O
,	O
so	O
there	O
is	O
no	O
way	O
to	O
avoid	O
code	O
duplication	O
;	O
it	O
would	O
have	O
to	O
be	O
added	O
to	O
every	O
enum	O
separately	O
.	O
Question	O
-	O
16635398	O
,	O
answer	O
-	O
20177092	O
The	O
better	O
practice	O
is	O
to	O
use	O
for	O
-	O
each	O
.	O
Besides	O
violating	O
the	O
Keep	O
It	O
Simple	O
,	O
Stupid	O
principle	O
,	O
the	O
new	O
-	O
fangled	O
forEach	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
has	O
at	O
least	O
the	O
following	O
deficiencies	O
:	O
#	O
li	O
Can	O
'	O
t	O
use	O
non	O
-	O
final	O
variables	O
.	O
So	O
,	O
code	O
like	O
the	O
following	O
can	O
'	O
t	O
be	O
turned	O
into	O
a	O
forEach	B-api_mention
lambda	O
:	O
#	O
blockquote	O
#	O
li	O
Can	O
'	O
t	O
handle	O
checked	O
exceptions	O
.	O
Lambdas	O
aren	O
'	O
t	O
actually	O
forbidden	O
from	O
throwing	O
checked	O
exceptions	O
,	O
but	O
common	O
functional	O
interfaces	O
like	O
Consumer	B-api_mention
don	O
'	O
t	O
declare	O
any	O
.	O
Therefore	O
,	O
any	O
code	O
that	O
throws	O
checked	O
exceptions	O
must	O
wrap	O
them	O
in	O
try	O
-	O
catch	O
or	O
Throwables	B-api_mention
.	I-api_mention
propagate	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
But	O
even	O
if	O
you	O
do	O
that	O
,	O
it	O
'	O
s	O
not	O
always	O
clear	O
what	O
happens	O
to	O
the	O
thrown	O
exception	O
.	O
It	O
could	O
get	O
swallowed	O
somewhere	O
in	O
the	O
guts	O
of	O
forEach	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
#	O
li	O
Limited	O
flow	O
-	O
control	O
.	O
A	O
return	O
in	O
a	O
lambda	O
equals	O
a	O
continue	O
in	O
a	O
for	O
-	O
each	O
,	O
but	O
there	O
is	O
no	O
equivalent	O
to	O
a	O
break	O
.	O
It	O
'	O
s	O
also	O
difficult	O
to	O
do	O
things	O
like	O
return	O
values	O
,	O
short	O
circuit	O
,	O
or	O
set	O
flags	O
(	O
which	O
would	O
have	O
alleviated	O
things	O
a	O
bit	O
,	O
if	O
it	O
wasn	O
'	O
t	O
a	O
violation	O
of	O
the	O
no	O
non	O
-	O
final	O
variables	O
rule	O
)	O
.	O
"	O
This	O
is	O
not	O
just	O
an	O
optimization	O
,	O
but	O
critical	O
when	O
you	O
consider	O
that	O
some	O
sequences	O
(	O
like	O
reading	O
the	O
lines	O
in	O
a	O
file	O
)	O
may	O
have	O
side	O
-	O
effects	O
,	O
or	O
you	O
may	O
have	O
an	O
infinite	O
sequence	O
.	O
"	O
#	O
li	O
Might	O
execute	O
in	O
parallel	O
,	O
which	O
is	O
a	O
horrible	O
,	O
horrible	O
thing	O
for	O
all	O
but	O
the	O
0	O
.	O
1	O
%	O
of	O
your	O
code	O
that	O
needs	O
to	O
be	O
optimized	O
.	O
Any	O
parallel	O
code	O
has	O
to	O
be	O
thought	O
through	O
(	O
even	O
if	O
it	O
doesn	O
'	O
t	O
use	O
locks	O
,	O
volatiles	O
,	O
and	O
other	O
particularly	O
nasty	O
aspects	O
of	O
traditional	O
multi	O
-	O
threaded	O
execution	O
)	O
.	O
Any	O
bug	O
will	O
be	O
tough	O
to	O
find	O
.	O
#	O
li	O
Might	O
hurt	O
performance	O
,	O
because	O
the	O
JIT	O
can	O
'	O
t	O
optimize	O
forEach	B-api_mention
(	I-api_mention
)	I-api_mention
+	O
lambda	O
to	O
the	O
same	O
extent	O
as	O
plain	O
loops	O
,	O
especially	O
now	O
that	O
lambdas	O
are	O
new	O
.	O
By	O
"	O
optimization	O
"	O
I	O
do	O
not	O
mean	O
the	O
overhead	O
of	O
calling	O
lambdas	O
(	O
which	O
is	O
small	O
)	O
,	O
but	O
to	O
the	O
sophisticated	O
analysis	O
and	O
transformation	O
that	O
the	O
modern	O
JIT	O
compiler	O
performs	O
on	O
running	O
code	O
.	O
#	O
li	O
If	O
you	O
do	O
need	O
parallelism	O
,	O
it	O
is	O
probably	O
much	O
faster	O
and	O
not	O
much	O
more	O
difficult	O
to	O
use	O
an	O
ExecutorService	B-api_mention
.	O
Streams	O
are	O
both	O
automagical	O
(	O
read	O
:	O
don	O
'	O
t	O
know	O
much	O
about	O
your	O
problem	O
)	O
and	O
use	O
a	O
specialized	O
(	O
read	O
:	O
inefficient	O
for	O
the	O
general	O
case	O
)	O
parallelization	O
strategy	O
(	O
fork	O
-	O
join	O
recursive	O
decomposition	O
)	O
.	O
#	O
li	O
Makes	O
debugging	O
more	O
confusing	O
,	O
because	O
of	O
the	O
nested	O
call	O
hierarchy	O
and	O
,	O
god	O
forbid	O
,	O
parallel	O
execution	O
.	O
The	O
debugger	O
may	O
have	O
issues	O
displaying	O
variables	O
from	O
the	O
surrounding	O
code	O
,	O
and	O
things	O
like	O
step	O
-	O
through	O
may	O
not	O
work	O
as	O
expected	O
.	O
#	O
li	O
Streams	O
in	O
general	O
are	O
more	O
difficult	O
to	O
code	O
,	O
read	O
,	O
and	O
debug	O
.	O
Actually	O
,	O
this	O
is	O
true	O
of	O
complex	O
"	O
fluent	O
"	O
APIs	O
in	O
general	O
.	O
The	O
combination	O
of	O
complex	O
single	O
statements	O
,	O
heavy	O
use	O
of	O
generics	O
,	O
and	O
lack	O
of	O
intermediate	O
variables	O
conspire	O
to	O
produce	O
confusing	O
error	O
messages	O
and	O
frustrate	O
debugging	O
.	O
Instead	O
of	O
"	O
this	O
method	O
doesn	O
'	O
t	O
have	O
an	O
overload	O
for	O
type	O
X	O
"	O
you	O
get	O
an	O
error	O
message	O
closer	O
to	O
"	O
somewhere	O
you	O
messed	O
up	O
the	O
types	O
,	O
but	O
we	O
don	O
'	O
t	O
know	O
where	O
or	O
how	O
.	O
"	O
Similarly	O
,	O
you	O
can	O
'	O
t	O
step	O
through	O
and	O
examine	O
things	O
in	O
a	O
debugger	O
as	O
easily	O
as	O
when	O
the	O
code	O
is	O
broken	O
into	O
multiple	O
statements	O
,	O
and	O
intermediate	O
values	O
are	O
saved	O
to	O
variables	O
.	O
Finally	O
,	O
reading	O
the	O
code	O
and	O
understanding	O
the	O
types	O
and	O
behavior	O
at	O
each	O
stage	O
of	O
execution	O
may	O
be	O
non	O
-	O
trivial	O
.	O
#	O
li	O
Sticks	O
out	O
like	O
a	O
sore	O
thumb	O
.	O
The	O
Java	O
language	O
already	O
has	O
the	O
for	O
-	O
each	O
statement	O
.	O
Why	O
replace	O
it	O
with	O
a	O
function	O
call	O
?	O
Why	O
encourage	O
hiding	O
side	O
-	O
effects	O
somewhere	O
in	O
expressions	O
?	O
Why	O
encourage	O
unwieldy	O
one	O
-	O
liners	O
?	O
Mixing	O
regular	O
for	O
-	O
each	O
and	O
new	O
forEach	B-api_mention
willy	O
-	O
nilly	O
is	O
bad	O
style	O
.	O
Code	O
should	O
speak	O
in	O
idioms	O
(	O
patterns	O
that	O
are	O
quick	O
to	O
comprehend	O
due	O
to	O
their	O
repetition	O
)	O
,	O
and	O
the	O
fewer	O
idioms	O
are	O
used	O
the	O
clearer	O
the	O
code	O
is	O
and	O
less	O
time	O
is	O
spent	O
deciding	O
which	O
idiom	O
to	O
use	O
(	O
a	O
big	O
time	O
-	O
drain	O
for	O
perfectionists	O
like	O
myself	O
!	O
)	O
.	O
As	O
you	O
can	O
see	O
,	O
I	O
'	O
m	O
not	O
a	O
big	O
fan	O
of	O
the	O
forEach	B-api_mention
(	I-api_mention
)	I-api_mention
except	O
in	O
cases	O
when	O
it	O
makes	O
sense	O
.	O
Particularly	O
offensive	O
to	O
me	O
is	O
the	O
fact	O
that	O
Stream	B-api_mention
does	O
not	O
implement	O
Iterable	B-api_mention
(	O
despite	O
actually	O
having	O
method	O
iterator	O
)	O
and	O
cannot	O
be	O
used	O
in	O
a	O
for	O
-	O
each	O
,	O
only	O
with	O
a	O
forEach	B-api_mention
(	I-api_mention
)	I-api_mention
.	O
I	O
recommend	O
casting	O
Streams	O
into	O
Iterables	O
with	O
(	O
Iterable	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
)	O
stream	O
:	O
:	O
iterator	O
.	O
A	O
better	O
alternative	O
is	O
to	O
use	O
StreamEx	O
which	O
fixes	O
a	O
number	O
of	O
Stream	B-api_mention
API	O
problems	O
,	O
including	O
implementing	O
Iterable	B-api_mention
.	O
That	O
said	O
,	O
forEach	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
is	O
useful	O
for	O
the	O
following	O
:	O
#	O
li	O
Atomically	O
iterating	O
over	O
a	O
synchronized	O
list	O
.	O
Prior	O
to	O
this	O
,	O
a	O
list	O
generated	O
with	O
Collections	B-api_mention
.	I-api_mention
synchronizedList	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
was	O
atomic	O
with	O
respect	O
to	O
things	O
like	O
get	O
or	O
set	O
,	O
but	O
was	O
not	O
thread	O
-	O
safe	O
when	O
iterating	O
.	O
#	O
li	O
Parallel	O
execution	O
(	O
using	O
an	O
appropriate	O
parallel	O
stream	O
)	O
.	O
This	O
saves	O
you	O
a	O
few	O
lines	O
of	O
code	O
vs	O
using	O
an	O
ExecutorService	B-api_mention
,	O
if	O
your	O
problem	O
matches	O
the	O
performance	O
assumptions	O
built	O
into	O
Streams	O
and	O
Spliterators	O
.	O
#	O
li	O
Specific	O
containers	O
which	O
,	O
like	O
the	O
synchronized	O
list	O
,	O
benefit	O
from	O
being	O
in	O
control	O
of	O
iteration	O
(	O
although	O
this	O
is	O
largely	O
theoretical	O
unless	O
people	O
can	O
bring	O
up	O
more	O
examples	O
)	O
#	O
li	O
Calling	O
a	O
single	O
function	O
more	O
cleanly	O
by	O
using	O
forEach	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
and	O
a	O
method	O
reference	O
argument	O
(	O
ie	O
,	O
list	O
.	B-api_mention
forEach	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
)	O
.	O
However	O
,	O
keep	O
in	O
mind	O
the	O
points	O
on	O
checked	O
exceptions	O
,	O
more	O
difficult	O
debugging	O
,	O
and	O
reducing	O
the	O
number	O
of	O
idioms	O
you	O
use	O
when	O
writing	O
code	O
.	O
Articles	O
I	O
used	O
for	O
reference	O
:	O
#	O
li	O
Everything	O
about	O
Java	O
8	O
#	O
li	O
Iteration	O
Inside	O
and	O
Out	O
(	O
as	O
pointed	O
out	O
by	O
another	O
poster	O
)	O
EDIT	O
:	O
Looks	O
like	O
some	O
of	O
the	O
original	O
proposals	O
for	O
lambdas	O
(	O
such	O
as	O
#	O
a	O
)	O
solved	O
some	O
of	O
the	O
issues	O
I	O
mentioned	O
(	O
while	O
adding	O
their	O
own	O
complications	O
,	O
of	O
course	O
)	O
.	O
Question	O
-	O
24914525	O
,	O
answer	O
-	O
24914586	O
std	O
:	O
:	O
list	O
in	O
C	O
+	O
+	O
is	O
a	O
linked	O
list	O
,	O
whereas	O
java	B-api_mention
.	I-api_mention
util	I-api_mention
.	I-api_mention
ArrayList	I-api_mention
is	O
an	O
array	O
.	O
Try	O
replacing	O
std	O
:	O
:	O
list	O
by	O
std	O
:	O
:	O
vector	O
.	O
Also	O
,	O
be	O
sure	O
to	O
compile	O
with	O
optimization	O
turned	O
on	O
.	O
Question	O
-	O
15655012	O
,	O
answer	O
-	O
15656208	O
This	O
is	O
favorite	O
interview	O
question	O
.	O
Interviewer	O
tries	O
to	O
find	O
out	O
here	O
,	O
how	O
much	O
you	O
understand	O
about	O
behavior	O
of	O
objects	O
with	O
respect	O
to	O
constructors	O
,	O
methods	O
,	O
class	O
variables	O
(	O
static	O
variables	O
)	O
,	O
instance	O
variables	O
.	O
#	O
pre	O
In	O
above	O
case	O
we	O
have	O
defined	O
Test	O
constructor	O
and	O
setFoo	O
method	O
.	O
About	O
constructor	O
:	O
Constructor	O
can	O
be	O
invoked	O
only	O
one	O
time	O
per	O
object	O
creation	O
by	O
using	O
new	O
keyword	O
.	O
Programmer	O
cannot	O
invoke	O
constructor	O
many	O
times	O
because	O
constructor	O
are	O
designed	O
so	O
.	O
About	O
method	O
:	O
Method	O
can	O
be	O
invoked	O
as	O
many	O
time	O
as	O
programmer	O
wants	O
and	O
compiler	O
knows	O
it	O
programmer	O
may	O
invoke	O
method	O
zero	O
or	O
multiple	O
time	O
.	O
Scenario	O
1	O
private	O
final	O
List	B-api_mention
foo	O
;	O
/	O
/	O
1	O
foo	O
is	O
an	O
instance	O
variable	O
.	O
When	O
we	O
create	O
Test	O
class	O
'	O
object	O
then	O
instance	O
variable	O
foo	O
will	O
be	O
copied	O
inside	O
object	O
of	O
Test	O
class	O
.	O
If	O
we	O
assign	O
foo	O
inside	O
constructor	O
then	O
compiler	O
know	O
that	O
Constructor	O
will	O
be	O
invoked	O
only	O
one	O
time	O
.	O
so	O
there	O
is	O
no	O
problem	O
to	O
assign	O
it	O
inside	O
constructor	O
.	O
If	O
we	O
assign	O
foo	O
inside	O
method	O
then	O
compiler	O
knows	O
that	O
method	O
may	O
be	O
invoked	O
multiple	O
time	O
.	O
So	O
value	O
will	O
have	O
to	O
be	O
changed	O
multiple	O
time	O
which	O
is	O
not	O
allowed	O
for	O
final	O
variable	O
.	O
You	O
can	O
assign	O
value	O
to	O
the	O
final	O
variable	O
only	O
one	O
time	O
.	O
So	O
compiler	O
decides	O
constructor	O
is	O
good	O
choice	O
!	O
Scenario	O
2	O
private	O
static	O
final	O
List	B-api_mention
foo	O
=	O
new	O
ArrayList	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
foo	O
is	O
now	O
static	O
variable	O
.	O
When	O
we	O
create	O
object	O
of	O
Test	O
class	O
then	O
foo	O
will	O
not	O
be	O
copied	O
to	O
the	O
object	O
of	O
Test	O
class	O
because	O
foo	O
is	O
static	O
.	O
Now	O
foo	O
is	O
not	O
the	O
property	O
of	O
each	O
object	O
.	O
This	O
is	O
the	O
property	O
of	O
Test	O
class	O
.	O
But	O
foo	O
can	O
be	O
seen	O
by	O
many	O
objects	O
and	O
if	O
every	O
object	O
which	O
is	O
created	O
by	O
using	O
new	O
keyword	O
which	O
ultimately	O
invoke	O
Test	O
constructor	O
then	O
value	O
will	O
be	O
changed	O
at	O
the	O
time	O
of	O
multiple	O
object	O
creation	O
(	O
Remember	O
static	O
foo	O
is	O
not	O
copied	O
in	O
every	O
object	O
now	O
but	O
is	O
shared	O
between	O
multiple	O
objects	O
.	O
)	O
Scenario	O
3	O
t	O
.	O
foo	O
.	B-api_mention
add	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
/	O
/	O
Modification	O
-	O
2	O
Above	O
Modification	O
-	O
2	O
is	O
from	O
your	O
question	O
.	O
In	O
above	O
case	O
you	O
are	O
not	O
changing	O
first	O
referenced	O
object	O
but	O
you	O
are	O
adding	O
contents	O
inside	O
foo	O
which	O
is	O
allowed	O
.	O
Compiler	O
complains	O
if	O
you	O
try	O
to	O
assign	O
new	O
ArrayList	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
object	O
to	O
the	O
foo	O
reference	O
variable	O
.	O
Rule	O
is	O
that	O
if	O
you	O
have	O
initialized	O
object	O
to	O
final	O
reference	O
variable	O
then	O
you	O
cannot	O
change	O
it	O
to	O
refer	O
different	O
ArrayList	B-api_mention
object	O
.	O
(	O
in	O
this	O
case	O
ArrayList	B-api_mention
)	O
final	O
class	O
cannot	O
be	O
subclassed	O
final	O
methods	O
cannot	O
be	O
overridden	O
.	O
(	O
This	O
method	O
is	O
in	O
superclass	O
)	O
final	O
methods	O
can	O
override	O
.	O
(	O
Read	O
this	O
in	O
grammatical	O
way	O
.	O
This	O
method	O
is	O
in	O
subclass	O
)	O
Question	O
-	O
26684562	O
In	O
Java	O
8	O
,	O
what	O
'	O
s	O
the	O
difference	O
between	O
Stream	B-api_mention
.	I-api_mention
map	I-api_mention
and	O
Stream	B-api_mention
.	I-api_mention
flatMap	I-api_mention
methods	O
?	O
Question	O
-	O
29095967	O
,	O
answer	O
-	O
29098447	O
The	O
solution	O
is	O
to	O
use	O
Stream	B-api_mention
.	I-api_mention
collect	I-api_mention
.	O
To	O
create	O
a	O
Collector	B-api_mention
using	O
its	O
builder	O
pattern	O
is	O
already	O
given	O
as	O
solution	O
.	O
The	O
alternative	O
is	O
the	O
other	O
overloaded	O
collect	O
being	O
a	O
tiny	O
bit	O
more	O
primitive	O
.	O
#	O
pre	O
As	O
one	O
sees	O
,	O
I	O
make	O
a	O
list	O
of	O
string	O
lists	O
,	O
where	O
there	O
always	O
is	O
at	O
least	O
one	O
last	O
(	O
empty	O
)	O
string	O
list	O
.	O
#	O
li	O
The	O
first	O
function	O
creates	O
a	O
starting	O
list	O
of	O
string	O
lists	O
.	O
It	O
specifies	O
the	O
result	O
(	O
typed	O
)	O
object	O
.	O
#	O
li	O
The	O
second	O
function	O
is	O
called	O
to	O
process	O
each	O
element	O
.	O
It	O
is	O
an	O
action	O
on	O
the	O
partial	O
result	O
and	O
an	O
element	O
.	O
#	O
li	O
The	O
third	O
is	O
not	O
really	O
used	O
,	O
it	O
comes	O
into	O
play	O
on	O
parallelising	O
the	O
processing	O
,	O
when	O
partial	O
results	O
must	O
be	O
combined	O
.	O
A	O
solution	O
with	O
an	O
accumulator	O
:	O
As	O
@	O
StuartMarks	O
points	O
out	O
,	O
the	O
combiner	O
does	O
not	O
fullfill	O
the	O
contract	O
for	O
parallelism	O
.	O
Due	O
to	O
the	O
comment	O
of	O
@	O
ArnaudDenoyelle	O
a	O
version	O
using	O
reduce	O
.	O
#	O
pre	O
#	O
li	O
The	O
first	O
parameter	O
is	O
the	O
accumulated	O
object	O
.	O
#	O
li	O
The	O
second	O
function	O
accumulates	O
.	O
#	O
li	O
The	O
third	O
is	O
the	O
aforementioned	O
combiner	O
.	O
Question	O
-	O
17489250	O
,	O
answer	O
-	O
17489376	O
String	B-api_mention
gets	O
special	O
treatment	O
in	O
the	O
JLS	O
:	O
it	O
'	O
s	O
one	O
of	O
the	O
two	O
non	O
-	O
primitive	O
types	O
for	O
which	O
literals	O
exist	O
(	O
the	O
other	O
is	O
Class	B-api_mention
)	O
*	O
.	O
From	O
the	O
JLS	O
:	O
#	O
blockquote	O
*	O
well	O
,	O
there	O
'	O
s	O
also	O
the	O
"	O
null	O
type	O
"	O
with	O
it	O
'	O
s	O
"	O
null	O
literal	O
"	O
null	O
,	O
but	O
most	O
people	O
don	O
'	O
t	O
think	O
of	O
the	O
"	O
null	O
type	O
"	O
as	O
a	O
proper	O
type	O
.	O
Question	O
-	O
22036885	O
,	O
answer	O
-	O
22037068	O
As	O
said	O
in	O
API	O
#	O
blockquote	O
It	O
'	O
s	O
because	O
of	O
cannot	O
represent	O
double	O
value	O
exactly	O
.	O
So	O
you	O
have	O
to	O
use	O
BigDecimal	B-api_mention
bigDecimal	O
=	O
BigDecimal	B-api_mention
.	I-api_mention
valueOf	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
instead	O
of	O
BigDecimal	B-api_mention
bigDecimal	O
=	O
new	O
BigDecimal	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Question	O
-	O
27504925	O
,	O
answer	O
-	O
27505121	O
I	O
'	O
d	O
like	O
to	O
point	O
out	O
this	O
article	O
.	O
It	O
seems	O
as	O
though	O
arrays	O
and	O
objects	O
follow	O
different	O
opcodes	O
.	O
I	O
can	O
'	O
t	O
honestly	O
summarize	O
it	O
more	O
than	O
that	O
however	O
it	O
seems	O
,	O
arrays	O
are	O
simply	O
not	O
treated	O
as	O
Objects	B-api_mention
like	O
we	O
'	O
re	O
normally	O
used	O
to	O
so	O
they	O
don	O
'	O
t	O
inherit	O
Object	B-api_mention
methods	O
.	O
Full	O
credits	O
to	O
the	O
author	O
of	O
that	O
post	O
as	O
it	O
'	O
s	O
a	O
very	O
interesting	O
read	O
,	O
both	O
short	O
&	O
detailed	O
.	O
Upon	O
further	O
digging	O
into	O
the	O
topic	O
via	O
multiple	O
sources	O
I	O
'	O
ve	O
decided	O
to	O
give	O
a	O
more	O
elaborate	O
version	O
of	O
my	O
previous	O
answer	O
.	O
The	O
first	O
thing	O
to	O
note	O
that	O
instantiation	O
of	O
Objects	B-api_mention
and	O
Arrays	B-api_mention
are	O
very	O
different	O
within	O
the	O
JVM	O
,	O
their	O
follow	O
their	O
respective	O
bytecode	O
.	O
Object	O
:	O
Object	B-api_mention
instantiation	O
follows	O
a	O
simple	O
Opcode	O
new	O
which	O
is	O
a	O
combination	O
of	O
two	O
operands	O
-	O
indexbyte1	O
&	O
indexbyte2	O
.	O
Once	O
instantiated	O
the	O
JVM	O
pushes	O
the	O
reference	O
to	O
this	O
object	O
onto	O
the	O
stack	O
.	O
This	O
occurs	O
for	O
all	O
objects	O
irrespective	O
of	O
their	O
types	O
.	O
Arrays	O
:	O
Array	B-api_mention
Opcodes	O
(	O
regarding	O
instantiation	O
of	O
an	O
array	O
)	O
however	O
are	O
divided	O
into	O
three	O
different	O
codes	O
.	O
#	O
blockquote	O
newarray	O
opcode	O
is	O
used	O
when	O
creating	O
arrays	O
that	O
involve	O
primitive	O
datatypes	O
(	O
byte	O
short	O
char	O
int	O
long	O
float	O
double	O
boolean	O
)	O
rather	O
than	O
object	O
references	O
.	O
#	O
blockquote	O
anewarray	O
opcode	O
is	O
used	O
when	O
creating	O
arrays	O
of	O
object	O
references	O
#	O
blockquote	O
multianewarray	O
instruction	O
is	O
used	O
when	O
allocating	O
multi	O
-	O
dimensional	O
arrays	O
Object	B-api_mention
can	O
be	O
a	O
class	O
instance	O
or	O
an	O
array	O
.	O
Take	O
from	O
Oracle	O
Docs	O
#	O
blockquote	O
BUT	O
#	O
blockquote	O
This	O
goes	O
hand	O
in	O
hand	O
with	O
the	O
information	O
regarding	O
the	O
opcodes	O
.	O
Arrays	O
are	O
simply	O
not	O
developed	O
to	O
be	O
class	O
interfaces	O
but	O
are	O
instead	O
explicitly	O
created	O
by	O
array	O
creation	O
expression	O
thus	O
naturally	O
wouldn	O
'	O
t	O
implicitly	O
be	O
able	O
to	O
inherit	O
and	O
/	O
or	O
override	O
Object	B-api_mention
.	O
As	O
we	O
have	O
seen	O
,	O
it	O
has	O
nothing	O
to	O
do	O
with	O
the	O
fact	O
that	O
arrays	O
may	O
hold	O
primitive	O
datatypes	O
.	O
After	O
giving	O
it	O
some	O
thought	O
though	O
,	O
it	O
isn	O
'	O
t	O
very	O
common	O
to	O
come	O
across	O
situations	O
where	O
one	O
might	O
want	O
to	O
toString	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
or	O
equals	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
however	O
was	O
still	O
a	O
very	O
interesting	O
question	O
to	O
try	O
and	O
answer	O
.	O
Resources	O
:	O
Oracle	O
-	O
Docs	O
chapter	O
4	O
.	O
3	O
.	O
1	O
Oracle	O
-	O
Docs	O
chapter	O
15	O
.	O
10	O
.	O
1	O
Artima	O
-	O
UnderTheHood	O
Question	O
-	O
7707556	O
,	O
answer	O
-	O
15870428	O
There	O
is	O
a	O
subtle	O
issue	O
here	O
that	O
is	O
a	O
bit	O
of	O
a	O
gotcha	O
.	O
The	O
toString	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
has	O
a	O
base	O
implementation	O
in	O
Object	B-api_mention
.	O
CharSequence	B-api_mention
is	O
an	O
interface	O
;	O
and	O
although	O
the	O
toString	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
appears	O
as	O
part	O
of	O
that	O
interface	O
,	O
there	O
is	O
nothing	O
at	O
compile	O
-	O
time	O
that	O
will	O
force	O
you	O
to	O
override	O
it	O
and	O
honor	O
the	O
additional	O
constraints	O
that	O
the	O
CharSequence	B-api_mention
toString	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
'	O
s	O
javadoc	O
puts	O
on	O
the	O
toString	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
;	O
ie	O
that	O
it	O
should	O
return	O
a	O
string	O
containing	O
the	O
characters	O
in	O
the	O
order	O
returned	O
by	O
charAt	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
Your	O
IDE	O
won	O
'	O
t	O
even	O
help	O
you	O
out	O
by	O
reminding	O
that	O
you	O
that	O
you	O
probably	O
should	O
override	O
toString	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
For	O
example	O
,	O
in	O
intellij	O
,	O
this	O
is	O
what	O
you	O
'	O
ll	O
see	O
if	O
you	O
create	O
a	O
new	O
CharSequence	B-api_mention
implementation	O
:	O
#	O
a	O
.	O
Note	O
the	O
absence	O
of	O
toString	B-api_mention
(	I-api_mention
args	I-api_mention
)	O
.	O
If	O
you	O
rely	O
on	O
toString	B-api_mention
(	I-api_mention
args	I-api_mention
)	O
on	O
an	O
arbitrary	O
CharSequence	B-api_mention
,	O
it	O
should	O
work	O
provided	O
the	O
CharSequence	B-api_mention
implementer	O
did	O
their	O
job	O
properly	O
.	O
But	O
if	O
you	O
want	O
to	O
avoid	O
any	O
uncertainty	O
altogether	O
,	O
you	O
should	O
use	O
a	O
StringBuilder	B-api_mention
and	O
append	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
,	O
like	O
so	O
:	O
#	O
pre	O
Question	O
-	O
32475166	O
,	O
answer	O
-	O
32475290	O
The	O
chief	O
difference	O
is	O
that	O
an	O
if	O
else	O
block	O
is	O
a	O
statement	O
whereas	O
the	O
ternary	O
(	O
more	O
often	O
known	O
as	O
the	O
conditional	O
operator	O
in	O
Java	O
)	O
is	O
an	O
expression	O
.	O
A	O
statement	O
can	O
do	O
things	O
like	O
return	O
to	O
the	O
caller	O
on	O
some	O
of	O
the	O
control	O
paths	O
.	O
An	O
expression	O
can	O
be	O
used	O
in	O
an	O
assignment	O
:	O
int	O
n	O
=	O
condition	O
?	O
3	O
:	O
2	O
;	O
So	O
the	O
two	O
expressions	O
in	O
the	O
ternary	O
after	O
the	O
condition	O
need	O
to	O
be	O
coercable	O
to	O
the	O
same	O
type	O
.	O
This	O
can	O
cause	O
some	O
odd	O
effects	O
in	O
Java	O
particularly	O
with	O
auto	O
-	O
boxing	O
and	O
automatic	O
reference	O
casting	O
-	O
this	O
is	O
what	O
the	O
comment	O
in	O
your	O
posted	O
code	O
is	O
referring	O
to	O
.	O
The	O
coercion	O
of	O
the	O
expressions	O
in	O
your	O
case	O
would	O
be	O
to	O
a	O
java	O
.	O
lang	O
.	O
reflect	O
.	O
Executable	O
type	O
(	O
as	O
that	O
'	O
s	O
the	O
most	O
specialised	O
type	O
)	O
and	O
that	O
does	O
not	O
exist	O
in	O
older	O
versions	O
of	O
Java	O
.	O
Stylistically	O
you	O
should	O
use	O
an	O
if	O
else	O
block	O
if	O
the	O
code	O
is	O
statement	O
-	O
like	O
,	O
and	O
a	O
ternary	O
if	O
it	O
'	O
s	O
expression	O
-	O
like	O
.	O
Of	O
course	O
,	O
you	O
can	O
make	O
an	O
if	O
else	O
block	O
behave	O
like	O
an	O
expression	O
if	O
you	O
use	O
a	O
lambda	O
function	O
.	O
Question	O
-	O
21163108	O
,	O
answer	O
-	O
34930831	O
To	O
measure	O
the	O
actual	O
number	O
of	O
used	O
threads	O
,	O
you	O
can	O
check	O
Thread	B-api_mention
.	I-api_mention
activeCount	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
:	O
#	O
pre	O
This	O
can	O
produce	O
on	O
a	O
4	O
-	O
core	O
CPU	O
an	O
output	O
like	O
:	O
#	O
pre	O
Without	O
.	B-api_mention
parallel	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
it	O
gives	O
:	O
#	O
pre	O
Question	O
-	O
17781150	O
,	O
answer	O
-	O
17781189	O
The	O
only	O
int	O
value	O
for	O
which	O
it	O
works	O
is	O
Integer	B-api_mention
.	I-api_mention
MIN	I-api_mention
_	I-api_mention
VALUE	I-api_mention
.	O
It	O
'	O
s	O
because	O
integers	O
are	O
negated	O
using	O
the	O
two	O
'	O
s	O
complement	O
way	O
.	O
Using	O
System	B-api_mention
.	I-api_mention
out	I-api_mention
.	I-api_mention
println	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
you	O
see	O
that	O
Integer	B-api_mention
.	I-api_mention
MIN	I-api_mention
_	I-api_mention
VALUE	I-api_mention
is	O
10000000000000000000000000000000	O
Taking	O
the	O
negative	O
value	O
is	O
done	O
by	O
first	O
swapping	O
0	O
and	O
1	O
,	O
which	O
gives	O
01111111111111111111111111111111	O
and	O
by	O
adding	O
1	O
,	O
which	O
gives	O
10000000000000000000000000000000	O
As	O
you	O
can	O
see	O
in	O
the	O
link	O
I	O
gave	O
,	O
Wikipedia	O
mentions	O
the	O
problem	O
with	O
the	O
most	O
negative	O
numbers	O
and	O
specifies	O
it	O
'	O
s	O
the	O
sole	O
exception	O
:	O
#	O
blockquote	O
Of	O
course	O
you	O
have	O
the	O
same	O
phenomenon	O
for	O
Long	B-api_mention
.	O
Min	O
_	O
Value	O
if	O
you	O
store	O
it	O
in	O
a	O
long	O
variable	O
.	O
Note	O
that	O
this	O
is	O
only	O
due	O
to	O
choices	O
that	O
were	O
made	O
regarding	O
the	O
binary	O
storage	O
of	O
ints	O
in	O
Java	O
.	O
Another	O
(	O
bad	O
)	O
solution	O
could	O
for	O
example	O
have	O
been	O
to	O
negate	O
by	O
simply	O
changing	O
the	O
most	O
significant	O
bit	O
and	O
letting	O
the	O
other	O
bits	O
unchanged	O
,	O
this	O
would	O
have	O
avoided	O
this	O
problem	O
with	O
MIN	B-api_mention
_	I-api_mention
VALUE	I-api_mention
but	O
would	O
have	O
made	O
2	O
different	O
0	O
values	O
and	O
complicated	O
binary	O
arithmetic	O
(	O
how	O
would	O
you	O
have	O
incremented	O
for	O
example	O
?	O
)	O
.	O
Question	O
-	O
13195797	O
I	O
want	O
to	O
delete	O
all	O
files	O
inside	O
ABC	O
directory	O
.	O
When	O
I	O
tried	O
with	O
FileUtils	B-api_mention
.	I-api_mention
deleteDirectory	I-api_mention
(	I-api_mention
args	I-api_mention
)	O
;	O
it	O
also	O
deletes	O
folder	O
ABC	O
.	O
Is	O
there	O
a	O
one	O
liner	O
solution	O
where	O
I	O
can	O
delete	O
files	O
inside	O
directory	O
but	O
not	O
directory	O
?	O
Question	O
-	O
8172420	O
,	O
answer	O
-	O
32174377	O
We	O
have	O
various	O
ways	O
to	O
convert	O
a	O
char	O
to	O
String	B-api_mention
.	O
One	O
way	O
is	O
to	O
make	O
use	O
of	O
static	O
method	O
toString	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
in	O
Character	O
class	O
:	O
#	O
pre	O
Actually	O
this	O
toString	B-api_mention
method	O
internally	O
makes	O
use	O
of	O
valueOf	B-api_mention
method	O
from	O
String	B-api_mention
class	O
which	O
makes	O
use	O
of	O
char	O
array	O
:	O
#	O
pre	O
So	O
second	O
way	O
is	O
to	O
use	O
this	O
directly	O
:	O
String	B-api_mention
str2	O
=	O
String	B-api_mention
.	I-api_mention
valueOf	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
This	O
valueOf	B-api_mention
method	O
in	O
String	B-api_mention
class	O
makes	O
use	O
of	O
char	O
array	O
:	O
#	O
pre	O
So	O
the	O
third	O
way	O
is	O
to	O
make	O
use	O
of	O
an	O
anonymous	O
array	O
to	O
wrap	O
a	O
single	O
character	O
and	O
then	O
passing	O
it	O
to	O
String	B-api_mention
constructor	O
:	O
String	B-api_mention
str4	O
=	O
new	O
String	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
The	O
fourth	O
way	O
is	O
to	O
make	O
use	O
of	O
concatenation	O
:	O
String	B-api_mention
str3	O
=	O
StringLiteral	O
+	O
ch	O
;	O
This	O
will	O
actually	O
make	O
use	O
of	O
append	B-api_mention
method	O
from	O
StringBuilder	B-api_mention
class	O
which	O
is	O
actually	O
preferred	O
when	O
we	O
are	O
doing	O
concatenation	O
in	O
a	O
loop	O
.	O
Question	O
-	O
7032070	O
,	O
answer	O
-	O
7032180	O
The	O
clear	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
removes	O
all	O
the	O
elements	O
of	O
a	O
single	O
ArrayList	B-api_mention
.	O
It	O
'	O
s	O
a	O
fast	O
operation	O
,	O
as	O
it	O
just	O
sets	O
some	O
array	O
elements	O
to	O
null	O
.	O
The	O
removeAll	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
,	O
which	O
is	O
inherited	O
from	O
AbstractCollection	B-api_mention
,	O
removes	O
all	O
the	O
elements	O
that	O
are	O
in	O
the	O
argument	O
collection	O
from	O
the	O
collection	O
you	O
call	O
the	O
method	O
on	O
.	O
It	O
'	O
s	O
a	O
relatively	O
slow	O
operation	O
,	O
as	O
it	O
has	O
to	O
search	O
through	O
one	O
of	O
the	O
collections	O
involved	O
.	O
Question	O
-	O
9324933	O
I	O
looked	O
at	O
the	O
default	O
Zip	B-api_mention
library	O
that	O
comes	O
with	O
the	O
JDK	O
and	O
the	O
Apache	O
compression	O
libs	O
and	O
I	O
am	O
unhappy	O
with	O
them	O
for	O
3	O
reasons	O
:	O
#	O
li	O
They	O
are	O
bloated	O
and	O
have	O
bad	O
API	O
design	O
.	O
I	O
have	O
to	O
write	O
50	O
lines	O
of	O
boiler	O
plate	O
byte	O
array	O
output	O
,	O
zip	O
input	O
,	O
file	O
out	O
streams	O
and	O
close	O
relevant	O
streams	O
and	O
catch	O
exceptions	O
and	O
move	O
byte	O
buffers	O
on	O
my	O
own	O
?	O
Why	O
can	O
'	O
t	O
I	O
have	O
a	O
simple	O
API	O
that	O
looks	O
like	O
this	O
Zipper	B-api_mention
.	I-api_mention
unzip	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
and	O
Zipper	B-api_mention
.	I-api_mention
zip	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
that	O
just	O
works	O
?	O
#	O
li	O
It	O
seems	O
zipping	O
unzipping	O
destroys	O
file	O
meta	O
-	O
data	O
and	O
password	O
handling	O
is	O
broken	O
.	O
#	O
li	O
Also	O
,	O
all	O
the	O
libraries	O
I	O
tried	O
were	O
2	O
-	O
3x	O
slow	O
compared	O
to	O
the	O
command	O
line	O
zip	O
tools	O
I	O
get	O
with	O
UNIX	O
?	O
For	O
me	O
(	O
2	O
)	O
and	O
(	O
3	O
)	O
are	O
minor	O
points	O
but	O
I	O
really	O
want	O
a	O
good	O
tested	O
library	O
with	O
a	O
one	O
-	O
line	O
interface	O
.	O
Question	O
-	O
6608795	O
,	O
answer	O
-	O
22327270	O
I	O
tried	O
reading	O
from	O
input1	O
.	O
txt	O
which	O
was	O
inside	O
one	O
of	O
my	O
packages	O
together	O
with	O
the	O
class	O
which	O
was	O
trying	O
to	O
read	O
it	O
.	O
The	O
following	O
works	O
:	O
#	O
pre	O
The	O
most	O
important	O
part	O
was	O
to	O
call	O
getPath	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
if	O
you	O
want	O
the	O
correct	O
path	O
name	O
in	O
String	B-api_mention
format	O
.	O
DO	O
NOT	O
USE	O
toString	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
because	O
it	O
will	O
add	O
some	O
extra	O
formatting	O
text	O
which	O
will	O
TOTALLY	O
MESS	O
UP	O
the	O
fileName	O
(	O
you	O
can	O
try	O
it	O
and	O
see	O
the	O
print	O
out	O
)	O
.	O
Spent	O
2	O
hours	O
debugging	O
this	O
.	O
.	O
.	O
:	O
(	O
Question	O
-	O
6470651	O
,	O
answer	O
-	O
6540248	O
Below	O
there	O
will	O
be	O
a	O
non	O
-	O
obvious	O
case	O
where	O
Java	O
leaks	O
,	O
besides	O
the	O
standard	O
case	O
of	O
forgotten	O
listeners	O
,	O
static	O
references	O
,	O
bogus	O
/	O
modifiable	O
keys	O
in	O
hashmaps	O
,	O
or	O
just	O
threads	O
stuck	O
without	O
any	O
chance	O
to	O
end	O
their	O
life	O
-	O
cycle	O
.	O
#	O
li	O
File	B-api_mention
.	I-api_mention
deleteOnExit	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
-	O
always	O
leaks	O
the	O
string	O
,	O
if	O
the	O
string	O
is	O
a	O
substring	O
,	O
the	O
leak	O
is	O
even	O
worse	O
(	O
the	O
underlying	O
char	O
[	O
]	O
is	O
also	O
leaked	O
)	O
-	O
in	O
Java	O
7	O
substring	O
also	O
copies	O
the	O
char	O
[	O
]	O
,	O
so	O
the	O
later	O
doesn	O
'	O
t	O
apply	O
;	O
@	O
Daniel	O
,	O
no	O
needs	O
for	O
votes	O
,	O
though	O
.	O
I	O
'	O
ll	O
concentrate	O
on	O
threads	O
to	O
show	O
the	O
danger	O
of	O
unmanaged	O
threads	O
mostly	O
,	O
don	O
'	O
t	O
wish	O
to	O
even	O
touch	O
swing	O
.	O
#	O
li	O
Runtime	B-api_mention
.	I-api_mention
addShutdownHook	I-api_mention
and	O
not	O
remove	O
.	O
.	O
.	O
and	O
then	O
even	O
with	O
removeShutdownHook	B-api_mention
due	O
to	O
a	O
bug	O
in	O
ThreadGroup	B-api_mention
class	O
regarding	O
unstarted	O
threads	O
it	O
may	O
not	O
get	O
collected	O
,	O
effectively	O
leak	O
the	O
ThreadGroup	B-api_mention
.	O
JGroup	O
has	O
the	O
leak	O
in	O
GossipRouter	O
.	O
#	O
li	O
Creating	O
,	O
but	O
not	O
starting	O
,	O
a	O
Thread	B-api_mention
goes	O
into	O
the	O
same	O
category	O
as	O
above	O
.	O
#	O
li	O
Creating	O
a	O
thread	O
inherits	O
the	O
ContextClassLoader	B-api_mention
and	O
AccessControlContext	B-api_mention
,	O
plus	O
the	O
ThreadGroup	B-api_mention
and	O
any	O
InheritedThreadLocal	B-api_mention
,	O
all	O
those	O
references	O
are	O
potential	O
leaks	O
,	O
along	O
with	O
the	O
entire	O
classes	O
loaded	O
by	O
the	O
classloader	O
and	O
all	O
static	O
references	O
,	O
and	O
ja	O
-	O
ja	O
.	O
The	O
effect	O
is	O
especially	O
visible	O
with	O
the	O
entire	O
j	O
.	O
u	O
.	O
c	O
.	O
Executor	O
framework	O
that	O
features	O
a	O
super	O
simple	O
ThreadFactory	B-api_mention
interface	O
,	O
yet	O
most	O
developers	O
have	O
no	O
clue	O
of	O
the	O
lurking	O
danger	O
.	O
Also	O
a	O
lot	O
of	O
libraries	O
do	O
start	O
threads	O
upon	O
request	O
(	O
way	O
too	O
many	O
industry	O
popular	O
libraries	O
)	O
.	O
#	O
li	O
ThreadLocal	O
caches	O
;	O
those	O
are	O
evil	O
in	O
many	O
cases	O
.	O
I	O
am	O
sure	O
everyone	O
has	O
seen	O
quite	O
a	O
bit	O
of	O
simple	O
caches	O
based	O
on	O
ThreadLocal	B-api_mention
,	O
well	O
the	O
bad	O
news	O
:	O
if	O
the	O
thread	O
keeps	O
going	O
more	O
than	O
expected	O
the	O
life	O
the	O
context	O
ClassLoader	B-api_mention
,	O
it	O
is	O
a	O
pure	O
nice	O
little	O
leak	O
.	O
Do	O
not	O
use	O
ThreadLocal	B-api_mention
caches	O
unless	O
really	O
needed	O
.	O
#	O
li	O
Calling	O
ThreadGroup	B-api_mention
.	I-api_mention
destroy	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
when	O
the	O
ThreadGroup	B-api_mention
has	O
no	O
threads	O
itself	O
,	O
but	O
it	O
still	O
keeps	O
child	O
ThreadGroups	B-api_mention
.	O
A	O
bad	O
leak	O
that	O
will	O
prevent	O
the	O
ThreadGroup	B-api_mention
to	O
remove	O
from	O
its	O
parent	O
,	O
but	O
all	O
the	O
children	O
become	O
un	O
-	O
enumerateable	O
.	O
#	O
li	O
Using	O
WeakHashMap	B-api_mention
and	O
the	O
value	O
(	O
in	O
)	O
directly	O
references	O
the	O
key	O
.	O
This	O
is	O
a	O
hard	O
one	O
to	O
find	O
without	O
a	O
heap	O
dump	O
.	O
That	O
applies	O
to	O
all	O
extended	O
Weak	O
/	O
SoftReference	B-api_mention
that	O
might	O
keep	O
a	O
hard	O
reference	O
back	O
to	O
the	O
guarded	O
object	O
.	O
#	O
li	O
Using	O
java	B-api_mention
.	I-api_mention
net	I-api_mention
.	I-api_mention
URL	I-api_mention
with	O
the	O
HTTP	O
(	O
S	O
)	O
protocol	O
and	O
loading	O
the	O
resource	O
from	O
(	O
!	O
)	O
.	O
This	O
one	O
is	O
special	O
,	O
the	O
KeepAliveCache	B-api_mention
creates	O
a	O
new	O
thread	O
in	O
the	O
system	O
ThreadGroup	B-api_mention
which	O
leaks	O
the	O
current	O
thread	O
'	O
s	O
context	O
classloader	O
.	O
The	O
thread	O
is	O
created	O
upon	O
the	O
first	O
request	O
when	O
no	O
alive	O
thread	O
exists	O
,	O
so	O
either	O
you	O
may	O
get	O
lucky	O
or	O
just	O
leak	O
.	O
The	O
leak	O
is	O
already	O
fixed	O
in	O
Java	O
7	O
and	O
the	O
code	O
that	O
creates	O
thread	O
properly	O
removes	O
the	O
context	O
classloader	O
.	O
There	O
are	O
few	O
more	O
cases	O
(	O
like	O
ImageFetcher	B-api_mention
,	O
also	O
fixed	O
)	O
of	O
creating	O
similar	O
threads	O
.	O
#	O
li	O
Using	O
InflaterInputStream	B-api_mention
passing	O
new	O
java	B-api_mention
.	I-api_mention
util	I-api_mention
.	I-api_mention
zip	I-api_mention
.	I-api_mention
Inflater	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
in	O
the	O
constructor	O
(	O
PNGImageDecoder	B-api_mention
for	O
instance	O
)	O
and	O
not	O
calling	O
end	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
of	O
the	O
inflater	O
.	O
Well	O
,	O
if	O
you	O
pass	O
in	O
the	O
constructor	O
with	O
just	O
new	O
,	O
no	O
chance	O
.	O
.	O
.	O
And	O
yes	O
,	O
calling	O
close	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
on	O
the	O
stream	O
does	O
not	O
close	O
the	O
inflater	O
if	O
it	O
'	O
s	O
manually	O
passed	O
as	O
constructor	O
parameter	O
.	O
This	O
is	O
not	O
a	O
true	O
leak	O
since	O
it	O
'	O
d	O
be	O
released	O
by	O
the	O
finalizer	O
.	O
.	O
.	O
when	O
it	O
deems	O
it	O
necessary	O
.	O
Till	O
that	O
moment	O
it	O
eats	O
native	O
memory	O
so	O
badly	O
it	O
can	O
cause	O
Linux	O
oom	O
_	O
killer	O
to	O
kill	O
the	O
process	O
with	O
impunity	O
.	O
The	O
main	O
issue	O
is	O
that	O
finalization	O
in	O
Java	O
is	O
very	O
unreliable	O
and	O
G1	O
made	O
it	O
worse	O
till	O
7	O
.	O
0	O
.	O
2	O
.	O
Moral	O
of	O
the	O
story	O
:	O
release	O
native	O
resources	O
as	O
soon	O
as	O
you	O
can	O
;	O
the	O
finalizer	O
is	O
just	O
too	O
poor	O
.	O
#	O
li	O
The	O
same	O
case	O
with	O
java	B-api_mention
.	I-api_mention
util	I-api_mention
.	I-api_mention
zip	I-api_mention
.	I-api_mention
Deflater	I-api_mention
.	O
This	O
one	O
is	O
far	O
worse	O
since	O
Deflater	B-api_mention
is	O
memory	O
hungry	O
in	O
Java	O
,	O
i	O
.	O
e	O
.	O
always	O
uses	O
15	O
bits	O
(	O
max	O
)	O
and	O
8	O
memory	O
levels	O
(	O
9	O
is	O
max	O
)	O
allocating	O
several	O
hundreds	O
KB	O
of	O
native	O
memory	O
.	O
Fortunately	O
,	O
Deflater	O
is	O
not	O
widely	O
used	O
and	O
to	O
my	O
knowledge	O
JDK	O
contains	O
no	O
misuses	O
.	O
Always	O
call	O
end	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
if	O
you	O
manually	O
create	O
a	O
Deflater	B-api_mention
or	O
Inflater	B-api_mention
.	O
The	O
best	O
part	O
of	O
the	O
last	O
two	O
:	O
you	O
can	O
'	O
t	O
find	O
them	O
via	O
normal	O
profiling	O
tools	O
available	O
.	O
(	O
I	O
can	O
add	O
some	O
more	O
time	O
wasters	O
I	O
have	O
encountered	O
upon	O
request	O
.	O
)	O
Good	O
luck	O
and	O
stay	O
safe	O
;	O
leaks	O
are	O
evil	O
!	O
Question	O
-	O
5585779	O
,	O
answer	O
-	O
5585876	O
For	O
example	O
,	O
here	O
are	O
two	O
ways	O
:	O
#	O
pre	O
There	O
is	O
a	O
slight	O
difference	O
between	O
these	O
methods	O
:	O
#	O
li	O
valueOf	B-api_mention
returns	O
a	O
new	O
or	O
cached	O
instance	O
of	O
java	B-api_mention
.	I-api_mention
lang	I-api_mention
.	I-api_mention
Integer	I-api_mention
#	O
li	O
parseInt	B-api_mention
returns	O
primitive	O
int	O
.	O
The	O
same	O
is	O
for	O
all	O
cases	O
:	O
Short	B-api_mention
.	I-api_mention
valueOf	I-api_mention
/	O
parseShort	B-api_mention
,	O
Long	B-api_mention
.	I-api_mention
valueOf	I-api_mention
/	O
parseLong	B-api_mention
,	O
etc	O
.	O
Question	O
-	O
5585779	O
,	O
answer	O
-	O
36394016	O
Whenever	O
there	O
is	O
the	O
slightest	O
possibility	O
that	O
the	O
given	O
String	B-api_mention
does	O
not	O
contain	O
an	O
Integer	O
,	O
you	O
have	O
to	O
handle	O
this	O
special	O
case	O
.	O
Sadly	O
,	O
the	O
standard	O
Java	O
methods	O
Integer	B-api_mention
:	I-api_mention
:	I-api_mention
parseInt	I-api_mention
and	O
Integer	B-api_mention
:	I-api_mention
:	I-api_mention
valueOf	I-api_mention
throw	O
a	O
NumberFormatException	B-api_mention
to	O
signal	O
this	O
special	O
case	O
.	O
Thus	O
,	O
you	O
have	O
to	O
use	O
exceptions	O
for	O
flow	O
control	O
,	O
which	O
is	O
generally	O
considered	O
bad	O
coding	O
style	O
.	O
In	O
my	O
opinion	O
,	O
this	O
special	O
case	O
should	O
be	O
handled	O
by	O
returning	O
an	O
Optional	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
.	O
Since	O
Java	O
does	O
not	O
offer	O
such	O
a	O
method	O
,	O
I	O
use	O
the	O
following	O
wrapper	O
:	O
#	O
pre	O
Usage	O
:	O
#	O
pre	O
While	O
this	O
is	O
still	O
using	O
exceptions	O
for	O
flow	O
control	O
internally	O
,	O
the	O
usage	O
code	O
becomes	O
very	O
clean	O
.	O
Question	O
-	O
14491966	O
,	O
answer	O
-	O
14563808	O
It	O
is	O
very	O
unlikely	O
that	O
random	O
number	O
generation	O
performance	O
would	O
be	O
an	O
issue	O
for	O
any	O
use	O
-	O
case	O
you	O
came	O
up	O
with	O
unless	O
accessing	O
a	O
single	O
Random	B-api_mention
instance	O
from	O
multiple	O
threads	O
(	O
because	O
Random	B-api_mention
is	O
synchronized	O
)	O
.	O
However	O
,	O
if	O
that	O
really	O
is	O
the	O
case	O
and	O
you	O
need	O
lots	O
of	O
random	O
numbers	O
fast	O
,	O
your	O
solution	O
is	O
far	O
too	O
unreliable	O
.	O
Sometimes	O
it	O
gives	O
good	O
results	O
,	O
sometimes	O
it	O
gives	O
horrible	O
results	O
(	O
based	O
on	O
the	O
initial	O
settings	O
)	O
.	O
If	O
you	O
want	O
the	O
same	O
numbers	O
that	O
the	O
Random	B-api_mention
class	O
gives	O
you	O
,	O
only	O
faster	O
,	O
you	O
could	O
get	O
rid	O
of	O
the	O
synchronization	O
in	O
there	O
:	O
#	O
pre	O
I	O
simply	O
took	O
the	O
java	B-api_mention
.	I-api_mention
util	I-api_mention
.	I-api_mention
Random	I-api_mention
code	O
and	O
removed	O
the	O
synchronization	O
which	O
results	O
in	O
twice	O
the	O
performance	O
compared	O
to	O
the	O
original	O
on	O
my	O
Oracle	O
HotSpot	O
JVM	O
7u9	O
.	O
It	O
is	O
still	O
slower	O
than	O
your	O
QuickRandom	B-api_mention
,	O
but	O
it	O
gives	O
much	O
more	O
consistent	O
results	O
.	O
To	O
be	O
precise	O
,	O
for	O
the	O
same	O
seed	O
values	O
and	O
single	O
threaded	O
applications	O
,	O
it	O
gives	O
the	O
same	O
pseudo	O
-	O
random	O
numbers	O
as	O
the	O
original	O
Random	B-api_mention
class	O
would	O
.	O
This	O
code	O
is	O
based	O
on	O
the	O
current	O
java	B-api_mention
.	I-api_mention
util	I-api_mention
.	I-api_mention
Random	I-api_mention
in	O
OpenJDK	O
7u	O
which	O
is	O
licensed	O
under	O
GNU	O
GPL	O
v2	O
.	O
EDIT	O
10	O
months	O
later	O
:	O
I	O
just	O
discovered	O
that	O
you	O
don	O
'	O
t	O
even	O
have	O
to	O
use	O
my	O
code	O
above	O
to	O
get	O
an	O
unsynchronized	O
Random	B-api_mention
instance	O
.	O
There	O
'	O
s	O
one	O
in	O
the	O
JDK	O
,	O
too	O
!	O
Look	O
at	O
Java	O
7	O
'	O
s	O
ThreadLocalRandom	B-api_mention
class	O
.	O
The	O
code	O
inside	O
it	O
is	O
almost	O
identical	O
to	O
my	O
code	O
above	O
.	O
The	O
class	O
is	O
simply	O
a	O
local	O
-	O
thread	O
-	O
isolated	O
Random	B-api_mention
version	O
suitable	O
for	O
generating	O
random	O
numbers	O
quickly	O
.	O
The	O
only	O
downside	O
I	O
can	O
think	O
of	O
is	O
that	O
you	O
can	O
'	O
t	O
set	O
its	O
seed	O
manually	O
.	O
Example	O
usage	O
:	O
Random	B-api_mention
random	O
=	O
ThreadLocalRandom	B-api_mention
.	I-api_mention
current	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Question	O
-	O
32693704	O
,	O
answer	O
-	O
32752970	O
I	O
will	O
try	O
to	O
summarize	O
three	O
moreless	O
reasonable	O
versions	O
which	O
were	O
proposed	O
in	O
comments	O
.	O
@	O
Holger	O
says	O
:	O
#	O
blockquote	O
This	O
is	O
the	O
most	O
easy	O
thing	O
to	O
test	O
.	O
Let	O
'	O
s	O
compile	O
such	O
program	O
:	O
#	O
pre	O
Run	O
it	O
with	O
java	O
-	O
verbose	O
:	O
class	O
HashMapTest	O
.	O
This	O
will	O
print	O
the	O
class	O
loading	O
events	O
as	O
they	O
occur	O
.	O
With	O
JDK	O
1	O
.	O
8	O
.	O
0	O
_	O
60	O
I	O
see	O
more	O
than	O
400	O
classes	O
loaded	O
:	O
#	O
pre	O
As	O
you	O
can	O
see	O
,	O
HashMap	B-api_mention
is	O
loaded	O
long	O
before	O
application	O
code	O
and	O
Arrays	B-api_mention
is	O
loaded	O
only	O
14	O
classes	O
after	O
HashMap	B-api_mention
.	O
The	O
HashMap	O
load	O
is	O
triggered	O
by	O
sun	O
.	O
reflect	O
.	O
Reflection	O
initialization	O
as	O
it	O
has	O
HashMap	O
static	O
fields	O
.	O
The	O
Arrays	O
load	O
is	O
likely	O
to	O
be	O
triggered	O
by	O
WeakHashMap	O
load	O
which	O
actually	O
has	O
Arrays	B-api_mention
.	I-api_mention
fill	I-api_mention
in	O
the	O
clear	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
.	O
The	O
WeakHashMap	B-api_mention
load	O
is	O
triggered	O
by	O
java	O
.	O
lang	O
.	O
ClassValue	O
$	O
ClassValueMap	O
which	O
extends	O
WeakHashMap	B-api_mention
.	O
The	O
ClassValueMap	O
is	O
present	O
in	O
every	O
java	O
.	O
lang	O
.	O
Class	O
instance	O
.	O
So	O
to	O
me	O
seems	O
that	O
without	O
Arrays	B-api_mention
class	O
the	O
JDK	O
cannot	O
be	O
initialized	O
at	O
all	O
.	O
Also	O
the	O
Arrays	B-api_mention
static	O
initializer	O
is	O
very	O
short	O
,	O
it	O
only	O
initializes	O
the	O
assertion	O
mechanism	O
.	O
This	O
mechanism	O
is	O
used	O
in	O
many	O
other	O
classes	O
(	O
including	O
,	O
for	O
example	O
,	O
java	B-api_mention
.	I-api_mention
lang	I-api_mention
.	I-api_mention
Throwable	I-api_mention
which	O
is	O
loaded	O
very	O
early	O
)	O
.	O
No	O
other	O
static	O
initialization	O
steps	O
are	O
performed	O
in	O
java	B-api_mention
.	I-api_mention
util	I-api_mention
.	I-api_mention
Arrays	I-api_mention
.	O
Thus	O
@	O
Holger	O
version	O
seems	O
incorrect	O
to	O
me	O
.	O
Here	O
we	O
also	O
found	O
very	O
interesting	O
thing	O
.	O
The	O
WeakHashMap	B-api_mention
.	I-api_mention
clear	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
still	O
uses	O
Arrays	O
.	O
fill	O
.	O
It	O
'	O
s	O
interesting	O
when	O
it	O
appeared	O
there	O
,	O
but	O
unfortunately	O
this	O
goes	O
to	O
prehistoric	O
times	O
(	O
it	O
was	O
already	O
there	O
in	O
the	O
very	O
first	O
public	O
OpenJDK	O
repository	O
)	O
.	O
Next	O
,	O
@	O
MarcoTopolnik	O
says	O
:	O
#	O
blockquote	O
It	O
was	O
actually	O
surprising	O
for	O
me	O
that	O
Arrays	B-api_mention
.	I-api_mention
fill	I-api_mention
is	O
not	O
directly	O
intrinsified	O
(	O
see	O
intrinsic	O
list	O
generated	O
by	O
@	O
apangin	O
)	O
.	O
Seems	O
that	O
such	O
loop	O
can	O
be	O
recognized	O
and	O
vectorized	O
by	O
JVM	O
without	O
explicit	O
intrinsic	O
handling	O
.	O
So	O
it	O
'	O
s	O
true	O
that	O
extra	O
call	O
can	O
be	O
not	O
inlined	O
in	O
very	O
specific	O
cases	O
(	O
for	O
example	O
if	O
MaxInlineLevel	O
limit	O
is	O
reached	O
)	O
.	O
On	O
the	O
other	O
hand	O
it	O
'	O
s	O
very	O
rare	O
situation	O
and	O
it	O
'	O
s	O
only	O
a	O
single	O
call	O
,	O
it	O
'	O
s	O
not	O
a	O
call	O
inside	O
loop	O
,	O
and	O
it	O
'	O
s	O
a	O
static	O
,	O
not	O
virtual	O
/	O
interface	O
call	O
,	O
thus	O
the	O
performance	O
improvement	O
could	O
be	O
only	O
marginal	O
and	O
only	O
in	O
some	O
specific	O
scenarios	O
.	O
Not	O
the	O
thing	O
the	O
JVM	O
developers	O
usually	O
care	O
.	O
Also	O
it	O
should	O
be	O
noted	O
that	O
even	O
C1	O
'	O
client	O
'	O
compiler	O
(	O
tier	O
1	O
-	O
3	O
)	O
is	O
capable	O
to	O
inline	O
Arrays	B-api_mention
.	I-api_mention
fill	I-api_mention
called	O
,	O
for	O
example	O
,	O
in	O
WeakHashMap	B-api_mention
.	I-api_mention
clear	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
,	O
as	O
inlining	O
log	O
(	O
-	O
XX	O
:	O
+	O
UnlockDiagnosticVMOptions	O
-	O
XX	O
:	O
+	O
PrintCompilation	O
-	O
XX	O
:	O
+	O
PrintInlining	O
)	O
says	O
:	O
#	O
pre	O
Of	O
course	O
,	O
it	O
'	O
s	O
also	O
easily	O
inlined	O
by	O
smart	O
and	O
powerful	O
C2	O
'	O
server	O
'	O
compiler	O
.	O
Thus	O
I	O
see	O
no	O
problems	O
here	O
.	O
Seems	O
that	O
@	O
Marco	O
version	O
is	O
incorrect	O
either	O
.	O
Finally	O
we	O
have	O
a	O
couple	O
of	O
comments	O
from	O
@	O
StuartMarks	O
(	O
who	O
is	O
JDK	O
developer	O
,	O
thus	O
some	O
official	O
voice	O
)	O
:	O
#	O
blockquote	O
Indeed	O
the	O
HashMap	B-api_mention
.	I-api_mention
clear	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
contained	O
the	O
loop	O
many	O
years	O
,	O
was	O
replaced	O
with	O
Arrays	B-api_mention
.	I-api_mention
fill	I-api_mention
on	O
Apr	O
10th	O
,	O
2013	O
and	O
stayed	O
less	O
one	O
half	O
-	O
a	O
-	O
year	O
until	O
Sept	O
4th	O
when	O
the	O
discussed	O
commit	O
was	O
introduced	O
.	O
The	O
discussed	O
commit	O
was	O
actually	O
a	O
major	O
rewrite	O
of	O
the	O
HashMap	B-api_mention
internals	O
to	O
fix	O
JDK	O
-	O
8023463	O
issue	O
.	O
It	O
was	O
a	O
long	O
story	O
about	O
possibility	O
to	O
poison	O
the	O
HashMap	B-api_mention
with	O
keys	O
having	O
duplicating	O
hashcodes	O
reducing	O
HashMap	B-api_mention
search	O
speed	O
to	O
linear	O
making	O
it	O
vulnerable	O
to	O
DoS	O
-	O
attacks	O
.	O
The	O
attempts	O
to	O
solve	O
this	O
were	O
performed	O
in	O
JDK	O
-	O
7	O
including	O
some	O
randomization	O
of	O
String	B-api_mention
hashCode	O
.	O
So	O
seems	O
that	O
the	O
HashMap	B-api_mention
implementation	O
was	O
forked	O
from	O
the	O
earlier	O
commit	O
,	O
developed	O
independently	O
,	O
then	O
merged	O
into	O
the	O
master	O
branch	O
overwriting	O
several	O
changes	O
introduced	O
in	O
-	O
between	O
.	O
We	O
may	O
support	O
this	O
hypothesis	O
performing	O
a	O
diff	O
.	O
Take	O
the	O
version	O
where	O
Arrays	O
.	O
fill	O
was	O
removed	O
(	O
2013	O
-	O
09	O
-	O
04	O
)	O
and	O
compare	O
it	O
with	O
previous	O
version	O
(	O
2013	O
-	O
07	O
-	O
30	O
)	O
.	O
The	O
diff	O
-	O
U0	O
output	O
has	O
4341	O
lines	O
.	O
Now	O
let	O
'	O
s	O
diff	O
against	O
the	O
version	O
prior	O
to	O
one	O
when	O
Arrays	O
.	O
fill	O
was	O
added	O
(	O
2013	O
-	O
04	O
-	O
01	O
)	O
.	O
Now	O
diff	O
-	O
U0	O
contains	O
only	O
2680	O
lines	O
.	O
Thus	O
the	O
newer	O
version	O
actually	O
more	O
similar	O
to	O
the	O
older	O
than	O
to	O
immediate	O
parent	O
.	O
Conclusion	O
So	O
to	O
conclude	O
I	O
would	O
agree	O
with	O
Stuart	O
Marks	O
.	O
There	O
were	O
no	O
concrete	O
reason	O
to	O
remove	O
Arrays	B-api_mention
.	I-api_mention
fill	I-api_mention
,	O
it	O
'	O
s	O
just	O
because	O
the	O
in	O
-	O
between	O
change	O
was	O
overwritten	O
by	O
mistake	O
.	O
Using	O
Arrays	B-api_mention
.	I-api_mention
fill	I-api_mention
is	O
perfectly	O
fine	O
both	O
in	O
JDK	O
code	O
and	O
in	O
user	O
applications	O
and	O
used	O
,	O
for	O
example	O
,	O
in	O
WeakHashMap	B-api_mention
.	O
The	O
Arrays	B-api_mention
class	O
is	O
loaded	O
anyways	O
pretty	O
early	O
during	O
the	O
JDK	O
initialization	O
,	O
has	O
very	O
simple	O
static	O
initializer	O
and	O
Arrays	O
.	O
fill	O
method	O
can	O
be	O
easily	O
inlined	O
even	O
by	O
client	O
compiler	O
,	O
so	O
no	O
performance	O
drawback	O
should	O
be	O
noted	O
.	O
Question	O
-	O
26318569	O
I	O
am	O
getting	O
following	O
exception	O
while	O
running	O
the	O
tests	O
.	O
I	O
am	O
using	O
Mockito	B-api_mention
for	O
mocking	O
.	O
The	O
hints	O
mentioned	O
by	O
Mockito	B-api_mention
library	O
are	O
not	O
helping	O
.	O
#	O
pre	O
Test	O
Code	O
from	O
DomainTestFactory	O
.	O
When	O
I	O
run	O
the	O
following	O
test	O
,	O
I	O
see	O
the	O
exception	O
#	O
pre	O
Question	O
-	O
20746429	O
,	O
answer	O
-	O
24531394	O
Here	O
is	O
a	O
version	O
done	O
on	O
ints	O
-	O
as	O
asked	O
in	O
the	O
question	O
.	O
Usage	O
:	O
StreamUtil	B-api_mention
.	O
takeWhile	O
(	O
args	O
)	O
;	O
Here	O
'	O
s	O
code	O
for	O
StreamUtil	B-api_mention
:	O
#	O
pre	O
Question	O
-	O
6841333	O
,	O
answer	O
-	O
20906129	O
As	O
explained	O
by	O
others	O
,	O
there	O
'	O
s	O
a	O
time	O
discontinuity	O
there	O
.	O
There	O
are	O
two	O
possible	O
timezone	O
offsets	O
for	O
1927	O
-	O
12	O
-	O
31	O
23	O
:	O
54	O
:	O
08	O
at	O
Asia	O
/	O
Shanghai	O
,	O
but	O
only	O
one	O
offset	O
for	O
1927	O
-	O
12	O
-	O
31	O
23	O
:	O
54	O
:	O
07	O
.	O
So	O
,	O
depending	O
on	O
which	O
offset	O
is	O
used	O
,	O
there	O
'	O
s	O
either	O
a	O
one	O
second	O
difference	O
or	O
a	O
5	O
minutes	O
and	O
53	O
seconds	O
difference	O
.	O
This	O
slight	O
shift	O
of	O
offsets	O
,	O
instead	O
of	O
the	O
usual	O
one	O
-	O
hour	O
daylight	O
savings	O
(	O
summer	O
time	O
)	O
we	O
are	O
used	O
to	O
,	O
obscures	O
the	O
problem	O
a	O
bit	O
.	O
Note	O
that	O
the	O
2013a	O
update	O
of	O
the	O
timezone	O
database	O
moved	O
this	O
discontinuity	O
a	O
few	O
seconds	O
earlier	O
,	O
but	O
the	O
effect	O
would	O
still	O
be	O
observable	O
.	O
The	O
new	O
java	O
.	O
time	O
package	O
on	O
Java	O
8	O
let	O
use	O
see	O
this	O
more	O
clearly	O
,	O
and	O
provide	O
tools	O
to	O
handle	O
it	O
.	O
Given	O
:	O
#	O
pre	O
Then	O
durationAtEarlierOffset	B-api_mention
will	O
be	O
one	O
second	O
,	O
while	O
durationAtLaterOffset	B-api_mention
will	O
be	O
five	O
minutes	O
and	O
53	O
seconds	O
.	O
Also	O
,	O
these	O
two	O
offsets	O
are	O
the	O
same	O
:	O
#	O
pre	O
But	O
these	O
two	O
are	O
different	O
:	O
#	O
pre	O
You	O
can	O
see	O
the	O
same	O
problem	O
comparing	O
1927	O
-	O
12	O
-	O
31	O
23	O
:	O
59	O
:	O
59	O
with	O
1928	O
-	O
01	O
-	O
01	O
00	O
:	O
00	O
:	O
00	O
,	O
though	O
,	O
in	O
this	O
case	O
,	O
it	O
is	O
the	O
earlier	O
offset	O
that	O
produce	O
the	O
longer	O
divergence	O
,	O
and	O
it	O
is	O
the	O
earlier	O
date	O
that	O
has	O
two	O
possible	O
offsets	O
.	O
Another	O
way	O
to	O
approach	O
this	O
is	O
to	O
check	O
whether	O
there	O
'	O
s	O
a	O
transition	O
going	O
on	O
.	O
We	O
can	O
do	O
this	O
like	O
this	O
:	O
#	O
pre	O
You	O
can	O
check	O
whether	O
the	O
transition	O
is	O
an	O
overlap	O
-	O
in	O
which	O
case	O
there	O
'	O
s	O
more	O
than	O
one	O
valid	O
offset	O
for	O
that	O
date	O
/	O
time	O
-	O
or	O
a	O
gap	O
-	O
in	O
which	O
case	O
that	O
date	O
/	O
time	O
is	O
not	O
valid	O
for	O
that	O
zone	O
id	O
-	O
by	O
using	O
the	O
isOverlap	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
and	O
isGap	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
methods	O
on	O
zot4	O
.	O
I	O
hope	O
this	O
helps	O
people	O
handle	O
this	O
sort	O
of	O
issue	O
once	O
Java	O
8	O
becomes	O
widely	O
available	O
,	O
or	O
to	O
those	O
using	O
Java	O
7	O
who	O
adopt	O
the	O
JSR	O
310	O
backport	O
.	O
Question	O
-	O
18666710	O
,	O
answer	O
-	O
18792306	O
An	O
important	O
feature	O
of	O
parametric	O
types	O
is	O
the	O
ability	O
to	O
write	O
polymorphic	O
algorithms	O
,	O
i	O
.	O
e	O
.	O
algorithms	O
that	O
operate	O
on	O
a	O
data	O
structure	O
regardless	O
of	O
its	O
parameter	O
value	O
,	O
such	O
as	O
Arrays	B-api_mention
.	I-api_mention
sort	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
With	O
generics	O
,	O
that	O
'	O
s	O
done	O
with	O
wildcard	O
types	O
:	O
<	O
E	O
extends	O
Comparable	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
>	O
void	O
sort	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
To	O
be	O
truly	O
useful	O
,	O
wildcard	O
types	O
require	O
wildcard	O
capture	O
,	O
and	O
that	O
requires	O
the	O
notion	O
of	O
a	O
type	O
parameter	O
.	O
None	O
of	O
that	O
was	O
available	O
at	O
the	O
time	O
arrays	O
were	O
added	O
to	O
Java	O
,	O
and	O
makings	O
arrays	O
of	O
reference	O
type	O
covariant	O
permitted	O
a	O
far	O
simpler	O
way	O
to	O
permit	O
polymorphic	O
algorithms	O
:	O
void	O
sort	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
However	O
,	O
that	O
simplicity	O
opened	O
a	O
loophole	O
in	O
the	O
static	O
type	O
system	O
:	O
#	O
pre	O
requiring	O
a	O
runtime	O
check	O
of	O
every	O
write	O
access	O
to	O
an	O
array	O
of	O
reference	O
type	O
.	O
In	O
a	O
nutshell	O
,	O
the	O
newer	O
approach	O
embodied	O
by	O
generics	O
makes	O
the	O
type	O
system	O
more	O
complex	O
,	O
but	O
also	O
more	O
statically	O
type	O
safe	O
,	O
while	O
the	O
older	O
approach	O
was	O
simpler	O
,	O
and	O
less	O
statically	O
type	O
safe	O
.	O
The	O
designers	O
of	O
the	O
language	O
opted	O
for	O
the	O
simpler	O
approach	O
,	O
having	O
more	O
important	O
things	O
to	O
do	O
than	O
closing	O
a	O
small	O
loophole	O
in	O
the	O
type	O
system	O
that	O
rarely	O
causes	O
problems	O
.	O
Later	O
,	O
when	O
Java	O
was	O
established	O
,	O
and	O
the	O
pressing	O
needs	O
taken	O
care	O
of	O
,	O
they	O
had	O
the	O
resources	O
to	O
do	O
it	O
right	O
for	O
generics	O
(	O
but	O
changing	O
it	O
for	O
arrays	O
would	O
have	O
broken	O
existing	O
Java	O
programs	O
)	O
.	O
Question	O
-	O
6667243	O
,	O
answer	O
-	O
6667307	O
mode1	O
.	B-api_mention
name	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
or	O
String	B-api_mention
.	I-api_mention
valueOf	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
It	O
doesn	O
'	O
t	O
get	O
better	O
than	O
that	O
,	O
I	O
'	O
m	O
afraid	O
Question	O
-	O
7488643	O
,	O
answer	O
-	O
7488710	O
Arrays	B-api_mention
.	I-api_mention
asList	I-api_mention
returns	O
a	O
fixed	O
-	O
size	O
List	O
backed	O
by	O
the	O
array	O
.	O
If	O
you	O
want	O
a	O
normal	O
mutable	O
java	B-api_mention
.	I-api_mention
util	I-api_mention
.	I-api_mention
ArrayList	I-api_mention
you	O
need	O
to	O
do	O
this	O
:	O
List	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
list	O
=	O
new	O
ArrayList	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Or	O
,	O
using	O
Guava	O
:	O
List	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
list	O
=	O
Lists	B-api_mention
.	I-api_mention
newArrayList	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Using	O
a	O
Splitter	B-api_mention
gives	O
you	O
more	O
flexibility	O
in	O
how	O
you	O
split	O
the	O
string	O
and	O
gives	O
you	O
the	O
ability	O
to	O
,	O
for	O
example	O
,	O
skip	O
empty	O
strings	O
in	O
the	O
results	O
and	O
trim	O
results	O
.	O
It	O
also	O
has	O
less	O
weird	O
behavior	O
than	O
String	B-api_mention
.	I-api_mention
split	I-api_mention
as	O
well	O
as	O
not	O
requiring	O
you	O
to	O
split	O
by	O
regex	O
(	O
that	O
'	O
s	O
just	O
one	O
option	O
)	O
.	O
Question	O
-	O
19431234	O
,	O
answer	O
-	O
23884116	O
the	O
following	O
seems	O
to	O
work	O
when	O
converting	O
from	O
new	O
API	O
LocalDateTime	B-api_mention
into	O
java	O
.	O
util	O
.	O
date	O
:	O
Date	B-api_mention
.	I-api_mention
from	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
the	O
reverse	O
conversion	O
can	O
be	O
(	O
hopefully	O
)	O
achieved	O
similar	O
way	O
.	O
.	O
.	O
hope	O
it	O
helps	O
.	O
.	O
.	O
Question	O
-	O
18448671	O
,	O
answer	O
-	O
18448685	O
If	O
you	O
want	O
to	O
modify	O
your	O
List	B-api_mention
during	O
traversal	O
,	O
then	O
you	O
need	O
to	O
use	O
the	O
Iterator	B-api_mention
.	O
And	O
then	O
you	O
can	O
use	O
iterator	O
.	B-api_mention
remove	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
to	O
remove	O
the	O
elements	O
during	O
traversal	O
.	O
Question	O
-	O
17828584	O
,	O
answer	O
-	O
17832168	O
I	O
think	O
the	O
number	O
displayed	O
is	O
the	O
number	O
of	O
time	O
the	O
System	B-api_mention
.	I-api_mention
out	I-api_mention
.	I-api_mention
println	I-api_mention
call	O
throws	O
the	O
Stackoverflow	O
exception	O
.	O
It	O
probably	O
depend	O
on	O
the	O
implementation	O
of	O
the	O
println	B-api_mention
and	O
the	O
number	O
of	O
stacking	O
call	O
it	O
is	O
made	O
in	O
it	O
.	O
As	O
an	O
illustration	O
:	O
The	O
main	O
(	O
args	O
)	O
call	O
trigger	O
the	O
Stackoverflow	O
exception	O
at	O
call	O
i	O
.	O
The	O
i	O
-	O
1	O
call	O
of	O
main	O
catch	O
the	O
exception	O
and	O
call	O
println	B-api_mention
which	O
trigger	O
a	O
second	O
Stackoverflow	O
.	O
cnt	O
get	O
increment	O
to	O
1	O
.	O
The	O
i	O
-	O
2	O
call	O
of	O
main	O
catch	O
now	O
the	O
exception	O
and	O
call	O
println	B-api_mention
.	O
In	O
println	B-api_mention
a	O
method	O
is	O
called	O
triggering	O
a	O
3rd	O
exception	O
.	O
cnt	O
get	O
increment	O
to	O
2	O
.	O
this	O
continue	O
until	O
println	B-api_mention
can	O
make	O
all	O
its	O
needed	O
call	O
and	O
finally	O
display	O
the	O
value	O
of	O
cnt	O
.	O
This	O
is	O
then	O
dependent	O
of	O
the	O
actual	O
implementation	O
of	O
println	B-api_mention
.	O
For	O
the	O
JDK7	O
either	O
it	O
detect	O
cycling	O
call	O
and	O
throws	O
the	O
exception	O
earlier	O
either	O
it	O
keep	O
some	O
stack	O
resource	O
and	O
throw	O
the	O
exception	O
before	O
reaching	O
the	O
limit	O
to	O
give	O
some	O
room	O
for	O
remediation	O
logic	O
either	O
the	O
println	O
implementation	O
doesn	O
'	O
t	O
make	O
calls	O
either	O
the	O
+	O
+	O
operation	O
is	O
done	O
after	O
the	O
println	B-api_mention
call	O
thus	O
is	O
by	O
pass	O
by	O
the	O
exception	O
.	O
Question	O
-	O
28584669	O
,	O
answer	O
-	O
28584954	O
Because	O
thats	O
the	O
standard	O
.	O
Infinity	O
represents	O
a	O
number	O
greater	O
than	O
or	O
less	O
than	O
Double	B-api_mention
.	I-api_mention
MAX	I-api_mention
_	I-api_mention
VALUE	I-api_mention
/	O
-	O
Double	B-api_mention
.	I-api_mention
MAX	I-api_mention
_	I-api_mention
VALUE	I-api_mention
.	O
NaN	O
represents	O
the	O
outcome	O
of	O
an	O
operation	O
that	O
didn	O
'	O
t	O
make	O
sense	O
.	O
That	O
is	O
,	O
the	O
operation	O
didn	O
'	O
t	O
possibly	O
come	O
out	O
with	O
a	O
number	O
.	O
I	O
would	O
guess	O
the	O
logic	O
is	O
once	O
a	O
number	O
gets	O
big	O
enough	O
(	O
infinity	O
)	O
and	O
because	O
of	O
the	O
limitation	O
of	O
floating	O
point	O
numbers	O
,	O
adding	O
numbers	O
to	O
it	O
won	O
'	O
t	O
change	O
the	O
outcome	O
,	O
so	O
its	O
'	O
like	O
'	O
infinity	O
.	O
So	O
if	O
you	O
want	O
to	O
compare	O
to	O
really	O
big	O
numbers	O
,	O
at	O
some	O
point	O
you	O
might	O
just	O
say	O
those	O
two	O
big	O
numbers	O
are	O
close	O
enough	O
for	O
all	O
intents	O
and	O
purposes	O
.	O
But	O
if	O
you	O
want	O
to	O
compare	O
two	O
things	O
that	O
both	O
aren	O
'	O
t	O
numbers	O
,	O
you	O
can	O
'	O
t	O
compare	O
them	O
so	O
its	O
false	O
.	O
At	O
least	O
you	O
couldn	O
'	O
t	O
compare	O
them	O
as	O
a	O
primitive	O
.	O
Question	O
-	O
19431234	O
,	O
answer	O
-	O
30133063	O
Much	O
more	O
convenient	O
way	O
if	O
you	O
are	O
sure	O
you	O
need	O
a	O
default	O
timezone	O
:	O
Date	B-api_mention
d	O
=	O
java	B-api_mention
.	I-api_mention
sql	I-api_mention
.	I-api_mention
Timestamp	I-api_mention
.	I-api_mention
valueOf	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Question	O
-	O
4772425	O
,	O
answer	O
-	O
4772461	O
Use	O
LocalDateTime	B-api_mention
#	I-api_mention
parse	I-api_mention
(	I-api_mention
)	I-api_mention
(	O
or	O
ZonedDateTime	B-api_mention
#	I-api_mention
parse	I-api_mention
(	I-api_mention
)	I-api_mention
if	O
the	O
string	O
happens	O
to	O
contain	O
a	O
time	O
zone	O
part	O
)	O
to	O
parse	O
a	O
String	B-api_mention
in	O
a	O
certain	O
pattern	O
into	O
a	O
LocalDateTime	B-api_mention
.	O
#	O
pre	O
Use	O
LocalDateTime	B-api_mention
#	I-api_mention
format	I-api_mention
(	I-api_mention
)	I-api_mention
(	O
or	O
ZonedDateTime	B-api_mention
#	I-api_mention
format	I-api_mention
(	I-api_mention
)	I-api_mention
)	O
to	O
format	O
a	O
LocalDateTime	B-api_mention
into	O
a	O
String	B-api_mention
in	O
a	O
certain	O
pattern	O
.	O
#	O
pre	O
Or	O
,	O
when	O
you	O
'	O
re	O
not	O
on	O
Java	O
8	O
yet	O
,	O
use	O
SimpleDateFormat	B-api_mention
#	I-api_mention
parse	I-api_mention
(	I-api_mention
)	I-api_mention
to	O
parse	O
a	O
String	B-api_mention
in	O
a	O
certain	O
pattern	O
into	O
a	O
Date	B-api_mention
.	O
#	O
pre	O
Use	O
SimpleDateFormat	B-api_mention
#	I-api_mention
format	I-api_mention
(	I-api_mention
)	I-api_mention
to	O
format	O
a	O
Date	B-api_mention
into	O
a	O
String	B-api_mention
in	O
a	O
certain	O
pattern	O
.	O
#	O
pre	O
See	O
also	O
:	O
#	O
li	O
Java	O
string	O
to	O
date	O
conversion	O
Update	O
:	O
as	O
per	O
your	O
failed	O
attempt	O
:	O
the	O
patterns	O
are	O
case	O
sensitive	O
.	O
Read	O
the	O
java	B-api_mention
.	I-api_mention
text	I-api_mention
.	I-api_mention
SimpleDateFormat	I-api_mention
javadoc	O
what	O
the	O
individual	O
parts	O
stands	O
for	O
.	O
So	O
stands	O
for	O
example	O
M	O
for	O
months	O
and	O
m	O
for	O
minutes	O
.	O
Also	O
,	O
years	O
exist	O
of	O
four	O
digits	O
yyyy	O
,	O
not	O
five	O
yyyyy	O
.	O
Look	O
closer	O
at	O
the	O
code	O
snippets	O
I	O
posted	O
here	O
above	O
.	O
Question	O
-	O
30384955	O
,	O
answer	O
-	O
30385343	O
This	O
happens	O
because	O
of	O
the	O
way	O
capture	O
conversion	O
works	O
:	O
#	O
blockquote	O
Note	O
the	O
end	O
bit	O
.	O
So	O
,	O
what	O
this	O
means	O
is	O
that	O
,	O
given	O
a	O
type	O
like	O
this	O
:	O
#	O
pre	O
Only	O
"	O
outside	O
"	O
wildcards	O
are	O
captured	O
.	O
The	O
Map	O
key	O
wildcard	O
is	O
captured	O
,	O
but	O
the	O
List	O
element	O
wildcard	O
is	O
not	O
.	O
This	O
is	O
why	O
,	O
for	O
example	O
,	O
we	O
can	O
add	O
to	O
a	O
List	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
,	O
but	O
not	O
a	O
List	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
.	O
The	O
placement	O
of	O
the	O
wildcard	O
is	O
what	O
matters	O
.	O
Carrying	O
this	O
over	O
to	O
TbinList	O
,	O
if	O
we	O
have	O
an	O
ArrayList	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
,	O
the	O
wildcard	O
is	O
in	O
a	O
place	O
where	O
it	O
does	O
not	O
get	O
captured	O
,	O
but	O
if	O
we	O
have	O
a	O
TbinList	O
<	O
T	O
>	O
,	O
the	O
wildcard	O
is	O
in	O
a	O
place	O
where	O
it	O
gets	O
captured	O
.	O
As	O
I	O
alluded	O
to	O
in	O
the	O
comments	O
,	O
one	O
very	O
interesting	O
test	O
is	O
this	O
:	O
ArrayList	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
test3	O
=	O
new	O
TbinList	O
<	O
T	O
>	O
(	O
args	O
)	O
;	O
We	O
get	O
this	O
error	O
:	O
#	O
pre	O
So	O
there	O
'	O
s	O
no	O
way	O
to	O
make	O
it	O
work	O
as	O
-	O
is	O
.	O
One	O
of	O
the	O
class	O
declarations	O
needs	O
to	O
be	O
changed	O
.	O
Additionally	O
,	O
think	O
about	O
it	O
this	O
way	O
.	O
Suppose	O
we	O
had	O
:	O
#	O
pre	O
And	O
since	O
a	O
wildcard	O
allows	O
subtyping	O
,	O
we	O
can	O
do	O
this	O
:	O
TbinList	O
<	O
T	O
>	O
test4	O
=	O
new	O
TbinList	O
<	O
T	O
>	O
(	O
args	O
)	O
;	O
Should	O
we	O
be	O
able	O
to	O
add	O
a	O
Tbin	O
<	O
T	O
>	O
to	O
test4	O
?	O
No	O
,	O
this	O
would	O
be	O
heap	O
pollution	O
.	O
We	O
might	O
end	O
up	O
with	O
Derived2	O
s	O
floating	O
around	O
in	O
a	O
TbinList	O
<	O
T	O
>	O
.	O
Question	O
-	O
28459498	O
,	O
answer	O
-	O
28459604	O
Background	O
While	O
the	O
question	O
appears	O
simple	O
,	O
the	O
actual	O
answer	O
requires	O
some	O
background	O
to	O
make	O
sense	O
.	O
If	O
you	O
want	O
to	O
skip	O
to	O
the	O
conclusion	O
,	O
scroll	O
down	O
.	O
.	O
.	O
Pick	O
your	O
comparison	O
point	O
-	O
Basic	O
functionality	O
Using	O
basic	O
concepts	O
,	O
C	O
#	O
'	O
s	O
IEnumerable	O
concept	O
is	O
more	O
closely	O
related	O
to	O
Java	O
'	O
s	O
Iterable	B-api_mention
,	O
which	O
is	O
able	O
to	O
create	O
as	O
many	O
Iterators	O
as	O
you	O
want	O
.	O
IEnumerables	O
create	O
IEnumerators	O
.	O
Java	O
'	O
s	O
Iterable	B-api_mention
create	O
Iterators	O
The	O
history	O
of	O
each	O
concept	O
is	O
similar	O
,	O
in	O
that	O
both	O
IEnumerable	O
and	O
Iterable	B-api_mention
have	O
a	O
basic	O
motivation	O
to	O
allow	O
'	O
for	O
-	O
each	O
'	O
style	O
looping	O
over	O
the	O
members	O
of	O
data	O
collections	O
.	O
That	O
'	O
s	O
an	O
oversimplification	O
as	O
they	O
both	O
allow	O
more	O
than	O
just	O
that	O
,	O
and	O
they	O
also	O
arrived	O
at	O
that	O
stage	O
via	O
different	O
progressions	O
,	O
but	O
it	O
is	O
a	O
significant	O
common	O
feature	O
regardless	O
.	O
Let	O
'	O
s	O
compare	O
that	O
feature	O
:	O
in	O
both	O
languages	O
,	O
if	O
a	O
class	O
implements	O
the	O
IEnumerable	O
/	O
Iterable	B-api_mention
,	O
then	O
that	O
class	O
must	O
implement	O
at	O
least	O
a	O
single	O
method	O
(	O
for	O
C	O
#	O
,	O
it	O
'	O
s	O
GetEnumerator	O
and	O
for	O
Java	O
it	O
'	O
s	O
iterator	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
)	O
.	O
In	O
each	O
case	O
,	O
the	O
instance	O
returned	O
from	O
that	O
(	O
IEnumerator	O
/	O
Iterator	B-api_mention
)	O
allows	O
you	O
to	O
access	O
the	O
current	O
and	O
subsequent	O
members	O
of	O
the	O
data	O
.	O
This	O
feature	O
is	O
used	O
in	O
the	O
for	O
-	O
each	O
language	O
syntax	O
.	O
Pick	O
your	O
comparison	O
point	O
-	O
Enhanced	O
functionality	O
IEnumerable	O
in	O
C	O
#	O
has	O
been	O
extended	O
to	O
allow	O
a	O
number	O
of	O
other	O
language	O
features	O
(	O
mostly	O
related	O
to	O
Linq	O
)	O
.	O
Features	O
added	O
include	O
selections	O
,	O
projections	O
,	O
aggregations	O
,	O
etc	O
.	O
These	O
extensions	O
have	O
a	O
strong	O
motivation	O
from	O
use	O
in	O
set	O
-	O
theory	O
,	O
similar	O
to	O
SQL	O
and	O
Relational	O
Database	O
concepts	O
.	O
Java	O
8	O
has	O
also	O
had	O
functionality	O
added	O
to	O
enable	O
a	O
degree	O
of	O
functional	O
programming	O
using	O
Streams	O
and	O
Lambdas	O
.	O
Note	O
that	O
Java	O
8	O
streams	O
are	O
not	O
primarily	O
motivated	O
by	O
set	O
theory	O
,	O
but	O
by	O
functional	O
programming	O
.	O
Regardless	O
,	O
there	O
are	O
a	O
lot	O
of	O
parallels	O
.	O
So	O
,	O
this	O
is	O
the	O
second	O
point	O
.	O
The	O
enhancements	O
made	O
to	O
C	O
#	O
were	O
implemented	O
as	O
an	O
enhancement	O
to	O
the	O
IEnumerable	O
concept	O
.	O
In	O
Java	O
,	O
though	O
,	O
the	O
enhancements	O
made	O
were	O
implemented	O
by	O
creating	O
new	O
base	O
concepts	O
of	O
Lambdas	O
and	O
Streams	O
,	O
and	O
then	O
also	O
creating	O
a	O
relatively	O
trivial	O
way	O
to	O
convert	O
from	O
Iterators	O
and	O
Iterables	O
to	O
Streams	O
,	O
and	O
visa	O
-	O
versa	O
.	O
So	O
,	O
comparing	O
IEnumerable	O
to	O
Java	O
'	O
s	O
Stream	B-api_mention
concept	O
is	O
incomplete	O
.	O
You	O
need	O
to	O
compare	O
it	O
to	O
the	O
combined	O
Streams	O
and	O
Collections	O
API	O
'	O
s	O
in	O
Java	O
.	O
In	O
Java	O
,	O
Streams	O
are	O
not	O
the	O
same	O
as	O
Iterables	O
,	O
or	O
Iterators	O
Streams	O
are	O
not	O
designed	O
to	O
solve	O
problems	O
the	O
same	O
way	O
that	O
iterators	O
are	O
:	O
#	O
li	O
Iterators	O
are	O
a	O
way	O
of	O
describing	O
the	O
sequence	O
of	O
data	O
.	O
#	O
li	O
Streams	O
are	O
a	O
way	O
of	O
describing	O
a	O
sequence	O
of	O
data	O
transformations	O
.	O
With	O
an	O
Iterator	O
,	O
you	O
get	O
a	O
data	O
value	O
,	O
process	O
it	O
,	O
and	O
then	O
get	O
another	O
data	O
value	O
.	O
With	O
Streams	O
,	O
you	O
chain	O
a	O
sequence	O
of	O
functions	O
together	O
,	O
then	O
you	O
feed	O
an	O
input	O
value	O
to	O
the	O
stream	O
,	O
and	O
get	O
the	O
output	O
value	O
from	O
the	O
combined	O
sequence	O
.	O
Note	O
,	O
in	O
Java	O
terms	O
,	O
each	O
function	O
is	O
encapsulated	O
in	O
a	O
single	O
Stream	B-api_mention
instance	O
.	O
The	O
Streams	O
API	O
allows	O
you	O
to	O
link	O
a	O
sequence	O
of	O
Stream	O
instances	O
in	O
a	O
way	O
that	O
chains	O
a	O
sequence	O
of	O
transformation	O
expressions	O
.	O
In	O
order	O
to	O
complete	O
the	O
Stream	B-api_mention
concept	O
,	O
you	O
need	O
a	O
source	O
of	O
data	O
to	O
feed	O
the	O
stream	O
,	O
and	O
a	O
terminal	O
function	O
that	O
consumes	O
the	O
stream	O
.	O
The	O
way	O
you	O
feed	O
values	O
in	O
to	O
the	O
stream	O
may	O
in	O
fact	O
be	O
from	O
an	O
Iterable	B-api_mention
,	O
but	O
the	O
Stream	O
sequence	O
itself	O
is	O
not	O
an	O
Iterable	B-api_mention
,	O
it	O
is	O
a	O
compound	O
function	O
.	O
A	O
Stream	B-api_mention
is	O
also	O
intended	O
to	O
be	O
lazy	O
,	O
in	O
the	O
sense	O
that	O
it	O
only	O
does	O
work	O
when	O
you	O
request	O
a	O
value	O
from	O
it	O
.	O
Note	O
these	O
significant	O
assumptions	O
and	O
features	O
of	O
Streams	O
:	O
#	O
li	O
A	O
Stream	B-api_mention
in	O
Java	O
is	O
a	O
transformation	O
engine	O
,	O
it	O
transforms	O
a	O
data	O
item	O
in	O
one	O
state	O
,	O
to	O
being	O
in	O
another	O
state	O
.	O
#	O
li	O
streams	O
have	O
no	O
concept	O
of	O
the	O
data	O
order	O
or	O
position	O
,	O
the	O
simply	O
transform	O
whatever	O
they	O
are	O
asked	O
to	O
.	O
#	O
li	O
streams	O
can	O
be	O
supplied	O
with	O
data	O
from	O
many	O
sources	O
,	O
including	O
other	O
streams	O
,	O
Iterators	O
,	O
Iterables	O
,	O
Collections	B-api_mention
,	O
#	O
li	O
you	O
cannot	O
"	O
reset	O
"	O
a	O
stream	O
,	O
that	O
would	O
be	O
like	O
"	O
reprogramming	O
the	O
transformation	O
"	O
.	O
Resetting	O
the	O
data	O
source	O
is	O
probably	O
what	O
you	O
want	O
.	O
#	O
li	O
there	O
is	O
logically	O
only	O
1	O
data	O
item	O
'	O
in	O
flight	O
'	O
in	O
the	O
stream	O
at	O
any	O
time	O
(	O
unless	O
the	O
stream	O
is	O
a	O
parallel	O
stream	O
,	O
at	O
which	O
point	O
,	O
there	O
is	O
1	O
item	O
per	O
thread	O
)	O
.	O
This	O
is	O
independent	O
of	O
the	O
data	O
source	O
which	O
may	O
have	O
more	O
than	O
the	O
current	O
items	O
'	O
ready	O
'	O
to	O
be	O
supplied	O
to	O
the	O
stream	O
,	O
or	O
the	O
stream	O
collector	O
which	O
may	O
need	O
to	O
aggregate	O
and	O
reduce	O
multiple	O
values	O
.	O
#	O
li	O
Streams	O
can	O
be	O
unbound	O
(	O
infinite	O
)	O
,	O
limited	O
only	O
by	O
the	O
data	O
source	O
,	O
or	O
collector	O
(	O
which	O
can	O
be	O
infinite	O
too	O
)	O
.	O
#	O
li	O
Streams	O
are	O
'	O
chainable	O
'	O
,	O
the	O
output	O
of	O
filtering	O
one	O
stream	O
,	O
is	O
another	O
stream	O
.	O
Values	O
input	O
to	O
and	O
transformed	O
by	O
a	O
stream	O
can	O
in	O
turn	O
be	O
supplied	O
to	O
another	O
stream	O
which	O
does	O
a	O
different	O
transformation	O
.	O
The	O
data	O
,	O
in	O
its	O
transformed	O
state	O
flows	O
from	O
one	O
stream	O
to	O
the	O
next	O
.	O
You	O
do	O
not	O
need	O
to	O
intervene	O
and	O
pull	O
the	O
data	O
from	O
one	O
stream	O
and	O
plug	O
it	O
in	O
to	O
the	O
next	O
.	O
C	O
#	O
Comparison	O
When	O
you	O
consider	O
that	O
a	O
Java	O
Stream	B-api_mention
is	O
just	O
a	O
part	O
of	O
a	O
supply	O
,	O
stream	O
,	O
and	O
collect	O
system	O
,	O
and	O
that	O
Streams	O
and	O
Iterators	O
are	O
often	O
used	O
together	O
with	O
Collections	O
,	O
then	O
it	O
is	O
no	O
wonder	O
that	O
it	O
is	O
hard	O
to	O
relate	O
to	O
the	O
same	O
concepts	O
which	O
are	O
almost	O
all	O
embedded	O
in	O
to	O
a	O
single	O
IEnumerable	O
concept	O
in	O
C	O
#	O
.	O
Parts	O
of	O
IEnumerable	O
(	O
and	O
close	O
related	O
concepts	O
)	O
are	O
apparent	O
in	O
all	O
of	O
the	O
Java	O
Iterator	B-api_mention
,	O
Iterable	B-api_mention
,	O
Lambda	O
,	O
and	O
Stream	B-api_mention
concepts	O
.	O
There	O
are	O
small	O
things	O
that	O
the	O
Java	O
concepts	O
can	O
do	O
that	O
are	O
harder	O
in	O
IEnumerable	O
,	O
and	O
visa	O
-	O
versa	O
.	O
Conclusion	O
#	O
li	O
There	O
'	O
s	O
no	O
design	O
problem	O
here	O
,	O
just	O
a	O
problem	O
in	O
matching	O
concepts	O
between	O
the	O
languages	O
.	O
#	O
li	O
Streams	O
solve	O
problems	O
in	O
a	O
different	O
way	O
#	O
li	O
Streams	O
add	O
functionality	O
to	O
Java	O
(	O
they	O
add	O
a	O
different	O
way	O
of	O
doing	O
things	O
,	O
they	O
do	O
not	O
take	O
functionality	O
away	O
)	O
Adding	O
Streams	O
gives	O
you	O
more	O
choices	O
when	O
solving	O
problems	O
,	O
which	O
is	O
fair	O
to	O
classify	O
as	O
'	O
enhancing	O
power	O
'	O
,	O
not	O
'	O
reducing	O
'	O
,	O
'	O
taking	O
away	O
'	O
,	O
or	O
'	O
restricting	O
'	O
it	O
.	O
Why	O
are	O
Java	O
Streams	O
once	O
-	O
off	O
?	O
This	O
question	O
is	O
misguided	O
,	O
because	O
streams	O
are	O
function	O
sequences	O
,	O
not	O
data	O
.	O
Depending	O
on	O
the	O
data	O
source	O
that	O
feeds	O
the	O
stream	O
,	O
you	O
can	O
reset	O
the	O
data	O
source	O
,	O
and	O
feed	O
the	O
same	O
,	O
or	O
different	O
stream	O
.	O
Unlike	O
C	O
#	O
'	O
s	O
IEnumerable	O
,	O
where	O
an	O
execution	O
pipeline	O
can	O
be	O
executed	O
as	O
many	O
times	O
as	O
we	O
want	O
,	O
in	O
Java	O
a	O
stream	O
can	O
be	O
'	O
iterated	O
'	O
only	O
once	O
.	O
Comparing	O
an	O
IEnumerable	O
to	O
a	O
Stream	B-api_mention
is	O
misguided	O
.	O
The	O
context	O
you	O
are	O
using	O
to	O
say	O
IEnumerable	O
can	O
be	O
executed	O
as	O
many	O
times	O
as	O
you	O
want	O
,	O
is	O
best	O
compared	O
to	O
Java	O
Iterables	O
,	O
which	O
can	O
be	O
iterated	O
as	O
many	O
times	O
as	O
you	O
want	O
.	O
A	O
Java	O
Stream	B-api_mention
represents	O
a	O
subset	O
of	O
the	O
IEnumerable	O
concept	O
,	O
and	O
not	O
the	O
subset	O
that	O
supplies	O
data	O
,	O
and	O
thus	O
cannot	O
be	O
'	O
rerun	O
'	O
.	O
Any	O
call	O
to	O
a	O
terminal	O
operation	O
closes	O
the	O
stream	O
,	O
rendering	O
it	O
unusable	O
.	O
This	O
'	O
feature	O
'	O
takes	O
away	O
a	O
lot	O
of	O
power	O
.	O
The	O
first	O
statement	O
is	O
true	O
,	O
in	O
a	O
sense	O
.	O
The	O
'	O
takes	O
away	O
power	O
'	O
statement	O
is	O
not	O
.	O
You	O
are	O
still	O
comparing	O
Streams	O
it	O
IEnumerables	O
.	O
The	O
terminal	O
operation	O
in	O
the	O
stream	O
is	O
like	O
a	O
'	O
break	O
'	O
clause	O
in	O
a	O
for	O
loop	O
.	O
You	O
are	O
always	O
free	O
to	O
have	O
another	O
stream	O
,	O
if	O
you	O
want	O
,	O
and	O
if	O
you	O
can	O
re	O
-	O
supply	O
the	O
data	O
you	O
need	O
.	O
Again	O
,	O
if	O
you	O
consider	O
the	O
IEnumerable	O
to	O
be	O
more	O
like	O
an	O
Iterable	B-api_mention
,	O
for	O
this	O
statement	O
,	O
Java	O
does	O
it	O
just	O
fine	O
.	O
I	O
imagine	O
the	O
reason	O
for	O
this	O
is	O
not	O
technical	O
.	O
What	O
were	O
the	O
design	O
considerations	O
behind	O
this	O
strange	O
restriction	O
?	O
The	O
reason	O
is	O
technical	O
,	O
and	O
for	O
the	O
simple	O
reason	O
that	O
a	O
Stream	B-api_mention
a	O
subset	O
of	O
what	O
think	O
it	O
is	O
.	O
The	O
stream	O
subset	O
does	O
not	O
control	O
the	O
data	O
supply	O
,	O
so	O
you	O
should	O
reset	O
the	O
supply	O
,	O
not	O
the	O
stream	O
.	O
In	O
that	O
context	O
,	O
it	O
is	O
not	O
so	O
strange	O
.	O
QuickSort	O
example	O
Your	O
quicksort	O
example	O
has	O
the	O
signature	O
:	O
IEnumerable	O
<	O
T	O
>	O
QuickSort	O
(	O
args	O
)	O
You	O
are	O
treating	O
the	O
input	O
IEnumerable	O
as	O
a	O
data	O
source	O
:	O
IEnumerable	O
<	O
T	O
>	O
lt	O
=	O
ints	O
.	O
Where	O
(	O
args	O
)	O
;	O
Additionally	O
,	O
return	O
value	O
is	O
IEnumerable	O
too	O
,	O
which	O
is	O
a	O
supply	O
of	O
data	O
,	O
and	O
since	O
this	O
is	O
a	O
Sort	O
operation	O
,	O
the	O
order	O
of	O
that	O
supply	O
is	O
significant	O
.	O
If	O
you	O
consider	O
the	O
Java	O
Iterable	B-api_mention
class	O
to	O
be	O
the	O
appropriate	O
match	O
for	O
this	O
,	O
specifically	O
the	O
List	B-api_mention
specialization	O
of	O
Iterable	B-api_mention
,	O
since	O
List	B-api_mention
is	O
a	O
supply	O
of	O
data	O
which	O
has	O
a	O
guaranteed	O
order	O
or	O
iteration	O
,	O
then	O
the	O
equivalent	O
Java	O
code	O
to	O
your	O
code	O
would	O
be	O
:	O
#	O
pre	O
Note	O
there	O
is	O
a	O
bug	O
(	O
which	O
I	O
have	O
reproduced	O
)	O
,	O
in	O
that	O
the	O
sort	O
does	O
not	O
handle	O
duplicate	O
values	O
gracefully	O
,	O
it	O
is	O
a	O
'	O
unique	O
value	O
'	O
sort	O
.	O
Also	O
note	O
how	O
the	O
Java	O
code	O
uses	O
data	O
source	O
(	O
List	O
)	O
,	O
and	O
stream	O
concepts	O
at	O
different	O
point	O
,	O
and	O
that	O
in	O
C	O
#	O
those	O
two	O
'	O
personalities	O
'	O
can	O
be	O
expressed	O
in	O
just	O
IEnumerable	O
.	O
Also	O
,	O
although	O
I	O
have	O
use	O
List	B-api_mention
as	O
the	O
base	O
type	O
,	O
I	O
could	O
have	O
used	O
the	O
more	O
general	O
Collection	B-api_mention
,	O
and	O
with	O
a	O
small	O
iterator	O
-	O
to	O
-	O
Stream	O
conversion	O
,	O
I	O
could	O
have	O
used	O
the	O
even	O
more	O
general	O
Iterable	B-api_mention
Question	O
-	O
5694385	O
,	O
answer	O
-	O
5694473	O
Create	O
a	O
File	B-api_mention
object	O
,	O
passing	O
the	O
directory	O
path	O
to	O
the	O
constructor	O
.	O
Use	O
the	O
listFiles	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
to	O
retrieve	O
an	O
array	O
of	O
File	B-api_mention
objects	O
for	O
each	O
file	O
in	O
the	O
directory	O
,	O
and	O
then	O
call	O
the	O
getName	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
to	O
get	O
the	O
filename	O
.	O
#	O
pre	O
Question	O
-	O
23308193	O
,	O
answer	O
-	O
32566745	O
This	O
is	O
possible	O
for	O
forEach	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
The	O
solution	O
is	O
not	O
nice	O
,	O
but	O
it	O
is	O
possible	O
.	O
WARNING	O
:	O
You	O
should	O
not	O
use	O
it	O
for	O
controlling	O
business	O
logic	O
,	O
but	O
purely	O
for	O
handling	O
an	O
exceptional	O
situation	O
which	O
occurs	O
during	O
the	O
execution	O
of	O
the	O
forEach	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
Such	O
as	O
a	O
resource	O
suddenly	O
stops	O
being	O
accessible	O
,	O
one	O
of	O
the	O
processed	O
objects	O
is	O
violating	O
a	O
contract	O
(	O
e	O
.	O
g	O
.	O
contract	O
says	O
that	O
all	O
the	O
elements	O
in	O
the	O
stream	O
must	O
not	O
be	O
null	O
but	O
suddenly	O
and	O
unexpectedly	O
one	O
of	O
them	O
is	O
null	O
)	O
etc	O
.	O
According	O
to	O
the	O
documentation	O
for	O
Iterable	B-api_mention
.	I-api_mention
forEach	I-api_mention
(	I-api_mention
)	I-api_mention
:	O
#	O
blockquote	O
So	O
you	O
throw	O
an	O
exception	O
which	O
will	O
immediately	O
break	O
the	O
internal	O
loop	O
.	O
The	O
code	O
will	O
be	O
something	O
like	O
this	O
-	O
I	O
cannot	O
say	O
I	O
like	O
it	O
but	O
it	O
works	O
.	O
You	O
create	O
your	O
own	O
class	O
BreakException	B-api_mention
which	O
extends	O
RuntimeException	B-api_mention
.	O
#	O
pre	O
Notice	O
that	O
the	O
try	O
.	O
.	O
.	O
catch	O
is	O
not	O
around	O
the	O
lambda	O
expression	O
,	O
but	O
rather	O
around	O
the	O
whole	O
forEach	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
.	O
To	O
make	O
it	O
more	O
visible	O
,	O
see	O
the	O
following	O
transcription	O
of	O
the	O
code	O
which	O
shows	O
it	O
more	O
clearly	O
:	O
#	O
pre	O
Question	O
-	O
4645020	O
It	O
is	O
supposed	O
to	O
be	O
generally	O
preferable	O
to	O
use	O
a	O
StringBuilder	B-api_mention
for	O
string	O
concatenation	O
in	O
Java	O
.	O
Is	O
this	O
always	O
the	O
case	O
?	O
What	O
I	O
mean	O
is	O
this	O
:	O
Is	O
the	O
overhead	O
of	O
creating	O
a	O
StringBuilder	B-api_mention
object	O
,	O
calling	O
the	O
append	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
and	O
finally	O
toString	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
already	O
smaller	O
then	O
concatenating	O
existing	O
strings	O
with	O
the	O
+	O
operator	O
for	O
two	O
strings	O
,	O
or	O
is	O
it	O
only	O
advisable	O
for	O
more	O
(	O
than	O
two	O
)	O
strings	O
?	O
If	O
there	O
is	O
such	O
a	O
threshold	O
,	O
what	O
does	O
it	O
depend	O
on	O
(	O
perhaps	O
the	O
string	O
length	O
,	O
but	O
in	O
which	O
way	O
)	O
?	O
And	O
finally	O
,	O
would	O
you	O
trade	O
the	O
readability	O
and	O
conciseness	O
of	O
the	O
+	O
concatenation	O
for	O
the	O
performance	O
of	O
the	O
StringBuilder	B-api_mention
in	O
smaller	O
cases	O
like	O
two	O
,	O
three	O
or	O
four	O
strings	O
?	O
EDIT	O
Explicit	O
use	O
of	O
StringBuilder	B-api_mention
for	O
regular	O
concatenations	O
is	O
being	O
mentioned	O
as	O
obsolete	O
at	O
obsolete	O
java	O
optimization	O
tips	O
as	O
well	O
as	O
at	O
java	O
urban	O
myths	O
.	O
Question	O
-	O
32693704	O
,	O
answer	O
-	O
32852619	O
Because	O
it	O
'	O
s	O
much	O
faster	O
!	O
I	O
ran	O
some	O
thorough	O
benchmarking	O
tests	O
on	O
cut	O
down	O
versions	O
of	O
the	O
two	O
methods	O
:	O
#	O
pre	O
operating	O
on	O
arrays	O
of	O
various	O
sizes	O
containing	O
random	O
values	O
.	O
Here	O
are	O
the	O
(	O
typical	O
)	O
results	O
:	O
#	O
pre	O
And	O
here	O
are	O
the	O
results	O
when	O
operating	O
over	O
an	O
array	O
filled	O
with	O
nulls	O
(	O
so	O
garbage	O
collection	O
issues	O
are	O
eradicated	O
)	O
:	O
#	O
pre	O
The	O
numbers	O
are	O
in	O
nanoseconds	O
,	O
(	O
sd	O
)	O
is	O
1	O
standard	O
deviation	O
expressed	O
as	O
a	O
percentage	O
of	O
the	O
result	O
(	O
fyi	O
,	O
a	O
"	O
normally	O
distributed	O
"	O
population	O
has	O
an	O
SD	O
of	O
68	O
)	O
,	O
vs	O
is	O
the	O
JDK	O
8	O
timing	O
relative	O
to	O
JDK	O
7	O
.	O
It	O
is	O
interesting	O
that	O
not	O
only	O
is	O
it	O
significantly	O
faster	O
,	O
but	O
the	O
deviation	O
is	O
also	O
slightly	O
narrower	O
,	O
which	O
means	O
that	O
the	O
JDK	O
8	O
implementation	O
gives	O
slightly	O
more	O
consistent	O
performance	O
.	O
The	O
tests	O
were	O
run	O
on	O
jdk	O
1	O
.	O
8	O
.	O
0	O
_	O
45	O
over	O
a	O
large	O
(	O
millions	O
)	O
number	O
of	O
times	O
on	O
arrays	O
populated	O
with	O
random	O
Integer	B-api_mention
objects	O
.	O
To	O
remove	O
out	O
-	O
lying	O
numbers	O
,	O
on	O
each	O
set	O
of	O
results	O
the	O
fastest	O
and	O
slowest	O
3	O
%	O
of	O
timings	O
were	O
discarded	O
.	O
Garbage	O
collection	O
was	O
requested	O
and	O
the	O
thread	O
yielded	O
and	O
slept	O
just	O
prior	O
to	O
running	O
each	O
invocation	O
of	O
the	O
method	O
.	O
JVM	O
warm	O
up	O
was	O
done	O
on	O
the	O
first	O
20	O
%	O
of	O
work	O
and	O
those	O
results	O
were	O
discarded	O
.	O
Question	O
-	O
6684665	O
,	O
answer	O
-	O
12685471	O
The	O
kind	O
of	O
output	O
you	O
are	O
seeing	O
from	O
your	O
byte	O
array	O
(	O
[	O
B	O
@	O
405217f8	O
)	O
is	O
also	O
an	O
output	O
for	O
a	O
zero	O
length	O
byte	O
array	O
(	O
ie	O
new	O
byte	O
[	O
0	O
]	O
)	O
.	O
It	O
looks	O
like	O
this	O
string	O
is	O
a	O
reference	O
to	O
the	O
array	O
rather	O
than	O
a	O
description	O
of	O
the	O
contents	O
of	O
the	O
array	O
like	O
we	O
might	O
expect	O
from	O
a	O
regular	O
collection	O
'	O
s	O
toString	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
.	O
As	O
with	O
other	O
respondents	O
,	O
I	O
would	O
point	O
you	O
to	O
the	O
String	B-api_mention
constructors	O
that	O
accept	O
a	O
byte	O
[	O
]	O
parameter	O
to	O
construct	O
a	O
string	O
from	O
the	O
contents	O
of	O
a	O
byte	O
array	O
.	O
You	O
should	O
be	O
able	O
to	O
read	O
raw	O
bytes	O
from	O
a	O
socket	O
'	O
s	O
InputStream	B-api_mention
if	O
you	O
want	O
to	O
obtain	O
bytes	O
from	O
a	O
TCP	O
connection	O
.	O
If	O
you	O
have	O
already	O
read	O
those	O
bytes	O
as	O
a	O
String	B-api_mention
(	O
using	O
an	O
InputStreamReader	B-api_mention
)	O
,	O
then	O
,	O
the	O
string	O
can	O
be	O
converted	O
to	O
bytes	O
using	O
the	O
getBytes	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
function	O
.	O
Be	O
sure	O
to	O
pass	O
in	O
your	O
desired	O
character	O
set	O
to	O
both	O
the	O
String	B-api_mention
constructor	O
and	O
getBytes	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
functions	O
,	O
and	O
this	O
will	O
only	O
work	O
if	O
the	O
byte	O
data	O
can	O
be	O
converted	O
to	O
characters	O
by	O
the	O
InputStreamReader	B-api_mention
.	O
If	O
you	O
want	O
to	O
deal	O
with	O
raw	O
bytes	O
you	O
should	O
really	O
avoid	O
using	O
this	O
stream	O
reader	O
layer	O
.	O
Question	O
-	O
28276423	O
,	O
answer	O
-	O
28276469	O
It	O
will	O
be	O
fine	O
if	O
you	O
only	O
close	O
the	O
last	O
stream	O
-	O
the	O
close	O
call	O
will	O
be	O
send	O
to	O
the	O
underlying	O
streams	O
,	O
too	O
.	O
Question	O
-	O
5192512	O
,	O
answer	O
-	O
5193094	O
There	O
are	O
basically	O
two	O
alternatives	O
,	O
using	O
setLength	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
to	O
reset	O
the	O
StringBuilder	B-api_mention
or	O
creating	O
a	O
new	O
one	O
in	O
each	O
iteration	O
.	O
Both	O
can	O
have	O
pros	O
and	O
cons	O
depending	O
on	O
the	O
usage	O
.	O
If	O
you	O
know	O
the	O
expected	O
capacity	O
of	O
the	O
StringBuilder	B-api_mention
beforehand	O
,	O
creating	O
a	O
new	O
one	O
each	O
time	O
should	O
be	O
just	O
as	O
fast	O
as	O
setting	O
a	O
new	O
length	O
.	O
It	O
will	O
also	O
help	O
the	O
garbage	O
collector	O
,	O
since	O
each	O
StringBuilder	B-api_mention
will	O
be	O
relatively	O
short	O
-	O
lived	O
and	O
the	O
gc	O
is	O
optimized	O
for	O
that	O
.	O
When	O
you	O
don	O
'	O
t	O
know	O
the	O
capacity	O
,	O
reusing	O
the	O
same	O
StringBuilder	B-api_mention
might	O
be	O
faster	O
.	O
Each	O
time	O
you	O
exceed	O
the	O
capacity	O
when	O
appending	O
,	O
a	O
new	O
backing	O
array	O
has	O
to	O
be	O
allocated	O
and	O
the	O
previous	O
content	O
has	O
to	O
be	O
copied	O
.	O
By	O
reusing	O
the	O
same	O
StringBuilder	B-api_mention
,	O
it	O
will	O
reach	O
the	O
needed	O
capacity	O
after	O
some	O
iterations	O
and	O
there	O
won	O
'	O
t	O
be	O
any	O
copying	O
thereafter	O
.	O
Question	O
-	O
4871051	O
,	O
answer	O
-	O
4871135	O
Current	O
working	O
directory	O
is	O
defined	O
differently	O
in	O
different	O
Java	O
implementations	O
For	O
certain	O
prior	O
to	O
Java	O
7	O
there	O
was	O
no	O
consistent	O
way	O
to	O
get	O
the	O
working	O
directory	O
.	O
You	O
could	O
work	O
around	O
this	O
by	O
launching	O
Java	O
with	O
-	O
D	O
and	O
defining	O
a	O
variable	O
to	O
hold	O
the	O
info	O
Something	O
like	O
java	O
-	O
Dcom	O
.	O
mycompany	O
.	O
workingDir	O
=	O
StringLiteral	O
That	O
'	O
s	O
not	O
quite	O
right	O
,	O
but	O
you	O
get	O
the	O
idea	O
.	O
Then	O
System	B-api_mention
.	I-api_mention
getProperty	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
.	O
.	O
Question	O
-	O
15182496	O
,	O
answer	O
-	O
15182578	O
The	O
other	O
answers	O
explain	O
why	O
,	O
but	O
here	O
is	O
how	O
:	O
new	O
Random	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
nextInt	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
The	O
first	O
6	O
numbers	O
that	O
the	O
above	O
random	O
generates	O
are	O
:	O
#	O
pre	O
and	O
the	O
first	O
6	O
numbers	O
that	O
new	O
Random	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
nextInt	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
generates	O
are	O
:	O
#	O
pre	O
Then	O
just	O
add	O
those	O
numbers	O
to	O
the	O
integer	O
representation	O
of	O
the	O
character	O
`	O
(	O
which	O
is	O
96	O
)	O
:	O
#	O
pre	O
Question	O
-	O
12552863	O
,	O
answer	O
-	O
12619799	O
I	O
would	O
say	O
don	O
'	O
t	O
use	O
ARM	O
and	O
go	O
on	O
with	O
Closeable	B-api_mention
.	O
Use	O
method	O
like	O
,	O
#	O
pre	O
Also	O
you	O
should	O
consider	O
calling	O
close	O
of	O
BufferedWriter	B-api_mention
as	O
it	O
is	O
not	O
just	O
delegating	O
the	O
close	O
to	O
FileWriter	B-api_mention
,	O
but	O
it	O
does	O
some	O
cleanup	O
like	O
flushBuffer	B-api_mention
.	O
Question	O
-	O
12552863	O
The	O
Java	O
7	O
try	O
-	O
with	O
-	O
resources	O
syntax	O
(	O
also	O
known	O
as	O
ARM	O
block	O
(	O
Automatic	O
Resource	O
Management	O
)	O
)	O
is	O
nice	O
,	O
short	O
and	O
straightforward	O
when	O
using	O
only	O
one	O
AutoCloseable	B-api_mention
resource	O
.	O
However	O
,	O
I	O
am	O
not	O
sure	O
what	O
is	O
the	O
correct	O
idiom	O
when	O
I	O
need	O
to	O
declare	O
multiple	O
resources	O
that	O
are	O
dependent	O
on	O
each	O
other	O
,	O
for	O
example	O
a	O
FileWriter	B-api_mention
and	O
a	O
BufferedWriter	B-api_mention
that	O
wraps	O
it	O
.	O
Of	O
course	O
,	O
this	O
question	O
concerns	O
any	O
case	O
when	O
some	O
AutoCloseable	B-api_mention
resources	O
are	O
wrapped	O
,	O
not	O
only	O
these	O
two	O
specific	O
classes	O
.	O
I	O
came	O
up	O
with	O
the	O
three	O
following	O
alternatives	O
:	O
1	O
)	O
The	O
naive	O
idiom	O
I	O
have	O
seen	O
is	O
to	O
declare	O
only	O
the	O
top	O
-	O
level	O
wrapper	O
in	O
the	O
ARM	O
-	O
managed	O
variable	O
:	O
#	O
pre	O
This	O
is	O
nice	O
and	O
short	O
,	O
but	O
it	O
is	O
broken	O
.	O
Because	O
the	O
underlying	O
FileWriter	B-api_mention
is	O
not	O
declared	O
in	O
a	O
variable	O
,	O
it	O
will	O
never	O
be	O
closed	O
directly	O
in	O
the	O
generated	O
finally	O
block	O
.	O
It	O
will	O
be	O
closed	O
only	O
through	O
the	O
close	O
method	O
of	O
the	O
wrapping	O
BufferedWriter	B-api_mention
.	O
The	O
problem	O
is	O
,	O
that	O
if	O
an	O
exception	O
is	O
thrown	O
from	O
the	O
bw	O
'	O
s	O
constructor	O
,	O
it	O
'	O
s	O
close	B-api_mention
will	O
not	O
be	O
called	O
and	O
therefore	O
the	O
underlying	O
FileWriter	B-api_mention
will	O
not	O
be	O
closed	O
.	O
2	O
)	O
#	O
pre	O
Here	O
,	O
both	O
the	O
underlying	O
and	O
the	O
wrapping	O
resource	O
are	O
declared	O
in	O
the	O
ARM	O
-	O
managed	O
variables	O
,	O
so	O
both	O
of	O
them	O
will	O
be	O
certainly	O
closed	O
,	O
so	O
certainly	O
that	O
the	O
underlying	O
fw	O
.	B-api_mention
close	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
will	O
be	O
called	O
twice	O
,	O
first	O
directly	O
and	O
for	O
the	O
second	O
time	O
through	O
the	O
wrapping	O
bw	O
.	B-api_mention
close	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
This	O
should	O
not	O
be	O
a	O
problem	O
for	O
these	O
two	O
specific	O
classes	O
that	O
both	O
implement	O
Closeable	B-api_mention
(	O
which	O
is	O
a	O
subtype	O
of	O
AutoCloseable	B-api_mention
)	O
,	O
whose	O
contract	O
states	O
that	O
multiple	O
calls	O
to	O
close	O
are	O
permitted	O
:	O
#	O
blockquote	O
However	O
,	O
in	O
a	O
general	O
case	O
,	O
I	O
can	O
have	O
resources	O
that	O
do	O
implement	O
only	O
AutoCloseable	B-api_mention
(	O
and	O
not	O
Closeable	B-api_mention
)	O
,	O
which	O
doesn	O
'	O
t	O
guarantee	O
that	O
the	O
close	B-api_mention
can	O
be	O
called	O
multiple	O
times	O
:	O
#	O
blockquote	O
3	O
)	O
#	O
pre	O
This	O
version	O
should	O
be	O
theoretically	O
correct	O
,	O
because	O
only	O
the	O
fw	O
represents	O
a	O
real	O
resource	O
that	O
needs	O
to	O
be	O
cleaned	O
up	O
.	O
The	O
bw	O
does	O
'	O
t	O
itself	O
hold	O
any	O
resource	O
,	O
it	O
only	O
delegates	O
to	O
the	O
fw	O
,	O
so	O
it	O
should	O
be	O
sufficient	O
to	O
only	O
close	O
the	O
underlying	O
fw	O
.	O
On	O
the	O
other	O
hand	O
,	O
the	O
syntax	O
is	O
a	O
bit	O
irregular	O
and	O
also	O
,	O
Eclipse	O
issues	O
a	O
warning	O
,	O
which	O
I	O
believe	O
is	O
a	O
false	O
alarm	O
,	O
but	O
it	O
is	O
still	O
a	O
warning	O
that	O
one	O
has	O
to	O
deal	O
with	O
:	O
#	O
blockquote	O
So	O
,	O
which	O
approach	O
to	O
go	O
for	O
?	O
Or	O
have	O
I	O
missed	O
some	O
other	O
idiom	O
that	O
is	O
the	O
correct	O
one	O
?	O
Question	O
-	O
32356762	O
,	O
answer	O
-	O
32357149	O
Disclaimer	O
:	O
I	O
am	O
not	O
a	O
JDK	O
author	O
.	O
I	O
agree	O
that	O
it	O
'	O
s	O
correct	O
to	O
write	O
your	O
own	O
code	O
to	O
interfaces	O
,	O
but	O
if	O
you	O
'	O
re	O
going	O
return	O
a	O
mutable	O
collection	O
to	O
a	O
third	O
party	O
,	O
it	O
'	O
s	O
important	O
to	O
let	O
the	O
third	O
party	O
know	O
what	O
sort	O
of	O
List	B-api_mention
they	O
'	O
re	O
getting	O
back	O
.	O
LinkedList	B-api_mention
and	O
ArrayList	B-api_mention
are	O
very	O
different	O
,	O
performance	O
wise	O
,	O
for	O
various	O
operations	O
.	O
For	O
example	O
,	O
removing	O
the	O
first	O
element	O
of	O
an	O
ArrayList	B-api_mention
is	O
O	O
(	O
args	O
)	O
,	O
but	O
removing	O
the	O
first	O
element	O
of	O
a	O
LinkedList	B-api_mention
is	O
O	O
(	O
args	O
)	O
.	O
By	O
fully	O
specifying	O
the	O
return	O
type	O
,	O
the	O
JDK	O
authors	O
are	O
communicating	O
extra	O
information	O
,	O
in	O
unambiguous	O
code	O
,	O
about	O
what	O
sort	O
of	O
object	O
they	O
'	O
re	O
giving	O
back	O
to	O
you	O
,	O
so	O
you	O
can	O
write	O
your	O
code	O
to	O
use	O
this	O
method	O
properly	O
.	O
If	O
you	O
really	O
need	O
a	O
LinkedList	B-api_mention
,	O
you	O
know	O
that	O
you	O
have	O
to	O
specify	O
one	O
here	O
.	O
Finally	O
,	O
the	O
main	O
reason	O
to	O
code	O
to	O
an	O
interface	O
over	O
an	O
implementation	O
is	O
if	O
you	O
think	O
that	O
the	O
implementation	O
will	O
change	O
.	O
The	O
JDK	O
authors	O
probably	O
figure	O
they	O
are	O
never	O
going	O
to	O
change	O
this	O
method	O
;	O
it	O
'	O
s	O
never	O
going	O
to	O
return	O
a	O
LinkedList	B-api_mention
or	O
a	O
Collections	B-api_mention
.	I-api_mention
UnmodifiableList	I-api_mention
.	O
However	O
,	O
in	O
most	O
cases	O
,	O
you	O
would	O
probably	O
still	O
do	O
:	O
List	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
list	O
=	O
Collections	B-api_mention
.	I-api_mention
list	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Question	O
-	O
14534767	O
,	O
answer	O
-	O
14534798	O
It	O
should	O
be	O
r	O
.	B-api_mention
append	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
But	O
I	O
recommend	O
you	O
to	O
do	O
as	O
below	O
,	O
r	O
.	B-api_mention
append	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
System	B-api_mention
.	I-api_mention
getProperty	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
gives	O
you	O
system	O
-	O
dependent	O
newline	O
in	O
java	O
.	O
Also	O
from	O
Java	O
7	O
there	O
'	O
s	O
a	O
method	O
that	O
returns	O
the	O
value	O
directly	O
:	O
System	B-api_mention
.	I-api_mention
lineSeparator	I-api_mention
(	I-api_mention
)	I-api_mention
Question	O
-	O
32334319	O
I	O
am	O
using	O
JDK	O
-	O
8	O
(	O
x64	O
)	O
.	O
For	O
Arrays	B-api_mention
.	I-api_mention
sort	I-api_mention
I	O
found	O
the	O
following	O
in	O
the	O
Java	O
documentation	O
:	O
#	O
blockquote	O
For	O
Collections	B-api_mention
.	I-api_mention
sort	I-api_mention
I	O
found	O
this	O
:	O
#	O
blockquote	O
If	O
Collections	B-api_mention
.	I-api_mention
sort	I-api_mention
uses	O
an	O
array	O
,	O
why	O
doesn	O
'	O
t	O
it	O
just	O
call	O
Arrays	B-api_mention
.	I-api_mention
sort	I-api_mention
or	O
use	O
dual	O
-	O
pivot	O
QuickSort	O
?	O
Why	O
use	O
Mergesort	O
?	O
Question	O
-	O
11359187	O
For	O
the	O
first	O
time	O
in	O
my	O
life	O
I	O
find	O
myself	O
in	O
a	O
position	O
where	O
I	O
'	O
m	O
writing	O
a	O
Java	O
API	O
that	O
will	O
be	O
open	O
sourced	O
.	O
Hopefully	O
to	O
be	O
included	O
in	O
many	O
other	O
projects	O
.	O
For	O
logging	O
I	O
(	O
and	O
indeed	O
the	O
people	O
I	O
work	O
with	O
)	O
have	O
always	O
used	O
JUL	B-api_mention
(	O
java	B-api_mention
.	I-api_mention
util	I-api_mention
.	I-api_mention
logging	I-api_mention
)	O
and	O
never	O
had	O
any	O
issues	O
with	O
it	O
.	O
However	O
now	O
I	O
need	O
to	O
understand	O
in	O
more	O
detail	O
what	O
I	O
should	O
do	O
for	O
my	O
API	O
development	O
.	O
I	O
'	O
ve	O
done	O
some	O
research	O
on	O
this	O
and	O
with	O
the	O
information	O
I	O
'	O
ve	O
got	O
I	O
just	O
get	O
more	O
confused	O
.	O
Hence	O
this	O
post	O
.	O
Since	O
I	O
come	O
from	O
JUL	B-api_mention
I	O
'	O
m	O
biased	O
on	O
that	O
.	O
My	O
knowledge	O
of	O
the	O
rest	O
is	O
not	O
that	O
big	O
.	O
From	O
the	O
research	O
I	O
'	O
ve	O
done	O
I	O
'	O
ve	O
come	O
up	O
with	O
these	O
reasons	O
why	O
people	O
do	O
not	O
like	O
JUL	B-api_mention
:	O
#	O
li	O
"	O
I	O
started	O
developing	O
in	O
Java	O
long	O
before	O
Sun	O
released	O
JUL	O
and	O
it	O
was	O
just	O
easier	O
for	O
me	O
to	O
continue	O
with	O
logging	O
-	O
framework	O
-	O
X	O
rather	O
than	O
to	O
learn	O
something	O
new	O
"	O
.	O
Hmm	O
.	O
I	O
'	O
m	O
not	O
kidding	O
,	O
this	O
is	O
actually	O
what	O
people	O
say	O
.	O
With	O
this	O
argument	O
we	O
could	O
all	O
be	O
doing	O
COBOL	O
.	O
(	O
however	O
I	O
can	O
certainly	O
relate	O
to	O
this	O
being	O
a	O
lazy	O
dude	O
myself	O
)	O
#	O
li	O
"	O
I	O
don	O
'	O
t	O
like	O
the	O
names	O
of	O
the	O
logging	O
levels	O
in	O
JUL	O
"	O
.	O
Ok	O
,	O
seriously	O
,	O
this	O
is	O
just	O
not	O
enough	O
of	O
a	O
reason	O
to	O
introduce	O
a	O
new	O
dependency	O
.	O
#	O
li	O
"	O
I	O
don	O
'	O
t	O
like	O
the	O
standard	O
format	O
of	O
the	O
output	O
from	O
JUL	B-api_mention
"	O
.	O
Hmm	O
.	O
This	O
is	O
just	O
configuration	O
.	O
You	O
do	O
not	O
even	O
have	O
to	O
do	O
anything	O
code	O
-	O
wise	O
.	O
(	O
true	O
,	O
back	O
in	O
old	O
days	O
you	O
may	O
have	O
had	O
to	O
create	O
your	O
own	O
Formatter	O
class	O
to	O
get	O
it	O
right	O
)	O
.	O
#	O
li	O
"	O
I	O
use	O
other	O
libraries	O
that	O
also	O
use	O
logging	O
-	O
framework	O
-	O
X	O
so	O
I	O
thought	O
it	O
easier	O
just	O
to	O
use	O
that	O
one	O
"	O
.	O
This	O
is	O
a	O
cyclic	O
argument	O
,	O
isn	O
'	O
t	O
?	O
Why	O
does	O
'	O
everybody	O
'	O
use	O
logging	O
-	O
framework	O
-	O
X	O
and	O
not	O
JUL	B-api_mention
?	O
#	O
li	O
"	O
Everybody	O
else	O
is	O
using	O
logging	O
-	O
framework	O
-	O
X	O
"	O
.	O
This	O
to	O
me	O
is	O
just	O
a	O
special	O
case	O
of	O
the	O
above	O
.	O
Majority	O
is	O
not	O
always	O
right	O
.	O
So	O
the	O
real	O
big	O
question	O
is	O
why	O
not	O
JUL	B-api_mention
?	O
.	O
What	O
is	O
it	O
I	O
have	O
missed	O
?	O
The	O
raison	O
d	O
'	O
ê	O
tre	O
for	O
logging	O
facades	O
(	O
SLF4J	B-api_mention
,	O
JCL	B-api_mention
)	O
is	O
that	O
multiple	O
logging	O
implementations	O
have	O
existed	O
historically	O
and	O
the	O
reason	O
for	O
that	O
really	O
goes	O
back	O
to	O
the	O
era	O
before	O
JUL	B-api_mention
as	O
I	O
see	O
it	O
.	O
If	O
JUL	B-api_mention
was	O
perfect	O
then	O
logging	O
facades	O
wouldn	O
'	O
t	O
exist	O
,	O
or	O
what	O
?	O
Rather	O
than	O
embracing	O
them	O
shouldn	O
'	O
t	O
we	O
question	O
why	O
they	O
were	O
necessary	O
in	O
the	O
first	O
place	O
?	O
(	O
and	O
see	O
if	O
those	O
reasons	O
still	O
exist	O
)	O
Ok	O
,	O
my	O
research	O
so	O
far	O
has	O
led	O
to	O
a	O
couple	O
of	O
things	O
that	O
I	O
can	O
see	O
may	O
be	O
real	O
issues	O
with	O
JUL	B-api_mention
:	O
#	O
li	O
Performance	O
.	O
Some	O
say	O
that	O
performance	O
in	O
SLF4J	B-api_mention
is	O
superior	O
to	O
the	O
rest	O
.	O
This	O
seems	O
to	O
me	O
to	O
be	O
a	O
case	O
of	O
premature	O
optimization	O
.	O
If	O
you	O
need	O
to	O
log	O
hundreds	O
of	O
megabytes	O
per	O
second	O
then	O
I	O
'	O
m	O
not	O
sure	O
you	O
are	O
on	O
the	O
right	O
path	O
anyway	O
.	O
JUL	B-api_mention
has	O
also	O
evolved	O
and	O
the	O
tests	O
you	O
did	O
on	O
Java	O
1	O
.	O
4	O
may	O
no	O
longer	O
be	O
true	O
.	O
You	O
can	O
read	O
about	O
it	O
here	O
and	O
this	O
fix	O
has	O
made	O
it	O
into	O
Java	O
7	O
.	O
Many	O
also	O
talk	O
about	O
the	O
overhead	O
of	O
string	O
concatenation	O
in	O
logging	O
methods	O
.	O
However	O
template	O
based	O
logging	O
avoids	O
this	O
cost	O
and	O
it	O
exist	O
also	O
in	O
JUL	B-api_mention
.	O
Personally	O
I	O
never	O
really	O
write	O
template	O
based	O
logging	O
.	O
Too	O
lazy	O
for	O
that	O
.	O
For	O
example	O
if	O
I	O
do	O
this	O
with	O
JUL	B-api_mention
:	O
log	B-api_mention
.	I-api_mention
finest	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
)	O
;	O
my	O
IDE	O
will	O
warn	O
me	O
and	O
ask	O
permission	O
that	O
it	O
should	O
change	O
it	O
to	O
:	O
log	B-api_mention
.	I-api_mention
log	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
.	O
.	O
which	O
I	O
will	O
of	O
course	O
accept	O
.	O
Permission	O
granted	O
!	O
Thank	O
you	O
for	O
your	O
help	O
.	O
So	O
I	O
don	O
'	O
t	O
actually	O
write	O
such	O
statements	O
myself	O
,	O
that	O
is	O
done	O
by	O
the	O
IDE	O
.	O
In	O
conclusion	O
on	O
the	O
issue	O
of	O
performance	O
I	O
haven	O
'	O
t	O
found	O
anything	O
that	O
would	O
suggest	O
that	O
JUL	B-api_mention
'	O
s	O
performance	O
is	O
not	O
ok	O
compared	O
to	O
the	O
competition	O
.	O
#	O
li	O
Configuration	O
from	O
classpath	O
.	O
Out	O
-	O
of	O
-	O
the	O
-	O
box	O
JUL	B-api_mention
cannot	O
load	O
a	O
configuration	O
file	O
from	O
the	O
classpath	O
.	O
It	O
is	O
a	O
few	O
lines	O
of	O
code	O
to	O
make	O
it	O
do	O
so	O
.	O
I	O
can	O
see	O
why	O
this	O
may	O
be	O
annoying	O
but	O
the	O
solution	O
is	O
short	O
and	O
simple	O
.	O
#	O
li	O
Availability	O
of	O
output	O
handlers	O
.	O
JUL	B-api_mention
comes	O
with	O
5	O
output	O
handlers	O
out	O
-	O
of	O
-	O
the	O
-	O
box	O
:	O
console	O
,	O
file	O
stream	O
,	O
socket	O
and	O
memory	O
.	O
These	O
can	O
be	O
extended	O
or	O
new	O
ones	O
can	O
be	O
written	O
.	O
This	O
may	O
for	O
example	O
be	O
writing	O
to	O
UNIX	O
/	O
Linux	O
Syslog	O
and	O
Windows	O
Event	O
Log	O
.	O
I	O
have	O
personally	O
never	O
had	O
this	O
requirement	O
nor	O
have	O
I	O
seen	O
it	O
used	O
but	O
I	O
can	O
certainly	O
relate	O
to	O
why	O
it	O
may	O
be	O
a	O
useful	O
feature	O
.	O
Logback	B-api_mention
comes	O
with	O
an	O
appender	O
for	O
Syslog	O
for	O
example	O
.	O
Still	O
I	O
would	O
argue	O
that	O
#	O
li	O
99	O
.	O
5	O
%	O
of	O
the	O
needs	O
for	O
output	O
destinations	O
are	O
covered	O
by	O
what	O
is	O
in	O
JUL	B-api_mention
out	O
-	O
of	O
-	O
the	O
-	O
box	O
.	O
#	O
li	O
Special	O
needs	O
could	O
be	O
catered	O
for	O
by	O
custom	O
handlers	O
on	O
top	O
of	O
JUL	B-api_mention
rather	O
than	O
on	O
top	O
of	O
something	O
else	O
.	O
There	O
'	O
s	O
nothing	O
to	O
me	O
that	O
suggests	O
that	O
it	O
takes	O
more	O
time	O
to	O
write	O
a	O
Syslog	O
output	O
handler	O
for	O
JUL	B-api_mention
than	O
it	O
does	O
for	O
another	O
logging	O
framework	O
.	O
I	O
'	O
m	O
really	O
concerned	O
that	O
there	O
'	O
s	O
something	O
I	O
'	O
ve	O
overlooked	O
.	O
The	O
use	O
of	O
logging	O
facades	O
and	O
logging	O
implementations	O
other	O
than	O
JUL	B-api_mention
is	O
so	O
widespread	O
that	O
I	O
have	O
to	O
come	O
to	O
the	O
conclusion	O
that	O
it	O
'	O
s	O
me	O
who	O
just	O
doesn	O
'	O
t	O
understand	O
.	O
That	O
wouldn	O
'	O
t	O
be	O
the	O
first	O
time	O
,	O
I	O
'	O
m	O
afraid	O
.	O
:	O
-	O
)	O
So	O
what	O
should	O
I	O
do	O
with	O
my	O
API	O
?	O
I	O
want	O
it	O
to	O
become	O
successful	O
.	O
I	O
can	O
of	O
course	O
just	O
"	O
go	O
with	O
the	O
flow	O
"	O
and	O
implement	O
SLF4J	B-api_mention
(	O
which	O
seems	O
the	O
most	O
popular	O
these	O
days	O
)	O
but	O
for	O
my	O
own	O
sake	O
I	O
still	O
need	O
to	O
understand	O
exactly	O
what	O
is	O
wrong	O
with	O
the	O
JUL	B-api_mention
of	O
today	O
that	O
warrants	O
all	O
the	O
fuzz	O
?	O
Will	O
I	O
sabotage	O
myself	O
by	O
choosing	O
JUL	B-api_mention
for	O
my	O
library	O
?	O
Testing	O
performance	O
(	O
section	O
added	O
by	O
nolan600	O
on	O
07	O
-	O
JUL	O
-	O
2012	O
)	O
There	O
'	O
s	O
a	O
reference	O
below	O
from	O
Ceki	O
about	O
SLF4J	B-api_mention
'	O
s	O
parametrization	O
being	O
10	O
times	O
or	O
more	O
faster	O
than	O
JUL	B-api_mention
'	O
s	O
.	O
So	O
I	O
'	O
ve	O
started	O
doing	O
some	O
simple	O
tests	O
.	O
At	O
first	O
glance	O
the	O
claim	O
is	O
certainly	O
correct	O
.	O
Here	O
are	O
the	O
preliminary	O
results	O
(	O
but	O
read	O
on	O
!	O
)	O
:	O
#	O
li	O
Execution	O
time	O
SLF4J	B-api_mention
,	O
backend	O
Logback	O
:	O
1515	O
#	O
li	O
Execution	O
time	O
SLF4J	B-api_mention
,	O
backend	O
JUL	B-api_mention
:	O
12938	O
#	O
li	O
Execution	O
time	O
JUL	B-api_mention
:	O
16911	O
The	O
numbers	O
above	O
are	O
msecs	O
so	O
less	O
is	O
better	O
.	O
So	O
10	O
times	O
performance	O
difference	O
is	O
by	O
first	O
actually	O
pretty	O
close	O
.	O
My	O
initial	O
reaction	O
:	O
That	O
is	O
a	O
lot	O
!	O
Here	O
is	O
the	O
core	O
of	O
the	O
test	O
.	O
As	O
can	O
be	O
seen	O
an	O
integer	O
and	O
a	O
string	O
is	O
construted	O
in	O
a	O
loop	O
which	O
is	O
then	O
used	O
in	O
the	O
log	O
statement	O
:	O
#	O
pre	O
(	O
I	O
wanted	O
the	O
log	O
statement	O
to	O
have	O
both	O
a	O
primitive	O
data	O
type	O
(	O
in	O
this	O
case	O
an	O
int	O
)	O
and	O
a	O
more	O
complex	O
data	O
type	O
(	O
in	O
this	O
case	O
a	O
String	B-api_mention
)	O
.	O
Not	O
sure	O
it	O
matters	O
but	O
there	O
you	O
have	O
it	O
.	O
)	O
The	O
log	O
statement	O
for	O
SLF4J	B-api_mention
:	O
logger	B-api_mention
.	I-api_mention
info	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
The	O
log	O
statement	O
for	O
JUL	B-api_mention
:	O
logger	B-api_mention
.	I-api_mention
log	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
The	O
JVM	O
was	O
'	O
warmed	O
up	O
'	O
with	O
the	O
same	O
test	O
executed	O
once	O
before	O
the	O
actual	O
measurement	O
was	O
done	O
.	O
Java	O
1	O
.	O
7	O
.	O
03	O
was	O
used	O
on	O
Windows	O
7	O
.	O
Latest	O
versions	O
of	O
SLF4J	B-api_mention
(	O
v1	O
.	O
6	O
.	O
6	O
)	O
and	O
Logback	B-api_mention
(	O
v1	O
.	O
0	O
.	O
6	O
)	O
was	O
used	O
.	O
Stdout	O
and	O
stderr	O
was	O
redirected	O
to	O
null	O
device	O
.	O
However	O
,	O
careful	O
now	O
,	O
it	O
turns	O
out	O
JUL	O
is	O
spending	O
most	O
of	O
its	O
time	O
in	O
getSourceClassName	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
because	O
JUL	B-api_mention
by	O
default	O
prints	O
the	O
source	O
class	O
name	O
in	O
the	O
output	O
,	O
while	O
Logback	B-api_mention
doesn	O
'	O
t	O
.	O
So	O
we	O
are	O
comparing	O
apples	O
and	O
oranges	O
.	O
I	O
have	O
to	O
do	O
the	O
test	O
again	O
and	O
configure	O
the	O
logging	O
implementations	O
in	O
a	O
similar	O
manner	O
so	O
that	O
they	O
actually	O
output	O
the	O
same	O
stuff	O
.	O
I	O
do	O
however	O
suspect	O
that	O
SLF4J	B-api_mention
+	O
Logback	B-api_mention
will	O
still	O
come	O
out	O
on	O
top	O
but	O
far	O
from	O
the	O
initial	O
numbers	O
as	O
given	O
above	O
.	O
Stay	O
tuned	O
.	O
Btw	O
:	O
The	O
test	O
was	O
first	O
time	O
I	O
'	O
ve	O
actually	O
worked	O
with	O
SLF4J	B-api_mention
or	O
Logback	B-api_mention
.	O
A	O
pleasant	O
experience	O
.	O
JUL	B-api_mention
is	O
certainly	O
a	O
lot	O
less	O
welcoming	O
when	O
you	O
are	O
starting	O
out	O
.	O
Testing	O
performance	O
(	O
part	O
2	O
)	O
(	O
section	O
added	O
by	O
nolan600	O
on	O
08	O
-	O
JUL	O
-	O
2012	O
)	O
As	O
it	O
turns	O
out	O
it	O
doesn	O
'	O
t	O
really	O
matter	O
for	O
performance	O
how	O
you	O
configure	O
your	O
pattern	O
in	O
JUL	B-api_mention
,	O
i	O
.	O
e	O
.	O
whether	O
or	O
not	O
it	O
includes	O
the	O
source	O
name	O
or	O
not	O
.	O
I	O
tried	O
with	O
a	O
very	O
simple	O
pattern	O
:	O
java	B-api_mention
.	I-api_mention
util	I-api_mention
.	I-api_mention
logging	I-api_mention
.	I-api_mention
SimpleFormatter	I-api_mention
.	I-api_mention
format	I-api_mention
=	O
StringLiteral	O
and	O
that	O
did	O
not	O
change	O
the	O
above	O
timings	O
at	O
all	O
.	O
My	O
profiler	O
revealed	O
that	O
the	O
logger	O
still	O
spent	O
a	O
lot	O
of	O
time	O
in	O
calls	O
to	O
getSourceClassName	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
even	O
if	O
this	O
was	O
not	O
part	O
of	O
my	O
pattern	O
.	O
The	O
pattern	O
doesn	O
'	O
t	O
matter	O
.	O
I	O
'	O
m	O
therefore	O
concluding	O
on	O
the	O
issue	O
of	O
performance	O
that	O
at	O
least	O
for	O
the	O
tested	O
template	O
based	O
log	O
statement	O
there	O
seems	O
to	O
be	O
roughly	O
a	O
factor	O
of	O
10	O
in	O
real	O
performance	O
difference	O
between	O
JUL	B-api_mention
(	O
slow	O
)	O
and	O
SLF4J	B-api_mention
+	O
Logback	B-api_mention
(	O
quick	O
)	O
.	O
Just	O
like	O
Ceki	O
said	O
.	O
I	O
can	O
also	O
see	O
another	O
thing	O
namely	O
that	O
SLF4J	B-api_mention
'	O
s	O
getLogger	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
call	O
is	O
a	O
lot	O
more	O
expensive	O
than	O
JUL	B-api_mention
'	O
s	O
ditto	O
.	O
(	O
95	O
ms	O
vs	O
0	O
.	O
3	O
ms	O
if	O
my	O
profiler	O
is	O
accurate	O
)	O
.	O
This	O
makes	O
sense	O
.	O
SLF4J	B-api_mention
has	O
to	O
do	O
some	O
time	O
on	O
the	O
binding	O
of	O
the	O
underlying	O
logging	O
implementation	O
.	O
This	O
doesn	O
'	O
t	O
scare	O
me	O
.	O
These	O
calls	O
should	O
be	O
somewhat	O
rare	O
in	O
the	O
lifetime	O
of	O
an	O
application	O
.	O
The	O
fastness	O
should	O
be	O
in	O
the	O
actual	O
log	O
calls	O
.	O
Final	O
conclusion	O
(	O
section	O
added	O
by	O
nolan600	O
on	O
08	O
-	O
JUL	O
-	O
2012	O
)	O
Thank	O
you	O
for	O
all	O
your	O
answers	O
.	O
Contrary	O
to	O
what	O
I	O
initially	O
thought	O
I	O
'	O
ve	O
ended	O
up	O
deciding	O
to	O
use	O
SLF4J	B-api_mention
for	O
my	O
API	O
.	O
This	O
is	O
based	O
on	O
a	O
number	O
of	O
things	O
and	O
your	O
input	O
:	O
#	O
li	O
It	O
gives	O
flexibility	O
to	O
choose	O
log	O
implementation	O
at	O
deployment	O
time	O
.	O
#	O
li	O
Issues	O
with	O
lack	O
of	O
flexibility	O
of	O
JUL	B-api_mention
'	O
s	O
configuration	O
when	O
run	O
inside	O
an	O
application	O
server	O
.	O
#	O
li	O
SLF4J	B-api_mention
is	O
certainly	O
a	O
lot	O
faster	O
as	O
detailed	O
above	O
in	O
particular	O
if	O
you	O
couple	O
it	O
with	O
Logback	B-api_mention
.	O
Even	O
if	O
this	O
was	O
just	O
a	O
rough	O
test	O
I	O
have	O
reason	O
to	O
believe	O
that	O
a	O
lot	O
more	O
effort	O
has	O
gone	O
into	O
optimization	O
on	O
SLF4J	B-api_mention
+	O
Logback	B-api_mention
than	O
on	O
JUL	B-api_mention
.	O
#	O
li	O
Documentation	O
.	O
The	O
documentation	O
for	O
SLF4J	B-api_mention
is	O
simply	O
a	O
lot	O
more	O
comprehensive	O
and	O
precise	O
.	O
#	O
li	O
Pattern	O
flexibility	O
.	O
As	O
I	O
did	O
the	O
tests	O
I	O
set	O
out	O
to	O
have	O
JUL	B-api_mention
mimic	O
the	O
default	O
pattern	O
from	O
Logback	B-api_mention
.	O
This	O
pattern	O
includes	O
the	O
name	O
of	O
the	O
thread	O
.	O
It	O
turns	O
out	O
JUL	B-api_mention
cannot	O
do	O
this	O
out	O
of	O
the	O
box	O
.	O
Ok	O
,	O
I	O
haven	O
'	O
t	O
missed	O
it	O
until	O
now	O
,	O
but	O
I	O
don	O
'	O
t	O
think	O
it	O
is	O
a	O
thing	O
that	O
should	O
be	O
missing	O
from	O
a	O
log	O
framework	O
.	O
Period	O
!	O
#	O
li	O
Most	O
(	O
or	O
many	O
)	O
Java	O
projects	O
today	O
use	O
Maven	O
so	O
adding	O
a	O
dependency	O
is	O
not	O
that	O
big	O
a	O
thing	O
especially	O
if	O
that	O
dependency	O
is	O
rather	O
stable	O
,	O
i	O
.	O
e	O
.	O
doesn	O
'	O
t	O
constantly	O
change	O
its	O
API	O
.	O
This	O
seems	O
to	O
be	O
true	O
for	O
SLF4J	B-api_mention
.	O
Also	O
the	O
SLF4J	B-api_mention
jar	O
and	O
friends	O
are	O
small	O
in	O
size	O
.	O
So	O
the	O
strange	O
thing	O
that	O
happened	O
was	O
that	O
I	O
actually	O
got	O
quite	O
upset	O
with	O
JUL	B-api_mention
after	O
having	O
worked	O
a	O
bit	O
with	O
SLF4J	B-api_mention
.	O
I	O
still	O
regret	O
that	O
it	O
has	O
to	O
be	O
this	O
way	O
with	O
JUL	B-api_mention
.	O
JUL	B-api_mention
is	O
far	O
from	O
perfect	O
but	O
kind	O
of	O
does	O
the	O
job	O
.	O
Just	O
not	O
quite	O
well	O
enough	O
.	O
The	O
same	O
can	O
be	O
said	O
about	O
Properties	O
as	O
an	O
example	O
but	O
we	O
do	O
not	O
think	O
about	O
abstracting	O
that	O
so	O
people	O
can	O
plug	O
in	O
their	O
own	O
configuration	O
library	O
and	O
what	O
have	O
you	O
.	O
I	O
think	O
the	O
reason	O
is	O
that	O
Properties	O
comes	O
in	O
just	O
above	O
the	O
bar	O
while	O
the	O
opposite	O
is	O
true	O
for	O
JUL	B-api_mention
of	O
today	O
.	O
.	O
.	O
and	O
in	O
the	O
past	O
it	O
came	O
in	O
at	O
zero	O
because	O
it	O
didn	O
'	O
t	O
exist	O
.	O
Question	O
-	O
8098953	O
,	O
answer	O
-	O
8103083	O
The	O
first	O
thing	O
to	O
keep	O
in	O
mind	O
is	O
that	O
Java	O
ternary	O
operators	O
have	O
a	O
"	O
type	O
"	O
,	O
and	O
that	O
this	O
is	O
what	O
the	O
compiler	O
will	O
determine	O
and	O
consider	O
no	O
matter	O
what	O
the	O
actual	O
/	O
real	O
types	O
of	O
the	O
second	O
or	O
third	O
parameter	O
are	O
.	O
Depending	O
on	O
several	O
factors	O
the	O
ternary	O
operator	O
type	O
is	O
determined	O
in	O
different	O
ways	O
as	O
illustrated	O
in	O
the	O
Java	O
Language	O
Specification	O
15	O
.	O
26	O
In	O
the	O
question	O
above	O
we	O
should	O
consider	O
the	O
last	O
case	O
:	O
#	O
blockquote	O
This	O
is	O
by	O
far	O
the	O
most	O
complex	O
case	O
once	O
you	O
take	O
a	O
look	O
at	O
applying	O
capture	O
conversion	O
(	O
§	O
5	O
.	O
1	O
.	O
10	O
)	O
and	O
most	O
of	O
all	O
at	O
lub	O
(	O
T1	O
,	O
T2	O
)	O
.	O
In	O
plain	O
English	O
and	O
after	O
an	O
extreme	O
simplification	O
we	O
can	O
describe	O
the	O
process	O
as	O
calculating	O
the	O
"	O
Least	O
Common	O
Superclass	O
"	O
(	O
yes	O
,	O
think	O
of	O
the	O
LCM	O
)	O
of	O
the	O
second	O
and	O
third	O
parameters	O
.	O
This	O
will	O
give	O
us	O
the	O
ternary	O
operator	O
"	O
type	O
"	O
.	O
Again	O
,	O
what	O
I	O
just	O
said	O
is	O
an	O
extreme	O
simplification	O
(	O
consider	O
classes	O
that	O
implement	O
multiple	O
common	O
interfaces	O
)	O
.	O
For	O
example	O
,	O
if	O
you	O
try	O
the	O
following	O
:	O
#	O
pre	O
You	O
'	O
ll	O
notice	O
that	O
resulting	O
type	O
of	O
the	O
conditional	O
expression	O
is	O
java	B-api_mention
.	I-api_mention
util	I-api_mention
.	I-api_mention
Date	I-api_mention
since	O
it	O
'	O
s	O
the	O
"	O
Least	O
Common	O
Superclass	O
"	O
for	O
the	O
Timestamp	B-api_mention
/	O
Time	B-api_mention
pair	O
.	O
Since	O
null	O
can	O
be	O
autoboxed	O
to	O
anything	O
,	O
the	O
"	O
Least	O
Common	O
Superclass	O
"	O
is	O
the	O
Integer	O
class	O
and	O
this	O
will	O
be	O
the	O
return	O
type	O
of	O
the	O
conditional	O
expression	O
(	O
ternary	O
operator	O
)	O
above	O
.	O
The	O
return	O
value	O
will	O
then	O
be	O
a	O
null	O
pointer	O
of	O
type	O
Integer	B-api_mention
and	O
that	O
is	O
what	O
will	O
be	O
returned	O
by	O
the	O
ternary	O
operator	O
.	O
At	O
runtime	O
,	O
when	O
the	O
Java	O
Virtual	O
Machine	O
unboxes	O
the	O
Integer	B-api_mention
a	O
NullPointerException	B-api_mention
is	O
thrown	O
.	O
This	O
happens	O
because	O
the	O
JVM	O
attempts	O
to	O
invoke	O
the	O
function	O
null	O
.	B-api_mention
intValue	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
,	O
where	O
null	O
is	O
the	O
result	O
of	O
autoboxing	O
.	O
In	O
my	O
opinion	O
(	O
and	O
since	O
my	O
opinion	O
is	O
not	O
in	O
the	O
Java	O
Language	O
Specification	O
many	O
people	O
will	O
find	O
it	O
wrong	O
anyway	O
)	O
the	O
compiler	O
does	O
a	O
poor	O
job	O
in	O
evaluating	O
the	O
expression	O
in	O
your	O
question	O
.	O
Given	O
that	O
you	O
wrote	O
true	O
?	O
param1	O
:	O
param2	O
the	O
compiler	O
should	O
determine	O
right	O
away	O
that	O
the	O
first	O
parameter	O
-	O
null	O
-	O
will	O
be	O
returned	O
and	O
it	O
should	O
generate	O
a	O
compiler	O
error	O
.	O
This	O
is	O
somewhat	O
similar	O
to	O
when	O
you	O
write	O
while	O
(	O
args	O
)	O
{	O
}	O
etc	O
.	O
.	O
.	O
and	O
the	O
compiler	O
complains	O
about	O
the	O
code	O
underneath	O
the	O
loop	O
and	O
flags	O
it	O
with	O
Unreachable	O
Statements	O
.	O
Your	O
second	O
case	O
is	O
pretty	O
straightforward	O
and	O
this	O
answer	O
is	O
already	O
too	O
long	O
.	O
.	O
.	O
;	O
)	O
CORRECTION	O
:	O
After	O
another	O
analysis	O
I	O
believe	O
that	O
I	O
was	O
wrong	O
to	O
say	O
that	O
a	O
null	O
value	O
can	O
be	O
boxed	O
/	O
autoboxed	O
to	O
anything	O
.	O
Talking	O
about	O
the	O
class	O
Integer	O
,	O
explicit	O
boxing	O
consists	O
in	O
invoking	O
the	O
new	O
Integer	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
constructor	O
or	O
maybe	O
the	O
Integer	B-api_mention
.	I-api_mention
valueOf	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
(	O
I	O
found	O
this	O
version	O
somewhere	O
)	O
.	O
The	O
former	O
would	O
throw	O
a	O
NumberFormatException	B-api_mention
(	O
and	O
this	O
does	O
not	O
happen	O
)	O
while	O
the	O
second	O
would	O
just	O
not	O
make	O
sense	O
since	O
an	O
int	O
cannot	O
be	O
null	O
.	O
.	O
.	O
Question	O
-	O
34250207	O
,	O
answer	O
-	O
34250231	O
Technically	O
,	O
it	O
'	O
s	O
10	O
,	O
not	O
zero	O
,	O
if	O
you	O
admit	O
for	O
a	O
lazy	O
initialisation	O
of	O
the	O
backing	O
array	O
.	O
See	O
:	O
#	O
pre	O
where	O
/	O
*	O
*	O
*	O
Default	O
initial	O
capacity	O
.	O
*	O
/	O
private	O
static	O
final	O
int	O
DEFAULT	O
_	O
CAPACITY	O
=	O
10	O
;	O
What	O
you	O
'	O
re	O
referring	O
to	O
is	O
just	O
the	O
zero	O
-	O
sized	O
initial	O
array	O
object	O
that	O
is	O
shared	O
among	O
all	O
initially	O
empty	O
ArrayList	B-api_mention
objects	O
.	O
I	O
.	O
e	O
.	O
the	O
capacity	O
of	O
10	O
is	O
guaranteed	O
lazily	O
,	O
an	O
optimisation	O
that	O
is	O
present	O
also	O
in	O
Java	O
7	O
.	O
Admittedly	O
,	O
the	O
constructor	O
contract	O
is	O
not	O
entirely	O
accurate	O
.	O
Perhaps	O
this	O
is	O
the	O
source	O
of	O
confusion	O
here	O
.	O
Background	O
Here	O
'	O
s	O
an	O
E	O
-	O
Mail	O
by	O
Mike	O
Duigou	O
#	O
blockquote	O
Question	O
-	O
31170459	O
,	O
answer	O
-	O
31170506	O
No	O
,	O
you	O
appear	O
to	O
have	O
a	O
legit	O
bug	O
.	O
The	O
bug	O
presents	O
in	O
JDK7	O
but	O
fixed	O
in	O
JDK8	O
.	O
Your	O
values	O
are	O
correctly	O
representable	O
as	O
BigDecimal	B-api_mention
s	O
,	O
and	O
should	O
behave	O
correctly	O
,	O
but	O
don	O
'	O
t	O
.	O
Tracing	O
through	O
the	O
source	O
code	O
of	O
BigDecimal	B-api_mention
,	O
on	O
line	O
2585	O
,	O
this	O
.	B-api_mention
precision	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
is	O
1	O
,	O
and	O
this	O
.	B-api_mention
scale	I-api_mention
is	O
-	O
2147483647	O
.	O
this	O
.	B-api_mention
precision	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
-	O
this	O
.	O
scale	O
therefore	O
overflows	O
,	O
and	O
the	O
following	O
overflow	O
is	O
not	O
handled	O
correctly	O
.	O
This	O
bug	O
has	O
been	O
fixed	O
in	O
JDK8	O
by	O
doing	O
the	O
subtraction	O
in	O
long	O
arithmetic	O
.	O
Question	O
-	O
16232833	O
I	O
'	O
m	O
using	O
Spring	O
MVC	O
for	O
a	O
simple	O
JSON	O
API	O
,	O
with	O
@	O
ResponseBody	O
based	O
approach	O
like	O
the	O
following	O
.	O
(	O
I	O
already	O
have	O
a	O
service	O
layer	O
producing	O
JSON	O
directly	O
.	O
)	O
#	O
pre	O
Question	O
is	O
,	O
in	O
the	O
given	O
scenario	O
,	O
what	O
is	O
the	O
simplest	O
,	O
cleanest	O
way	O
to	O
respond	O
with	O
a	O
HTTP	O
400	O
error	O
?	O
I	O
did	O
come	O
across	O
approaches	O
like	O
:	O
return	O
new	O
ResponseEntity	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
.	O
.	O
.	O
but	O
I	O
can	O
'	O
t	O
use	O
it	O
here	O
since	O
my	O
method	O
'	O
s	O
return	O
type	O
is	O
String	B-api_mention
,	O
not	O
ResponseEntity	B-api_mention
.	O
Question	O
-	O
14491966	O
,	O
answer	O
-	O
14492043	O
'	O
Random	O
'	O
is	O
more	O
than	O
just	O
about	O
getting	O
numbers	O
.	O
.	O
.	O
.	O
what	O
you	O
have	O
is	O
pseudo	O
-	O
random	O
If	O
pseudo	O
-	O
random	O
is	O
good	O
enough	O
for	O
your	O
purposes	O
,	O
then	O
sure	O
,	O
it	O
'	O
s	O
way	O
faster	O
(	O
and	O
XOR	O
+	O
Bitshift	O
will	O
be	O
faster	O
than	O
what	O
you	O
have	O
)	O
Rolf	O
Edit	O
:	O
OK	O
,	O
after	O
being	O
too	O
hasty	O
in	O
this	O
answer	O
,	O
let	O
me	O
answer	O
the	O
real	O
reason	O
why	O
your	O
code	O
is	O
faster	O
:	O
From	O
the	O
JavaDoc	O
for	O
Math	B-api_mention
.	I-api_mention
Random	I-api_mention
(	I-api_mention
)	I-api_mention
#	O
blockquote	O
This	O
is	O
likely	O
why	O
your	O
code	O
is	O
faster	O
.	O
Question	O
-	O
14534767	O
I	O
have	O
a	O
StringBuilder	B-api_mention
object	O
,	O
#	O
pre	O
Now	O
I	O
want	O
to	O
append	O
a	O
newline	O
character	O
to	O
the	O
StringBuilder	B-api_mention
.	O
How	O
can	O
I	O
do	O
it	O
?	O
result	O
.	O
append	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Does	O
not	O
work	O
.	O
So	O
,	O
I	O
was	O
thinking	O
about	O
writing	O
a	O
newline	O
using	O
Unicode	O
.	O
Will	O
this	O
help	O
?	O
If	O
so	O
,	O
how	O
can	O
I	O
add	O
one	O
?	O
Question	O
-	O
29333689	O
The	O
following	O
is	O
taken	O
from	O
a	O
job	O
interview	O
:	O
#	O
blockquote	O
I	O
thought	O
about	O
using	O
an	O
HashSet	B-api_mention
,	O
but	O
it	O
might	O
complicate	O
everything	O
.	O
.	O
.	O
Any	O
ideas	O
of	O
a	O
simple	O
solution	O
?	O
Question	O
-	O
30384955	O
,	O
answer	O
-	O
30385298	O
Replacing	O
the	O
definition	O
of	O
TbinList	O
with	O
class	O
TbinList	O
<	O
T	O
>	O
extends	O
ArrayList	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
{	O
}	O
and	O
defining	O
test2	O
with	O
TbinList	O
<	O
T	O
>	O
test2	O
=	O
new	O
TbinList	O
<	O
T	O
>	O
(	O
args	O
)	O
;	O
instead	O
would	O
solve	O
the	O
issue	O
.	O
With	O
your	O
definition	O
you	O
'	O
re	O
ending	O
up	O
with	O
an	O
ArrayList	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
where	O
T	O
is	O
any	O
fixed	O
class	O
extending	O
Base	O
.	O
Question	O
-	O
20129762	O
,	O
answer	O
-	O
20130475	O
To	O
convert	O
a	O
Stream	B-api_mention
to	O
an	O
Iterable	B-api_mention
,	O
you	O
can	O
do	O
#	O
pre	O
To	O
pass	O
a	O
Stream	B-api_mention
to	O
a	O
method	O
that	O
expects	O
Iterable	B-api_mention
,	O
void	O
foo	O
(	O
args	O
)	O
simply	O
foo	O
(	O
args	O
)	O
however	O
it	O
probably	O
looks	O
funny	O
;	O
it	O
might	O
be	O
better	O
to	O
be	O
a	O
little	O
bit	O
more	O
explicit	O
foo	O
(	O
args	O
)	O
;	O
Question	O
-	O
4709175	O
,	O
answer	O
-	O
4709284	O
#	O
blockquote	O
You	O
can	O
use	O
an	O
Enum	B-api_mention
to	O
represent	O
a	O
smallish	O
fixed	O
set	O
of	O
constants	O
or	O
an	O
internal	O
class	O
mode	O
while	O
increasing	O
readability	O
.	O
Also	O
,	O
Enums	O
can	O
enforce	O
a	O
certain	O
rigidity	O
when	O
used	O
in	O
method	O
parameters	O
.	O
They	O
offer	O
the	O
interesting	O
possibility	O
of	O
passing	O
information	O
to	O
a	O
constructor	O
like	O
in	O
the	O
Planets	O
example	O
on	O
Oracle	O
'	O
s	O
site	O
and	O
,	O
as	O
you	O
'	O
ve	O
discovered	O
,	O
also	O
allow	O
a	O
simple	O
way	O
to	O
create	O
a	O
singleton	O
pattern	O
.	O
ex	O
:	O
Locale	B-api_mention
.	I-api_mention
setDefault	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
reads	O
better	O
than	O
Locale	B-api_mention
.	I-api_mention
setDefault	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
and	O
enforces	O
the	O
use	O
of	O
fixed	O
set	O
of	O
values	O
shown	O
in	O
an	O
IDE	O
when	O
you	O
add	O
the	O
.	O
separator	O
instead	O
of	O
all	O
integers	O
.	O
Question	O
-	O
32356762	O
,	O
answer	O
-	O
32357142	O
When	O
returning	O
List	B-api_mention
,	O
you	O
'	O
ll	O
be	O
promoting	O
program	O
to	O
an	O
interface	O
,	O
which	O
is	O
a	O
very	O
good	O
practice	O
.	O
However	O
,	O
this	O
approach	O
has	O
its	O
limitation	O
.	O
For	O
example	O
,	O
you	O
cannot	O
use	O
some	O
methods	O
that	O
are	O
defined	O
for	O
ArrayList	B-api_mention
and	O
don	O
'	O
t	O
exist	O
in	O
the	O
List	B-api_mention
interface	O
-	O
See	O
this	O
answer	O
for	O
details	O
.	O
I	O
'	O
m	O
quoting	O
the	O
API	O
Design	O
from	O
the	O
The	O
Java	O
™	O
Tutorials	O
:	O
#	O
blockquote	O
Since	O
ArrayList	B-api_mention
is	O
essentially	O
an	O
array	O
,	O
they	O
are	O
my	O
first	O
choice	O
when	O
I	O
need	O
to	O
have	O
a	O
"	O
collection	O
-	O
array	O
"	O
.	O
So	O
if	O
I	O
want	O
to	O
convert	O
enumeration	O
to	O
a	O
list	O
,	O
my	O
choice	O
would	O
be	O
an	O
array	O
list	O
.	O
In	O
any	O
other	O
cases	O
,	O
it	O
'	O
s	O
still	O
valid	O
to	O
write	O
:	O
List	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
list	O
=	O
Collections	B-api_mention
.	I-api_mention
list	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Question	O
-	O
8189466	O
,	O
answer	O
-	O
23592535	O
I	O
had	O
that	O
same	O
problem	O
but	O
in	O
case	O
that	O
I	O
was	O
adding	O
en	O
element	O
into	O
iterated	O
list	O
.	O
I	O
made	O
it	O
this	O
way	O
#	O
pre	O
Now	O
everything	O
goes	O
fine	O
because	O
you	O
don	O
'	O
t	O
create	O
any	O
iterator	O
over	O
your	O
list	O
,	O
you	O
iterate	O
over	O
it	O
"	O
manually	O
"	O
.	O
And	O
condition	O
i	O
<	O
integerList	O
.	B-api_mention
size	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
will	O
never	O
fool	O
you	O
because	O
when	O
you	O
remove	O
/	O
add	O
something	O
into	O
List	B-api_mention
size	O
of	O
the	O
List	B-api_mention
decrement	O
/	O
increment	O
.	O
.	O
Hope	O
it	O
helps	O
,	O
for	O
me	O
that	O
was	O
solution	O
.	O
Question	O
-	O
31993377	O
,	O
answer	O
-	O
31993533	O
The	O
reason	O
is	O
that	O
hasNext	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
checks	O
if	O
there	O
are	O
any	O
more	O
non	O
-	O
whitespace	O
characters	O
available	O
.	O
hasNextLine	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
checks	O
to	O
see	O
if	O
there	O
is	O
another	O
line	O
of	O
text	O
available	O
.	O
Your	O
text	O
file	O
probably	O
has	O
a	O
newline	O
at	O
the	O
end	O
of	O
it	O
so	O
it	O
has	O
another	O
line	O
but	O
no	O
more	O
characters	O
that	O
are	O
not	O
whitespace	O
.	O
Many	O
text	O
editors	O
automatically	O
add	O
a	O
newline	O
to	O
the	O
end	O
of	O
a	O
file	O
if	O
there	O
isn	O
'	O
t	O
one	O
already	O
.	O
In	O
other	O
words	O
,	O
your	O
input	O
file	O
is	O
not	O
this	O
(	O
the	O
numbers	O
are	O
line	O
numbers	O
)	O
:	O
#	O
pre	O
It	O
is	O
actually	O
this	O
:	O
#	O
pre	O
Question	O
-	O
31993377	O
,	O
answer	O
-	O
31993534	O
You	O
have	O
a	O
single	O
extra	O
newline	O
at	O
the	O
end	O
of	O
your	O
file	O
.	O
#	O
li	O
hasNextLine	B-api_mention
(	I-api_mention
)	I-api_mention
checks	O
to	O
see	O
if	O
there	O
is	O
another	O
linePattern	O
in	O
the	O
buffer	O
.	O
#	O
li	O
hasNext	B-api_mention
(	I-api_mention
)	I-api_mention
checks	O
to	O
see	O
if	O
there	O
is	O
a	O
parseable	O
token	O
in	O
the	O
buffer	O
,	O
as	O
separated	O
by	O
the	O
scanner	O
'	O
s	O
delimiter	O
.	O
Since	O
the	O
scanner	O
'	O
s	O
delimiter	O
is	O
whitespace	O
,	O
and	O
the	O
linePattern	O
is	O
also	O
white	O
space	O
,	O
it	O
is	O
possible	O
for	O
there	O
to	O
be	O
a	O
linePattern	O
in	O
the	O
buffer	O
but	O
no	O
parseable	O
tokens	O
.	O
Typically	O
,	O
the	O
most	O
common	O
way	O
to	O
deal	O
with	O
this	O
issue	O
by	O
always	O
calling	O
nextLine	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
after	O
parsing	O
all	O
the	O
tokens	O
(	O
e	O
.	O
g	O
.	O
numbers	O
)	O
in	O
each	O
line	O
of	O
your	O
text	O
.	O
You	O
need	O
to	O
do	O
this	O
when	O
using	O
Scanner	B-api_mention
when	O
reading	O
a	O
user	O
'	O
s	O
input	O
too	O
from	O
System	B-api_mention
.	I-api_mention
in	I-api_mention
.	O
To	O
advance	O
the	O
scanner	O
past	O
this	O
whitespace	O
delimiter	O
,	O
you	O
must	O
use	O
scanner	O
.	B-api_mention
nextLine	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
to	O
clear	O
the	O
line	O
delimiter	O
.	O
See	O
:	O
Using	O
scanner	O
.	B-api_mention
nextLine	I-api_mention
(	I-api_mention
)	I-api_mention
Appendix	O
:	O
LinePattern	O
is	O
defined	O
to	O
be	O
a	O
Pattern	B-api_mention
that	O
matches	O
this	O
:	O
#	O
pre	O
The	O
default	O
token	O
delimiter	O
is	O
this	O
Pattern	B-api_mention
:	O
private	O
static	O
Pattern	B-api_mention
WHITESPACE	O
_	O
PATTERN	O
=	O
Pattern	B-api_mention
.	I-api_mention
compile	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Question	O
-	O
29183904	O
,	O
answer	O
-	O
29972028	O
Use	O
enum	O
when	O
you	O
need	O
its	O
features	O
.	O
Don	O
'	O
t	O
avoid	O
it	O
strictly	O
.	O
Java	O
enum	O
is	O
more	O
powerful	O
,	O
but	O
if	O
you	O
don	O
'	O
t	O
need	O
its	O
features	O
,	O
use	O
constants	O
,	O
they	O
occupy	O
less	O
space	O
and	O
they	O
can	O
be	O
primitive	O
itself	O
.	O
When	O
to	O
use	O
enum	O
:	O
#	O
li	O
type	O
checking	O
-	O
you	O
can	O
accept	O
only	O
listed	O
values	O
,	O
and	O
they	O
are	O
not	O
continuous	O
(	O
see	O
below	O
what	O
I	O
call	O
continuous	O
here	O
)	O
#	O
li	O
method	O
overloading	O
-	O
every	O
enum	O
constant	O
has	O
its	O
own	O
implementation	O
of	O
a	O
method	O
#	O
pre	O
#	O
li	O
more	O
data	O
-	O
your	O
one	O
constant	O
contains	O
more	O
than	O
one	O
information	O
that	O
cannot	O
be	O
put	O
in	O
one	O
variable	O
#	O
li	O
complicated	O
data	O
-	O
your	O
constant	O
need	O
methods	O
to	O
operate	O
on	O
the	O
data	O
When	O
not	O
to	O
use	O
enum	O
:	O
#	O
li	O
you	O
can	O
accept	O
all	O
values	O
of	O
one	O
type	O
,	O
and	O
your	O
constants	O
contain	O
only	O
these	O
most	O
used	O
#	O
li	O
you	O
can	O
accept	O
continuous	O
data	O
#	O
pre	O
#	O
li	O
for	O
names	O
(	O
like	O
in	O
your	O
example	O
)	O
#	O
li	O
for	O
everything	O
other	O
that	O
really	O
doesn	O
'	O
t	O
need	O
an	O
enum	O
Enum	O
occupies	O
more	O
space	O
#	O
li	O
a	O
single	O
reference	O
to	O
an	O
enum	O
constant	O
occupy	O
4	O
bytes	O
#	O
li	O
every	O
enum	O
constant	O
occupy	O
space	O
that	O
is	O
a	O
sum	O
of	O
its	O
fields	O
'	O
sizes	O
aligned	O
to	O
8	O
bytes	O
+	O
overhead	O
of	O
the	O
object	O
#	O
li	O
the	O
enum	O
class	O
itself	O
occupy	O
some	O
space	O
Constant	O
occupies	O
less	O
space	O
#	O
li	O
a	O
constant	O
doesn	O
'	O
t	O
have	O
a	O
reference	O
so	O
it	O
'	O
s	O
a	O
pure	O
data	O
(	O
even	O
if	O
it	O
'	O
s	O
a	O
reference	O
,	O
then	O
enum	O
instance	O
would	O
be	O
a	O
reference	O
to	O
another	O
reference	O
)	O
#	O
li	O
constants	O
may	O
be	O
added	O
to	O
existing	O
class	O
-	O
it	O
'	O
s	O
not	O
necessary	O
to	O
add	O
another	O
class	O
#	O
li	O
constants	O
may	O
be	O
inlined	O
;	O
it	O
brings	O
extended	O
compile	O
-	O
time	O
features	O
(	O
such	O
as	O
null	O
checking	O
,	O
finding	O
dead	O
code	O
etc	O
.	O
)	O
Question	O
-	O
11359187	O
,	O
answer	O
-	O
11359320	O
#	O
li	O
java	B-api_mention
.	I-api_mention
util	I-api_mention
.	I-api_mention
logging	I-api_mention
was	O
introduced	O
in	O
Java	O
1	O
.	O
4	O
.	O
There	O
were	O
uses	O
for	O
logging	O
before	O
that	O
,	O
that	O
'	O
s	O
why	O
many	O
other	O
logging	O
APIs	O
exist	O
.	O
Those	O
APIs	O
where	O
used	O
heavily	O
before	O
Java	O
1	O
.	O
4	O
and	O
thus	O
had	O
a	O
great	O
marketshare	O
that	O
didn	O
'	O
t	O
just	O
drop	O
to	O
0	O
when	O
1	O
.	O
4	O
was	O
release	O
.	O
#	O
li	O
JUL	B-api_mention
didn	O
'	O
t	O
start	O
out	O
all	O
that	O
great	O
,	O
many	O
of	O
the	O
things	O
you	O
mentioned	O
where	O
a	O
lot	O
worse	O
in	O
1	O
.	O
4	O
and	O
only	O
got	O
better	O
in	O
1	O
.	O
5	O
(	O
and	O
I	O
guess	O
in	O
6	O
as	O
well	O
,	O
but	O
I	O
'	O
m	O
not	O
too	O
sure	O
)	O
.	O
#	O
li	O
JUL	B-api_mention
isn	O
'	O
t	O
well	O
suited	O
for	O
multiple	O
applications	O
with	O
different	O
configurations	O
in	O
the	O
same	O
JVM	O
(	O
think	O
multiple	O
web	O
applications	O
that	O
should	O
not	O
interact	O
)	O
.	O
Tomcat	O
needs	O
to	O
jump	O
through	O
some	O
hoops	O
to	O
get	O
that	O
working	O
(	O
effectively	O
re	O
-	O
implementing	O
JUL	B-api_mention
if	O
I	O
understood	O
that	O
correctly	O
)	O
.	O
#	O
li	O
You	O
can	O
'	O
t	O
always	O
influence	O
what	O
logging	O
framework	O
your	O
libraries	O
use	O
.	O
Therefore	O
using	O
SLF4J	B-api_mention
(	O
which	O
is	O
actually	O
just	O
a	O
very	O
thin	O
API	O
layer	O
above	O
other	O
libraries	O
)	O
helps	O
keeping	O
a	O
somewhat	O
consistent	O
picture	O
of	O
the	O
entire	O
logging	O
world	O
(	O
so	O
you	O
can	O
decide	O
the	O
underlying	O
logging	O
framework	O
while	O
still	O
having	O
library	O
logging	O
in	O
the	O
same	O
system	O
)	O
.	O
#	O
li	O
Libraries	O
can	O
'	O
t	O
easily	O
change	O
.	O
If	O
a	O
previous	O
version	O
of	O
a	O
library	O
used	O
to	O
use	O
logging	O
-	O
library	O
-	O
X	O
it	O
can	O
'	O
t	O
easily	O
switch	O
to	O
logging	O
-	O
library	O
-	O
Y	O
(	O
for	O
example	O
JUL	B-api_mention
)	O
,	O
even	O
if	O
the	O
latter	O
is	O
clearly	O
superious	O
:	O
any	O
user	O
of	O
that	O
library	O
would	O
need	O
to	O
learn	O
the	O
new	O
logging	O
framework	O
and	O
(	O
at	O
least	O
)	O
reconfigure	O
their	O
logging	O
.	O
That	O
'	O
s	O
a	O
big	O
no	O
-	O
no	O
,	O
especially	O
when	O
it	O
brings	O
no	O
apparent	O
gain	O
to	O
most	O
people	O
.	O
Having	O
said	O
all	O
that	O
I	O
think	O
JUL	B-api_mention
is	O
at	O
least	O
a	O
valid	O
alternative	O
to	O
other	O
logging	O
frameworks	O
these	O
days	O
.	O
Question	O
-	O
5694385	O
,	O
answer	O
-	O
5694464	O
Rather	O
than	O
spoon	O
-	O
feed	O
you	O
code	O
,	O
here	O
'	O
s	O
how	O
to	O
look	O
in	O
the	O
documentation	O
.	O
First	O
,	O
you	O
'	O
re	O
dealing	O
with	O
IO	O
,	O
so	O
look	O
in	O
the	O
java	O
.	O
io	O
package	O
.	O
There	O
are	O
two	O
classes	O
that	O
look	O
interesting	O
:	O
FileFilter	B-api_mention
and	O
FileNameFilter	B-api_mention
.	O
When	O
I	O
clicked	O
on	O
the	O
first	O
,	O
it	O
showed	O
me	O
that	O
there	O
was	O
a	O
a	O
listFiles	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
in	O
the	O
File	B-api_mention
class	O
.	O
And	O
the	O
documentation	O
for	O
that	O
method	O
says	O
:	O
#	O
blockquote	O
Scrolling	O
up	O
in	O
the	O
File	O
JavaDoc	O
,	O
I	O
see	O
the	O
constructors	O
.	O
And	O
that	O
'	O
s	O
really	O
all	O
I	O
need	O
to	O
be	O
able	O
to	O
create	O
a	O
File	O
instance	O
and	O
call	O
listFiles	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
on	O
it	O
.	O
Scrolling	O
still	O
further	O
,	O
I	O
can	O
see	O
some	O
information	O
about	O
how	O
files	O
are	O
named	O
in	O
different	O
operating	O
systems	O
.	O
Question	O
-	O
5439529	O
,	O
answer	O
-	O
5439600	O
As	O
an	O
alternative	O
to	O
trying	O
to	O
parse	O
the	O
string	O
and	O
catching	O
NumberFormatException	B-api_mention
,	O
you	O
could	O
use	O
a	O
regex	O
;	O
e	O
.	O
g	O
.	O
#	O
pre	O
This	O
is	O
likely	O
to	O
be	O
faster	O
,	O
especially	O
if	O
you	O
precompile	O
and	O
reuse	O
the	O
regex	O
.	O
However	O
,	O
the	O
catch	O
is	O
that	O
Integer	B-api_mention
.	I-api_mention
parseInt	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
will	O
still	O
fail	O
if	O
str	O
represents	O
a	O
number	O
that	O
is	O
outside	O
range	O
of	O
legal	O
int	O
values	O
.	O
Question	O
-	O
15336477	O
,	O
answer	O
-	O
15336606	O
It	O
got	O
deprecated	O
in	O
version	O
4	O
.	O
3	O
-	O
alpha1	O
which	O
you	O
use	O
because	O
of	O
the	O
LATEST	O
version	O
specification	O
.	O
If	O
you	O
take	O
a	O
look	O
at	O
the	O
javadoc	O
of	O
the	O
class	O
,	O
it	O
tells	O
you	O
what	O
to	O
use	O
instead	O
:	O
HttpClientBuilder	B-api_mention
.	O
In	O
the	O
latest	O
stable	O
version	O
(	O
4	O
.	O
2	O
.	O
3	O
)	O
the	O
DefaultHttpClient	B-api_mention
is	O
not	O
deprecated	O
yet	O
.	O
Question	O
-	O
20331163	O
I	O
have	O
a	O
string	O
"	O
11	O
/	O
15	O
/	O
2013	O
08	O
:	O
00	O
:	O
00	O
"	O
,	O
I	O
want	O
to	O
format	O
it	O
to	O
"	O
11	O
/	O
15	O
/	O
2013	O
"	O
,	O
what	O
is	O
the	O
correct	O
DateTimeFormatter	B-api_mention
pattern	O
?	O
I	O
'	O
ve	O
tried	O
many	O
and	O
googled	O
and	O
still	O
unable	O
to	O
find	O
the	O
correct	O
pattern	O
.	O
edit	O
:	O
I	O
am	O
looking	O
for	O
Joda	O
-	O
Time	O
DateTimeFormatter	B-api_mention
,	O
not	O
Java	O
'	O
s	O
SimpleDateFormat	B-api_mention
.	O
.	O
Question	O
-	O
33477695	O
,	O
answer	O
-	O
33477803	O
The	O
java	O
.	O
time	O
API	O
in	O
general	O
does	O
have	O
nanosecond	O
precision	O
.	O
For	O
example	O
:	O
#	O
pre	O
Output	O
:	O
2015	O
-	O
11	O
-	O
02T12	O
:	O
38	O
:	O
00	O
,	O
123456789	O
+	O
0000	O
However	O
,	O
it	O
'	O
s	O
the	O
clock	O
value	O
returned	O
by	O
OffsetDateTime	O
.	O
now	O
(	O
args	O
)	O
which	O
is	O
returning	O
a	O
value	O
which	O
only	O
has	O
milliseconds	O
.	O
From	O
Clock	B-api_mention
implementation	O
in	O
Java	O
8	O
:	O
#	O
blockquote	O
So	O
there	O
'	O
s	O
nothing	O
inherently	O
imprecise	O
here	O
-	O
just	O
the	O
default	O
implementation	O
of	O
Clock	B-api_mention
using	O
System	B-api_mention
.	I-api_mention
currentTimeMillis	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
You	O
could	O
potentially	O
create	O
your	O
own	O
more	O
precise	O
subclass	O
.	O
However	O
,	O
you	O
should	O
note	O
that	O
adding	O
more	O
precision	O
without	O
adding	O
more	O
accuracy	O
probably	O
isn	O
'	O
t	O
terribly	O
useful	O
.	O
(	O
There	O
are	O
times	O
when	O
it	O
might	O
be	O
,	O
admittedly	O
.	O
.	O
.	O
)	O
Question	O
-	O
12732422	O
I	O
'	O
m	O
trying	O
to	O
add	O
header	O
for	O
my	O
request	O
using	O
HttpUrlConnection	B-api_mention
but	O
the	O
method	O
setRequestProperty	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
doesn	O
'	O
t	O
seem	O
working	O
.	O
The	O
server	O
side	O
doesn	O
'	O
t	O
receive	O
any	O
request	O
with	O
my	O
header	O
.	O
Can	O
anyone	O
help	O
me	O
?	O
Thanks	O
in	O
advance	O
.	O
#	O
pre	O
Question	O
-	O
14833008	O
,	O
answer	O
-	O
14833098	O
"	O
.	O
"	O
is	O
a	O
special	O
character	O
in	O
java	O
.	O
You	O
have	O
to	O
use	O
"	O
\	O
.	O
"	O
to	O
escape	O
this	O
character	O
:	O
final	O
String	B-api_mention
extensionRemoved	O
=	O
filename	O
.	B-api_mention
split	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
[	O
0	O
]	O
;	O
I	O
hope	O
this	O
helps	O
Question	O
-	O
22725537	O
,	O
answer	O
-	O
22735184	O
You	O
cannot	O
do	O
it	O
more	O
concise	O
as	O
you	O
are	O
already	O
doing	O
.	O
You	O
claim	O
that	O
you	O
do	O
not	O
want	O
.	B-api_mention
filter	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
and	O
.	B-api_mention
map	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
This	O
has	O
been	O
resolved	O
by	O
the	O
method	O
@	O
StuartMarks	O
describes	O
,	O
however	O
as	O
a	O
result	O
you	O
now	O
map	O
it	O
to	O
an	O
Optional	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
,	O
so	O
now	O
you	O
need	O
to	O
use	O
.	B-api_mention
flatMap	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
and	O
a	O
get	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
in	O
the	O
end	O
.	O
So	O
it	O
still	O
consists	O
of	O
two	O
statements	O
and	O
you	O
can	O
now	O
get	O
exceptions	O
with	O
the	O
new	O
method	O
!	O
Because	O
,	O
what	O
if	O
every	O
optional	O
is	O
empty	O
?	O
Then	O
the	O
findFirst	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
will	O
return	O
an	O
empty	O
optional	O
and	O
your	O
get	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
will	O
fail	O
!	O
So	O
what	O
you	O
have	O
:	O
things	O
.	B-api_mention
stream	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
map	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
filter	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
map	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
findFirst	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
is	O
actually	O
the	O
best	O
way	O
to	O
accomplish	O
what	O
you	O
want	O
,	O
and	O
that	O
is	O
you	O
want	O
to	O
save	O
the	O
result	O
as	O
a	O
T	B-api_mention
,	O
not	O
as	O
an	O
Optional	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
.	O
I	O
took	O
the	O
liberty	O
of	O
creating	O
a	O
CustomOptional	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
class	O
that	O
wraps	O
the	O
Optional	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
and	O
provides	O
an	O
extra	O
method	O
,	O
flatStream	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
Note	O
that	O
you	O
cannot	O
extend	O
Optional	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
:	O
#	O
pre	O
You	O
will	O
see	O
that	O
I	O
added	O
flatStream	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
,	O
as	O
here	O
:	O
#	O
pre	O
Used	O
as	O
:	O
String	B-api_mention
result	O
=	O
Stream	B-api_mention
.	I-api_mention
of	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
map	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
flatMap	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
findFirst	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
get	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
You	O
still	O
will	O
need	O
to	O
return	O
a	O
Stream	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
here	O
,	O
as	O
you	O
cannot	O
return	O
T	B-api_mention
,	O
because	O
if	O
!	O
optional	O
.	B-api_mention
isPresent	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
,	O
then	O
T	O
=	O
=	O
null	O
if	O
you	O
declare	O
it	O
such	O
,	O
but	O
then	O
your	O
.	B-api_mention
flatMap	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
would	O
attempt	O
to	O
add	O
null	O
to	O
a	O
stream	O
and	O
that	O
is	O
not	O
possible	O
.	O
As	O
example	O
:	O
#	O
pre	O
Used	O
as	O
:	O
String	B-api_mention
result	O
=	O
Stream	B-api_mention
.	I-api_mention
of	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
map	O
(	O
args	O
)	O
.	O
map	O
(	O
args	O
)	O
.	B-api_mention
findFirst	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
get	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Will	O
now	O
throw	O
a	O
NullPointerException	B-api_mention
inside	O
the	O
stream	O
operations	O
.	O
Conclusion	O
The	O
method	O
you	O
used	O
,	O
is	O
actually	O
the	O
best	O
method	O
.	O
Question	O
-	O
11411022	O
,	O
answer	O
-	O
34052602	O
The	O
best	O
way	O
is	O
the	O
clearest	O
way	O
:	O
*	O
Thread	B-api_mention
.	I-api_mention
currentThread	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
=	O
=	O
Looper	B-api_mention
.	I-api_mention
getMainLooper	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
getThread	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
Or	O
,	O
if	O
the	O
runtime	O
platform	O
is	O
API	O
level	O
23	O
(	O
Marshmallow	O
6	O
.	O
0	O
)	O
or	O
higher	O
:	O
Looper	B-api_mention
.	I-api_mention
getMainLooper	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
isCurrentThread	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
See	O
the	O
Looper	B-api_mention
API	O
.	O
Note	O
that	O
calling	O
Looper	B-api_mention
.	I-api_mention
getMainLooper	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
involves	O
synchonization	O
(	O
see	O
the	O
source	O
)	O
.	O
You	O
might	O
want	O
to	O
avoid	O
the	O
overhead	O
by	O
storing	O
the	O
return	O
value	O
and	O
reusing	O
it	O
.	O
*	O
credit	O
greg7gkb	O
Question	O
-	O
13291076	O
,	O
answer	O
-	O
13291166	O
name	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
is	O
a	O
"	O
built	O
-	O
in	O
"	O
method	O
of	O
enum	O
.	O
It	O
is	O
final	O
and	O
you	O
cannot	O
change	O
its	O
implementation	O
.	O
It	O
returns	O
the	O
name	O
of	O
enum	O
constant	O
as	O
it	O
is	O
written	O
,	O
e	O
.	O
g	O
.	O
in	O
upper	O
case	O
,	O
without	O
spaces	O
etc	O
.	O
Compare	O
MOBILE	O
_	O
PHONE	O
_	O
NUMBER	O
and	O
Mobile	O
phone	O
number	O
.	O
Which	O
version	O
is	O
more	O
readable	O
?	O
I	O
believe	O
the	O
second	O
one	O
.	O
This	O
is	O
the	O
difference	O
:	O
name	B-api_mention
(	I-api_mention
args	I-api_mention
)	O
always	O
returns	O
MOBILE	O
_	O
PHONE	O
_	O
NUMBER	O
,	O
toString	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
may	O
be	O
overriden	O
to	O
return	O
Mobile	O
phone	O
number	O
.	O
Question	O
-	O
25222811	O
,	O
answer	O
-	O
26676046	O
To	O
begin	O
with	O
(	O
and	O
unrelated	O
)	O
,	O
instantiating	O
the	O
Application	B-api_mention
class	O
by	O
yourself	O
does	O
not	O
seem	O
to	O
be	O
its	O
intended	O
use	O
.	O
From	O
what	O
one	O
can	O
read	O
from	O
its	O
source	O
,	O
you	O
are	O
rather	O
expected	O
to	O
use	O
the	O
static	O
instance	O
returned	O
by	O
getApplication	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
Now	O
let	O
'	O
s	O
get	O
to	O
the	O
error	O
Eclipse	O
reports	O
.	O
I	O
'	O
ve	O
ran	O
into	O
a	O
similar	O
issue	O
recently	O
:	O
Access	O
restriction	O
:	O
The	O
method	O
.	O
.	O
.	O
is	O
not	O
API	O
(	O
args	O
)	O
.	O
I	O
called	O
the	O
method	O
in	O
question	O
as	O
a	O
method	O
of	O
an	O
object	O
which	O
inherited	O
that	O
method	O
from	O
a	O
super	O
class	O
.	O
All	O
I	O
had	O
to	O
do	O
was	O
to	O
add	O
the	O
package	O
the	O
super	O
class	O
was	O
in	O
to	O
the	O
packages	O
imported	O
by	O
my	O
plugin	O
.	O
However	O
,	O
there	O
is	O
a	O
lot	O
of	O
different	O
causes	O
for	O
errors	O
based	O
on	O
"	O
restriction	O
on	O
required	O
project	O
/	O
library	O
"	O
.	O
Similar	O
to	O
the	O
problem	O
described	O
above	O
,	O
the	O
type	O
you	O
are	O
using	O
might	O
have	O
dependencies	O
to	O
packages	O
that	O
are	O
not	O
exported	O
by	O
the	O
library	O
or	O
might	O
not	O
be	O
exported	O
itself	O
.	O
In	O
that	O
case	O
you	O
can	O
try	O
to	O
track	O
down	O
the	O
missing	O
packages	O
and	O
export	O
them	O
my	O
yourself	O
,	O
as	O
suggested	O
here	O
,	O
or	O
try	O
Access	O
Rules	O
.	O
Other	O
possible	O
scenarios	O
include	O
:	O
#	O
li	O
Eclipse	O
wants	O
to	O
keep	O
you	O
from	O
using	O
available	O
packages	O
that	O
are	O
not	O
part	O
of	O
the	O
public	O
Java	O
API	O
(	O
solution	O
1	O
,	O
2	O
)	O
#	O
li	O
Dependencies	O
are	O
satisfied	O
by	O
multiple	O
sources	O
,	O
versions	O
are	O
conflicting	O
etc	O
.	O
(	O
solution	O
1	O
,	O
2	O
,	O
3	O
)	O
#	O
li	O
Eclipse	O
is	O
using	O
a	O
JRE	O
where	O
a	O
JDK	O
is	O
necessary	O
(	O
which	O
might	O
be	O
the	O
case	O
here	O
,	O
from	O
what	O
your	O
errors	O
say	O
;	O
solution	O
)	O
or	O
JRE	O
/	O
JDK	O
version	O
in	O
project	O
build	O
path	O
is	O
not	O
the	O
right	O
one	O
This	O
ended	O
up	O
as	O
more	O
like	O
a	O
medley	O
of	O
restriction	O
-	O
related	O
issues	O
than	O
an	O
actual	O
answer	O
.	O
But	O
since	O
restriction	O
on	O
required	O
projects	O
is	O
such	O
a	O
versatile	O
error	O
to	O
be	O
reported	O
,	O
the	O
perfect	O
recipe	O
is	O
probably	O
still	O
to	O
be	O
found	O
.	O
Question	O
-	O
6416706	O
,	O
answer	O
-	O
6416788	O
As	O
soon	O
as	O
you	O
call	O
contains	B-api_mention
,	O
containsAll	B-api_mention
,	O
equals	B-api_mention
,	O
hashCode	B-api_mention
,	O
remove	B-api_mention
,	O
retainAll	B-api_mention
,	O
size	B-api_mention
or	O
toArray	B-api_mention
,	O
you	O
'	O
d	O
have	O
to	O
traverse	O
the	O
elements	O
anyway	O
.	O
If	O
you	O
'	O
re	O
occasionally	O
only	O
calling	O
methods	O
such	O
as	O
isEmpty	B-api_mention
or	O
clear	O
I	O
suppose	O
you	O
'	O
d	O
be	O
better	O
of	O
by	O
creating	O
the	O
collection	O
lazily	O
.	O
You	O
could	O
for	O
instance	O
have	O
a	O
backing	O
ArrayList	B-api_mention
for	O
storing	O
previously	O
iterated	O
elements	O
.	O
I	O
don	O
'	O
t	O
know	O
of	O
any	O
such	O
class	O
in	O
any	O
library	O
,	O
but	O
it	O
should	O
be	O
a	O
fairly	O
simple	O
exercise	O
to	O
write	O
up	O
.	O
Question	O
-	O
6252678	O
,	O
answer	O
-	O
6252802	O
You	O
need	O
a	O
DateTimeFormatter	B-api_mention
appropriate	O
to	O
the	O
format	O
you	O
'	O
re	O
using	O
.	O
Take	O
a	O
look	O
at	O
the	O
docs	O
for	O
instructions	O
on	O
how	O
to	O
build	O
one	O
.	O
Off	O
the	O
cuff	O
,	O
I	O
think	O
you	O
need	O
format	O
=	O
DateTimeFormat	B-api_mention
.	I-api_mention
forPattern	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
Question	O
-	O
7520432	O
,	O
answer	O
-	O
27478241	O
=	O
=	O
can	O
be	O
used	O
in	O
many	O
object	O
types	O
but	O
you	O
can	O
use	O
Object	B-api_mention
.	I-api_mention
equals	I-api_mention
for	O
any	O
type	O
,	O
especially	O
Strings	O
and	O
Google	O
Map	O
Markers	O
.	O
Question	O
-	O
27949213	O
,	O
answer	O
-	O
27949367	O
The	O
strategy	O
they	O
describe	O
is	O
to	O
simply	O
reuse	O
the	O
internal	O
character	O
array	O
of	O
one	O
String	B-api_mention
in	O
possibly	O
many	O
equal	O
Strings	O
.	O
There	O
'	O
s	O
no	O
need	O
for	O
each	O
String	B-api_mention
to	O
have	O
its	O
own	O
copy	O
if	O
they	O
are	O
equal	O
.	O
In	O
order	O
to	O
more	O
quickly	O
determine	O
if	O
2	O
strings	O
are	O
equal	O
,	O
the	O
hash	O
code	O
is	O
used	O
as	O
a	O
first	O
step	O
,	O
as	O
it	O
is	O
a	O
fast	O
way	O
to	O
determine	O
if	O
Strings	O
may	O
be	O
equal	O
.	O
Hence	O
their	O
statement	O
:	O
#	O
blockquote	O
This	O
is	O
to	O
make	O
a	O
certain	O
(	O
but	O
slower	O
)	O
comparison	O
for	O
equality	O
once	O
possible	O
equality	O
has	O
been	O
determined	O
using	O
the	O
hash	O
code	O
.	O
In	O
the	O
end	O
,	O
equal	O
Strings	O
will	O
share	O
a	O
single	O
underlying	O
char	O
array	O
.	O
Java	O
has	O
had	O
String	B-api_mention
.	I-api_mention
intern	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
for	O
a	O
long	O
time	O
,	O
to	O
do	O
more	O
or	O
less	O
the	O
same	O
(	O
i	O
.	O
e	O
.	O
save	O
memory	O
by	O
deduplicating	O
equal	O
Strings	O
)	O
.	O
What	O
'	O
s	O
novel	O
about	O
this	O
is	O
that	O
it	O
happens	O
during	O
garbage	O
collection	O
time	O
and	O
can	O
be	O
externally	O
controlled	O
.	O
Question	O
-	O
29333689	O
,	O
answer	O
-	O
29337734	O
My	O
intuition	O
in	O
Python	O
is	O
to	O
use	O
the	O
collections	O
.	O
Counter	O
as	O
a	O
multiset	O
:	O
#	O
pre	O
So	O
we	O
have	O
a	O
list	O
of	O
integers	O
from	O
0	O
-	O
99	O
twice	O
except	O
for	O
66	O
.	O
#	O
pre	O
Which	O
gets	O
the	O
least	O
common	O
(	O
last	O
item	O
)	O
from	O
a	O
list	O
sorted	O
by	O
frequency	O
.	O
Such	O
a	O
function	O
would	O
be	O
:	O
#	O
pre	O
And	O
usage	O
:	O
#	O
pre	O
This	O
is	O
a	O
generalized	O
solution	O
that	O
works	O
for	O
any	O
number	O
of	O
items	O
.	O
Question	O
-	O
7032070	O
Assuming	O
that	O
arraylist	O
is	O
defined	O
as	O
ArrayList	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
arraylist	O
,	O
is	O
arraylist	O
.	B-api_mention
removeAll	I-api_mention
(	I-api_mention
arraylist	I-api_mention
)	I-api_mention
equivalent	O
to	O
arraylist	O
.	B-api_mention
clear	I-api_mention
(	I-api_mention
)	I-api_mention
?	O
If	O
so	O
,	O
can	O
I	O
assume	O
that	O
the	O
clear	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
is	O
more	O
efficient	O
for	O
emptying	O
the	O
array	O
list	O
?	O
Are	O
there	O
any	O
caveats	O
in	O
using	O
arraylist	O
.	B-api_mention
removeAll	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
instead	O
of	O
arraylist	O
.	B-api_mention
clear	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
?	O
Question	O
-	O
28724850	O
Running	O
the	O
following	O
stream	O
example	O
in	O
Java8	O
:	O
System	B-api_mention
.	I-api_mention
out	I-api_mention
.	I-api_mention
println	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
yields	O
:	O
/	O
a	O
/	O
b	O
/	O
c	O
/	O
d	O
/	O
e	O
/	O
f	O
Which	O
is	O
-	O
of	O
course	O
-	O
no	O
surprise	O
.	O
Due	O
to	O
#	O
a	O
it	O
shouldn	O
'	O
t	O
matter	O
whether	O
the	O
stream	O
is	O
executed	O
sequentially	O
or	O
parallel	O
:	O
#	O
blockquote	O
AFAIK	O
reduce	O
(	O
args	O
)	O
is	O
deterministic	O
and	O
(	O
s1	O
,	O
s2	O
)	O
-	O
>	O
s1	O
+	O
StringLiteral	O
+	O
s2	O
is	O
associative	O
,	O
so	O
that	O
adding	O
parallel	O
(	O
args	O
)	O
should	O
yield	O
the	O
same	O
result	O
:	O
System	B-api_mention
.	I-api_mention
out	I-api_mention
.	I-api_mention
println	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
However	O
the	O
result	O
on	O
my	O
machine	O
is	O
:	O
/	O
a	O
/	O
/	O
b	O
/	O
/	O
c	O
/	O
/	O
d	O
/	O
/	O
e	O
/	O
/	O
f	O
What	O
'	O
s	O
wrong	O
here	O
?	O
BTW	O
:	O
using	O
(	O
the	O
preferred	O
)	O
.	O
collect	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
instead	O
of	O
reduce	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
yields	O
the	O
same	O
result	O
a	O
/	O
b	O
/	O
c	O
/	O
d	O
/	O
e	O
/	O
f	O
for	O
sequential	O
and	O
parallel	O
execution	O
.	O
JVM	O
details	O
:	O
#	O
pre	O
Question	O
-	O
8579657	O
,	O
answer	O
-	O
8641412	O
Thread	B-api_mention
.	I-api_mention
start	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
code	O
registers	O
the	O
Thread	B-api_mention
with	O
scheduler	O
and	O
the	O
scheduler	O
calls	O
the	O
run	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
.	O
Also	O
,	O
Thread	B-api_mention
is	O
class	O
while	O
Runnable	B-api_mention
is	O
an	O
interface	O
.	O
Question	O
-	O
23756966	O
While	O
investigating	O
for	O
a	O
little	O
debate	O
w	O
.	O
r	O
.	O
t	O
.	O
using	O
StringLiteral	B-api_mention
+	O
n	O
and	O
Integer	B-api_mention
.	I-api_mention
toString	I-api_mention
(	I-api_mention
int	I-api_mention
)	I-api_mention
to	O
convert	O
an	O
integer	O
primitive	O
to	O
a	O
string	O
I	O
wrote	O
this	O
JMH	O
microbenchmark	O
:	O
#	O
pre	O
I	O
ran	O
it	O
with	O
the	O
default	O
JMH	O
options	O
with	O
both	O
Java	O
VMs	O
that	O
exist	O
on	O
my	O
Linux	O
machine	O
(	O
up	O
-	O
to	O
-	O
date	O
Mageia	O
4	O
64	O
-	O
bit	O
,	O
Intel	O
i7	O
-	O
3770	O
CPU	O
,	O
32GB	O
RAM	O
)	O
.	O
The	O
first	O
JVM	O
was	O
the	O
one	O
supplied	O
with	O
Oracle	O
JDK	O
8u5	O
64	O
-	O
bit	O
:	O
#	O
pre	O
With	O
this	O
JVM	O
I	O
got	O
pretty	O
much	O
what	O
I	O
expected	O
:	O
#	O
pre	O
I	O
.	O
e	O
.	O
using	O
the	O
StringBuilder	B-api_mention
class	O
is	O
slower	O
due	O
to	O
the	O
additional	O
overhead	O
of	O
creating	O
the	O
StringBuilder	B-api_mention
object	O
and	O
appending	O
an	O
empty	O
string	O
.	O
Using	O
String	B-api_mention
.	I-api_mention
format	I-api_mention
(	I-api_mention
args	I-api_mention
)	O
is	O
even	O
slower	O
,	O
by	O
an	O
order	O
of	O
magnitude	O
or	O
so	O
.	O
The	O
distribution	O
-	O
provided	O
compiler	O
,	O
on	O
the	O
other	O
hand	O
,	O
is	O
based	O
on	O
OpenJDK	O
1	O
.	O
7	O
:	O
#	O
pre	O
The	O
results	O
here	O
were	O
interesting	O
:	O
#	O
pre	O
Why	O
does	O
StringBuilder	B-api_mention
.	I-api_mention
append	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
appear	O
so	O
much	O
faster	O
with	O
this	O
JVM	O
?	O
Looking	O
at	O
the	O
StringBuilder	B-api_mention
class	O
source	O
code	O
revealed	O
nothing	O
particularly	O
interesting	O
-	O
the	O
method	O
in	O
question	O
is	O
almost	O
identical	O
to	O
Integer	O
#	O
toString	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
Interestingly	O
enough	O
,	O
appending	O
the	O
result	O
of	O
Integer	B-api_mention
.	I-api_mention
toString	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
(	O
the	O
stringBuilder2	O
microbenchmark	O
)	O
does	O
not	O
appear	O
to	O
be	O
faster	O
.	O
Is	O
this	O
performance	O
discrepancy	O
an	O
issue	O
with	O
the	O
testing	O
harness	O
?	O
Or	O
does	O
my	O
OpenJDK	O
JVM	O
contain	O
optimizations	O
that	O
would	O
affect	O
this	O
particular	O
code	O
(	O
anti	O
)	O
-	O
pattern	O
?	O
EDIT	O
:	O
For	O
a	O
more	O
straight	O
-	O
forward	O
comparison	O
,	O
I	O
installed	O
Oracle	O
JDK	O
1	O
.	O
7u55	O
:	O
#	O
pre	O
The	O
results	O
are	O
similar	O
to	O
those	O
of	O
OpenJDK	O
:	O
#	O
pre	O
It	O
seems	O
that	O
this	O
is	O
a	O
more	O
general	O
Java	O
7	O
vs	O
Java	O
8	O
issue	O
.	O
Perhaps	O
Java	O
7	O
had	O
more	O
aggressive	O
string	O
optimizations	O
?	O
EDIT	O
2	O
:	O
For	O
completeness	O
,	O
here	O
are	O
the	O
string	O
-	O
related	O
VM	O
options	O
for	O
both	O
of	O
these	O
JVMs	O
:	O
For	O
Oracle	O
JDK	O
8u5	O
:	O
#	O
pre	O
For	O
OpenJDK	O
1	O
.	O
7	O
:	O
#	O
pre	O
The	O
UseStringCache	B-api_mention
option	O
was	O
removed	O
in	O
Java	O
8	O
with	O
no	O
replacement	O
,	O
so	O
I	O
doubt	O
that	O
makes	O
any	O
difference	O
.	O
The	O
rest	O
of	O
the	O
options	O
appear	O
to	O
have	O
the	O
same	O
settings	O
.	O
EDIT	O
3	O
:	O
A	O
side	O
-	O
by	O
-	O
side	O
comparison	O
of	O
the	O
source	O
code	O
of	O
the	O
AbstractStringBuilder	B-api_mention
,	O
StringBuilder	B-api_mention
and	O
Integer	B-api_mention
classes	O
from	O
the	O
src	O
.	O
zip	O
file	O
of	O
reveals	O
nothing	O
noteworty	O
.	O
Apart	O
from	O
a	O
whole	O
lot	O
of	O
cosmetic	O
and	O
documentation	O
changes	O
,	O
Integer	B-api_mention
now	O
has	O
some	O
support	O
for	O
unsigned	O
integers	O
and	O
StringBuilder	B-api_mention
has	O
been	O
slightly	O
refactored	O
to	O
share	O
more	O
code	O
with	O
StringBuffer	B-api_mention
.	O
None	O
of	O
these	O
changes	O
seem	O
to	O
affect	O
the	O
code	O
paths	O
used	O
by	O
StringBuilder	B-api_mention
#	I-api_mention
append	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
,	O
although	O
I	O
may	O
have	O
missed	O
something	O
.	O
A	O
comparison	O
of	O
the	O
assembly	O
code	O
generated	O
for	O
IntStr	O
#	O
integerToString	O
(	O
args	O
)	O
and	O
IntStr	O
#	O
stringBuilder0	O
(	O
args	O
)	O
is	O
far	O
more	O
interesting	O
.	O
The	O
basic	O
layout	O
of	O
the	O
code	O
generated	O
for	O
IntStr	O
#	O
integerToString	O
(	O
args	O
)	O
was	O
similar	O
for	O
both	O
JVMs	O
,	O
although	O
Oracle	O
JDK	O
8u5	O
seemed	O
to	O
be	O
more	O
aggressive	O
w	O
.	O
r	O
.	O
t	O
.	O
inlining	O
some	O
calls	O
within	O
the	O
Integer	B-api_mention
#	I-api_mention
toString	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
code	O
.	O
There	O
was	O
a	O
clear	O
correspondence	O
with	O
the	O
Java	O
source	O
code	O
,	O
even	O
for	O
someone	O
with	O
minimal	O
assembly	O
experience	O
.	O
The	O
assembly	O
code	O
for	O
IntStr	B-api_mention
#	I-api_mention
stringBuilder0	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
,	O
however	O
,	O
was	O
radically	O
different	O
.	O
The	O
code	O
generated	O
by	O
Oracle	O
JDK	O
8u5	O
was	O
once	O
again	O
directly	O
related	O
to	O
the	O
Java	O
source	O
code	O
-	O
I	O
could	O
easily	O
recognise	O
the	O
same	O
layout	O
.	O
On	O
the	O
contrary	O
,	O
the	O
code	O
generated	O
by	O
OpenJDK	O
7	O
was	O
almost	O
unrecognisable	O
to	O
the	O
untrained	O
eye	O
(	O
like	O
mine	O
)	O
.	O
The	O
new	O
StringBuilder	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
call	O
was	O
seemingly	O
removed	O
,	O
as	O
was	O
the	O
creation	O
of	O
the	O
array	O
in	O
the	O
StringBuilder	B-api_mention
constructor	O
.	O
Additionaly	O
,	O
the	O
disassembler	O
plugin	O
was	O
not	O
able	O
to	O
provide	O
as	O
many	O
references	O
to	O
the	O
source	O
code	O
as	O
it	O
did	O
in	O
JDK	O
8	O
.	O
I	O
assume	O
that	O
this	O
is	O
either	O
the	O
result	O
of	O
a	O
much	O
more	O
aggressive	O
optimization	O
pass	O
in	O
OpenJDK	O
7	O
,	O
or	O
more	O
probably	O
the	O
result	O
of	O
inserting	O
hand	O
-	O
written	O
low	O
-	O
level	O
code	O
for	O
certain	O
StringBuilder	B-api_mention
operations	O
.	O
I	O
am	O
unsure	O
why	O
this	O
optimization	O
does	O
not	O
happen	O
in	O
my	O
JVM	O
8	O
implementation	O
or	O
why	O
the	O
same	O
optimizations	O
were	O
not	O
implemented	O
for	O
Integer	B-api_mention
#	I-api_mention
toString	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
in	O
JVM	O
7	O
.	O
I	O
guess	O
someone	O
familiar	O
with	O
the	O
related	O
parts	O
of	O
the	O
JRE	O
source	O
code	O
would	O
have	O
to	O
answer	O
these	O
questions	O
.	O
.	O
.	O
Question	O
-	O
27908213	O
,	O
answer	O
-	O
27908294	O
The	O
Oracle	O
documentation	O
about	O
Enum	O
says	O
(	O
first	O
line	O
)	O
:	O
#	O
blockquote	O
If	O
this	O
is	O
true	O
then	O
,	O
yes	O
,	O
your	O
enum1	O
.	O
name	O
(	O
args	O
)	O
=	O
=	O
enum2	O
.	O
name	O
(	O
args	O
)	O
is	O
guaranteed	O
to	O
be	O
true	O
if	O
the	O
names	O
are	O
the	O
same	O
.	O
Also	O
,	O
in	O
the	O
method	O
name	O
(	O
args	O
)	O
javadoc	O
:	O
#	O
blockquote	O
For	O
example	O
,	O
if	O
you	O
had	O
two	O
enums	O
,	O
Days	O
and	O
MyDays	O
,	O
where	O
SUNDAY	O
is	O
a	O
common	O
value	O
,	O
=	O
=	O
between	O
the	O
enum	O
object	O
values	O
,	O
SUNDAY	O
will	O
return	O
true	O
as	O
you	O
are	O
comparing	O
two	O
strings	O
-	O
see	O
the	O
working	O
example	O
in	O
#	O
a	O
.	O
#	O
pre	O
Question	O
-	O
6271417	O
,	O
answer	O
-	O
6271520	O
Try	O
using	O
this	O
.	B-api_mention
getClass	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
getCanonicalName	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
or	O
this	O
.	B-api_mention
getClass	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
getSimpleName	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
If	O
it	O
'	O
s	O
an	O
anonymous	O
class	O
,	O
use	O
this	O
.	B-api_mention
getClass	I-api_mention
.	I-api_mention
getSuperclass	I-api_mention
.	I-api_mention
getName	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
Question	O
-	O
27949213	O
Since	O
String	B-api_mention
in	O
Java	O
(	O
like	O
other	O
languages	O
)	O
consumes	O
a	O
lot	O
of	O
memory	O
because	O
each	O
character	O
consumes	O
two	O
bytes	O
,	O
Java	O
8	O
has	O
introduced	O
a	O
new	O
feature	O
called	O
String	O
Deduplication	O
which	O
takes	O
advantage	O
of	O
the	O
fact	O
that	O
the	O
char	O
arrays	O
are	O
internal	O
to	O
strings	O
and	O
final	O
,	O
so	O
the	O
JVM	O
can	O
mess	O
around	O
with	O
them	O
.	O
I	O
have	O
read	O
this	O
example	O
so	O
far	O
but	O
since	O
I	O
am	O
not	O
a	O
pro	O
java	O
coder	O
,	O
I	O
am	O
having	O
a	O
hard	O
time	O
grasping	O
the	O
concept	O
.	O
Here	O
is	O
what	O
it	O
says	O
,	O
#	O
blockquote	O
My	O
First	O
question	O
,	O
There	O
is	O
still	O
a	O
lack	O
of	O
resources	O
on	O
this	O
topic	O
since	O
it	O
is	O
recently	O
added	O
in	O
Java	O
8	O
update	O
20	O
,	O
could	O
anyone	O
here	O
share	O
some	O
practical	O
examples	O
on	O
how	O
it	O
help	O
in	O
reducing	O
the	O
memory	O
consumed	O
by	O
String	B-api_mention
in	O
Java	O
?	O
Edit	O
:	O
The	O
above	O
link	O
says	O
,	O
#	O
blockquote	O
My	O
2nd	O
question	O
,	O
If	O
hash	O
code	O
of	O
two	O
String	B-api_mention
are	O
same	O
then	O
the	O
Strings	O
are	O
already	O
the	O
same	O
,	O
then	O
why	O
compare	O
them	O
char	O
by	O
char	O
once	O
it	O
is	O
found	O
that	O
the	O
two	O
String	B-api_mention
have	O
same	O
hash	O
code	O
?	O
Question	O
-	O
22182669	O
,	O
answer	O
-	O
22222274	O
StackOverflowError	B-api_mention
occurs	O
due	O
to	O
an	O
application	O
recurses	O
too	O
deeply	O
(	O
This	O
is	O
not	O
an	O
answer	O
you	O
are	O
expecting	O
)	O
.	O
Now	O
other	O
things	O
to	O
happen	O
to	O
StackOverflowError	B-api_mention
is	O
keep	O
calling	O
methods	O
from	O
methods	O
till	O
you	O
get	O
StackOverflowError	B-api_mention
,	O
but	O
nobody	O
can	O
program	O
to	O
get	O
StackOverflowError	B-api_mention
and	O
even	O
if	O
those	O
programmer	O
are	O
doing	O
so	O
then	O
they	O
are	O
not	O
following	O
coding	O
standards	O
for	O
cyclomatic	O
complixity	O
that	O
every	O
programmer	O
has	O
to	O
understand	O
while	O
programming	O
.	O
Such	O
reason	O
for	O
'	B-api_mention
StackOverflowError	I-api_mention
'	I-api_mention
will	O
require	O
much	O
time	O
to	O
rectify	O
it	O
.	O
But	O
unknowingly	O
coding	O
one	O
line	O
or	O
two	O
line	O
which	O
causes	O
StackOverflowError	B-api_mention
is	O
understandable	O
and	O
JVM	O
throws	O
that	O
and	O
we	O
can	O
rectify	O
it	O
instantly	O
.	O
Here	O
is	O
my	O
answer	O
with	O
picture	O
for	O
some	O
other	O
question	O
.	O
Question	O
-	O
22725537	O
The	O
new	O
Java	O
8	O
stream	O
framework	O
and	O
friends	O
make	O
for	O
some	O
very	O
concise	O
java	O
code	O
,	O
but	O
I	O
have	O
come	O
across	O
a	O
seemingly	O
-	O
simple	O
situation	O
that	O
is	O
tricky	O
to	O
do	O
concisely	O
.	O
Consider	O
a	O
List	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
things	O
and	O
method	O
Optional	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
resolve	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
I	O
want	O
to	O
map	O
the	O
Thing	O
s	O
to	O
Optional	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
s	O
and	O
get	O
the	O
first	O
Other	O
.	O
The	O
obvious	O
solution	O
would	O
be	O
to	O
use	O
things	B-api_mention
.	I-api_mention
stream	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
flatMap	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
findFirst	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
,	O
but	O
flatMap	B-api_mention
requires	O
that	O
you	O
return	O
a	O
stream	O
,	O
and	O
Optional	B-api_mention
doesn	O
'	O
t	O
have	O
a	O
stream	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
(	O
or	O
is	O
it	O
a	O
Collection	B-api_mention
or	O
provide	O
a	O
method	O
to	O
convert	O
it	O
to	O
or	O
view	O
it	O
as	O
a	O
Collection	B-api_mention
)	O
.	O
The	O
best	O
I	O
can	O
come	O
up	O
with	O
is	O
this	O
:	O
things	B-api_mention
.	I-api_mention
stream	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
map	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
filter	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
map	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
findFirst	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
But	O
that	O
seems	O
awfully	O
long	O
-	O
winded	O
for	O
what	O
seems	O
like	O
a	O
very	O
common	O
case	O
.	O
Anyone	O
have	O
a	O
better	O
idea	O
?	O
Question	O
-	O
20129762	O
,	O
answer	O
-	O
30548433	O
I	O
would	O
like	O
to	O
point	O
out	O
that	O
StreamEx	O
does	O
implement	O
Iterable	B-api_mention
(	O
and	O
Stream	B-api_mention
)	O
,	O
as	O
well	O
as	O
a	O
host	O
of	O
other	O
immensely	O
awesome	O
functionality	O
missing	O
from	O
Stream	B-api_mention
.	O
Question	O
-	O
12576156	O
,	O
answer	O
-	O
12576308	O
Have	O
you	O
considered	O
@	O
Autowired	O
ing	O
the	O
constructor	O
or	O
a	O
setter	O
and	O
String	B-api_mention
.	I-api_mention
split	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
ing	O
in	O
the	O
body	O
?	O
#	O
pre	O
I	O
tend	O
to	O
prefer	O
doing	O
my	O
autowiring	O
in	O
one	O
of	O
these	O
ways	O
to	O
enhance	O
the	O
testability	O
of	O
my	O
code	O
.	O
Question	O
-	O
17489250	O
,	O
answer	O
-	O
17489394	O
It	O
'	O
s	O
a	O
feature	O
of	O
the	O
Java	O
language	O
.	O
String	B-api_mention
literals	O
in	O
the	O
source	O
code	O
is	O
given	O
special	O
treatment	O
.	O
The	O
language	O
spec	O
,	O
here	O
,	O
simply	O
says	O
that	O
a	O
string	O
literal	O
is	O
of	O
String	B-api_mention
type	O
Question	O
-	O
12146298	O
I	O
would	O
like	O
to	O
know	O
what	O
is	O
the	O
cleanest	O
and	O
best	O
way	O
to	O
perform	O
form	O
validation	O
of	O
user	O
inputs	O
.	O
I	O
have	O
seen	O
some	O
developers	O
implement	O
org	B-api_mention
.	I-api_mention
springframework	I-api_mention
.	I-api_mention
validation	I-api_mention
.	I-api_mention
Validator	I-api_mention
.	O
A	O
question	O
about	O
that	O
:	O
I	O
saw	O
it	O
validates	O
a	O
class	O
.	O
Does	O
the	O
class	O
have	O
to	O
be	O
filled	O
manually	O
with	O
the	O
values	O
from	O
the	O
user	O
input	O
,	O
and	O
then	O
passed	O
to	O
the	O
validator	O
?	O
I	O
am	O
confused	O
about	O
the	O
cleanest	O
and	O
best	O
way	O
to	O
validate	O
the	O
user	O
input	O
.	O
I	O
know	O
about	O
the	O
traditional	O
method	O
of	O
using	O
request	B-api_mention
.	I-api_mention
getParameter	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
and	O
then	O
manually	O
checking	O
for	O
nulls	O
,	O
but	O
I	O
don	O
'	O
t	O
want	O
to	O
do	O
all	O
the	O
validation	O
in	O
my	O
Controller	O
.	O
Some	O
good	O
advice	O
on	O
this	O
area	O
will	O
be	O
greatly	O
appreciated	O
.	O
I	O
am	O
not	O
using	O
Hibernate	O
in	O
this	O
application	O
.	O
Question	O
-	O
13744450	O
The	O
interviewer	O
asked	O
me	O
:	O
#	O
blockquote	O
I	O
wasn	O
'	O
t	O
aware	O
of	O
these	O
terms	O
.	O
So	O
,	O
when	O
I	O
came	O
back	O
to	O
home	O
,	O
then	O
I	O
started	O
looking	O
into	O
Google	O
about	O
Observer	B-api_mention
and	O
Observable	B-api_mention
and	O
found	O
some	O
point	O
from	O
different	O
resources	O
:	O
#	O
blockquote	O
I	O
found	O
this	O
example	O
:	O
#	O
pre	O
But	O
I	O
'	O
m	O
still	O
unable	O
to	O
figure	O
out	O
why	O
do	O
we	O
need	O
Observer	B-api_mention
and	O
Observable	B-api_mention
?	O
What	O
are	O
the	O
setChanged	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
and	O
notifyObservers	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
methods	O
for	O
?	O
Question	O
-	O
20918650	O
,	O
answer	O
-	O
20918709	O
A	O
subsequent	O
post	O
by	O
the	O
same	O
user	O
in	O
the	O
same	O
conversation	O
:	O
#	O
blockquote	O
(	O
This	O
was	O
in	O
response	O
to	O
a	O
statement	O
by	O
another	O
user	O
,	O
namely	O
that	O
"	O
it	O
seems	O
in	O
some	O
situations	O
'	O
new	O
T	B-api_mention
'	O
would	O
be	O
better	O
"	O
,	O
the	O
idea	O
being	O
that	O
new	O
T	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
is	O
impossible	O
due	O
to	O
type	O
erasure	O
.	O
(	O
This	O
is	O
debatable	O
—	O
even	O
if	O
T	B-api_mention
were	O
available	O
at	O
runtime	O
,	O
it	O
could	O
be	O
an	O
abstract	O
class	O
or	O
interface	O
,	O
or	O
it	O
could	O
be	O
Void	O
,	O
or	O
it	O
could	O
lack	O
a	O
no	O
-	O
arg	O
constructor	O
,	O
or	O
its	O
no	O
-	O
arg	O
constructor	O
could	O
be	O
private	O
(	O
e	O
.	O
g	O
.	O
,	O
because	O
it	O
'	O
s	O
supposed	O
to	O
be	O
a	O
singleton	O
class	O
)	O
,	O
or	O
its	O
no	O
-	O
arg	O
constructor	O
could	O
specify	O
a	O
checked	O
exception	O
that	O
the	O
generic	O
method	O
does	O
not	O
catch	O
or	O
specify	O
—	O
but	O
that	O
was	O
the	O
premise	O
.	O
Regardless	O
,	O
it	O
'	O
s	O
true	O
that	O
without	O
erasure	O
you	O
could	O
at	O
least	O
write	O
T	B-api_mention
.	I-api_mention
class	I-api_mention
.	I-api_mention
newInstance	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
,	O
which	O
handles	O
those	O
issues	O
.	O
)	O
)	O
This	O
view	O
,	O
that	O
types	O
are	O
isomorphic	O
to	O
propositions	O
,	O
suggests	O
that	O
the	O
user	O
has	O
a	O
background	O
in	O
formal	O
type	O
theory	O
.	O
(	O
S	O
)	O
he	O
very	O
likely	O
does	O
not	O
like	O
"	O
dynamic	O
types	O
"	O
or	O
"	O
runtime	O
-	O
types	O
"	O
and	O
would	O
prefer	O
a	O
Java	O
without	O
downcasts	O
and	O
instanceof	B-api_mention
and	O
reflection	O
and	O
so	O
on	O
.	O
(	O
Think	O
of	O
a	O
language	O
like	O
Standard	O
ML	O
,	O
which	O
has	O
a	O
very	O
rich	O
(	O
static	O
)	O
type	O
system	O
and	O
whose	O
dynamic	O
semantics	O
do	O
not	O
depend	O
on	O
any	O
type	O
information	O
whatsoever	O
.	O
)	O
It	O
'	O
s	O
worth	O
keeping	O
in	O
mind	O
,	O
by	O
the	O
way	O
,	O
that	O
the	O
user	O
is	O
trolling	O
:	O
while	O
(	O
s	O
)	O
he	O
likely	O
sincerely	O
prefers	O
(	O
statically	O
)	O
typed	O
languages	O
,	O
(	O
s	O
)	O
he	O
is	O
not	O
sincerely	O
trying	O
to	O
persuade	O
others	O
of	O
that	O
view	O
.	O
Rather	O
,	O
the	O
main	O
purpose	O
of	O
the	O
original	O
tweet	O
was	O
to	O
mock	O
those	O
who	O
disagree	O
,	O
and	O
after	O
some	O
of	O
those	O
disagree	O
-	O
ers	O
chimed	O
in	O
,	O
the	O
user	O
posted	O
follow	O
-	O
up	O
tweets	O
such	O
as	O
"	O
the	O
reason	O
java	O
has	O
type	O
erasure	O
is	O
that	O
Wadler	O
et	O
al	O
know	O
what	O
they	O
are	O
doing	O
,	O
unlike	O
users	O
of	O
java	O
"	O
.	O
Unfortunately	O
,	O
this	O
makes	O
it	O
hard	O
to	O
find	O
out	O
what	O
(	O
s	O
)	O
he	O
'	O
s	O
actually	O
thinking	O
;	O
but	O
fortunately	O
,	O
it	O
also	O
likely	O
means	O
that	O
it	O
'	O
s	O
not	O
very	O
important	O
to	O
do	O
so	O
.	O
People	O
with	O
actual	O
depth	O
to	O
their	O
views	O
don	O
'	O
t	O
generally	O
resort	O
to	O
trolls	O
that	O
are	O
quite	O
this	O
content	O
-	O
free	O
.	O
Question	O
-	O
21488056	O
,	O
answer	O
-	O
36242382	O
You	O
can	O
use	O
Predicates	O
from	O
Eclipse	O
Collections	O
#	O
pre	O
If	O
you	O
can	O
'	O
t	O
change	O
the	O
strings	O
from	O
List	B-api_mention
:	O
#	O
pre	O
If	O
you	O
only	O
need	O
a	O
negation	O
of	O
String	B-api_mention
.	I-api_mention
isEmpty	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
you	O
can	O
also	O
use	O
StringPredicates	B-api_mention
.	I-api_mention
notEmpty	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
Note	O
:	O
I	O
am	O
a	O
contributor	O
to	O
Eclipse	O
Collections	O
.	O
Question	O
-	O
29095967	O
,	O
answer	O
-	O
29111023	O
Although	O
there	O
are	O
several	O
answers	O
already	O
,	O
and	O
an	O
accepted	O
answer	O
,	O
there	O
are	O
still	O
a	O
couple	O
points	O
missing	O
from	O
this	O
topic	O
.	O
First	O
,	O
the	O
consensus	O
seems	O
to	O
be	O
that	O
solving	O
this	O
problem	O
using	O
streams	O
is	O
merely	O
an	O
exercise	O
,	O
and	O
that	O
the	O
conventional	O
for	O
-	O
loop	O
approach	O
is	O
preferable	O
.	O
Second	O
,	O
the	O
answers	O
given	O
thus	O
far	O
have	O
overlooked	O
an	O
approach	O
using	O
array	O
or	O
vector	O
-	O
style	O
techniques	O
that	O
I	O
think	O
improves	O
the	O
streams	O
solution	O
considerably	O
.	O
First	O
,	O
here	O
'	O
s	O
a	O
conventional	O
solution	O
,	O
for	O
purposes	O
of	O
discussion	O
and	O
analysis	O
:	O
#	O
pre	O
This	O
is	O
mostly	O
straightforward	O
but	O
there	O
'	O
s	O
a	O
bit	O
of	O
subtlety	O
.	O
One	O
point	O
is	O
that	O
a	O
pending	O
sublist	O
from	O
prev	O
to	O
cur	O
is	O
always	O
open	O
.	O
When	O
we	O
encounter	O
null	O
we	O
close	O
it	O
,	O
add	O
it	O
to	O
the	O
result	O
list	O
,	O
and	O
advance	O
prev	O
.	O
After	O
the	O
loop	O
we	O
close	O
the	O
sublist	O
unconditionally	O
.	O
Another	O
observation	O
is	O
that	O
this	O
is	O
a	O
loop	O
over	O
indexes	O
,	O
not	O
over	O
the	O
values	O
themselves	O
,	O
thus	O
we	O
use	O
an	O
arithmetic	O
for	O
-	O
loop	O
instead	O
of	O
the	O
enhanced	O
"	O
for	O
-	O
each	O
"	O
loop	O
.	O
But	O
it	O
suggests	O
that	O
we	O
can	O
stream	O
using	O
the	O
indexes	O
to	O
generate	O
subranges	O
instead	O
of	O
streaming	O
over	O
values	O
and	O
putting	O
the	O
logic	O
into	O
the	O
collector	O
(	O
as	O
was	O
done	O
by	O
Joop	O
Eggen	O
'	O
s	O
proposed	O
solution	O
)	O
.	O
Once	O
we	O
'	O
ve	O
realized	O
that	O
,	O
we	O
can	O
see	O
that	O
each	O
position	O
of	O
null	O
in	O
the	O
input	O
is	O
the	O
delimiter	O
for	O
a	O
sublist	O
:	O
it	O
'	O
s	O
the	O
right	O
end	O
of	O
the	O
sublist	O
to	O
the	O
left	O
,	O
and	O
it	O
(	O
plus	O
one	O
)	O
is	O
the	O
left	O
end	O
of	O
the	O
sublist	O
to	O
the	O
right	O
.	O
If	O
we	O
can	O
handle	O
the	O
edge	O
cases	O
,	O
it	O
leads	O
to	O
an	O
approach	O
where	O
we	O
find	O
the	O
indexes	O
at	O
which	O
null	O
elements	O
occur	O
,	O
map	O
them	O
to	O
sublists	O
,	O
and	O
collect	O
the	O
sublists	O
.	O
The	O
resulting	O
code	O
is	O
as	O
follows	O
:	O
#	O
pre	O
Getting	O
the	O
indexes	O
at	O
which	O
null	O
occurs	O
is	O
pretty	O
easy	O
.	O
The	O
stumbling	O
block	O
is	O
adding	O
-	O
1	O
at	O
the	O
left	O
and	O
size	O
at	O
the	O
right	O
end	O
.	O
I	O
'	O
ve	O
opted	O
to	O
use	O
Stream	B-api_mention
.	I-api_mention
of	I-api_mention
to	O
do	O
the	O
appending	O
and	O
then	O
flatMapToInt	O
to	O
flatten	O
them	O
out	O
.	O
(	O
I	O
tried	O
several	O
other	O
approaches	O
but	O
this	O
one	O
seemed	O
like	O
the	O
cleanest	O
.	O
)	O
It	O
'	O
s	O
a	O
bit	O
more	O
convenient	O
to	O
use	O
arrays	O
for	O
the	O
indexes	O
here	O
.	O
First	O
,	O
the	O
notation	O
for	O
accessing	O
an	O
array	O
is	O
nicer	O
than	O
for	O
a	O
List	B-api_mention
:	O
indexes	O
[	O
i	O
]	O
vs	O
.	O
indexes	O
.	B-api_mention
get	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
Second	O
,	O
using	O
an	O
array	O
avoids	O
boxing	O
.	O
At	O
this	O
point	O
,	O
each	O
index	O
value	O
in	O
the	O
array	O
(	O
except	O
for	O
the	O
last	O
)	O
is	O
one	O
less	O
than	O
the	O
beginning	O
position	O
of	O
a	O
sublist	O
.	O
The	O
index	O
to	O
its	O
immediate	O
right	O
is	O
the	O
end	O
of	O
the	O
sublist	O
.	O
We	O
simply	O
stream	O
over	O
the	O
array	O
and	O
map	O
each	O
pair	O
of	O
indexes	O
into	O
a	O
sublist	O
and	O
collect	O
the	O
output	O
.	O
Discussion	O
The	O
streams	O
approach	O
is	O
slightly	O
shorter	O
than	O
the	O
for	O
-	O
loop	O
version	O
,	O
but	O
it	O
'	O
s	O
denser	O
.	O
The	O
for	O
-	O
loop	O
version	O
is	O
familiar	O
,	O
because	O
we	O
do	O
this	O
stuff	O
in	O
Java	O
all	O
the	O
time	O
,	O
but	O
if	O
you	O
'	O
re	O
not	O
already	O
aware	O
of	O
what	O
this	O
loop	O
is	O
supposed	O
to	O
be	O
doing	O
,	O
it	O
'	O
s	O
not	O
obvious	O
.	O
You	O
might	O
have	O
to	O
simulate	O
a	O
few	O
loop	O
executions	O
before	O
you	O
figure	O
out	O
what	O
prev	O
is	O
doing	O
and	O
why	O
the	O
open	O
sublist	O
has	O
to	O
be	O
closed	O
after	O
the	O
end	O
of	O
the	O
loop	O
.	O
(	O
I	O
initially	O
forgot	O
to	O
have	O
it	O
,	O
but	O
I	O
caught	O
this	O
in	O
testing	O
.	O
)	O
The	O
streams	O
approach	O
is	O
,	O
I	O
think	O
,	O
easier	O
to	O
conceptualize	O
what	O
'	O
s	O
going	O
on	O
:	O
get	O
a	O
list	O
(	O
or	O
an	O
array	O
)	O
that	O
indicates	O
the	O
boundaries	O
between	O
sublists	O
.	O
That	O
'	O
s	O
an	O
easy	O
streams	O
two	O
-	O
liner	O
.	O
The	O
difficulty	O
,	O
as	O
I	O
mentioned	O
above	O
,	O
is	O
finding	O
a	O
way	O
to	O
tack	O
the	O
edge	O
values	O
onto	O
the	O
ends	O
.	O
If	O
there	O
were	O
a	O
better	O
syntax	O
for	O
doing	O
this	O
,	O
e	O
.	O
g	O
.	O
,	O
/	O
/	O
Java	O
plus	O
pidgin	O
Scala	O
int	O
[	O
]	O
indexes	O
=	O
[	O
-	O
1	O
]	O
+	O
+	O
IntStream	B-api_mention
.	I-api_mention
range	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
filter	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
+	O
+	O
[	O
input	O
.	O
size	O
(	O
args	O
)	O
]	O
;	O
it	O
would	O
make	O
things	O
a	O
lot	O
less	O
cluttered	O
.	O
(	O
What	O
we	O
really	O
need	O
is	O
array	O
or	O
list	O
comprehension	O
.	O
)	O
Once	O
you	O
have	O
the	O
indexes	O
,	O
it	O
'	O
s	O
a	O
simple	O
matter	O
to	O
map	O
them	O
into	O
actual	O
sublists	O
and	O
collect	O
them	O
into	O
the	O
result	O
list	O
.	O
And	O
of	O
course	O
this	O
is	O
safe	O
when	O
run	O
in	O
parallel	O
.	O
UPDATE	O
2016	O
-	O
02	O
-	O
06	O
Here	O
'	O
s	O
a	O
nicer	O
way	O
to	O
create	O
the	O
array	O
of	O
sublist	O
indexes	O
.	O
It	O
'	O
s	O
based	O
on	O
the	O
same	O
principles	O
,	O
but	O
it	O
adjusts	O
the	O
index	O
range	O
and	O
adds	O
some	O
conditions	O
to	O
the	O
filter	O
to	O
avoid	O
having	O
to	O
concatenate	O
and	O
flatmap	O
the	O
indexes	O
.	O
#	O
pre	O
Question	O
-	O
16159203	O
,	O
answer	O
-	O
18258659	O
You	O
have	O
ordinary	O
memory	O
,	O
the	O
'	O
currentpos	O
'	O
reference	O
and	O
the	O
Point	B-api_mention
object	O
and	O
its	O
fields	O
behind	O
it	O
,	O
shared	O
between	O
2	O
threads	O
,	O
without	O
synchronisation	O
.	O
Thus	O
,	O
there	O
is	O
no	O
defined	O
ordering	O
between	O
the	O
writes	O
that	O
happen	O
to	O
this	O
memory	O
in	O
the	O
main	O
thread	O
and	O
the	O
reads	O
in	O
the	O
created	O
thread	O
(	O
call	O
it	O
T	O
)	O
.	O
Main	O
thread	O
is	O
doing	O
the	O
following	O
writes	O
(	O
ignoring	O
the	O
initial	O
setup	O
of	O
point	O
,	O
will	O
result	O
in	O
p	O
.	O
x	O
and	O
p	O
.	O
y	O
having	O
default	O
values	O
)	O
:	O
#	O
li	O
to	O
p	O
.	O
x	O
#	O
li	O
to	O
p	O
.	O
y	O
#	O
li	O
to	O
currentpos	O
Because	O
there	O
is	O
nothing	O
special	O
about	O
these	O
writes	O
in	O
terms	O
of	O
synchronisation	O
/	O
barriers	O
,	O
the	O
runtime	O
is	O
free	O
to	O
allow	O
the	O
T	O
thread	O
see	O
them	O
occur	O
in	O
any	O
order	O
(	O
the	O
main	O
thread	O
of	O
course	O
always	O
sees	O
writes	O
and	O
reads	O
ordered	O
according	O
to	O
programme	O
order	O
)	O
,	O
and	O
occur	O
at	O
any	O
point	O
between	O
the	O
reads	O
in	O
T	O
.	O
So	O
T	O
is	O
doing	O
:	O
#	O
li	O
reads	O
currentpos	O
to	O
p	O
#	O
li	O
read	O
p	O
.	O
x	O
and	O
p	O
.	O
y	O
(	O
in	O
either	O
order	O
)	O
#	O
li	O
compare	O
,	O
and	O
take	O
the	O
branch	O
#	O
li	O
read	O
p	O
.	O
x	O
and	O
p	O
.	O
y	O
(	O
either	O
order	O
)	O
and	O
call	O
System	B-api_mention
.	I-api_mention
out	I-api_mention
.	I-api_mention
println	I-api_mention
Given	O
there	O
'	O
s	O
no	O
ordering	O
relationships	O
between	O
the	O
writes	O
in	O
main	O
,	O
and	O
the	O
reads	O
in	O
T	O
,	O
there	O
are	O
clearly	O
several	O
ways	O
this	O
can	O
produce	O
your	O
result	O
,	O
as	O
T	O
may	O
see	O
main	O
'	O
s	O
write	O
to	O
currentpos	O
before	O
the	O
writes	O
to	O
currentpos	O
.	O
y	O
or	O
currentpos	O
.	O
x	O
:	O
#	O
li	O
It	O
reads	O
currentpos	O
.	O
x	O
first	O
,	O
before	O
the	O
x	O
write	O
has	O
occurred	O
-	O
gets	O
0	O
,	O
then	O
reads	O
currentpos	O
.	O
y	O
before	O
the	O
y	O
write	O
has	O
occurred	O
-	O
gets	O
0	O
.	O
Compare	O
evals	O
to	O
true	O
.	O
The	O
writes	O
become	O
visible	O
to	O
T	O
.	O
System	B-api_mention
.	I-api_mention
out	I-api_mention
.	I-api_mention
println	I-api_mention
is	O
called	O
.	O
#	O
li	O
It	O
reads	O
currentpos	O
.	O
x	O
first	O
,	O
after	O
the	O
x	O
write	O
has	O
occurred	O
,	O
then	O
reads	O
currentpos	O
.	O
y	O
before	O
the	O
y	O
write	O
has	O
occurred	O
-	O
gets	O
0	O
.	O
Compare	O
evals	O
to	O
true	O
.	O
Writes	O
become	O
visible	O
to	O
T	O
.	O
.	O
.	O
etc	O
.	O
#	O
li	O
It	O
reads	O
currentpos	O
.	O
y	O
first	O
,	O
before	O
the	O
y	O
write	O
has	O
occurred	O
(	O
0	O
)	O
,	O
then	O
reads	O
currentpos	O
.	O
x	O
after	O
the	O
x	O
write	O
,	O
evals	O
to	O
true	O
.	O
etc	O
.	O
and	O
so	O
on	O
.	O
.	O
.	O
There	O
are	O
a	O
number	O
of	O
data	O
races	O
here	O
.	O
I	O
suspect	O
the	O
flawed	O
assumption	O
here	O
is	O
thinking	O
that	O
the	O
writes	O
that	O
result	O
from	O
this	O
line	O
are	O
made	O
visible	O
across	O
all	O
the	O
threads	O
in	O
the	O
programme	O
order	O
of	O
the	O
thread	O
executing	O
it	O
:	O
currentPos	O
=	O
new	O
Point	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Java	O
makes	O
no	O
such	O
guarantee	O
(	O
it	O
'	O
d	O
be	O
terrible	O
for	O
performance	O
)	O
.	O
Something	O
more	O
must	O
be	O
added	O
if	O
your	O
programme	O
needs	O
a	O
guaranteed	O
ordering	O
of	O
the	O
writes	O
relative	O
to	O
reads	O
in	O
other	O
threads	O
.	O
Others	O
have	O
suggested	O
making	O
the	O
x	O
,	O
y	O
fields	O
final	O
,	O
or	O
alternatively	O
making	O
currentpos	O
volatile	O
.	O
#	O
li	O
If	O
you	O
make	O
the	O
x	O
,	O
y	O
fields	O
final	O
,	O
then	O
Java	O
guarantees	O
that	O
the	O
writes	O
of	O
their	O
values	O
will	O
be	O
seen	O
to	O
occur	O
before	O
the	O
constructor	O
returns	O
,	O
in	O
all	O
threads	O
.	O
Thus	O
,	O
as	O
the	O
assignment	O
to	O
currentpos	O
is	O
after	O
the	O
constructor	O
,	O
the	O
T	O
thread	O
is	O
guaranteed	O
to	O
see	O
the	O
writes	O
in	O
the	O
correct	O
order	O
.	O
#	O
li	O
If	O
you	O
make	O
currentpos	O
volatile	O
,	O
then	O
Java	O
guarantees	O
that	O
that	O
this	O
is	O
a	O
synchronisation	O
point	O
which	O
will	O
be	O
total	O
-	O
ordered	O
wrt	O
other	O
synchronisation	O
points	O
.	O
As	O
in	O
main	O
the	O
writes	O
to	O
x	O
and	O
y	O
must	O
happen	O
before	O
the	O
write	O
to	O
currentpos	O
,	O
then	O
any	O
read	O
of	O
currentpos	O
in	O
another	O
thread	O
must	O
see	O
also	O
the	O
writes	O
of	O
x	O
,	O
y	O
that	O
happened	O
before	O
.	O
Using	O
final	O
has	O
the	O
advantage	O
that	O
it	O
makes	O
the	O
fields	O
immutable	O
,	O
and	O
thus	O
allows	O
the	O
values	O
to	O
be	O
cached	O
.	O
Using	O
volatile	O
leads	O
to	O
synchronisation	O
on	O
every	O
write	O
and	O
read	O
of	O
currentpos	O
,	O
which	O
might	O
hurt	O
performance	O
.	O
See	O
chapter	O
17	O
of	O
the	O
Java	O
Language	O
Spec	O
for	O
the	O
gory	O
details	O
:	O
#	O
a	O
(	O
Initial	O
answer	O
assumed	O
a	O
weaker	O
memory	O
model	O
,	O
as	O
I	O
was	O
not	O
sure	O
the	O
JLS	O
guaranteed	O
volatile	O
was	O
sufficient	O
.	O
Answer	O
edited	O
to	O
reflect	O
comment	O
from	O
assylias	O
,	O
pointing	O
out	O
the	O
Java	O
model	O
is	O
stronger	O
-	O
happens	O
-	O
before	O
is	O
transitive	O
-	O
and	O
so	O
volatile	O
on	O
currentpos	O
also	O
suffices	O
)	O
.	O
Question	O
-	O
10631715	O
,	O
answer	O
-	O
32362691	O
For	O
completeness	O
,	O
using	O
the	O
Guava	O
library	O
,	O
you	O
'	O
d	O
do	O
:	O
Splitter	B-api_mention
.	I-api_mention
on	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
split	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
Another	O
example	O
:	O
#	O
pre	O
Splitter	B-api_mention
.	I-api_mention
split	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
returns	O
an	O
Iterable	O
,	O
so	O
if	O
you	O
need	O
a	O
List	O
,	O
wrap	O
it	O
in	O
Lists	B-api_mention
.	I-api_mention
newArrayList	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
as	O
above	O
.	O
Otherwise	O
just	O
go	O
with	O
the	O
Iterable	O
,	O
for	O
example	O
:	O
#	O
pre	O
Note	O
how	O
trimResults	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
handles	O
all	O
your	O
trimming	O
needs	O
without	O
having	O
to	O
tweak	O
regexes	O
for	O
corner	O
cases	O
,	O
as	O
with	O
String	B-api_mention
.	I-api_mention
split	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
If	O
your	O
project	O
uses	O
Guava	O
already	O
,	O
this	O
should	O
be	O
your	O
preferred	O
solution	O
.	O
See	O
Splitter	B-api_mention
documentation	O
in	O
Guava	O
User	O
Guide	O
or	O
the	O
javadocs	O
for	O
more	O
configuration	O
options	O
.	O
Question	O
-	O
27845223	O
,	O
answer	O
-	O
27846417	O
Pavel	O
Horal	O
'	O
s	O
answer	O
is	O
nice	O
.	O
As	O
he	O
says	O
,	O
the	O
word	O
"	O
file	O
"	O
has	O
totally	O
different	O
(	O
practically	O
unrelated	O
)	O
meanings	O
in	O
URL	B-api_mention
#	O
getFile	B-api_mention
vs	O
java	O
.	O
io	O
.	O
File	O
-	O
may	O
be	O
that	O
'	O
s	O
part	O
of	O
the	O
confusion	O
.	O
Just	O
to	O
add	O
:	O
#	O
li	O
A	O
resource	O
in	O
Java	O
is	O
an	O
abstract	O
concept	O
,	O
a	O
source	O
of	O
data	O
that	O
can	O
be	O
read	O
.	O
The	O
location	O
(	O
or	O
address	O
)	O
of	O
a	O
resource	O
is	O
represented	O
in	O
Java	O
by	O
a	O
URL	B-api_mention
object	O
.	O
#	O
li	O
A	O
resource	O
can	O
correspond	O
to	O
a	O
regular	O
file	O
in	O
the	O
local	O
filesystem	O
(	O
specifically	O
,	O
when	O
its	O
URL	O
begins	O
with	O
file	O
:	O
/	O
/	O
)	O
.	O
But	O
a	O
resource	O
is	O
more	O
general	O
(	O
it	O
can	O
be	O
also	O
some	O
file	O
stored	O
in	O
a	O
jar	O
,	O
or	O
some	O
data	O
to	O
be	O
read	O
from	O
the	O
network	O
,	O
or	O
from	O
memory	O
,	O
or	O
.	O
.	O
.	O
)	O
.	O
And	O
it	O
'	O
s	O
also	O
more	O
limited	O
,	O
because	O
a	O
File	B-api_mention
(	O
besides	O
being	O
other	O
things	O
than	O
a	O
regular	O
file	O
:	O
a	O
directory	O
,	O
a	O
link	O
)	O
can	O
also	O
be	O
created	O
and	O
writen	O
to	O
.	O
#	O
li	O
Remember	O
in	O
Java	O
a	O
File	B-api_mention
object	O
does	O
not	O
really	O
represents	O
"	O
a	O
file	O
"	O
but	O
the	O
location	O
(	O
the	O
full	O
name	O
,	O
with	O
path	O
)	O
of	O
a	O
file	O
.	O
So	O
,	O
a	O
File	B-api_mention
object	O
allows	O
you	O
to	O
locate	O
(	O
and	O
open	O
)	O
a	O
file	O
,	O
as	O
a	O
URL	B-api_mention
allows	O
you	O
to	O
access	O
(	O
and	O
open	O
)	O
a	O
resource	O
.	O
(	O
There	O
is	O
no	O
Resource	B-api_mention
class	O
in	O
Java	O
to	O
represent	O
a	O
resource	O
,	O
but	O
neither	O
there	O
is	O
one	O
to	O
represent	O
a	O
file	O
!	O
once	O
more	O
:	O
File	B-api_mention
is	O
not	O
a	O
file	O
,	O
it	O
'	O
s	O
the	O
path	O
of	O
a	O
file	O
)	O
.	O
Question	O
-	O
32294367	O
,	O
answer	O
-	O
32294898	O
#	O
blockquote	O
Let	O
me	O
ask	O
a	O
counterquestion	O
:	O
why	O
do	O
you	O
think	O
Thread	B-api_mention
.	I-api_mention
stop	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
has	O
been	O
deprecated	O
for	O
more	O
than	O
a	O
decade	O
?	O
The	O
reason	O
why	O
is	O
precisely	O
the	O
negation	O
of	O
your	O
statement	O
above	O
.	O
To	O
give	O
two	O
specific	O
examples	O
:	O
you	O
stop	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
a	O
thread	O
while	O
it	O
'	O
s	O
executing	O
something	O
as	O
innocuous	O
-	O
sounding	O
as	O
System	B-api_mention
.	I-api_mention
out	I-api_mention
.	I-api_mention
println	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
or	O
Math	B-api_mention
.	I-api_mention
random	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
Result	O
:	O
those	O
two	O
features	O
are	O
now	O
broken	O
for	O
the	O
entire	O
JVM	O
.	O
The	O
same	O
pertains	O
to	O
any	O
other	O
synchronized	O
code	O
your	O
application	O
may	O
execute	O
.	O
#	O
blockquote	O
The	O
application	O
may	O
theoretically	O
be	O
coded	O
such	O
that	O
absolutely	O
no	O
shared	O
resource	O
protected	O
by	O
locks	O
is	O
ever	O
used	O
;	O
however	O
that	O
will	O
only	O
help	O
to	O
point	O
out	O
the	O
exact	O
extent	O
to	O
which	O
Java	O
threads	O
are	O
codependent	O
.	O
And	O
the	O
"	O
independence	O
"	O
achieved	O
will	O
only	O
pertain	O
to	O
the	O
request	O
-	O
processing	O
threads	O
,	O
not	O
to	O
all	O
threads	O
in	O
such	O
an	O
application	O
.	O
Question	O
-	O
7935858	O
I	O
have	O
prepared	O
a	O
simple	O
code	O
snippet	O
in	O
order	O
to	O
separate	O
the	O
erroneous	O
portion	O
from	O
my	O
web	O
application	O
.	O
#	O
pre	O
I	O
have	O
tested	O
it	O
while	O
building	O
a	O
web	O
application	O
JSF	O
.	O
I	O
just	O
want	O
to	O
know	O
why	O
in	O
the	O
above	O
code	O
temp	O
.	O
split	O
(	O
args	O
)	O
does	O
not	O
work	O
.	O
The	O
statement	O
,	O
System	B-api_mention
.	I-api_mention
out	I-api_mention
.	I-api_mention
println	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
displays	O
nothing	O
on	O
the	O
console	O
means	O
that	O
it	O
doesn	O
'	O
t	O
go	O
through	O
the	O
loop	O
.	O
When	O
I	O
change	O
the	O
argument	O
of	O
the	O
temp	O
.	B-api_mention
split	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
to	O
other	O
characters	O
,	O
It	O
works	O
just	O
fine	O
as	O
usual	O
.	O
What	O
might	O
be	O
the	O
problem	O
?	O
Question	O
-	O
27504925	O
The	O
Java	O
language	O
specification	O
specifies	O
that	O
#	O
blockquote	O
So	O
,	O
considering	O
arrays	O
are	O
objects	O
—	O
why	O
did	O
the	O
Java	O
designers	O
make	O
the	O
decision	O
not	O
to	O
allow	O
inherit	O
and	O
override	O
from	O
it	O
,	O
for	O
example	O
,	O
toString	B-api_mention
(	I-api_mention
)	I-api_mention
or	O
equals	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
?	O
The	O
current	O
syntax	O
wouldn	O
'	O
t	O
allow	O
creating	O
anonymous	O
classes	O
with	O
an	O
array	O
as	O
the	O
base	O
class	O
,	O
but	O
I	O
don	O
'	O
t	O
think	O
that	O
was	O
the	O
reason	O
for	O
their	O
decision	O
.	O
Question	O
-	O
22382453	O
,	O
answer	O
-	O
22384113	O
Made	O
up	O
example	O
Imagine	O
that	O
you	O
want	O
to	O
create	O
the	O
following	O
sequence	O
:	O
1	O
,	O
2	O
,	O
2	O
,	O
3	O
,	O
3	O
,	O
3	O
,	O
4	O
,	O
4	O
,	O
4	O
,	O
4	O
etc	O
.	O
(	O
in	O
other	O
words	O
:	O
1x1	O
,	O
2x2	O
,	O
3x3	O
etc	O
.	O
)	O
With	O
flatMap	B-api_mention
it	O
could	O
look	O
like	O
:	O
#	O
pre	O
where	O
:	O
#	O
li	O
IntStream	B-api_mention
.	I-api_mention
rangeClosed	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
creates	O
a	O
stream	O
of	O
int	O
from	O
1	O
to	O
4	O
,	O
inclusive	O
#	O
li	O
IntStream	B-api_mention
.	I-api_mention
iterate	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
limit	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
creates	O
a	O
stream	O
of	O
length	O
i	O
of	O
int	O
i	O
-	O
so	O
applied	O
to	O
i	O
=	O
4	O
it	O
creates	O
a	O
stream	O
:	O
4	O
,	O
4	O
,	O
4	O
,	O
4	O
#	O
li	O
flatMap	B-api_mention
"	O
flattens	O
"	O
the	O
stream	O
and	O
"	O
concatenates	O
"	O
it	O
to	O
the	O
original	O
stream	O
With	O
Java	O
<	O
8	O
you	O
would	O
need	O
two	O
nested	O
loops	O
:	O
#	O
pre	O
Real	O
world	O
example	O
Let	O
'	O
s	O
say	O
I	O
have	O
a	O
List	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
where	O
each	O
TimeSeries	O
is	O
essentially	O
a	O
Map	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
.	O
I	O
want	O
to	O
get	O
a	O
list	O
of	O
all	O
dates	O
for	O
which	O
at	O
least	O
one	O
of	O
the	O
time	O
series	O
has	O
a	O
value	O
.	O
flatMap	B-api_mention
to	O
the	O
rescue	O
:	O
list	O
.	B-api_mention
stream	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
parallel	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
flatMap	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
/	O
/	O
for	O
each	O
TS	O
,	O
stream	O
dates	O
and	O
flatmap	O
.	B-api_mention
distinct	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
/	O
/	O
remove	O
duplicates	O
.	B-api_mention
sorted	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
/	O
/	O
sort	O
ascending	O
.	B-api_mention
collect	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Not	O
only	O
is	O
it	O
readable	O
,	O
but	O
if	O
you	O
suddenly	O
need	O
to	O
process	O
100k	O
elements	O
,	O
simply	O
adding	O
parallel	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
will	O
improve	O
performance	O
without	O
you	O
writing	O
any	O
concurrent	O
code	O
.	O
Question	O
-	O
10977992	O
#	O
pre	O
We	O
can	O
use	O
Iterator	B-api_mention
to	O
traverse	O
a	O
Set	B-api_mention
or	O
a	O
List	B-api_mention
or	O
a	O
Map	B-api_mention
.	O
But	O
ListIterator	B-api_mention
can	O
only	O
be	O
used	O
to	O
traverse	O
a	O
List	B-api_mention
,	O
it	O
can	O
'	O
t	O
traverse	O
a	O
Set	B-api_mention
.	O
Why	O
?	O
I	O
know	O
that	O
the	O
main	O
difference	O
is	O
that	O
with	O
iterator	B-api_mention
we	O
can	O
travel	O
in	O
only	O
one	O
direction	O
but	O
with	O
ListIterator	B-api_mention
we	O
can	O
travel	O
both	O
directions	O
.	O
Are	O
there	O
any	O
other	O
differences	O
?	O
And	O
any	O
advantages	O
of	O
ListIterator	B-api_mention
over	O
Iterator	B-api_mention
?	O
Question	O
-	O
6470651	O
,	O
answer	O
-	O
6470695	O
A	O
simple	O
thing	O
to	O
do	O
is	O
to	O
use	O
a	O
HashSet	B-api_mention
with	O
an	O
incorrect	O
(	O
or	O
non	O
-	O
existent	O
)	O
hashCode	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
or	O
equals	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
,	O
and	O
then	O
keep	O
adding	O
"	O
duplicates	O
"	O
.	O
Instead	O
of	O
ignoring	O
duplicates	O
as	O
it	O
should	O
,	O
the	O
set	O
will	O
only	O
ever	O
grow	O
and	O
you	O
won	O
'	O
t	O
be	O
able	O
to	O
remove	O
them	O
.	O
If	O
you	O
want	O
these	O
bad	O
keys	O
/	O
elements	O
to	O
hang	O
around	O
you	O
can	O
use	O
a	O
static	O
field	O
like	O
#	O
pre	O
Question	O
-	O
15655012	O
,	O
answer	O
-	O
24895623	O
First	O
of	O
all	O
,	O
the	O
place	O
in	O
your	O
code	O
where	O
you	O
are	O
initializing	O
(	O
i	O
.	O
e	O
.	O
assigning	O
for	O
the	O
first	O
time	O
)	O
foo	O
is	O
here	O
:	O
foo	O
=	O
new	O
ArrayList	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
foo	O
is	O
an	O
object	O
(	O
with	O
type	O
List	O
)	O
so	O
it	O
is	O
a	O
reference	O
type	O
,	O
not	O
a	O
value	O
type	O
(	O
like	O
int	O
)	O
.	O
As	O
such	O
,	O
it	O
holds	O
a	O
reference	O
to	O
a	O
memory	O
location	O
(	O
e	O
.	O
g	O
.	O
0xA7D2A834	O
)	O
where	O
your	O
List	B-api_mention
elements	O
are	O
stored	O
.	O
Lines	O
like	O
this	O
foo	O
.	O
add	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
/	O
/	O
Modification	O
-	O
1	O
do	O
not	O
change	O
the	O
value	O
of	O
foo	O
(	O
which	O
,	O
again	O
,	O
is	O
just	O
a	O
reference	O
to	O
a	O
memory	O
location	O
)	O
.	O
Instead	O
,	O
they	O
just	O
add	O
elements	O
into	O
that	O
referenced	O
memory	O
location	O
.	O
To	O
violate	O
the	O
final	O
keyword	O
,	O
you	O
would	O
have	O
to	O
try	O
to	O
re	O
-	O
assign	O
foo	O
as	O
follows	O
again	O
:	O
foo	O
=	O
new	O
ArrayList	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
That	O
would	O
give	O
you	O
a	O
compilation	O
error	O
.	O
Now	O
,	O
with	O
that	O
out	O
of	O
the	O
way	O
,	O
think	O
about	O
what	O
happens	O
when	O
you	O
add	O
the	O
static	O
keyword	O
.	O
When	O
you	O
do	O
NOT	O
have	O
the	O
static	O
keyword	O
,	O
each	O
object	O
that	O
instantiates	O
the	O
class	O
has	O
its	O
own	O
copy	O
of	O
foo	O
.	O
Therefore	O
,	O
the	O
constructor	O
assigns	O
a	O
value	O
to	O
a	O
blank	O
,	O
fresh	O
copy	O
of	O
the	O
foo	O
variable	O
,	O
which	O
is	O
perfectly	O
fine	O
.	O
However	O
,	O
when	O
you	O
DO	O
have	O
the	O
static	O
keyword	O
,	O
only	O
one	O
foo	O
exists	O
in	O
memory	O
that	O
is	O
associated	O
with	O
the	O
class	O
.	O
If	O
you	O
were	O
to	O
create	O
two	O
or	O
more	O
objects	O
,	O
the	O
constructor	O
would	O
be	O
attempting	O
to	O
re	O
-	O
assign	O
that	O
one	O
foo	O
each	O
time	O
,	O
violating	O
the	O
final	O
keyword	O
.	O
Question	O
-	O
31922866	O
I	O
'	O
ve	O
read	O
on	O
many	O
Web	O
sites	O
Optional	B-api_mention
should	O
be	O
used	O
as	O
a	O
return	O
type	O
only	O
,	O
and	O
not	O
used	O
in	O
method	O
arguments	O
.	O
I	O
'	O
m	O
struggling	O
to	O
find	O
a	O
logical	O
reason	O
why	O
.	O
For	O
example	O
I	O
have	O
a	O
piece	O
of	O
logic	O
which	O
has	O
2	O
optional	O
parameters	O
.	O
Therefore	O
I	O
think	O
it	O
would	O
make	O
sense	O
to	O
write	O
my	O
method	O
signature	O
like	O
this	O
(	O
solution	O
1	O
)	O
:	O
#	O
pre	O
Many	O
web	O
pages	O
specify	O
Optional	B-api_mention
should	O
not	O
be	O
used	O
as	O
method	O
arguments	O
.	O
With	O
this	O
in	O
mind	O
I	O
could	O
use	O
the	O
following	O
method	O
signature	O
and	O
add	O
a	O
clear	O
Javadoc	O
comment	O
specifying	O
the	O
arguments	O
maybe	O
null	O
hoping	O
future	O
future	O
maintainers	O
will	O
read	O
the	O
javadoc	O
and	O
therefore	O
always	O
carry	O
out	O
null	O
checks	O
prior	O
to	O
using	O
the	O
arguments	O
(	O
solution	O
2	O
)	O
:	O
#	O
pre	O
Alternatively	O
I	O
could	O
replace	O
my	O
method	O
with	O
4	O
public	O
methods	O
to	O
provide	O
a	O
nicer	O
interface	O
and	O
make	O
it	O
more	O
obvious	O
p1	O
and	O
p2	O
are	O
optional	O
(	O
solution	O
3	O
)	O
:	O
#	O
pre	O
Now	O
I	O
try	O
writing	O
the	O
code	O
of	O
the	O
class	O
which	O
invokes	O
this	O
piece	O
of	O
logic	O
for	O
each	O
approach	O
.	O
I	O
first	O
retrieve	O
the	O
2	O
input	O
parameters	O
from	O
another	O
object	O
which	O
returns	O
optionals	O
and	O
then	O
I	O
invoke	O
calculateSomething	O
.	O
Therefore	O
if	O
solution	O
1	O
is	O
used	O
the	O
calling	O
code	O
would	O
look	O
like	O
this	O
:	O
#	O
pre	O
if	O
solution	O
2	O
is	O
used	O
the	O
calling	O
code	O
would	O
look	O
like	O
this	O
:	O
#	O
pre	O
if	O
solution	O
3	O
is	O
used	O
I	O
could	O
use	O
the	O
code	O
above	O
or	O
I	O
could	O
use	O
the	O
following	O
(	O
but	O
its	O
a	O
significant	O
amount	O
more	O
code	O
)	O
:	O
#	O
pre	O
So	O
my	O
question	O
is	O
why	O
is	O
it	O
considered	O
bad	O
practice	O
to	O
use	O
Optionals	O
as	O
method	O
arguments	O
as	O
in	O
solution	O
1	O
?	O
It	O
looks	O
like	O
the	O
most	O
readable	O
solution	O
to	O
me	O
and	O
makes	O
it	O
most	O
obvious	O
that	O
the	O
parameters	O
could	O
be	O
empty	O
/	O
null	O
to	O
future	O
maintainers	O
.	O
(	O
I	O
'	O
m	O
aware	O
the	O
designers	O
of	O
Optional	B-api_mention
intended	O
it	O
to	O
only	O
be	O
used	O
as	O
a	O
return	O
type	O
,	O
but	O
I	O
can	O
'	O
t	O
find	O
any	O
logical	O
reasons	O
not	O
to	O
use	O
it	O
in	O
this	O
scenario	O
)	O
Question	O
-	O
8725387	O
,	O
answer	O
-	O
8725518	O
Because	O
the	O
concept	O
of	O
a	O
List	B-api_mention
is	O
incompatible	O
with	O
the	O
concept	O
of	O
an	O
automatically	O
sorted	O
collection	O
.	O
The	O
point	O
of	O
a	O
List	B-api_mention
is	O
that	O
after	O
calling	O
list	B-api_mention
.	I-api_mention
add	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
,	O
a	O
call	O
to	O
list	B-api_mention
.	I-api_mention
get	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
will	O
return	O
elem	O
.	O
With	O
an	O
auto	O
-	O
sorted	O
list	O
,	O
the	O
element	O
could	O
end	O
up	O
in	O
an	O
arbitrary	O
position	O
.	O
Question	O
-	O
5839359	O
,	O
answer	O
-	O
5839392	O
You	O
'	O
re	O
essentially	O
running	O
out	O
of	O
memory	O
to	O
run	O
the	O
process	O
smoothly	O
.	O
Options	O
that	O
come	O
to	O
mind	O
:	O
#	O
li	O
Specify	O
more	O
memory	O
like	O
you	O
mentioned	O
,	O
try	O
something	O
in	O
between	O
like	O
-	O
Xmx512m	O
first	O
#	O
li	O
Work	O
with	O
smaller	O
batches	O
of	O
HashMap	B-api_mention
objects	O
to	O
process	O
at	O
once	O
if	O
possible	O
#	O
li	O
If	O
you	O
have	O
a	O
lot	O
of	O
duplicate	O
strings	O
,	O
use	O
String	B-api_mention
.	I-api_mention
intern	I-api_mention
(	I-api_mention
)	I-api_mention
on	O
them	O
before	O
putting	O
them	O
into	O
the	O
HashMap	B-api_mention
#	O
li	O
Use	O
the	O
HashMap	B-api_mention
(	I-api_mention
int	I-api_mention
initialCapacity	I-api_mention
,	I-api_mention
float	I-api_mention
loadFactor	I-api_mention
)	I-api_mention
constructor	O
to	O
tune	O
for	O
your	O
case	O
Question	O
-	O
34509566	O
,	O
answer	O
-	O
34529067	O
Keep	O
in	O
mind	O
that	O
Java	O
holds	O
a	O
pool	O
of	O
all	O
string	O
literals	O
found	O
in	O
program	O
,	O
used	O
for	O
matching	O
purposes	O
among	O
others	O
,	O
so	O
any	O
different	O
string	O
literal	O
concatenation	O
above	O
will	O
lead	O
to	O
the	O
same	O
object	O
,	O
to	O
the	O
same	O
string	O
literal	O
.	O
You	O
can	O
check	O
out	O
this	O
useful	O
article	O
for	O
more	O
.	O
On	O
the	O
other	O
hand	O
,	O
the	O
concatenation	O
of	O
a	O
String	B-api_mention
object	O
and	O
a	O
literal	O
(	O
case	O
c	O
+	O
StringLiteral	O
)	O
will	O
lead	O
to	O
the	O
creation	O
of	O
a	O
as	O
StringBuilder	B-api_mention
object	O
at	O
runtime	O
,	O
different	O
to	O
the	O
literals	O
found	O
in	O
pool	O
.	O
Question	O
-	O
18723596	O
String	B-api_mention
x	O
=	O
(	O
String	B-api_mention
)	O
null	O
;	O
Why	O
there	O
is	O
no	O
exception	O
in	O
this	O
statement	O
?	O
#	O
pre	O
It	O
prints	O
null	O
.	O
But	O
.	B-api_mention
toString	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
should	O
throw	O
a	O
null	O
pointer	O
exception	O
.	O
Question	O
-	O
23114015	O
I	O
am	O
wondering	O
why	O
the	O
Iterable	B-api_mention
interface	O
does	O
not	O
provide	O
the	O
stream	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
and	O
parallelStream	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
methods	O
.	O
Consider	O
the	O
following	O
class	O
:	O
#	O
pre	O
It	O
is	O
an	O
implementation	O
of	O
a	O
Hand	O
as	O
you	O
can	O
have	O
cards	O
in	O
your	O
hand	O
while	O
playing	O
a	O
Trading	O
Card	O
Game	O
.	O
Essentially	O
it	O
wraps	O
a	O
List	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
,	O
ensures	O
a	O
maximum	O
capacity	O
and	O
offers	O
some	O
other	O
useful	O
features	O
.	O
It	O
is	O
better	O
as	O
implementing	O
it	O
directly	O
as	O
a	O
List	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
.	O
Now	O
,	O
for	O
convienience	O
I	O
thought	O
it	O
would	O
be	O
nice	O
to	O
implement	O
Iterable	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
,	O
such	O
that	O
you	O
can	O
use	O
enhanced	O
for	O
-	O
loops	O
if	O
you	O
want	O
to	O
loop	O
over	O
it	O
.	O
(	O
My	O
Hand	O
class	O
also	O
provides	O
a	O
get	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
,	O
hence	O
the	O
Iterable	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
is	O
justified	O
in	O
my	O
opinion	O
.	O
)	O
The	O
Iterable	O
interface	O
provides	O
the	O
following	O
(	O
left	O
out	O
javadoc	O
)	O
:	O
#	O
pre	O
Now	O
can	O
you	O
obtain	O
a	O
stream	O
with	O
:	O
Stream	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
stream	O
=	O
StreamSupport	B-api_mention
.	I-api_mention
stream	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
So	O
onto	O
the	O
real	O
question	O
:	O
#	O
li	O
Why	O
does	O
Iterable	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
not	O
provide	O
a	O
default	O
methods	O
that	O
implement	B-api_mention
stream	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
and	O
parallelStream	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
,	O
I	O
see	O
nothing	O
that	O
would	O
make	O
this	O
impossible	O
or	O
unwanted	O
?	O
A	O
related	O
question	O
I	O
found	O
is	O
the	O
following	O
though	O
:	O
Why	O
does	O
Stream	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
not	O
implement	O
Iterable	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
?	O
Which	O
is	O
oddly	O
enough	O
suggesting	O
it	O
to	O
do	O
it	O
somewhat	O
the	O
other	O
way	O
around	O
.	O
Question	O
-	O
10786042	O
,	O
answer	O
-	O
10786112	O
URLEncoder	B-api_mention
should	O
be	O
the	O
way	O
to	O
go	O
.	O
You	O
only	O
need	O
to	O
keep	O
in	O
mind	O
to	O
encode	O
only	O
the	O
individual	O
query	O
string	O
parameter	O
name	O
and	O
/	O
or	O
value	O
,	O
not	O
the	O
entire	O
URL	O
,	O
for	O
sure	O
not	O
the	O
query	O
string	O
parameter	O
separator	O
character	O
&	O
nor	O
the	O
parameter	O
name	O
-	O
value	O
separator	O
character	O
=	O
.	O
#	O
pre	O
Note	O
that	O
spaces	O
in	O
query	O
parameters	O
are	O
represented	O
by	O
+	O
,	O
not	O
%	O
20	O
,	O
which	O
is	O
legitimately	O
valid	O
.	O
The	O
%	O
20	O
is	O
usually	O
to	O
be	O
used	O
to	O
represent	O
spaces	O
in	O
URI	O
itself	O
(	O
the	O
part	O
before	O
the	O
URI	O
-	O
query	O
string	O
separator	O
character	O
?	O
)	O
,	O
not	O
in	O
query	O
string	O
(	O
the	O
part	O
after	O
?	O
)	O
.	O
Also	O
note	O
that	O
there	O
are	O
two	O
encode	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
methods	O
.	O
One	O
without	O
charset	O
argument	O
and	O
another	O
with	O
.	O
The	O
one	O
without	O
charset	O
argument	O
is	O
deprecated	O
.	O
Never	O
use	O
it	O
and	O
always	O
specify	O
the	O
charset	O
argument	O
.	O
The	O
javadoc	O
even	O
explicitly	O
recommends	O
to	O
use	O
the	O
UTF	O
-	O
8	O
encoding	O
,	O
as	O
mandated	O
by	O
RFC3986	O
and	O
W3C	O
.	O
#	O
blockquote	O
See	O
also	O
:	O
#	O
li	O
What	O
every	O
web	O
developer	O
must	O
know	O
about	O
URL	O
encoding	O
Question	O
-	O
24630963	O
,	O
answer	O
-	O
32648397	O
I	O
wrote	O
a	O
Collector	B-api_mention
which	O
,	O
unlike	O
the	O
default	O
java	O
one	O
,	O
does	O
not	O
crash	O
when	O
you	O
have	O
null	O
values	O
:	O
#	O
pre	O
Just	O
replace	O
your	O
Collectors	B-api_mention
.	I-api_mention
toMap	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
call	O
to	O
a	O
call	O
to	O
this	O
function	O
and	O
it	O
'	O
ll	O
fix	O
the	O
problem	O
.	O
Question	O
-	O
14636178	O
I	O
am	O
trying	O
to	O
use	O
the	O
org	B-api_mention
.	I-api_mention
springframework	I-api_mention
.	I-api_mention
orm	I-api_mention
.	I-api_mention
jdo	I-api_mention
.	I-api_mention
TransactionAwarePersistenceManagerFactoryProxy	I-api_mention
in	O
my	O
Spring	O
project	O
,	O
but	O
I	O
am	O
not	O
sure	O
how	O
to	O
use	O
it	O
or	O
whether	O
it	O
'	O
s	O
exactly	O
what	O
I	O
am	O
looking	O
for	O
.	O
I	O
realize	O
it	O
can	O
help	O
make	O
my	O
DAOs	O
work	O
with	O
a	O
plain	O
JDO	O
PersistenceManagerFactory	B-api_mention
.	O
Another	O
question	O
is	O
:	O
what	O
happens	O
if	O
the	O
proxy	O
doesn	O
'	O
t	O
get	O
made	O
properly	O
?	O
Can	O
I	O
still	O
use	O
it	O
to	O
access	O
my	O
factory	O
to	O
create	O
a	O
transaction	O
aware	O
persistence	O
manager	O
?	O
If	O
the	O
object	O
managed	O
by	O
the	O
factory	O
is	O
a	O
singleton	O
,	O
does	O
this	O
change	O
things	O
?	O
Why	O
not	O
just	O
access	O
the	O
PersistenceManagerFactory	B-api_mention
directly	O
?	O
Perhaps	O
PersistenceManagerFactoryUtils	B-api_mention
.	I-api_mention
getPersistenceManager	I-api_mention
would	O
be	O
more	O
suited	O
to	O
my	O
needs	O
?	O
Can	O
getObject	B-api_mention
return	O
null	O
?	O
Question	O
-	O
7520432	O
,	O
answer	O
-	O
7520464	O
In	O
general	O
,	O
the	O
answer	O
to	O
your	O
question	O
is	O
"	O
yes	O
"	O
,	O
but	O
.	O
.	O
.	O
#	O
li	O
equals	B-api_mention
will	O
only	O
compare	O
what	O
it	O
is	O
written	O
to	O
compare	O
,	O
no	O
more	O
,	O
no	O
less	O
.	O
#	O
li	O
if	O
a	O
class	O
does	O
not	O
override	O
the	O
equals	O
method	O
,	O
then	O
it	O
defaults	O
to	O
the	O
equals	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
of	O
the	O
closest	O
parent	O
class	O
that	O
has	O
overridden	O
this	O
method	O
.	O
#	O
li	O
If	O
no	O
parent	O
classes	O
have	O
provided	O
an	O
override	O
,	O
then	O
it	O
defaults	O
to	O
the	O
method	O
from	O
the	O
ultimate	O
parent	O
class	O
,	O
Object	B-api_mention
,	O
and	O
so	O
you	O
'	O
re	O
left	O
with	O
the	O
Object	B-api_mention
#	I-api_mention
equals	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
.	O
Per	O
the	O
Object	O
API	O
this	O
is	O
the	O
same	O
as	O
=	O
=	O
;	O
that	O
is	O
,	O
it	O
returns	O
true	O
if	O
and	O
only	O
if	O
both	O
variables	O
refer	O
to	O
the	O
same	O
object	O
,	O
if	O
their	O
references	O
are	O
one	O
and	O
the	O
same	O
.	O
Thus	O
you	O
will	O
be	O
testing	O
for	O
object	O
equality	O
and	O
not	O
functional	O
equality	O
.	O
#	O
li	O
Always	O
remember	O
to	O
override	O
hashCode	B-api_mention
if	O
you	O
override	O
equals	O
so	O
as	O
not	O
to	O
"	O
break	O
the	O
contract	O
"	O
.	O
As	O
per	O
the	O
API	O
,	O
the	O
result	O
returned	O
from	O
the	O
hashCode	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
for	O
two	O
objects	O
must	O
be	O
the	O
same	O
if	O
their	O
equals	O
methods	O
shows	O
that	O
they	O
are	O
equivalent	O
.	O
The	O
converse	O
is	O
not	O
necessarily	O
true	O
.	O
Question	O
-	O
19431234	O
Java	O
8	O
has	O
a	O
completely	O
new	O
API	O
for	O
date	O
and	O
time	O
.	O
One	O
of	O
the	O
most	O
useful	O
classes	O
in	O
this	O
API	O
is	O
LocalDateTime	B-api_mention
,	O
for	O
holding	O
a	O
timezone	O
-	O
independent	O
date	O
-	O
with	O
-	O
time	O
value	O
.	O
There	O
are	O
probably	O
millions	O
of	O
lines	O
of	O
code	O
using	O
the	O
legacy	O
class	O
java	B-api_mention
.	I-api_mention
util	I-api_mention
.	I-api_mention
Date	I-api_mention
for	O
this	O
purpose	O
.	O
As	O
such	O
,	O
when	O
interfacing	O
old	O
and	O
new	O
code	O
there	O
will	O
be	O
a	O
need	O
for	O
converting	O
between	O
the	O
two	O
.	O
As	O
there	O
seems	O
to	O
be	O
no	O
direct	O
methods	O
for	O
accomplishing	O
this	O
,	O
how	O
can	O
it	O
be	O
done	O
?	O
Question	O
-	O
27683759	O
I	O
just	O
studied	O
about	O
generic	O
programming	O
,	O
the	O
List	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
interface	O
,	O
and	O
ArrayList	B-api_mention
,	O
so	O
I	O
can	O
understand	O
the	O
statement	O
below	O
.	O
ArrayList	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
list	O
=	O
new	O
ArrayList	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
But	O
I	O
don	O
'	O
t	O
understand	O
the	O
next	O
statement	O
which	O
I	O
saw	O
while	O
surfing	O
the	O
web	O
.	O
List	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
list2	O
=	O
Collections	B-api_mention
.	I-api_mention
<	I-api_mention
String	I-api_mention
>	I-api_mention
emptyList	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
#	O
li	O
What	O
is	O
Collections	B-api_mention
?	O
Why	O
isn	O
'	O
t	O
it	O
Collections	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
or	O
Collections	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
?	O
#	O
li	O
Why	O
is	O
<	O
String	O
>	O
placed	O
before	O
the	O
method	O
name	O
emptyList	O
?	O
(	O
Isn	O
'	O
t	O
emptyList	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
correct	O
for	O
Generic	O
?	O
)	O
#	O
li	O
What	O
does	O
the	O
statement	O
mean	O
?	O
Question	O
-	O
14376807	O
,	O
answer	O
-	O
22092971	O
For	O
those	O
looking	O
for	O
a	O
general	O
strategy	O
for	O
reading	O
and	O
writing	O
a	O
string	O
to	O
file	O
:	O
First	O
,	O
get	O
a	O
file	O
object	O
You	O
'	O
ll	O
need	O
the	O
storage	O
path	O
.	O
For	O
the	O
internal	O
storage	O
,	O
use	O
:	O
File	B-api_mention
path	O
=	O
context	O
.	B-api_mention
getFilesDir	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
For	O
the	O
external	O
storage	O
(	O
SD	O
card	O
)	O
,	O
use	O
:	O
File	B-api_mention
path	O
=	O
context	O
.	B-api_mention
getExternalFilesDir	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Then	O
create	O
your	O
file	O
object	O
:	O
File	B-api_mention
file	O
=	O
new	O
File	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Write	O
a	O
string	O
to	O
the	O
file	O
#	O
pre	O
Or	O
with	O
Google	O
Guava	O
Files	B-api_mention
.	I-api_mention
write	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Read	O
the	O
file	O
to	O
a	O
string	O
#	O
pre	O
Or	O
if	O
you	O
are	O
using	O
Google	O
Guava	O
String	B-api_mention
contents	O
=	O
Files	B-api_mention
.	I-api_mention
toString	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
For	O
completeness	O
I	O
'	O
ll	O
mention	O
String	B-api_mention
contents	O
=	O
new	O
Scanner	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
useDelimiter	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
next	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
which	O
requires	O
no	O
libraries	O
,	O
but	O
benchmarks	O
50	O
%	O
-	O
400	O
%	O
slower	O
than	O
the	O
other	O
options	O
(	O
in	O
various	O
tests	O
on	O
my	O
Nexus	O
5	O
)	O
.	O
Notes	O
For	O
each	O
of	O
these	O
strategies	O
,	O
you	O
'	O
ll	O
be	O
asked	O
to	O
catch	O
an	O
IOException	B-api_mention
.	O
The	O
default	O
character	O
encoding	O
on	O
Android	O
is	O
UTF	O
-	O
8	O
.	O
If	O
you	O
are	O
using	O
external	O
storage	O
,	O
you	O
'	O
ll	O
need	O
to	O
add	O
to	O
your	O
manifest	O
either	O
:	O
<	O
uses	O
-	O
permission	O
android	O
:	O
name	O
=	O
StringLiteral	O
/	O
>	O
or	O
<	O
uses	O
-	O
permission	O
android	O
:	O
name	O
=	O
StringLiteral	O
/	O
>	O
Write	O
permission	O
implies	O
read	O
permission	O
,	O
so	O
you	O
don	O
'	O
t	O
need	O
both	O
.	O
Question	O
-	O
26791441	O
,	O
answer	O
-	O
26796725	O
Swapping	O
Only	O
One	O
Occurrence	O
If	O
there	O
is	O
only	O
one	O
occurrence	O
of	O
each	O
of	O
the	O
swapable	O
strings	O
in	O
the	O
input	O
,	O
you	O
can	O
do	O
the	O
following	O
:	O
Before	O
proceeding	O
to	O
any	O
replace	O
,	O
get	O
the	O
indices	O
of	O
the	O
occurrences	O
of	O
the	O
words	O
.	O
After	O
that	O
we	O
only	O
replace	O
the	O
word	O
found	O
at	O
these	O
indexes	O
,	O
and	O
not	O
all	O
occurrences	O
.	O
This	O
solution	O
uses	O
StringBuilder	B-api_mention
and	O
does	O
not	O
produce	O
intermediate	O
String	B-api_mention
s	O
like	O
String	B-api_mention
.	I-api_mention
replace	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	O
One	O
thing	O
to	O
note	O
:	O
if	O
the	O
swapable	O
words	O
have	O
different	O
lengths	O
,	O
after	O
the	O
first	O
replace	O
the	O
second	O
index	O
might	O
change	O
(	O
if	O
the	O
1st	O
word	O
occurs	O
before	O
the	O
2nd	O
)	O
exactly	O
with	O
the	O
difference	O
of	O
the	O
2	O
lengths	O
.	O
So	O
aligning	O
the	O
second	O
index	O
will	O
ensure	O
this	O
works	O
even	O
if	O
we	O
'	O
re	O
swapping	O
words	O
with	O
different	O
lengths	O
.	O
#	O
pre	O
Swapping	O
Arbitrary	O
Number	O
of	O
Occurrences	O
Analogous	O
to	O
the	O
previous	O
case	O
we	O
will	O
first	O
collect	O
the	O
indexes	O
(	O
occurrences	O
)	O
of	O
the	O
words	O
,	O
but	O
in	O
this	O
case	O
it	O
will	O
a	O
list	O
of	O
integers	O
for	O
each	O
word	O
,	O
not	O
just	O
one	O
int	O
.	O
For	O
this	O
we	O
will	O
use	O
the	O
following	O
utility	O
method	O
:	O
#	O
pre	O
And	O
using	O
this	O
we	O
will	O
replace	O
the	O
words	O
with	O
the	O
other	O
one	O
by	O
decreasing	O
index	O
(	O
which	O
might	O
require	O
to	O
alternate	O
between	O
the	O
2	O
swapable	O
words	O
)	O
so	O
that	O
we	O
won	O
'	O
t	O
even	O
have	O
to	O
correct	O
the	O
indices	O
after	O
a	O
replace	O
:	O
#	O
pre	O
Question	O
-	O
22409102	O
,	O
answer	O
-	O
33501556	O
Double	B-api_mention
.	I-api_mention
equals	I-api_mention
distinguishes	O
±	O
0	O
.	O
0	O
in	O
Java	O
.	O
(	O
There	O
'	O
s	O
also	O
Float	B-api_mention
.	I-api_mention
equals	I-api_mention
.	O
)	O
I	O
'	O
m	O
a	O
bit	O
surprised	O
no	O
-	O
one	O
has	O
mentioned	O
these	O
,	O
as	O
they	O
seem	O
to	O
me	O
clearer	O
than	O
any	O
method	O
given	O
so	O
far	O
!	O
Question	O
-	O
4576352	O
,	O
answer	O
-	O
11325546	O
You	O
can	O
use	O
str	O
=	O
str	O
.	B-api_mention
replace	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
as	O
mentioned	O
before	O
and	O
you	O
will	O
be	O
fine	O
.	O
For	O
your	O
information	O
CharLiteral	O
is	O
not	O
an	O
empty	O
(	O
or	O
a	O
valid	O
)	O
character	O
but	O
CharLiteral	O
is	O
.	O
So	O
you	O
could	O
use	O
str	O
=	O
str	O
.	B-api_mention
replace	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
instead	O
.	O
Question	O
-	O
16148575	O
,	O
answer	O
-	O
16148619	O
use	O
int	O
as	O
Object	B-api_mention
not	O
as	O
primitive	O
type	O
HashMap	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
myMap	O
=	O
new	O
HashMap	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
Question	O
-	O
5243754	O
What	O
is	O
the	O
difference	O
between	O
getAttribute	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
and	O
getParameter	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
methods	O
within	O
HttpServletRequest	B-api_mention
class	O
?	O
Question	O
-	O
31471444	O
,	O
answer	O
-	O
31471530	O
You	O
should	O
not	O
.	O
The	O
INTEGER	O
_	O
ONE	O
name	O
is	O
no	O
more	O
meaningful	O
than	O
1	O
.	O
If	O
however	O
this	O
value	O
has	O
some	O
other	O
meaning	O
(	O
for	O
example	O
,	O
month	O
in	O
the	O
year	O
)	O
,	O
then	O
using	O
a	O
constant	O
(	O
like	O
Calendar	B-api_mention
.	I-api_mention
FEBRUARY	I-api_mention
)	O
will	O
make	O
your	O
code	O
clearer	O
.	O
I	O
can	O
guess	O
that	O
this	O
constant	O
in	O
Commons	O
Math	O
library	O
was	O
created	O
in	O
Java	O
1	O
.	O
4	O
when	O
there	O
were	O
no	O
Integer	B-api_mention
cache	O
and	O
autoboxing	O
,	O
so	O
it	O
had	O
sense	O
in	O
terms	O
that	O
you	O
may	O
reuse	O
the	O
same	O
Integer	B-api_mention
object	O
(	O
not	O
primitive	O
int	O
)	O
in	O
different	O
places	O
to	O
save	O
memory	O
.	O
So	O
it	O
was	O
added	O
for	O
performance	O
reasons	O
,	O
not	O
for	O
code	O
clarity	O
.	O
Now	O
it	O
'	O
s	O
obsolete	O
:	O
even	O
if	O
you	O
need	O
an	O
Integer	B-api_mention
object	O
,	O
you	O
can	O
use	O
Integer	B-api_mention
.	I-api_mention
valueOf	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
or	O
implicit	O
autoboxing	O
and	O
get	O
the	O
cached	O
one	O
.	O
Question	O
-	O
7520432	O
,	O
answer	O
-	O
35399386	O
The	O
String	B-api_mention
pool	O
(	O
aka	O
interning	O
)	O
and	O
Integer	B-api_mention
pool	O
blur	O
the	O
difference	O
further	O
,	O
and	O
may	O
allow	O
you	O
to	O
use	O
=	O
=	O
for	O
objects	O
in	O
some	O
cases	O
instead	O
of	O
.	B-api_mention
equals	I-api_mention
This	O
can	O
give	O
you	O
greater	O
performance	O
(	O
?	O
)	O
,	O
at	O
the	O
cost	O
of	O
greater	O
complexity	O
.	O
E	O
.	O
g	O
.	O
:	O
#	O
pre	O
Complexity	O
tradeoff	O
:	O
the	O
following	O
may	O
surprise	O
you	O
:	O
#	O
pre	O
I	O
advise	O
you	O
to	O
stay	O
away	O
from	O
such	O
micro	O
-	O
optimization	O
,	O
and	O
always	O
use	O
.	O
equals	O
for	O
objects	O
,	O
and	O
=	O
=	O
for	O
primitives	O
:	O
#	O
pre	O
Question	O
-	O
8172420	O
,	O
answer	O
-	O
8172439	O
You	O
can	O
use	O
Character	B-api_mention
.	I-api_mention
toString	I-api_mention
(	I-api_mention
char	I-api_mention
)	I-api_mention
.	O
Note	O
that	O
this	O
method	O
simply	O
returns	O
a	O
call	O
to	O
String	B-api_mention
.	I-api_mention
valueOf	I-api_mention
(	I-api_mention
char	I-api_mention
)	I-api_mention
,	O
which	O
also	O
works	O
.	O
As	O
others	O
have	O
noted	O
,	O
string	O
concatenation	O
works	O
as	O
a	O
shortcut	O
as	O
well	O
:	O
String	B-api_mention
s	O
=	O
StringLiteral	O
+	O
CharLiteral	O
;	O
But	O
this	O
compiles	O
down	O
to	O
:	O
String	B-api_mention
s	O
=	O
new	O
StringBuilder	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
append	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
append	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
.	I-api_mention
toString	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
which	O
is	O
less	O
efficient	O
because	O
the	O
StringBuilder	B-api_mention
is	O
backed	O
by	O
a	O
char	O
[	O
]	O
(	O
over	O
-	O
allocated	O
by	O
StringBuilder	B-api_mention
(	I-api_mention
)	I-api_mention
to	O
16	O
)	O
,	O
only	O
for	O
that	O
array	O
to	O
be	O
defensively	O
copied	O
by	O
the	O
resulting	O
String	B-api_mention
.	O
String	B-api_mention
.	I-api_mention
valueOf	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
"	O
gets	O
in	O
the	O
back	O
door	O
"	O
by	O
wrapping	O
the	O
char	O
in	O
a	O
single	O
-	O
element	O
array	O
and	O
passing	O
it	O
to	O
the	O
package	O
private	O
constructor	O
String	B-api_mention
(	I-api_mention
char	I-api_mention
[	I-api_mention
]	I-api_mention
,	I-api_mention
boolean	I-api_mention
)	I-api_mention
,	O
which	O
avoids	O
the	O
array	O
copy	O
.	O
Question	O
-	O
4576352	O
I	O
can	O
use	O
this	O
:	O
#	O
pre	O
Is	O
there	O
a	O
way	O
to	O
remove	O
all	O
occurrences	O
of	O
character	O
X	O
from	O
a	O
String	O
in	O
Java	O
?	O
I	O
tried	O
this	O
and	O
is	O
not	O
what	O
I	O
want	O
:	O
str	B-api_mention
.	I-api_mention
replace	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
/	O
/	O
replace	O
with	O
space	O
Question	O
-	O
21488056	O
,	O
answer	O
-	O
30506585	O
Predicate	B-api_mention
has	O
methods	O
and	O
,	O
or	O
and	O
negate	O
.	O
However	O
,	O
String	B-api_mention
:	I-api_mention
:	I-api_mention
isEmpty	I-api_mention
is	O
not	O
a	O
Predicate	B-api_mention
.	O
It	O
could	O
as	O
well	O
be	O
Function	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
or	O
MyProprietaryClass	B-api_mention
.	O
The	O
type	O
information	O
is	O
inferred	O
from	O
the	O
variable	O
or	O
the	O
call	O
.	O
So	O
,	O
you	O
need	O
to	O
cast	O
a	O
method	O
reference	O
explicitly	O
(	O
as	O
@	O
axtavt	O
mentioned	O
)	O
:	O
(	O
(	O
Predicate	B-api_mention
<	I-api_mention
T	I-api_mention
>	I-api_mention
)	O
String	B-api_mention
:	I-api_mention
:	I-api_mention
isEmpty	I-api_mention
)	O
.	B-api_mention
negate	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
But	O
it	O
'	O
s	O
absolutely	O
ugly	O
and	O
Predicate	B-api_mention
seems	O
to	O
use	O
lambdas	O
under	O
the	O
hood	O
anyway	O
.	O
So	O
I	O
think	O
you	O
are	O
better	O
off	O
writing	O
a	O
lambda	O
or	O
even	O
your	O
own	O
not	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
method	O
(	O
e	O
.	O
g	O
.	O
in	O
utility	O
,	O
static	O
import	O
)	O
.	O
Question	O
-	O
4576352	O
,	O
answer	O
-	O
4576367	O
using	O
public	O
String	B-api_mention
replaceAll	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
will	O
work	O
usage	O
would	O
be	O
str	O
.	B-api_mention
replace	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
executing	O
StringLiteral	O
.	B-api_mention
replaceAll	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
returns	O
:	O
lakjsdf	O
xx	O
Question	O
-	O
20358883	O
,	O
answer	O
-	O
20358917	O
Very	O
simply	O
:	O
Arrays	B-api_mention
.	I-api_mention
asList	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
Question	O
-	O
25168062	O
Why	O
is	O
i	O
+	O
+	O
not	O
atomic	O
in	O
Java	O
?	O
To	O
get	O
a	O
bit	O
deeper	O
in	O
Java	O
I	O
tried	O
to	O
count	O
how	O
often	O
the	O
loop	O
in	O
threads	O
are	O
executed	O
.	O
So	O
I	O
used	O
a	O
private	O
static	O
int	O
total	O
=	O
0	O
;	O
in	O
the	O
main	O
class	O
.	O
I	O
have	O
two	O
threads	O
.	O
#	O
li	O
Thread	O
1	O
:	O
Prints	O
System	B-api_mention
.	I-api_mention
out	I-api_mention
.	I-api_mention
println	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
#	O
li	O
Thread	O
2	O
:	O
Prints	O
System	B-api_mention
.	I-api_mention
out	I-api_mention
.	I-api_mention
println	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
And	O
I	O
count	O
the	O
lines	O
printed	O
by	O
thread	O
1	O
and	O
thread	O
2	O
.	O
But	O
the	O
lines	O
of	O
thread	O
1	O
+	O
lines	O
of	O
thread	O
2	O
don	O
'	O
t	O
match	O
the	O
total	O
number	O
of	O
lines	O
printed	O
out	O
.	O
Here	O
is	O
my	O
code	O
:	O
#	O
pre	O
Question	O
-	O
6992608	O
,	O
answer	O
-	O
6992643	O
There	O
'	O
s	O
no	O
built	O
in	O
type	O
for	O
ConcurrentHashSet	B-api_mention
because	O
you	O
can	O
always	O
derive	O
a	O
set	O
from	O
a	O
map	O
.	O
Since	O
there	O
are	O
many	O
types	O
of	O
maps	O
,	O
you	O
use	O
a	O
method	O
to	O
produce	O
a	O
set	O
from	O
a	O
given	O
map	O
(	O
or	O
map	O
class	O
)	O
.	O
Prior	O
to	O
Java	O
8	O
,	O
you	O
produce	O
a	O
concurrent	O
hash	O
set	O
backed	O
by	O
a	O
concurrent	O
hash	O
map	O
,	O
by	O
using	O
Collections	B-api_mention
.	I-api_mention
newSetFromMap	I-api_mention
(	I-api_mention
map	I-api_mention
)	I-api_mention
In	O
Java	O
8	O
(	O
pointed	O
out	O
by	O
@	O
Matt	O
)	O
,	O
you	O
can	O
get	O
a	O
concurrent	O
hash	O
set	O
view	O
via	O
ConcurrentHashMap	B-api_mention
.	I-api_mention
newKeySet	I-api_mention
(	I-api_mention
)	I-api_mention
.	O
This	O
is	O
a	O
bit	O
simpler	O
than	O
the	O
old	O
newSetFromMap	B-api_mention
which	O
required	O
you	O
to	O
pass	O
in	O
an	O
empty	O
map	O
object	O
.	O
But	O
it	O
is	O
specific	O
to	O
ConcurrentHashMap	B-api_mention
.	O
Anyway	O
,	O
the	O
Java	O
designers	O
could	O
have	O
created	O
a	O
new	O
set	O
interface	O
every	O
time	O
a	O
new	O
map	O
interface	O
was	O
created	O
,	O
but	O
that	O
pattern	O
would	O
be	O
impossible	O
to	O
enforce	O
when	O
third	O
parties	O
create	O
their	O
own	O
maps	O
.	O
It	O
is	O
better	O
to	O
have	O
the	O
static	O
methods	O
that	O
derive	O
new	O
sets	O
;	O
that	O
approach	O
always	O
works	O
,	O
even	O
when	O
you	O
create	O
your	O
own	O
map	O
implementations	O
.	O
Question	O
-	O
27430092	O
,	O
answer	O
-	O
27430172	O
A	O
possible	O
use	O
case	O
is	O
in	O
testing	O
primality	O
of	O
a	O
given	O
number	O
(	O
at	O
test	O
which	O
in	O
itself	O
has	O
many	O
uses	O
)	O
.	O
The	O
isProbablePrime	B-api_mention
algorithm	O
will	O
run	O
much	O
faster	O
than	O
an	O
exact	O
algorithm	O
,	O
so	O
if	O
the	O
number	O
fails	O
isProbablePrime	B-api_mention
,	O
then	O
one	O
need	O
not	O
go	O
to	O
the	O
expense	O
of	O
running	O
the	O
more	O
expensive	O
algorithm	O
.	O
Question	O
-	O
15182496	O
The	O
following	O
print	O
statement	O
would	O
print	O
"	O
hello	O
world	O
"	O
.	O
Could	O
anyone	O
explain	O
this	O
?	O
System	B-api_mention
.	I-api_mention
out	I-api_mention
.	I-api_mention
println	I-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
;	O
And	O
randomString	B-api_mention
(	I-api_mention
args	I-api_mention
)	I-api_mention
looks	O
like	O
this	O
:	O
#	O
pre	O
