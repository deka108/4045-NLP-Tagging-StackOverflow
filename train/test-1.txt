Question - 22463062 Java 8 added a new API for working with dates and times ( JSR 310 ) . I have date and time as string ( e . g . StringLiteral ) . How can I obtain a LocalDateTime instance from the given string ? After I finished working with the LocalDateTime object : How can I then convert the LocalDateTime instance back to a string with the same format as shown above ?

Question - 8579657 , answer - 13134221 Actually Thread . start ( args ) creates a new thread and have its own execution scenario . Thread . start ( args ) calls the run ( args ) method asynchronously , which changes the state of new Thread to Runnable . But Thread . run ( args ) does not create any new thread . Instead it execute the run method in the current running thread synchronously . If you are using Thread . run ( args ) then you are not using the features of multi threading at all .

Question - 28276423 , answer - 28276463 If all of the streams have been instantiated then closing only the outermost is just fine . The documentation on Closeable interface states that close method : # blockquote The releasing system resources includes closing streams . It also states that : # blockquote So if you close them explicitly afterwards , nothing wrong will happen .

Question - 24609564 , answer - 24609841 If you will read comment above the code , It is mentioned that . . . If the caller is not a ForkJoinTask , this method is behaviorally equivalent to # pre So it is just another form to implement above code in else part . . . ! ! In Style notes it is mentioned that , # blockquote And if you will see implementation of ManagedLocker # isReleasable , It is updating the lock and returns true if blocking is unnecessary . Interpretation : Blank while loops are used to provide an interrupt until some condition reset to true / false . Here , do { } while ( args ) is a blocker / interrupt until blocker . block ( args ) will be true when blocker . isReleasable ( args ) is false . Loop will continue execution while blocker is not releasable ( ! blocker . isReleasable ( args ) ) and blocker is not blocked ! ! Execution will be out of loop as soon as blocker . block ( args ) will set to true . Note that , do { } while ( args ) does not update CAS variable , but it guarantee that program will wait until variable gets updated ( force to wait until variable gets updated ) .

Question - 5769669 , answer - 5769679 You can use Double . parseDouble ( ) to convert a String to a double : # pre For your case it looks like you want : # pre

Question - 30217236 , answer - 30219144 Why this should be problem in the first place is kind of nebulous to me . I suspect you ' ve instead misunderstood something about the ways in which the type system is useful . What can we do with a < T > void x ( args ) ? Well , not a whole lot . Inside the body of x , T is the same as Object , so we could only do something like call toString on a and b to print them . There ' s really no practical reason a and b must have the same type . Just that they have some type in common , and that type is Object or a subtype of it . In fact , there ' s no clear reason why < T > void x ( args ) actually needs to be generic at all . # li The method body doesn ' t care what the actual types of a and b are because it couldn ' t use them anyway . # li The call site doesn ' t care what the actual types of a and b are because x is a void method so it ' s a black hole . It ' s more typical for a method to have a result , like < T > List < T > Arrays . asList ( args ) : / / This will cause a compile error because / / the type inferred must be compatible / / with the return assignment . List < T > r = Arrays . asList ( args ) ; Or a bound : # pre Or a bound which asserts some kind of relation : # pre

Question - 7693324 I got a simple question in Java : How can I convert a String that was obtained by Long . toString ( args ) to long ?

Question - 18410035 , answer - 37409771 In Java 8 collection classes that implement Iterable ( for example all lists ) now have forEach method : Arrays . asList ( args ) . forEach ( args ) ; The above example makes use of method - reference introduced in Java 8 . We can also iterate over a list using Stream as : Arrays . asList ( args ) . stream ( args ) . forEach ( args ) ; The advantage with later option is that we can also make use of parallel streams wherever appropriate . If the objective is only to print the items irrespective of the order then we can use parallel stream as : Arrays . asList ( args ) . parallelStream ( args ) . forEach ( args ) ;

Question - 30081520 I am aware that it is better to call the equals method over using the = = operator ( see this question ) . I want two strings to compare as equal if they are both null or if they represent the same string . Unfortunately the equals method will throw an NPE if the strings are null . My code is currently : # pre This is inelegant . What is the correct way to perform this test ?

Question - 26684562 , answer - 26684710 Both map and flatMap can be applied to a Stream < T > and they both return a Stream < T > . The difference is that the map operation produces one output value for each input value , whereas the flatMap operation produces an arbitrary number ( zero or more ) values for each input value . This is reflected in the arguments to each operation . The map operation takes a Function , which is called for each value in the input stream and produces one result value , which is sent to the output stream . The flatMap operation takes a function that conceptually wants to consume one value and produce an arbitrary number of values . However , in Java , it ' s cumbersome for a method to return an arbitrary number of values , since methods can return only zero or one value . One could imagine an API where the mapper function for flatMap takes a value and returns an array or a List of values , which are then sent to the output . Given that this is the streams library , a particularly apt way to represent an arbitrary number of return values is for the mapper function itself to return a stream ! The values from the stream returned by the mapper are drained from the stream and are passed to the output stream . The " clumps " of values returned by each call to the mapper function are not distinguished at all in the output stream , thus the output is said to have been " flattened . " Typical use is for the mapper function of flatMap to return Stream . empty ( args ) if it wants to send zero values , or something like Stream . of ( args ) if it wants to return several values . But of course any stream can be returned .

Question - 31922866 , answer - 31923015 I believe the reson of being is you have to first check whether or not Optional is null itself and then try to evaluate value it wraps . Too many unnecessary validations .

Question - 33147339 , answer - 33147610 a < b and a - b < 0 can mean two different things . Consider the following code : # pre When run , this will only print a - b < 0 . What happens is that a < b is clearly false , but a - b overflows and becomes - 1 , which is negative . Now , having said that , consider that the array has a length that is really close to Integer . MAX _ VALUE . The code in ArrayList goes like this : # pre oldCapacity is really close to Integer . MAX _ VALUE so newCapacity ( which is oldCapacity + 0 . 5 * oldCapacity ) might overflow and become Integer . MIN _ VALUE ( i . e . negative ) . Then , subtracting minCapacity underflows back into a positive number . This check ensures that the if is not executed . If the code were written as if ( args ) , it would be true in this case ( since newCapacity is negative ) so the newCapacity would be forced to minCapacity regardless of the oldCapacity . This overflow case is handled by the next if . When newCapacity has overflowed , this will be true : MAX _ ARRAY _ SIZE is defined as Integer . MAX _ VALUE - 8 and Integer . MIN _ VALUE - ( Integer . MAX _ VALUE - 8 ) > 0 is true . The newCapacity is therefore rightly handled : hugeCapacity method returns MAX _ ARRAY _ SIZE or Integer . MAX _ VALUE . NB : this is what the / / overflow - conscious code comment in this method is saying .

Question - 12862659 , answer - 12862662 use the second argument on the Mockito . verify method , as in : verify ( args ) . someMethod ( args )

Question - 8725387 In Java there are the SortedSet and SortedMap interfaces . Both belong to Java ' s standard Collections framework and provide a sorted way to access the elements . However , in my understanding there is no SortedList in Java . You can use java . util . Collections . sort ( args ) to sort a list . Any idea why it is designed like that ?

Question - 28770822 , answer - 28853754 TLDR : Jump to the conclusion # blockquote A brief history of @ Native I made some search on the mailing lists . I found some interesting things . At first an annotation ( 1 2 ) javax . tools . annotation . ForceNativeHeader was introduced to # blockquote It is used by com . sun . tools . javac . processing . NativeapiVisitor . By looking at the code we can see that the native header is generated if the class declare some native methods or if the class is annotated @ ForceNativeHeader . Later this annotation was renamed to GenerateNativeHeader ( 1 2 ) . Then this annotation was added to several types ( especially Integer and Long ) with an interresting comment : # pre But by adding this annotation it add a problematic dependency from base module to the module containing javax . tools . So the annotation were removed from Integer and Long and these files were explicitly added to the build process since the header were no more automatically generated . . . a " ( hopefully temporary ) hack " . So a new annotation java . lang . annotation . Native was created and used in Integer and Long . The annotation was set a TargetType FIELD . # blockquote All the purpose of this stuff is : # blockquote It is the case of Integer and Long this was a part of the JEP 139 : Enhance javac to Improve Build Speed : # blockquote A basic experimentation I made a basic experimentation on the JDK . I clone the open - jdk forest and i successfully build it . As expected the header files where generated for Integer and Long ( thanks to @ Native ) and for Float and Double ( thanks to their native methods ) but not for Byte , Short . . . # pre Then i tried to remove the @ Native from the Integer fields and i tried to build again the jdk but i get an error : # pre logically since the header have not been generated . I have also confirmed that java _ lang _ Integer . h is included in several c and cpp files : # pre like Long # pre like Float # pre and like Double # pre but neither Short find . \ ( - name StringLiteral - o - name StringLiteral \ ) - exec grep StringLiteral { } \ ; - print nor Byte , nor Character . Conclusion Among all these types , only Integer , Long , Float , Double are used in the native source code of the jdk . And only the Integer and Long fields are annotated with @ Native because they have no native methods ( as opposed to Float and Double )

Question - 4871051 , answer - 20810612 I ' m on Linux and get same result for both of these approaches : # pre Paths . get ( " " ) docs System . getProperty ( " user . dir " ) docs

Question - 9510125 , answer - 9511578 Just IMHO . Not sure it ' s 100 % correct . invalidate ( args ) marks the container as invalid . Means the content is somehow wrong and must be relayed out . But it ' s just a kind of mark / flag . It ' s possible that multiple invalid containers must be refreshed later . validate ( args ) performs relayout . It means invalid content is asked for all the sizes and all the subcomponents ' sizes are set to proper values by LayoutManager . revalidate ( args ) is just sum of both . It marks the container as invalid and performs layout of the container .

Question - 26375932 , answer - 26407637 It is an integer overflow . The int data type is 4 bytes , or 32 bits . Therefore , numbers larger than 2 ^ ( 32 - 1 ) - 1 ( 2 , 147 , 483 , 647 ) cannot be stored in this data type . Your numerical values will be incorrect . For very large numbers , you will want to import and use the class java . math . BigInteger : # pre NOTE : For numerical values that are still too large for the int data type , but small enough to fit within 8 bytes ( absolute value less than or equal to 2 ^ ( 64 - 1 ) - 1 ) , you should probably use the long primitive . HackerRank ' s practice problems ( www . hackerrank . com ) , such as the Algorithms practice section , ( # a ) include some very good large - number questions that give good practice about how to think about the appropriate data type to use .

Question - 16635398 , answer - 16637740 forEach ( args ) can be implemented to be faster than for - each loop , because the iterable knows the best way to iterate its elements , as opposed to the standard iterator way . So the difference is loop internally or loop externally . For example ArrayList . forEach ( args ) may be simply implemented as # pre as opposed to the for - each loop which requires a lot of scaffolding # pre However , we also need to account for two overhead costs by using forEach ( args ) , one is making the lambda object , the other is invoking the lambda method . They are probably not significant . see also # a for comparing internal / external iterations for different use cases .

Question - 5038204 , answer - 5039178 The commons / lang builders are great and I have been using them for years without noticeable performance overhead ( with and without hibernate ) . But as Alain writes , the Guava way is even nicer : Here ' s a sample Bean : # pre Here ' s equals ( ) and hashCode ( ) implemented with Commons / Lang : # pre and here with Guava : # pre As you can see the Guava version is shorter and avoids superfluous helper objects . In case of equals , it even allows for short - circuiting the evaluation if an earlier Object . equal ( args ) call returns false ( to be fair : commons / lang has an ObjectUtils . equals ( args ) method with identical semantics which could be used instead of EqualsBuilder to allow short - circuiting as above ) . So : yes , the commons lang builders are very preferable over manually constructed equals ( args ) and hashCode ( args ) methods ( or those awful monsters Eclipse will generate for you ) , but the Guava versions are even better . And a note about Hibernate : be careful about using lazy collections in your equals ( ) , hashCode ( ) and toString ( ) implementations . That will fail miserably if you don ' t have an open Session . Note ( about equals ( ) ) : a ) in both versions of equals ( ) above , you might want to use one or both of these shortcuts also : # pre b ) depending on your interpretation of the equals ( ) contract , you might also change the line ( s ) if ( args ) { to # pre If you use the second version , you probably also want to call super ( args ) inside your equals ( args ) method . Opinions differ here , the topic is discussed in this question : # blockquote ( although it ' s about hashCode ( args ) , the same applies to equals ( args ) ) Note ( inspired by Comment from kayahr ) Objects . hashCode ( args ) ( just as the underlying Arrays . hashCode ( args ) ) might perform badly if you have many primitive fields . In such cases , EqualsBuilder may actually be the better solution .

Question - 27949213 , answer - 27950675 Since your first question has already been answered , I ' ll answer your second question . The String objects must be compared character by character , because though equal Object s implies equal hashes , the inverse is not necessarily true . As Holger said in his comment , this represents a hash collision . The applicable specifications for the hashcode ( args ) method are as follows : # blockquote This means that in order for them to guarantee equality , the comparison of each character is necessary in order for them to confirm the equality of the two objects . They start by comparing hashCode s rather than using equals since they are using a hash table for the references , and this improves performance .

Question - 28584669 , answer - 28584932 Your reasoning is that Double . POSITIVE _ INFINITY should not be equal to itself because it is “ likely ” to have been obtained as the result of a loss of accuracy . This line of reasoning applies to all of floating - point . Any finite value can be obtained as the result of an inaccurate operation . That did not push the IEEE 754 standardization committee to define = = as always evaluating to false for finite values , so why should infinities be different ? As defined , = = is useful for people who understand what it does ( that is , test the floating - point values that have been obtained , and certainly not the values that should have been obtained with real computations ) . For anyone who understands that , and you need to understand it to use floating - point even for computations that do not involve infinity , having Double . POSITIVE _ INFINITY = = Double . POSITIVE _ INFINITY evaluate to true is convenient , if only to test if the floating - point result of a floating - point computation is Double . POSITIVE _ INFINITY . That leaves the question of why NaN can afford to have special behavior , and infinities should follow the same general principles as finite values . NaN is different from infinities : the underlying principle of the IEEE 754 standard is that values are exactly what they are , but the result of an operation can be approximated with respect to the real result , and in this case , the resulting floating - point value is obtained according to the rounding mode . Forget for an instant that 1 . 0 / 0 . 0 is defined as + inf , which is an annoyance in this discussion . Think for the moment of Double . POSITIVE _ INFINITY only as the result of operations such as 1 . 0e100 / 1 . 0e - 300 or Double . MAX _ VALUE + Double . MAX _ VALUE . For these operations , + inf is the closest approximation of the real result , just like for operations that produce a finite result . By contrast , NaN is the result you obtain when the operation doesn ' t make sense . It is defensible to have NaN behave specially , but inf is just an approximation of all the values too large to represent . In reality , 1 . 0 / 0 . 0 also produces + inf , but that should be considered an exception . It would have been just as coherent to define the result of that operation as NaN , but defining it as + inf was more convenient in the implementation of some algorithms . An example is provided page 10 in Kahan ' s notes . More details than most will wish for are in the article “ Branch Cuts for Complex Elementary Functions , or Much Ado About Nothing ' s Sign Bit ” . I would also interpret the existence in IEEE 754 of a “ division by zero ” flag separate from the NaN flag as recognition that the user may want to treat division by zero specially although it is not defined as producing NaN .

Question - 9510125 Swing components have multiple methods related to updates of screen layout , in particular : # li validate ( ) # li invalidate ( ) # li revalidate ( ) The Java documentation defines these somewhat from a technical perspective , but it ' s not particularly clear how they are meant to be used . What is the difference between these , and in what circumstances should you use one rather than the others ?

Question - 5673260 , answer - 5673375 You should be able to write the file on the response directly . Something like # pre and then write the file as a binary stream on response . getOutputStream ( args ) . Remember to do response . flush ( args ) at the end and that should do it .

Question - 13195797 , answer - 13195890 FileUtils . cleanDirectory ( args ) ; There is this method available in the same file . This will also recursively deletes all sub - folders and files under them . Docs : org . apache . commons . io . FileUtils . cleanDirectory

Question - 6470651 , answer - 18544736 Threads are not collected until they terminate . They serve as roots of garbage collection . They are one of the few objects that won ' t be reclaimed simply by forgetting about them or clearing references to them . Consider : the basic pattern to terminate a worker thread is to set some condition variable seen by the thread . The thread can check the variable periodically and use that as a signal to terminate . If the variable is not declared volatile , then the change to the variable might not be seen by the thread , so it won ' t know to terminate . Or imagine if some threads want to update a shared object , but deadlock while trying to lock on it . If you only have a handful of threads these bugs will probably be obvious because your program will stop working properly . If you have a thread pool that creates more threads as needed , then the obsolete / stuck threads might not be noticed , and will accumulate indefinitely , causing a memory leak . Threads are likely to use other data in your application , so will also prevent anything they directly reference from ever being collected . As a toy example : # pre Call System . gc ( args ) all you like , but the object passed to leakMe will never die . ( * edited * )

Question - 28584669 Why doesn ' t infinity comparison follow the logic applied to NaNs ? This code prints out false three times : # pre However , if I change Double . NaN to Double . POSITIVE _ INFINITY , I get true for equality , but false for the greater - than and less - than comparisons : # pre This seems dangerous . Assuming that infinite values result from overflows , I imagine it ' s more likely that two variables that ended up as infinities wouldn ' t actually be equal in perfect arithmetic .

Question - 8894258 , answer - 8894348 The first one using str . charAt should be faster . If you dig inside the source code of String class , we can see that charAt is implemented as follows : # pre Here , all it does is index an array and return the value . Now , if we see the implementation of toCharArray , we will find the below : # pre As you see , it is doing a System . arraycopy which is definitely going to be a tad slower than not doing it .

Question - 14491966 , answer - 14502259 There are many , many pseudo random number generators out there . For example Knuth ' s ranarray , the Mersenne twister , or look for LFSR generators . Knuth ' s monumental " Seminumerical algorithms " analizes the area , and proposes some linear congruential generators ( simple to implement , fast ) . But I ' d suggest you just stick to java . util . Random or Math . random , they fast and at least OK for occasional use ( i . e . , games and such ) . If you are just paranoid on the distribution ( some Monte Carlo program , or a genetic algorithm ) , check out their implementation ( source is available somewhere ) , and seed them with some truly random number , either from your operating system or from random . org . If this is required for some application where security is critical , you ' ll have to dig yourself . And as in that case you shouldn ' t believe what some colored square with missing bits spouts here , I ' ll shut up now .

Question - 9481865 I am trying to develop a system where there are different nodes that are run on different system or on different ports on the same system . Now all the nodes create a Socket with a target IP as the IP of a special node known as a bootstrapping node . The nodes then create their own ServerSocket and start listening for connections . The bootstrapping node maintains a list of Nodes and returns them on being quired . Now what I need is the node must register its IP to the bootstrapping node . I tried using cli . getInetAddress ( args ) once the client connects to the ServerSocket of bootstrapping node but that didn ' t work . # li I need the client to register its PPP IP if available ; # li Otherwise the LAN IP if available ; # li Otherwise it must register 127 . 0 . 0 . 1 assuming its the same computer . Please help me with this . EDIT using the code : System . out . println ( args ) ; or System . out . println ( args ) ; My PPP Connection IP address is : 117 . 204 . 44 . 192 but the above returns me 192 . 168 . 1 . 2 EDIT2 I am using the following code : # pre I am able to get all the IP addresses associated all NetworkInterface s , but how do I distinguish them ? ? This is the output I am getting : # pre

Question - 8881291 , answer - 14060804 # li Strings are immutable in Java if you store password as plain text it will be available in memory until Garbage collector clears it and since Strings are used in String pool for re - usability there is pretty high chance that it will be remain in memory for long duration , which pose a security threat . Since any one who has access to memory dump can find the password in clear text # li Java recommendation using getPassword ( args ) method of JPasswordField which returns a char [ ] and deprecated getText ( args ) method which returns password in clear text stating security reason . # li toString ( ) there is always a risk of printing plain text in log file or console but if use Array you won ' t print contents of array instead its memory location get printed . # pre # blockquote Final thoughts : Though using char [ ] is not just enough you need to erase content to be more secure . I also suggest working with hash ' d or encrypted password instead of plaintext and clearing it from memory as soon as authentication is completed .

Question - 20331163 , answer - 20331241 I have a very dumb but working option . if you have the String fullDate = " 11 / 15 / 2013 08 : 00 : 00 " ; String finalDate = fullDate . split ( args ) [ 0 ] ; That should work easy and fast . : )

Question - 19235606 I am having trouble understanding the Stream interface in Java 8 , especially where it has to do with the Spliterator and Collector interfaces . My problem is that I simply can ' t understand yet the Spliterator and the Collector interfaces , and as a result the Stream interface is still somewhat obscure to me . What exactly is a Spliterator and a Collector , and how can I use them ? If I am willing to write my own Spliterator or Collector ( and probably my own Stream in that process ) , what should I do and not do ? I read some examples scattered around the web , but since everything here is stil new and subject to changes , examples and tutorials are still very sparse .

Question - 14534767 , answer - 34073047 Another option is to use Apache Commons StrBuilder , which has the functionality that ' s lacking in StringBuilder . StrBuilder . appendLn ( )

Question - 13102045 I am using Scanner methods nextInt ( args ) and nextLine ( args ) for reading input . Basically , it looks like this : # pre The problem is that after entering the numerical value , the first input . nextLine ( args ) is skipped and the second input . nextLine ( args ) is executed , so that my output looks like this : # pre I tested my application and it looks like the problem lies in using input . nextInt ( args ) . If I delete it , then both string1 = input . nextLine ( args ) and string2 = input . nextLine ( args ) are executed as I want them to be .

Question - 28584669 , answer - 28590286 Since Double . Nan . equals ( Double . NaN ) was mentioned : It ' s one thing what should happen when you perform arithmetic and compare numbers , it ' s a totally different thing when you consider how objects should behave . Two typical problem cases are : Sorting an array of numbers , and using hash values to implement dictionaries , sets , and so on . There are two exceptional cases where the normal ordering with < , = and > doesn ' t apply : One case is that + 0 = - 0 and the other is that NaN ≠ NaN , and x < NaN , x > NaN , x = NaN will always be false whatever x is . Sorting algorithms can get into trouble with this . A sorting algorithm may assume that x = x is always true . So if I know that x is stored in an array and look for it , I might not do any bounds check because the search for it must find something . Not if x is NaN . A sorting algorithm may assume that exactly one of a < b and a > = b must be true . Not if one is NaN . So a naive sorting algorithm may crash when NaNs are present . You ' d have to decide where you want NaNs to end up when sorting the array , and then change your comparison code so that it works . Now dictionaries and sets and generally hashing : What if I use an NaN as the key ? A set contains unique objects . If the set contains an NaN and I try to add another one , is it unique because it is not equal to the one that is already there ? What about + 0 and - 0 , should they be considered equal or different ? There ' s the rule that any two items considered equal must have the same hash value . So the sensible thing is ( probably ) that a hash function returns one unique value for all NaNs , and one unique value for + 0 and - 0 . And after the hash lookup when you need to find an element with the same hash value that is actually equal , two NaNs should be considered equal ( but different from anything else ) . That ' s probably why Double . Nan . equal ( ) behaves different from = = .

Question - 28459498 , answer - 28465634 I think there are very few differences between the two when you look closely enough . At it ' s face , an IEnumerable does appear to be a reusable construct : # pre However , the compiler is actually doing a little bit of work to help us out ; it generates the following code : # pre Each time you would actually iterate over the enumerable , the compiler creates an enumerator . The enumerator is not reusable ; further calls to MoveNext will just return false , and there is no way to reset it to the beginning . If you want to iterate over the numbers again , you will need to create another enumerator instance . To better illustrate that the IEnumerable has ( can have ) the same ' feature ' as a Java Stream , consider a enumerable whose source of the numbers is not a static collection . For example , we can create an enumerable object which generates a sequence of 5 random numbers : # pre Now we have very similar code to the previous array - based enumerable , but with a second iteration over numbers : # pre The second time we iterate over numbers we will get a different sequence of numbers , which isn ' t reusable in the same sense . Or , we could have written the RandomNumberStream to thrown an exception if you try to iterate over it multiple times , making the enumerable actually unusable ( like a Java Stream ) . Also , what does your enumerable - based quick sort mean when applied to a RandomNumberStream ? Conclusion So , the biggest difference is that . NET allows you to reuse an IEnumerable by implicitly creating a new IEnumerator in the background whenever it would need to access elements in the sequence . This implicit behavior is often useful ( and ' powerful ' as you state ) , because we can repeatedly iterate over a collection . But sometimes , this implicit behavior can actually cause problems . If your data source is not static , or is costly to access ( like a database or web site ) , then a lot of assumptions about IEnumerable have to be discarded ; reuse is not that straight - forward

Question - 32334319 , answer - 39380442 As stated across many of the answers . The Quicksort is used by Arrays . sort for sorting primitive collections because stability isn ' t required ( you won ' t know or care if two identical ints were swapped in the sort ) MergeSort or more specifically Timsort is used by Arrays . sort for sorting collections of objects . Stability is required . Quicksort does not provide for stability , Timsort does . Collections . sort delegates to Arrays . sort which is why you see the javadoc referencing the MergeSort .

Question - 31445024 , answer - 31445150 I first tought your question was a dupe of What code does the compiler generate for autoboxing ? However , after your comment on @ ElliottFrisch I realized it was different : # blockquote For other readers , assume that " behaves that way " means using valueOf . Remember that there are multiples compilers for Java . To be " legal " they must follow the contract given in the JLS . Therefore , as long as all the rules here are respected , there is no guarantee of how autoboxing is internally implemented . But I don ' t see any reason to not use valueOf , specially that it uses the cached values and is the recommended way as per this article by Joseph D . Darcy .

Question - 16324831 , answer - 16324963 Note : everything in this post is in the source of Java7 - b147 Double . parseDouble ( args ) goes into a Sun library ( in sun . misc . FloatingDecimal ) the first important thing that happens is : # pre Integer . parseInt ( args ) is done manually in the Integer class . The first important thing that happens is : # pre I would guess there are two different authors .

Question - 20945049 , answer - 20945113 String is immutable * but this only means you cannot change it using its public API . What you are doing here is circumventing the normal API , using reflection . The same way , you can change the values of enums , change the lookup table used in Integer autoboxing etc . Now , the reason s1 and s2 change value , is that they both refer to the same interned string . The compiler does this ( as mentioned by other answers ) . The reason s3 does not was actually a bit surprising to me , as I thought it would share the value array ( it did in earlier version of Java , before Java 7u6 ) . However , looking at the source code of String , we can see that the value character array for a substring is actually copied ( using Arrays . copyOfRange ( args ) ) . This is why it goes unchanged . You can install a SecurityManager , to avoid malicious code to do such things . But keep in mind that some libraries depend on using these kind of reflection tricks ( typically ORM tools , AOP libraries etc ) . * ) I initially wrote that String s aren ' t really immutable , just " effective immutable " . This might be misleading in the current implementation of String , where the value array is indeed marked private final . It ' s still worth noting , though , that there is no way to declare an array in Java as immutable , so care must be taken not to expose it outside its class , even with the proper access modifiers . As this topic seems overwhelmingly popular , here ' s some suggested further reading : Heinz Kabutz ' s Reflection Madness talk from JavaZone 2009 , which covers a lot of the issues in the OP , along with other reflection . . . well . . . madness . It covers why this is sometimes useful . And why , most of the time , you should avoid it . : - )

Question - 23218874 , answer - 23232560 For simple cases such as the one illustrated , they are mostly the same . However , there are a number of subtle differences that might be significant . One issue is with ordering . With Stream . forEach , the order is undefined . It ' s unlikely to occur with sequential streams , still , it ' s within the specification for Stream . forEach to execute in some arbitrary order . This does occur frequently in parallel streams . By contrast , Iterable . forEach is always executed in the iteration order of the Iterable , if one is specified . Another issue is with side effects . The action specified in Stream . forEach is required to be non - interfering . ( See the java . util . stream package doc . ) Iterable . forEach potentially has fewer restrictions . For the collections in java . util , Iterable . forEach will generally use that collection ' s Iterator , most of which are designed to be fail - fast and which will throw ConcurrentModificationException if the collection is structurally modified during the iteration . However , modifications that aren ' t structural are allowed during iteration . For example , the ArrayList class documentation says " merely setting the value of an element is not a structural modification . " Thus , the action for ArrayList . forEach is allowed to set values in the underlying ArrayList without problems . The concurrent collections are yet again different . Instead of fail - fast , they are designed to be weakly consistent . The full definition is at that link . Briefly , though , consider ConcurrentLinkedDeque . The action passed to its forEach method is allowed to modify the underlying deque , even structurally , and ConcurrentModificationException is never thrown . However , the modification that occurs might or might not be visible in this iteration . ( Hence the " weak " consistency . ) Still another difference is visible if Iterable . forEach is iterating over a synchronized collection . On such a collection , Iterable . forEach takes the collection ' s lock once and holds it across all the calls to the action method . The Stream . forEach call uses the collection ' s spliterator , which does not lock , and which relies on the prevailing rule of non - interference . The collection backing the stream could be modified during iteration , and if it is , a ConcurrentModificationException or inconsistent behavior could result .

Question - 5785745 , answer - 15962949 If you want to make a copy of : int [ ] a = { 1 , 2 , 3 , 4 , 5 } ; This is the way to go : int [ ] b = Arrays . copyOf ( args ) ; Arrays . copyOf may be faster than a . clone ( args ) on small arrays . Both copy elements equally fast but clone ( ) returns Object so the compiler has to insert an implicit cast to int [ ] . You can see it in the bytecode , something like this : # pre

Question - 34250207 As I recall , before Java 8 , the default capacity of ArrayList was 10 . Surprisingly , the comment on the default ( void ) constructor still says : Constructs an empty list with an initial capacity of ten . From ArrayList . java : # pre

Question - 21947452 I generated two matrices of 1000 x 1000 : First Matrix : O and # . Second Matrix : O and B . Using the following code , the first matrix took 8 . 52 seconds to complete : # pre With this code , the second matrix took 259 . 152 seconds to complete : # pre What is the reason behind the dramatically different run times ? As suggested in the comments , printing only System . out . print ( args ) ; takes 7 . 8871 seconds , whereas System . out . print ( args ) ; gives still printing . . . . As others who pointed out that it works for them normally , I tried Ideone . com for instance , and both pieces of code execute at the same speed . Test Conditions : # li I ran this test from Netbeans 7 . 2 , with the output into its console # li I used System . nanoTime ( args ) for measurements

Question - 21163108 , answer - 22269778 There actually is a trick how to execute a parallel operation in a specific fork - join pool . If you execute it as a task in a fork - join pool , it stays there and does not use the common one . # pre The trick is based on ForkJoinTask . fork which specifies : " Arranges to asynchronously execute this task in the pool the current task is running in , if applicable , or using the ForkJoinPool . commonPool ( ) if not inForkJoinPool ( ) "

Question - 17828584 I was wondering what happens when you try to catch an StackOverflowError and came up with the following method : # pre Now my question : Why does this method print ' 4 ' ? I thought maybe it was because System . out . println ( args ) needs 3 segments on the call stack , but I don ' t know where the number 3 comes from . When you look at the source code ( and bytecode ) of System . out . println ( args ) , it normally would lead to far more method invocations than 3 ( so 3 segments on the call stack would not be sufficient ) . If it ' s because of optimizations the Hotspot VM applies ( method inlining ) , I wonder if the result would be different on another VM . Edit : As the output seems to be highly JVM specific , I get the result 4 using Java ( TM ) SE Runtime Environment ( build 1 . 6 . 0 _ 41 - b02 ) Java HotSpot ( TM ) 64 - Bit Server VM ( build 20 . 14 - b01 , mixed mode ) Explanation why I think this question is different from Understanding java stack : My question is not about why there is a cnt > 0 ( obviously because System . out . println ( args ) requires stack size and throws another StackOverflowError before something gets printed ) , but why it has the particular value of 4 , respectively 0 , 3 , 8 , 55 or something else on other systems .

Question - 8189466 Note : I am aware of the Iterator # remove ( args ) method . In the following code sample , I don ' t understand why the List . remove in main method throws ConcurrentModificationException but not in the remove method . # pre

Question - 28584669 , answer - 28596792 To me , it seems that " because it should behave the same as zero " would make a good answer . Arithmetic overflow and underflow should be handlable similarly . If you underflow from the largest near - infinitesimally small value which can be stored in a float , you get zero , and zeros compare as identical . If you overflow from the largest near - infinitely large value which can be stored in a float , you get INF , and INFs compare as identical . This means that code which handles numbers which are out - of - scope in both directions will not require separate special - casing for one or the other . Instead , either both or neither will need to be treated differently . And the simplest requirement is covered by the " neither " case : you want to check if something over / underflowed , you can compare it to zero / INF using just the normal arithmetic comparison operators , without needing to know you current language ' s special syntax for the checking command : is it Math . isInfinite ( ) , Float . checkForPositiveInfinity ( ) , hasOverflowed ( ) . . . ?

Question - 11408427 , answer - 11408482 The Java language provides special support for the string concatenation operator ( + ) and for conversion of other objects to strings . String concatenation is implemented through the StringBuilder ( or StringBuffer ) class and its append method .

Question - 13744450 , answer - 13744816 In very simple terms ( because the other answers are referring you to all the official design patterns anyway , so look at them for further details ) : If you want to have a class which is monitored by other classes in the ecosystem of your program you say that you want the class to be observable . I . e . there might be some changes in its state which you would want to broadcast to the rest of the program . Now , to do this we have to call some kind of method . We don ' t want the Observable class to be tightly coupled with the classes that are interested in observing it . It doesn ' t care who it is as long as it fulfils certain criteria . ( Imagine it is a radio station , it doesn ' t care who is listening as long as they have an FM radio tuned on their frequency ) . To achieve that we use an interface , referred to as the Observer . Therefore , the Observable class will have a list of Observers ( i . e . instances implementing the Observer interface methods you might have ) . Whenever it wants to broadcast something , it just calls the method on all the observers , one after the other . The last thing to close the puzzle is how will the Observable class know who is interested ? So the Observable class must offer some mechanism to allow Observers to register their interest . A method such as addObserver ( args ) internally adds the Observer to the list of observers , so that when something important happens , it loops through the list and calls the respective notification method of the Observer interface of each instance in the list . It might be that in the interview they did not ask you explicitly about the java . util . Observer and java . util . Observable but about the generic concept . The concept is a design pattern , which Java happens to provide support for directly out of the box to help you implement it quickly when you need it . So I would suggest that you understand the concept rather than the actual methods / classes ( which you can look up when you need them ) . UPDATE In response to your comment , the actual java . util . Observable class offers the following facilities : # li Maintaining a list of java . util . Observer instances . New instances interested in being notified can be added through addObserver ( args ) , and removed through deleteObserver ( args ) . # li Maintaining an internal state , specifying whether the object has changed since the last notification to the observers . This is useful because it separates the part where you say that the Observable has changed , from the part where you notify the changes . ( E . g . Its useful if you have multiple changes happening and you only want to notify at the end of the process rather than at each small step ) . This is done through setChanged ( args ) . So you just call it when you changed something to the Observable and you want the rest of the Observers to eventually know about it . # li Notifying all observers that the specific Observable has changed state . This is done through notifyObservers ( args ) . This checks if the object has actually changed ( i . e . a call to setChanged ( args ) was made ) before proceeding with the notification . There are 2 versions , one with no arguments and one with an Object argument , in case you want to pass some extra information with the notification . Internally what happens is that it just iterates through the list of Observer instances and calls the update ( Observable o , Object arg ) method for each of them . This tells the Observer which was the Observable object that changed ( you could be observing more than one ) , and the extra Object arg to potentially carry some extra information ( passed through notifyObservers ( args ) .

Question - 18571223 , answer - 18571352 You can use String . getBytes ( args ) which returns the byte [ ] array .

Question - 27908213 Are enum names interned in Java ? I . e . is it guaranteed that enum1 . name ( args ) = = enum2 . name ( args ) in case of the same name ? And is it safe to compare enum . name ( args ) to a String that is guaranteed to be interned .

Question - 28840047 , answer - 28840048 This is of course a " feature " . The ConcurrentHashMap . computeIfAbsent ( ) Javadoc reads : # blockquote The " must not " wording is a clear contract , which my algorithm violated , although not for the same concurrency reasons . What ' s still interesting is that there is no ConcurrentModificationException . Instead , the program just never halts - which still is a rather dangerous bug in my opinion ( i . e . infinite loops . or : anything that can possibly go wrong , does ) . The simplest use - site solution for this concrete problem would be to not use a ConcurrentHashMap , but just a HashMap instead : static Map < T > cache = new HashMap < T > ( args ) ; Now , everything works fine . Note : The HashMap . computeIfAbsent ( ) or Map . computeIfAbsent ( ) Javadoc don ' t forbid such recursive computation , which is of course ridiculous as the type of the cache is Map < T > , not ConcurrentHashMap < T > . It is very dangerous for subtypes to drastically re - define super type contracts ( Set vs . SortedSet is greeting ) . It should thus be forbidden also in super types , to perform such recursion .

Question - 20358883 , answer - 20358920 Fixed size List The easiest way , that I know of , is to create a fixed - size single element List with Arrays . asList ( T . . . ) like / / Returns a List backed by a varargs T . return Arrays . asList ( args ) ; Variable size List If it needs vary in size you can construct an ArrayList and the fixed - size List like return new ArrayList < T > ( args ) ; and ( in Java 7 + ) you can use the diamond operator < > to make it return new ArrayList < T > ( args ) ;

Question - 29494800 , answer - 29495065 # li It is checking if newType is array of Objects or not : # pre Why to do that ? Because new Object [ n ] is faster than Array . newInstance # li Array . newInstance ( args ) creates an array of types defined by the first argument , eg String . class - > String [ ] . Note that String [ ] . class . getComponentType ( args ) returns String . class # li You cannot use it like that , but it can be like this Integer [ ] nums = Arrays . copyOf ( args ) ; in this case it depends only on actual type of elements , eg Arrays . copyOf ( args ) ; will fail , you cannot write in Integer [ ] anything but Integer

Question - 34509566 , answer - 34509669 The difference between d and e is that when you concatenate string literals , the concatenation is performed at compile time . Java compiler treats StringLiteral + StringLiteral expression in the same way as StringLiteral expression , producing the same literal at compile time . Since all String literals get interned , d , which is a result of StringLiteral + StringLiteral , also ends up referencing the same object as a and b ' s StringLiteral . The expression for e , which is c + StringLiteral , is evaluated at runtime . Even though it produces the same string , this fact is not used by the compiler . That ' s why a different String object is produced , resulting in failed comparison on = = .

Question - 18777989 , answer - 37905386 Many junior developers make the mistake of thinking of interfaces , abstract and concrete classes as slight variations of the same thing , and choose one of them purely on technical grounds : Do I need multiple inheritance ? Do I need some place to put common methods ? Do I need to bother with something other than just a concrete class ? This is wrong , and hidden in these questions is the main problem : " I " . When you write code for yourself , by yourself , you rarely think of other present or future developers working on or with your code . Interfaces and abstract classes , although apparently similar from a technical point of view , have completely different meanings and purposes . Summary # li An interface defines a contract that some implementation will fulfill for you . # li An abstract class provides a default behavior that your implementation can reuse . These two points above is what I ' m looking for when interviewing , and is a compact enough summary . Read on for more details . Alternative summary # li An interface is for defining public APIs # li An abstract class is for internal use , and for defining SPIs By example To put it differently : A concrete class does the actual work , in a very specific way . For example , an ArrayList uses a contiguous area of memory to store a list of objects in a compact manner which offers fast random access , iteration , and in - place changes , but is terrible at insertions , deletions , and occasionally even additions ; meanwhile , a LinkedList uses double - linked nodes to store a list of objects , which instead offers fast iteration , in - place changes , and insertion / deletion / addition , but is terrible at random access . These two types of lists are optimized for different use cases , and it matters a lot how you ' re going to use them . When you ' re trying to squeeze performance out of a list that you ' re heavily interacting with , and when picking the type of list is up to you , you should carefully pick which one you ' re instantiating . On the other hand , high level users of a list don ' t really care how it is actually implemented , and they should be insulated from these details . Let ' s imagine that Java didn ' t expose the List interface , but only had a concrete List class that ' s actually what LinkedList is right now . All Java developers would have tailored their code to fit the implementation details : avoid random access , add a cache to speed up access , or just reimplement ArrayList on their own , although it would be incompatible with all the other code that actually works with List only . That would be terrible . . . But now imagine that the Java masters actually realize that a linked list is terrible for most actual use cases , and decided to switch over to an array list for their only List class available . This would affect the performance of every Java program in the world , and people wouldn ' t be happy about it . And the main culprit is that implementation details were available , and the developers assumed that those details are a permanent contract that they can rely on . This is why it ' s important to hide implementation details , and only define an abstract contract . This is the purpose of an interface : define what kind of input a method accepts , and what kind of output is expected , without exposing all the guts that would tempt programmers to tweak their code to fit the internal details that might change with any future update . An abstract class is in the middle between interfaces and concrete classes . It is supposed to help implementations share common or boring code . For example , AbstractCollection provides basic implementations for isEmpty based on size is 0 , contains as iterate and compare , addAll as repeated add , and so on . This lets implementations focus on the crucial parts that differentiate between them : how to actually store and retrieve data . Another perspective : APIs versus SPIs Interfaces are low - cohesion gateways between different parts of code . They allow libraries to exist and evolve without breaking every library user when something changes internally . It ' s called Application Programming Interface Abstract classes are high - cohesion helpers to be used when implementing an interface , assuming some level of implementation details . Alternatively , abstract classes are used for defining SPIs , Service Provider Interfaces . The difference between an API and an SPI is subtle , but important : for an API , the focus is on who uses it , and for an SPI the focus is on who implements it . Adding methods to an API is easy , all existing users of the API will still compile . Adding methods to an SPI is hard , since every service provider ( concrete implementation ) will have to implement the new methods . If interfaces are used to define an SPI , a provider will have to release a new version whenever the SPI contract changes . If abstract classes are used instead , new methods could either be defined in terms of existing abstract methods , or as empty throw not implemented exception stubs , which will at least allow an older version of a service implementation to still compile and run . A note on Java 8 and default methods Although Java 8 introduced default methods for interfaces , which makes the line between interfaces and abstract classes even blurrier , this wasn ' t so that implementations can reuse code , but to make it easier to change interfaces that serve both as an API and as an SPI ( or are wrongly used for defining SPIs instead of abstract classes ) . " Book knowledge " The technical details provided in the OP ' s answer are considered " book knowledge " because this is usually the approach used in school and in most technology books about a language : what a thing is , not how to use it in practice , especially in large scale applications . Here ' s an analogy : supposed the question was : # blockquote The technical answer sounds like : # blockquote That is all true , but completely misses the points that they are two completely different things , and both can be used at the same time for different purposes , and the " doing it " aspect is not the most important thing about either of the two options . The answer lacks perspective , it shows an immature way of thinking , while correctly presenting true " facts " .

Question - 15202997 , answer - 29527145 Adding local classes , lambdas and the toString ( args ) method to complete the previous two answers . Further , I add arrays of lambdas and arrays of anonymous classes ( which do not make any sense in practice though ) : # pre This is the full output : # pre So , here are the rules . First , lets start with primitive types and void : # li If the class object represents a primitive type or void , all the four methods simply returns its name . Now the rules for the getName ( args ) method : # li Every non - lambda and non - array class or interface ( i . e , top - level , nested , inner , local and anonymous ) has a name ( which is returned by getName ( args ) ) that is the package name followed by a dot ( if there is a package ) , followed by the name of its class - file as generated by the compiler ( whithout the suffix . class ) . If there is no package , it is simply the name of the class - file . If the class is an inner , nested , local or anonymous class , the compiler should generate at least one $ in its class - file name . Note that for anonymous classes , the class name would end with a dollar - sign followed by a number . # li Lambda class names are generally unpredictable , and you shouldn ' t care about they anyway . Exactly , their name is the name of the enclosing class , followed by $ $ Lambda $ , followed by a number , followed by a slash , followed by another number . # li The class descriptor of the primitives are Z for boolean , B for byte , S for short , C for char , I for int , J for long , F for float and D for double . For non - array classes and interfaces the class descriptor is L followed by what is given by getName ( args ) followed by ; . For array classes , the class descriptor is [ followed by the class descriptor of the component type ( which may be itself another array class ) . # li For array classes , the getName ( args ) method returns its class descriptor . This rule seems to fail only for array classes whose the component type is a lambda ( which possibly is a bug ) , but hopefully this should not matter anyway because there is no point even on the existence of array classes whose component type is a lambda . Now , the toString ( args ) method : # li If the class instance represents an interface ( or an annotation , which is a special type of interface ) , the toString ( args ) returns StringLiteral + getName ( args ) . If it is a primitive , it returns simply getName ( args ) . If it is something else ( a class type , even if it is a pretty weird one ) , it returns StringLiteral + getName ( args ) . The getCanonicalName ( args ) method : # li For top - level classes and interfaces , the getCanonicalName ( args ) method returns just what the getName ( args ) method returns . # li The getCanonicalName ( args ) method returns null for anonymous or local classes and for array classes of those . # li For inner and nested classes and interfaces , the getCanonicalName ( args ) method returns what the getName ( args ) method would replacing the compiler - introduced dollar - signs by dots . # li For array classes , the getCanonicalName ( args ) method returns null if the canonical name of the component type is null . Otherwise , it returns the canonical name of the component type followed by [ ] . The getSimpleName ( args ) method : # li For top - level , nested , inner and local classes , the getSimpleName ( args ) returns the name of the class as written in the source file . # li For anonymous classes the getSimpleName ( args ) returns an empty String . # li For lambda classes the getSimpleName ( args ) just returns what the getName ( args ) would return without the package name . This do not makes much sense and looks like a bug for me , but there is no point in calling getSimpleName ( args ) on a lambda class to start with . # li For array classes the getSimpleName ( args ) method returns the simple name of the component class followed by [ ] . This have the funny / weird side - effect that array classes whose component type is an anonymous class have just [ ] as their simple names .

Question - 16252269 , answer - 16252296 Use util method of java . util . Collections class , i . e Collections . sort ( args ) In fact , if you want to sort custom object you can use Collections . sort ( args ) see collections api

Question - 16148575 I am trying to build a HashMap which will have integer as keys and objects as values . My syntax is : HashMap < T > myMap = new HashMap < T > ( args ) ; However , the error returned is - Syntax error on token " int " , Dimensions expected after this token - I don ' t understand why I should add a dimension ( ie : making the int into an array ) since I only need to store a digit as key . What could I do ? Thanks in advance ! : )

Question - 5585779 , answer - 5585800 int foo = Integer . parseInt ( args ) ; See the Java Documentation for more information . ( If you have it in a StringBuilder ( or the ancient StringBuffer ) , you ' ll need to do Integer . parseInt ( args ) ; instead ) .

Question - 20331163 , answer - 20331243 Create a DateTimeFormatter using DateTimeFormat . forPattern ( String ) Using Joda time you would do it like this : # pre Also , if you wanted to use standard Java , you would do it like this : # pre

Question - 25850328 , answer - 25850576 # li Is the definition of a marker interface mentioned above in 1st point wrong ? - It is correct in the parts that ( 1 ) a marker interface must be empty , and ( 2 ) implementing it is meant to imply some special treatment of the implementing class . The part that is incorrect is that it implies that JVM or the compiler would treat the objects of that class differently : you are correct in observing that it is the code of Java class library that treats these objects as cloneable , serializable , etc . It has nothing to do with the compiler or the JVM . # li instead of using the instanceOf operator why can ' t the method be something like writeObject ( args ) so that there is a compile - time type checking - This lets you avoid polluting your code with the name of the marker interface when a " plain Object " is needed . For example , if you make a class that needs to be serializable , and has object members , you would be forced to either do casting or make your objects Serializable at compile time . This is inconvenient , because the interface is devoid of any functionality . # li How Annotations are better than Marker Interfaces ? - They let you achieve the same purpose of conveying metadata about the class to its consumers without creating a separate type for it . Annotations are more powerful , too , letting programmers pass more sophisticated information to classes that " consume " it .

Question - 33358248 Currently the BlendModes ( Subtract , Exclusion etc ) use the LauncherImage as the mask . Can I apply these BlendModes to a ColorMatrix ? I ' m using the GPUImageLibrary colorMatrix [ 0 . 393 , 0 . 7689999 , 0 . 18899999 , 0 , 0 , 0 . 349 , 0 . 6859999 , 0 . 16799999 , 0 , 0 , 0 . 272 , 0 . 5339999 , 0 . 13099999 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ; SubtractBlendFilter . java # pre GPUIMageTwoInputFilter . java # pre My guess it involves changing something with String SUBTRACT _ BLEND _ GRAGMENT _ SHADER & String VERTEX _ SHADER .

Question - 18987692 , answer - 18987738 You can use IsNull . nullValue ( ) method : # pre

Question - 29945627 , answer - 29946155 The syntax you ' re after is possible with a little helper function that converts a Runnable into Action < T > ( you can place it in Action for example ) : # pre

Question - 11821801 I ' m trying to understand what makes the lock in concurrency so important if one can use synchronized ( args ) . In the dummy code below , I can do either : # li synchronized the entire method or synchronize the vulnerable area ( synchronized ( this ) { . . . } ) # li OR lock the vulnerable code area with a ReentrantLock . Code : # pre

Question - 7348711 , answer - 20793241 Environment variables may also provide a useful means - - COMPUTERNAME on Windows , HOSTNAME on most modern Unix / Linux shells . See : # a I ' m using these as " supplementary " methods to InetAddress . getLocalHost ( args ) . getHostName ( args ) , since as several people point out , that function doesn ' t work in all environments . Runtime . getRuntime ( args ) . exec ( args ) is another possible supplement . At this stage , I haven ' t used it . # pre

Question - 28840047 Some time ago , I ' ve blogged about a Java 8 functional way of calculating fibonacci numbers recursively , with a ConcurrentHashMap cache and the new , useful computeIfAbsent ( args ) method : # pre I chose ConcurrentHashMap because I was thinking of making this example even more sophisticated by introducing parallelism ( which I didn ' t in the end ) . Now , let ' s increase the number from 8 to 25 and observe what happens : System . out . println ( args ) ; The program never halts . Inside the method , there ' s a loop that just runs forever : # pre I ' m using : # pre Matthias , a reader of that blog post also confirmed the issue ( he actually found it ) . This is weird . I would have expected any of the following two : # li It works # li It throws a ConcurrentModificationException But just never halting ? That seems dangerous . Is it a bug ? Or did I misunderstand some contract ?

Question - 28818506 , answer - 28833677 The cleanest “ try services ” approach given the current API would be : Optional < T > o = Stream . < Supplier < T > > of ( args ) . map ( args ) . filter ( args ) . map ( args ) . findFirst ( args ) ; The important aspect is not the ( constant ) chain of operations you have to write once but how easy it is to add another service ( or modify the list of services is general ) . Here , adding or removing a single ( ) - > serviceX ( args ) is enough . Due to the lazy evaluation of streams , no service will be invoked if a preceding service returned a non - empty Optional .

Question - 24676877 , answer - 24681959 I have a few points to add to Brian Goetz ' excellent answer . It ' s quite common to return a Stream from a " getter " style method call . See the Stream usage page in the Java 8 javadoc and look for " methods . . . that return Stream " for the packages other than java . util . Stream . These methods are usually on classes that represent or can contain multiple values or aggregations of something . In such cases , APIs typically have returned collections or arrays of them . For all the reasons that Brian noted in his answer , it ' s very flexible to add Stream - returning methods here . Many of these classes have collections - or array - returning methods already , because the classes predate the Streams API . If you ' re designing a new API , and it makes sense to provide Stream - returning methods , it might not be necessary to add collection - returning methods as well . Brian mentioned the cost of " materializing " the values into a collection . To amplify this point , there are actually two costs here : the cost of storing values in the collection ( memory allocation and copying ) and also the cost of creating the values in the first place . The latter cost can often be reduced or avoided by taking advantage of a Stream ' s laziness - seeking behavior . A good example of this are the APIs in java . nio . file . Files : # pre Not only does readAllLines have to hold the entire file contents in memory in order to store it into the result list , it also has to read the file to the very end before it returns the list . The lines method can return almost immediately after it has performed some setup , leaving file reading and line breaking until later when it ' s necessary - - or not at all . This is a huge benefit , if for example , the caller is interested only in the first ten lines : List < T > firstTen = Files . lines ( args ) . limit ( args ) . collect ( args ) ; Of course considerable memory space can be saved if the caller filters the stream to return only lines matching a pattern , etc . An idiom that seems to be emerging is to name stream - returning methods after the plural of the name of the things that it represents or contains , without a get prefix . Also , while stream ( args ) is a reasonable name for a stream - returning method when there is only one possible set of values to be returned , sometimes there are classes that have aggregations of multiple types of values . For example , suppose you have some object that contains both attributes and elements . You might provide two stream - returning APIs : # pre

Question - 28770822 , answer - 28816219 Looking at the issue and fix , it looks like this has been done to resolve a handling of a header file generation for special classes in jigsaw Jigsaw is a module system designated to use in Java SE Platform and JDK . More details here Here is a corresponding changeset . You can see a comment , # blockquote From the changeset I see that for the sake of purpose in addition to java . lang . Integer and java . lang . Long , also some properties in java . net . SocketOptions , sun . nio . ch . IOStatus , java . io . FileSystem have been changed to @ Native . So I assume only those were needed to solve the dependency with jigsaw .

Question - 20363719 , answer - 34675066 I was trying to do this and found that , using the answers above , when using Functions . identity ( args ) for the key to the Map , then I had issues with using a local method like this : : localMethodName to actually work because of typing issues . Functions . identity ( args ) actually does something to the typing in this case so the method would only work by returning Object and accepting a param of Object To solve this , I ended up ditching Functions . identity ( args ) and using s - > s instead . So my code , in my case to list all directories inside a directory , and for each one use the name of the directory as the key to the map and then call a method with the directory name and return a collection of items , looks like : Map < T > items = Arrays . stream ( args ) . map ( args ) . collect ( args ) ;

Question - 30522698 The problem I would like to be able to override my apps resources such as R . colour . brand _ colour or R . drawable . ic _ action _ start at runtime . My application connects to a CMS system that will provide branding colours and images . Once the app has downloaded the CMS data it needs to be able to re - skin itself . I know what you are about to say - overriding resources at runtime is not possible . Except that it kinda is . In particular I have found this Bachelor Thesis from 2012 which explains the basic concept - The Activity class in android extends ContextWrapper , which contains the attachBaseContext method . You can override attachBaseContext to wrap the Context with your own custom class which overrides methods such as getColor and getDrawable . Your own implementation of getColor could look the colour up however it wanted . The Calligraphy library uses a similar approach to inject a custom LayoutInflator which can deal with loading custom fonts . The code I have created a simple Activity which uses this approach to override the loading of a colour . # pre The problem is , it doesn ' t work ! The logging shows calls to load resources such as layout / activity _ main and mipmap / ic _ launcher however color / theme _ colour is never loaded . It seems that the context is being used to create the window and action bar , but not the activity ' s content view . My questions is - Where does the layout inflator load resources from , if not the activities context ? I would also like to know - Is there a workable way to override the loading of colours and drawables at runtime ? A word about alternative approaches I know its possible to theme an app from CMS data other ways - for example we could create a method getCMSColour ( args ) then inside our onCreate ( args ) we have a bunch of code along the lines of : myTextView . setTextColour ( args ) A similar approach could be taken for drawables , strings , etc . However this would result in a large amount of boilerplate code - all of which needs maintaining . When modifying the UI it would be easy to forget to set the colour on a particular view . Wrapping the Context to return our own custom values is ' cleaner ' and less prone to breakage . I would like to understand why it doesn ' t work , before exploring alternative approaches .

Question - 27683759 , answer - 27684040 That line creates an empty list of strings by calling a static method with a generic type parameter . Inside the Collections class , there is a static method emptyList declared like : # pre This has a generic type parameter T . We call call this method by using : List < T > list = Collections . emptyList ( args ) ; and T is infered to be a String because of the type of list . We can also specify the type of T by putting it in angle brackets when calling emptyList . This may be needed if we want a more specific type than is inferred : List < T > list = Collections . < String > emptyList ( args ) ; emptyList < T > ( args ) is not correct because that placement is only valid when creating instances of generic classes , not calling methods . When using new there are two possible type parameters , the ones before the class name are for the constructor only , and the ones after the class name are for the whole instance , so with the class : # pre We can call its constructor where A is String and B is Integer like : MyClass < T > a = new < T > MyClass < T > ( args ) ; or by using type inference : MyClass < T > a = new MyClass < T > ( args ) ; See also : # li Generic Methods # li Type Inference

Question - 30125296 , answer - 35035659 You can use reduce method : long creditAmountSum = result . stream ( args ) . map ( args ) . reduce ( args ) ;

Question - 20358883 Is there a Utility method somewhere that can do this in 1 line ? I can ' t find it anywhere in Collections , or List . # pre I don ' t want to re - invent the wheel unless I plan on putting fancy rims on it . Well . . . the type can be T , and not String . but you get the point . ( with all the null checking , safety checks . . . etc )

Question - 25850328 I was being taught that Marker interface in Java is an empty interface and is used to signal to compiler or JVM that the objects of the class implementing this interface must be treated in a special way , like serializing , cloning , etc . But lately I have learned that it actually has nothing to do with the compiler or the JVM . For example , in case of Serializable interface the method writeObject ( args ) of ObjectOutputStream does something like instanceOf Serializable to detect whether the class implements Serializable & throws NotSerializableException accordingly . Everything is handled in the code and this seems to be a design - pattern so I think we can define our own marker interfaces . Now my doubts : # li Is the definition of a marker interface mentioned above in 1st point wrong ? How can we define a Marker interface then ? # li And instead of using the instanceOf operator why can ' t the method be something like writeObject ( args ) so that there is a compile - time type checking rather than runtime ? # li How are Annotations better than Marker Interfaces ?

Question - 26791441 , answer - 26819171 This is not an easy problem . And the more search - replacement parameters you have , the trickier it gets . You have several options , scattered on the palette of ugly - elegant , efficient - wasteful : # li Use StringUtils . replaceEach from Apache Commons as @ AlanHay recommended . This is a good option if you ' re free to add new dependencies in your project . You might get lucky : the dependency might be included already in your project # li Use a temporary placeholder as @ Jeroen suggested , and perform the replacement in 2 steps : # li Replace all search patterns with a unique tag that doesn ' t exist in the original text # li Replace the placeholders with the real target replacement This is not a great approach , for several reasons : it needs to ensure that the tags used in the first step are really unique ; it performs more string replacement operations than really necessary # li Build a regex from all the patterns and use the method with Matcher and StringBuffer as suggested by @ arshajii . This is not terrible , but not that great either , as building the regex is kind of hackish , and it involves StringBuffer which went out of fashion a while ago in favor of StringBuilder . # li Use a recursive solution proposed by @ mjolka , by splitting the string at the matched patterns , and recursing on the remaining segments . This is a fine solution , compact and quite elegant . Its weakness is the potentially many substring and concatenation operations , and the stack size limits that apply to all recursive solutions # li Split the text to words and use Java 8 streams to perform the replacements elegantly as @ msandiford suggested , but of course that only works if you are ok with splitting at word boundaries , which makes it not suitable as a general solution Here ' s my version , based on ideas borrowed from Apache ' s implementation . It ' s neither simple nor elegant , but it works , and should be relatively efficient , without unnecessary steps . In a nutshell , it works like this : repeatedly find the next matching search pattern in the text , and use a StringBuilder to accumulate the unmatched segments and the replacements . # pre Unit tests : # pre

Question - 32175145 , answer - 32175224 Since equals ( . . . ) is not a final method of Object , yes , it is very well be possible in a different situation . # pre This question , however , specifically says that these are primitive wrappers ( e . g . Integer , Boolean , etc . ) and since these classes are final , you cannot extend them , thus a . equals ( args ) will always return true .

Question - 17489250 , answer - 17489437 Java . lang . String is not just a class . It ' s an integral part of the core language . The compiler has syntactic sugar for it . For example , StringLiteral is like an abbreviation for new String ( args ) . When written StringLiteral the compiler optimizes identical strings to the same instance to save space . StringLiteral + 5 = = StringLiteral = = > true The compiler has syntactic sugar for a lot of stuff , including not having to box / unbox between object versions and their native types , no parent means Object , default constructor , . . .

Question - 5071040 , answer - 22547954 Always use either String . valueOf ( args ) or Integer . toString ( args ) . Using " " + number is an overhead and does the following : # pre

Question - 34172978 , answer - 34173658 If you want to stop either if number 5 is reached or 10 elements are collected , there ' s Stream . takeWhile ( args ) method added in Java - 9 : # pre

Question - 8777257 , answer - 8777266 It ' s a famous problem : . equals ( args ) for arrays is badly broken , just don ' t use it , ever . That said , it ' s not " broken " as in " someone has done it in a really wrong way " — it ' s just doing what ' s defined and not what ' s usually expected . So for purists : it ' s perfectly fine , and that also means , don ' t use it , ever . Now the expected behaviour for equals is to compare data . The default behaviour is to compare the identity , as Object does not have any data ( for purists : yes it has , but it ' s not the point ) ; assumption is , if you need equals in subclasses , you ' ll implement it . In arrays , there ' s no implementation for you , so you ' re not supposed to use it . So the difference is , Arrays . equals ( args ) works as you would expect ( i . e . compares content ) , array1 . equals ( args ) falls back to Object . equals implementation , which in turn compares identity , and thus better replaced by = = ( for purists : yes I know about null ) . Problem is , even Arrays . equals ( args ) will bite you hard if elements of array do not implement equals properly . It ' s a very naive statement , I know , but there ' s a very important less - than - obvious case : consider a 2D array . 2D array in Java is an array of arrays , and arrays ' equals is broken ( or useless if you prefer ) , so Arrays . equals ( args ) will not work as you expect on 2D arrays . Hope that helps .

Question - 7520432 , answer - 29226136 Also note that . equals ( args ) normally contains = = for testing as this is the first thing you would wish to test for if you wanted to test if two objects are equal . And = = actually does look at values for primitive types , for objects it checks the reference .

Question - 32859038 , answer - 32863263 Don ' t feel like you have to do everything in / with the stream . I would just do : # pre As long as you don ' t parallelise the stream this will work and it avoids potentially expensive and / or problematic ( in the case of duplicates ) get ( args ) and indexOf ( args ) operations . ( You cannot use a regular int variable in place of the AtomicInteger because variables used from outside a lambda expression must be effectively final . Note that when uncontested ( as in this case ) , AtomicInteger is very fast and won ' t pose a performance problem . But if it worries you you can use a non - thread - safe counter . )

Question - 12539365 , answer - 29349910 I must say , that you are absolutely right from a classical approach ' s point of view : # li If you first create ( or change ) business logic of your application and then cover it with ( adopt ) tests ( Test - Last approach ) , then it will be very painful and dangerous to let tests know anything about how your software works , other than checking inputs and outputs . # li If you are practicing a Test - Driven approach , then your tests are the first to be written , to be changed and to reflect the use cases of your software ' s functionality . The implementation depends on tests . That sometimes mean , that you want your software to be implemented in some particular way , e . g . rely on some other component ' s method or even call it a particular amount of times . That is where Mockito . verify ( ) comes in handy ! It is important to remember , that there are no universal tools . The type of software , it ' s size , company goals and market situation , team skills and many other things influence the decision on which approach to use at your particular case .

Question - 12575990 , answer - 12576219 A Java Date is a container for the number of milliseconds since January 1 , 1970 , 00 : 00 : 00 GMT . When you use something like System . out . println ( args ) , Java uses Date . toString ( args ) to print the contents . The only way to change it is to override Date and provide your own implementation of Date . toString ( args ) . Now before you fire up your IDE and try this , I wouldn ' t ; it will only complicate matters . You are better off formatting the date to the format you want to use ( or display ) . What you can do , is format the date . # pre These are actually the same date , represented differently .

Question - 6684665 , answer - 6684822 You can ' t just take the returned string and construct a string from it . . . it ' s not a byte [ ] data type anymore , it ' s already a string ; you need to parse it . For example : # pre * * EDIT * * You get an hint of your problem in your question , where you say " Whatever I seem to try I end up getting a byte array which looks as follows . . . [ 91 , 45 , . . . " , because 91 is the byte value for [ , so [ 91 , 45 , . . . is the byte array of the string " [ - 45 , 1 , 16 , . . . " string . The method Arrays . toString ( args ) will return a String representation of the specified array ; meaning that the returned value will not be a array anymore . For example : # pre As you can see , s1 holds the string representation of the array b1 , while s2 holds the string representation of the bytes contained in b1 . Now , in your problem , your server returns a string similar to s1 , therefore to get the array representation back , you need the opposite constructor method . If s2 . getBytes ( args ) is the opposite of new String ( args ) , you need to find the opposite of Arrays . toString ( args ) , thus the code I pasted in the first snippet of this answer .

Question - 34509566 , answer - 34509655 As you said internally the last concatenation is done to something similar to String e = new StringBuilder ( args ) . append ( args ) . append ( args ) . toString ( args ) ; the implementation of toString ( args ) of StringBuilder creates a new String . Here is the implementation . # pre Comparing strings using = = instead of . equals ( args ) returns true only if both strings are the same . In this case they are not the same because the second string is created as a new object of type String . The other concatenations are performed directly by the compiler so no new String is created .

Question - 29229373 , answer - 33839551 In my free StreamEx library I introduced the short - circuiting collectors . When collecting sequential stream with short - circuiting collector ( like MoreCollectors . first ( ) ) exactly one element is consumed from the source . Internally it ' s implemented in quite dirty way : using a custom exception to break the control flow . Using my library your sample could be rewritten in this way : # pre The result is the following : # pre

Question - 29280857 , answer - 29282558 As you have mentioned there will be 1000 - 10000 concurrent transaction you expecting at a time than you can store accounts on which some transaction is going on and handle concurrency One Solution is to allow system to create only one object of particulate account id , means that if you want to make a transaction between account " 123 " and " 456 " than your thread will create account object and in that constructor of account class we will check if any other object of account is there with particulate account id , if other object of account is there with same account id means that some transaction is going on with particulate account id so you have to wait to get the account object . So we can do transaction between " 123 " and " 456 " and at same time we can do transaction between " abc " and " xyz " but if at same time some other thread will try to create object of account " 123 " than system will say please wait for reference you can see below code Please note : # li dont forgote to remove your account id from locks map by call to freeAccount ( BigDecimal accId ) from LockHolder class # li I have used HasMap instand of list because list will not be a good choice when you are randomly removing element from it ( or when frequently you are updating it ) # pre

Question - 33147339 I was reading Java ' s ArrayList source code and noticed some comparisons in if - statements . In Java 7 , the method grow ( int ) uses if ( args ) newCapacity = minCapacity ; In Java 6 , grow didn ' t exist . The method ensureCapacity ( int ) however uses if ( args ) newCapacity = minCapacity ; What was the reason behind the change ? Was it a performance issue or just a style ? I could imagine that comparing against zero is faster , but performing a complete subtraction just to check whether it ' s negative seems a bit overkill to me . Also in terms of bytecode , this would involve two instructions ( ISUB and IF _ ICMPGE ) instead of one ( IFGE ) .

Question - 22929237 , answer - 28564046 You can use java . sql . Date . valueOf ( args ) method as : Date date = java . sql . Date . valueOf ( args ) ; No need to add time and time zone info here because they are taken implicitly . See Simpliest java8 LocalDate to java . util . Date conversion and vice versa ?

Question - 18571223 , answer - 18571348 The object your method decompressGZIP ( args ) needs is a byte [ ] . So the basic , technical answer to the question you have asked is : # pre However the problem you appear to be wrestling with is that this doesn ' t display very well . Calling toString ( args ) will just give you the default Object . toString ( args ) which is the class name + memory address . In your result [ B @ 38ee9f13 , the [ B means byte [ ] and 38ee9f13 is the memory address , separated by an @ . For display purposes you can use : Arrays . toString ( args ) ; But this will just display as a sequence of comma - separated integers , which may or may not be what you want . To get a readable String back from a byte [ ] , use : String string = new String ( args ) ; The reason the Charset version is favoured , is that all String objects in Java are stored internally as UTF - 16 . When converting to a byte [ ] you will get a different breakdown of bytes for the given glyphs of that String , depending upon the chosen charset .

Question - 6094575 , answer - 26159586 when using ( i . e . ) getConstructor ( args ) the constructor has to be declared public . Otherwise a NoSuchMethodException is thrown . if you want to access a non - public constructor you have to use instead ( i . e . ) getDeclaredConstructor ( args ) .

Question - 23114015 , answer - 32874755 If you know the size you could use java . util . Collection which provides the stream ( args ) method : # pre And then : new Hand ( args ) . stream ( args ) . map ( args ) I faced the same problem and was surprised that my Iterable implementation could be very easily extended to an AbstractCollection implementation by simply adding the size ( args ) method ( luckily I had the size of the collection : - ) You should also consider to override Spliterator < T > spliterator ( args ) .

Question - 32859038 , answer - 32918035 Eran ' s answer is usually the best approach for random - access lists . If your List isn ' t random access , or if you have a Stream instead of a List , you can use forEachOrdered : # pre This is safe , if the stream is parallel , even though the destination map is thread - unsafe and is operated upon as a side effect . The forEachOrdered guarantees that items are processed one - at - a - time , in order . For this reason it ' s unlikely that any speedup will result from running in parallel . ( There might be some speedup if there are expensive operations in the pipeline before the forEachOrdered . )

Question - 14526260 , answer - 14526289 just use File . getName ( ) # pre using String methods : # pre

Question - 18532488 , answer - 33142346 Once a repeat function is somewhere defined as # pre You can use it now and then this way , e . g . : repeat . accept ( args ) ; To get and equivalent to Haskell ' s take 8 ( args ) You could write # pre

Question - 7520432 I wanted to clarify if I understand this correctly : # li = = - > is a reference comparison , i . e . both objects point to the same memory location # li . equals ( args ) - > evaluates to the comparison of values in the objects Am I correct in my understanding ?

Question - 22409102 , answer - 22409270 You can use Float . floatToIntBits to convert it to an int and look at the bit pattern : # pre

Question - 18636561 , answer - 18824858 Whenever a new keyword is used it Creates a Object at the Heap 1 ) StringBuilder sample = new StringBuilder ( ) ; 2 ) StringBuilder referToSample = sample ; In 2 ) the Reference of referSample is created on same object sample thus referToSample = null ; is Nulling Only the referSample Reference giving no effect to sample that ' s why you are not getting NULL Pointer Exception Thanks to Java ' s Garbage Collection

Question - 16635398 , answer - 31707746 One of most upleasing functional forEach ' s limitations is lack of checked exceptions support . One possible workaround is to replace terminal forEach with plain old foreach loop : # pre Here is list of most popular questions with other workarounds on checked exception handling within lambdas and streams : Java 8 Lambda function that throws exception ? Java 8 : Lambda - Streams , Filter by Method with Exception How can I throw CHECKED exceptions from inside Java 8 streams ? Java 8 : Mandatory checked exceptions handling in lambda expressions . Why mandatory , not optional ?

Question - 20877086 , answer - 20889556 To complement the given answers , also take note of the following : # pre This code will also print : false As user Jay has claimed in a comment for the accepted answer , care must be taken when using operator = = on objects , here you ' re checking if both references are the same , which is not , because they are different objets , although they represent the very same value . To compare objects , you should use the equals method instead : # pre This will print : true You may ask , But then why the first line printed true ? . Checking the source code for the Integer . valueOf method , you can see the following : # pre If the param is an integer between IntegerCache . low ( defaulted to - 128 ) and IntegerCache . high ( calculated at runtime with minimum value 127 ) then a pre - allocated ( cached ) object is returned . So when you use 127 as parameter , you ' re getting two references to same cached object and getting true in the comparison of the references .

Question - 6470651 , answer - 6548647 Static field holding object reference [ esp final field ] # pre Calling String . intern ( ) on lengthy String # pre ( Unclosed ) open streams ( file , network etc . . . ) # pre Unclosed connections # pre Areas that are unreachable from JVM ' s garbage collector , such as memory allocated through native methods In web applications , some objects are stored in application scope until the application is explicitly stopped or removed . getServletContext ( args ) . setAttribute ( args ) ; Incorrect or inappropriate JVM options , such as the noclassgc option on IBM JDK that prevents unused class garbage collection See IBM jdk settings .

Question - 13659217 , answer - 13659231 You can ' t see this method in javadoc because it ' s added by the compiler . Documented in three places : # li Enum Types , The Java Tutorials # blockquote # li Enum . valueOf class ( The special implicit values method is mentioned in description of valueOf method ) # blockquote # li Enum Types , Section 8 . 9 , Java Language Specification The values function simply list all values of the enumeration .

Question - 5031614 , answer - 5103360 We usually have two IDs in our entities : # li Is for persistence layer only ( so that persistence provider and database can figure out relationships between objects ) . # li Is for our application needs ( equals ( args ) and hashCode ( args ) in particular ) Take a look : # pre EDIT : to clarify my point regarding calls to setUuid ( args ) method . Here ' s a typical scenario : # pre When I run my tests and see the log output I fix the problem : # pre Alternatively , one can provide a separate constructor : # pre So my example would look like this : # pre I use a default constructor and a setter , but you may find two - constructors approach more suitable for you .

Question - 14602062 , answer - 14602092 From String . split ( ) API Doc : # blockquote Overloaded String . split ( regex , int ) is more appropriate for your case .

Question - 22718744 , answer - 27477312 The behavior of String . split ( which calls Pattern . split ) changes between Java 7 and Java 8 . Documentation Comparing between the documentation of Pattern . split in Java 7 and Java 8 , we observe the following clause being added : # blockquote The same clause is also added to String . split in Java 8 , compared to Java 7 . Reference implementation Let us compare the code of Pattern . split of the reference implemetation in Java 7 and Java 8 . The code is retrieved from grepcode , for version 7u40 - b43 and 8 - b132 . Java 7 # pre Java 8 # pre The addition of the following code in Java 8 excludes the zero - length match at the beginning of the input string , which explains the behavior above . # pre Maintaining compatibility Following behavior in Java 8 and above To make split behaves consistently across versions and compatible with the behavior in Java 8 : # li If your regex can match zero - length string , just add ( ? ! \ A ) at the end of the regex and wrap the original regex in non - capturing group ( ? : . . . ) ( if necessary ) . # li If your regex can ' t match zero - length string , you don ' t need to do anything . # li If you don ' t know whether the regex can match zero - length string or not , do both the actions in step 1 . ( ? ! \ A ) checks that the string does not end at the beginning of the string , which implies that the match is an empty match at the beginning of the string . Following behavior in Java 7 and prior There is no general solution to make split backward - compatible with Java 7 and prior , short of replacing all instance of split to point to your own custom implementation .

Question - 31419029 I ' ve tried to build my own Map to increase the performance for a special environment , and I realized something pretty interesting : Creating a new Hashmap < T > ( args ) is faster than new Object [ 2000 ] - no matter in which order I execute these commands . That ' s pretty confusing to me , esp . because the Hashmap constructor contains a table = new Entry [ capacity ] , according to this . Is there something wrong with my testbench ? # pre I ' d love to see the results of testing on another computer . I ' ve got no clue why creating a HashMap is 10 times faster than creating a Object [ ] .

Question - 13659217 I declare an enum as : enum Sex { MALE , FEMALE } ; And then , iterate enum as shown below : # pre I checked the Java API but can ' t find the values ( ) method ? I ' m curious as to where this method comes from ? API link : # a

Question - 20363719 , answer - 25453317 If your key is NOT guaranteed to be unique for all elements in the list , you should convert it to a Map < String , List < T > instead of a Map < T > Map < T > result = choices . stream ( args ) . collect ( args ) ;

Question - 8579657 , answer - 35264580 Main difference is that when program calls start ( args ) method a new Thread is created and code inside run ( ) method is executed in new Thread while if you call run ( args ) method directly no new Thread is created and code inside run ( ) will execute on current Thread . Another difference between start vs run in Java thread is that you can not call start ( ) method twice on thread object . once started , second call of start ( ) will throw IllegalStateException in Java while you can call run ( ) method twice .

Question - 22463062 , answer - 28324294 You can also use LocalDate . parse ( args ) or LocalDateTime . parse ( args ) on a String without providing it with a pattern , if the String is in ISO - 8601 format . for example , # pre Output , # pre and use DateTimeFormatter only if you have to deal with other date patterns , For example , dd MMM uuuu represents the day of the month ( two digits ) , three letters of the name of the month ( Jan , Feb , Mar , . . . ) , and a four - digit year : # pre Output 04 Aug 2015 parses to 2015 - 08 - 04 also remember that the DateTimeFormatter object is bidirectional ; it can both parse input and format output . # pre Output 2015 - 08 - 04 formats as 04 Aug 2015 ( see complete list of Patterns for Formatting and Parsing DateFormatter ) # pre

Question - 31696485 When using the Java 8 Optional class , there are two ways in which a value can be wrapped in an optional . # pre I understand Optional . ofNullable is the only safe way of using Optional , but why does Optional . of exist at all ? Why not just use Optional . ofNullable and be on the safe side at all times ?

Question - 7032070 , answer - 7032144 The source code for clear ( args ) : # pre The source code for removeAll ( args ) ( As defined in AbstractCollection ) : # pre clear ( args ) is much faster since it doesn ' t have to deal with all those extra method calls . And as Atrey points out , c . contains ( args ) increases the time complexity of removeAll to O ( n ^ 2 ) as opposed to clear ' s O ( n ) .

Question - 5439529 , answer - 9991624 You can use Integer . parseInt ( args ) and catch the NumberFormatException if the string is not a valid integer , in the following fashion ( as pointed out by all answers ) : # pre However , note here that if the evaluated integer overflows , the same exception will be thrown . Your purpose was to find out whether or not , it was a valid integer . So its safer to make your own method to check for validity : # pre

Question - 16148575 , answer - 20454885 For everybody who codes Java for Android devices and ends up here : use SparseArray for better performance private final SparseArray < T > myMap = new SparseArray < T > ( args ) ; with this you can use int instead of Integer like # pre

Question - 5192512 , answer - 30190425 I ' ll vote for sb . setLength ( args ) ; not only because it ' s one function call but because it don ' t actually copy the array into another array like sb . delete ( args ) ; , It just fill the remaining characters to be 0 and set the length variable to the new length . You can take a look into their implementation to validate my point from here at setLength function and delete0 function .

Question - 27908213 , answer - 27908402 Although there is no explicit guarantee of this , the end result is bound to be such that the comparison always succeeds for enum constants with identical names : # pre The reason for this is that Java compiler constructs subclasses of Enum in such a way that they end up calling Enum ' s sole protected constructor , passing it the name of enum value : protected Enum ( args ) ; The name is embedded into the generated code in the form of a string literal . According to String documentation , # blockquote This amounts to an implicit guarantee of your expression succeeding when names of enum constants are identical . However , I would not rely on this behavior , and use equals ( args ) instead , because anyone reading my code would be scratching his head , thinking that I made a mistake .

Question - 15202997 , answer - 36978943 I ' ve been confused by the wide range of different naming schemes as well , and was just about to ask and answer my own question on this when I found this question here . I think my findings fit it well enough , and complement what ' s already here . My focus is looking for documentation on the various terms , and adding some more related terms that might crop up in other places . Consider the following example : # pre # li The simple name of D is D . That ' s just the part you wrote when declaring the class . Anonymous classes have no simple name . Class . getSimpleName ( ) returns this name or the empty string . It is possible for the simple name to contain a $ if you write it like this , since $ is a valid part of an identifier . # li According to the JLS section 6 . 7 , both a . b . C . D and a . b . C . D . D . D would be fully qualified names , but only a . b . C . D would be the canonical name of D . So every canonical name is a fully qualified name , but the converes is not always true . Class . getCanonicalName ( ) will return the canonical name or null . # li Class . getName ( ) is documented to return the binary name , as specified in JLS section 13 . 1 . In this case it returns a . b . C $ D for D and [ La . b . C $ D ; for D [ ] . # li This answer demonstrates that it is possible for two classes loaded by the same class loader to have the same canonical name but distinct binary names . Neither name is sufficient to reliably deduce the other : if you have the canonical name , you don ' t know which parts of the name are packages and which are containing classes . If you have the binary name , you don ' t know which $ were introduced as separators and which were part of some simple name . # li Anonymous classes and local classes have no fully qualified names but still have a binary name . The same holds for classes nested inside such classes . Every class has a binary name . # li Running javap - v - private on a / b / C . class shows that the bytecode refers to the type of d as La / b / C $ D ; and that of the array ds as [ La / b / C $ D ; . These are called descriptors , and they are specified in JVMS section 4 . 3 . # li The class name a / b / C $ D used in both of these descriptors is what you get by replacing . by / in the binary name . The JVM spec apparently calls this the internal form of the binary name . JVMS section 4 . 2 . 1 describes it , and states that the difference from the binary name were for historical reasons . # li The file name of a class in one of the typical filename - based class loaders is what you get if you interpret the / in the internal form of the binary name as a directory separator , and append the file name extension . class to it . It ' s resolved relative to the class path used by the class loader in question .

Question - 26791441 , answer - 26877910 What I can only share is my own method . You can use a temporary String temp = StringLiteral ; or String . Format ( args ) ; This is my example code created in console application via c # - " Idea Only , Not Exact Answer " . # pre Or you can also use the String . Format ( args ) ; # pre Output : time upon a Once , there was a bar and a foo .

Question - 22561614 Note : this question originates from a dead link which was a previous SO question , but here goes . . . See this code ( note : I do know that this code won ' t " work " and that Integer : : compare should be used - - I just extracted it from the linked question ) : # pre According to the javadoc of . min ( ) and . max ( ) , the argument of both should be a Comparator . Yet here the method references are to static methods of the Integer class . So , why does this compile at all ?

Question - 13102045 , answer - 7056786 It ' s because when you enter a number then press Enter , input . nextInt ( args ) consumes only the number , not the " end of line " . When input . nextLine ( args ) executes , it consumes the " end of line " still in the buffer from the first input . Instead , use input . nextLine ( args ) immediately after input . nextInt ( args )

Question - 17489250 , answer - 17489410 Java String is Special # blockquote For example # pre # img Note : String literals are stored in a common pool . This facilitates sharing of storage for strings with the same contents to conserve storage . String objects allocated via new operator are stored in the heap , and there is no sharing of storage for the same contents .

Question - 28818506 , answer - 28818627 Perhaps this is what you ' re after : Get value from one Optional or another Otherwise , you may want to have a look at Optional . orElseGet . Here ' s an example of what I think that you ' re after : result = Optional . ofNullable ( args ) ;

Question - 31188231 It has generally been the case the Java source code has been forward compatible . Until Java 8 , as far as I know , both compiled classes and source have been forward compatible with later JDK / JVM releases . [ Update : this is not correct , see comments re ' enum ' , etc , below . ] However , with the addition of default methods in Java 8 this appears to no longer be the case . For example , a library I have been using has an implementation of java . util . List which includes a List < T > sort ( args ) . This method returns a copy of the contents of the list sorted . This library , deployed as a jar file dependency , worked fine in a project being built using JDK 1 . 8 . However , later I had occasion to recompile the library itself using JDK 1 . 8 and I found the library no longer compiles : the List - implementing class with its own sort ( args ) method now conflicts with the Java 8 java . util . List . sort ( args ) default method . The Java 8 sort ( args ) default method sorts the list in place ( returns void ) ; my library ' s sort ( args ) method - since it returns a new sorted list - has an incompatible signature . So my basic question is : # li Doesn ' t JDK 1 . 8 introduce a forward incompatibility for Java source code due to default methods ? Also : # li Is this the first such forward incompatible change ? # li Was this considered or discussed when default methods where designed and implemented ? Is it documented anywhere ? # li Was the ( admittedly small ) inconvenience discounted versus the benefits ? The following is an example of some code that compiles and runs under 1 . 7 and runs under 1 . 8 - but does not compile under 1 . 8 : # pre The following shows this code being compiled ( or failing to ) and being run . # pre

Question - 32693704 I noticed something strange in the implementation of HashMap . clear ( args ) . This is how it looked in OpenJDK 7u40 : # pre And this is how it looks as of OpenJDK 8u40 : # pre I understand that now the table can be null for empty an map , thus the additional check and caching in a local variable is required . But why was Arrays . fill ( args ) replaced with a for - loop ? It seems that the change was introduced in this commit . Unfortunately I found no explanation for why a plain for loop might be better than Arrays . fill ( args ) . Is it faster ? Or safer ?

Question - 8430805 , answer - 22332291 Sudheesh B Nair ' s has a nice ( and accepted ) answer on the question , which i think should have a better alternative such as ; What ' s wrong with measuring time passed and checking if TIME _ INTERVAL miliseconds ( say 2000 ) passed since the last back press . The following sample code uses System . currentTimeMillis ( args ) ; to store the time onBackPressed ( args ) is called ; # pre Back on accepted answer critique ; Using a flag to indicate if it was pressed in last TIME _ INTERVAL ( say 2000 ) milliseconds and set - reset is via Handler ' s postDelayed ( args ) method was the first thing to come in my mind . But the postDelayed ( args ) action should be cancelled when activity is closing , removing the Runnable . In order to remove the Runnable , it must not be declared anonymous , and be declared as member along with the Handler aswell . Then removeCallbacks ( args ) method of Handler can be called appropriately . The following sample is the demonstration ; # pre Thanks to @ NSouth for contributing ; In order to prevent toast message appearing even after the application is closed , Toast can be declared as a member - say mExitToast - and can be cancelled via mExitToast . cancel ( args ) ; just before super . onBackPressed ( args ) ; call .

Question - 12468764 , answer - 13368831 Actual Answer : The default deserializer for enums uses . name ( args ) to deserialize , so it ' s not using the @ JsonValue . So as @ OldCurmudgeon pointed out , you ' d need to pass in { StringLiteral : StringLiteral } to match the . name ( args ) value . An other option ( assuming you want the write and read json values to be the same ) . . . More Info : There is ( yet ) another way to manage the serialization and deserialization process with Jackson . You can specify these annotations to use your own custom serializer and deserializer : # pre Then you have to write MySerializer and MyDeserializer which look like this : MySerializer # pre MyDeserializer # pre Last little bit , particularly for doing this to an enum JsonEnum that serializes with the method getYourValue ( args ) , your serializer and deserializer might look like this : # pre

Question - 12539365 I write jUnit test cases for 3 purposes : # li To ensure that my code satisfies all of the required functionality , under all ( or most of ) the input combinations / values . # li To ensure that I can change the implementation , and rely on JUnit test cases to tell me that all my functionality is still satisfied . # li As a documentation of all the use cases my code handles , and act as a spec for refactoring - should the code ever need to be rewritten . ( Refactor the code , and if my jUnit tests fail - you probably missed some use case ) . I do not understand why or when Mockito . verify ( args ) should be used . When I see verify ( args ) being called , it is telling me that my jUnit is becoming aware of the implementation . ( Thus changing my implementation would break my jUnits , even though my functionality was unaffected ) . I ' m looking for : # li What should be the guidelines for appropriate usage of Mockito . verify ( args ) ? # li Is it fundamentally correct for jUnits to be aware of , or tightly coupled to , the implementation of the class under test ?

Question - 10904911 I am using trying to use the toString ( args ) method , but I think I am doing it wrong : # a My code : # pre The output is : [ I @ 23fc4bec Also I tried printing like this , but : # pre I took this code out of bigger and more complex code , but I can add it if needed . But this should give general information . I am looking for output , like in Oracle ' s documentation : # blockquote

Question - 7348711 , answer - 28043703 As others have noted , getting the hostname based on DNS resolution is unreliable . Since this question is unfortunately still relevant in 2016 , I ' d like to share with you my network - independent solution , with some test runs on different systems . The following code tries to do the following : # li On Windows # li Read the COMPUTERNAME environment variable through System . getenv ( args ) . # li Execute hostname . exe and read the response # li On Linux # li Read the HOSTNAME environment variable through System . getenv ( args ) # li Execute hostname and read the response # li Read / etc / hostname ( to do this I ' m executing cat since the snippet already contains code to execute and read . Simply reading the file would be better , though ) . The code : # pre Results for different operating systems : OpenSuse 13 . 1 # pre Ubuntu 14 . 04 LTS This one is kinda strange since echo $ HOSTNAME returns the correct hostname , but System . getenv ( args ) does not : # pre EDIT : According to legolas108 , System . getenv ( args ) works on Ubuntu 14 . 04 if you run export HOSTNAME before executing the Java code . Windows 7 # pre The machine names have been replaced but I kept the capitalization and structure . Note the extra newline when executing hostname , you might have to take it into account in some cases .

Question - 6652687 , answer - 6652772 Use String # trim ( ) method or String allRemoved = myString . replaceAll ( args ) for trim both the end . For left trim : String leftRemoved = myString . replaceAll ( args ) ; For right trim : String rightRemoved = myString . replaceAll ( args ) ;

Question - 5243754 , answer - 25074487 - getParameter ( ) : # pre request . getParameter ( args ) will get the value from the posted form of the input box named " testParam " which is " Client param " . It will then print it out , so you should see " Client Param " on the screen . So request . getParameter ( ) will retrieve a value that the client has submitted . You will get the value on the server side . - getAttribute ( ) : request . getAttribute ( args ) , this is all done server side . YOU add the attribute to the request and YOU submit the request to another resource , the client does not know about this . So all the code handling this would typically be in servlets . getAttribute always return object .

Question - 20358883 , answer - 20358928 You can use the utility method Arrays . asList and feed that result into a new ArrayList . ArrayList < T > list = new ArrayList < T > ( args ) ; Other options : ArrayList < T > list = new ArrayList < T > ( args ) ; and ArrayList < T > list = new ArrayList < T > ( args ) ; # li ArrayList ( Collection ) constructor . # li Arrays . asList method . # li Collections . nCopies method . # li Collections . singletonList method .

Question - 22718744 , answer - 22718904 This has been specified in the documentation of split ( String regex , limit ) . # blockquote In StringLiteral . split ( args ) you got a zero - width match at the beginning so the leading empty substring is not included in the resulting array . However in your second snippet when you split on StringLiteral you got a positive width match ( 1 in this case ) , so the empty leading substring is included as expected . ( Removed irrelevant source code )

Question - 32475166 , answer - 32476850 When you think about the type of the operands , the problem becomes more apparent : this . method ! = null ? this . method : this . constructor has as type the most specialized common type of both the operands , i . e . the most specialized type common to both this . method and this . constructor . In Java 7 this is java . lang . reflect . Member , however the Java 8 class library introduces a new type java . lang . reflect . Executable which is more specialized than the generic Member . Hence with a Java 8 class library the result type of the ternary expression is Executable rather than Member . Some ( pre - release ) versions of the Java 8 compiler seem to have produced an explicit reference to Executable inside generated code when compiling the ternary operator . This would trigger a class load , and thus in turn a ClassNotFoundException at runtime when running with a class library < JDK 8 , because Executable only exists for JDK ≥ 8 . As noted by Tagir Valeev in this answer , this is actually a bug in pre - release versions of JDK 8 and has since been fixed , so both the if - else workaround and the explanatory comment are now obsolete . Additional note : One might come to the conclusion that this compiler bug was present before Java 8 . However , the byte code generated for the ternary by OpenJDK 7 is the same as the byte code generated by OpenJDK 8 . In fact , the type of the expression goes completely unmentioned at runtime , the code is really only test , branch , load , return without any additional checks going on . So rest assured that this is not a problem ( anymore ) and indeed seems to have been a temporary problem during development of Java 8 .

Question - 28276423 , answer - 28276498 Assuming all the streams get created okay , yes , just closing bw is fine with those stream implementations ; but that ' s a big assumption . I ' d use try - with - resources ( tutorial ) so that any issues constructing the subsequent streams that throw exceptions don ' t leave the previous streams hanging , and so you don ' t have to rely on the stream implementation having the call to close the underlying stream : # pre Note you no longer call close at all . Important note : To have try - with - resources close them , you must assign the streams to variables as you open them , you cannot use nesting . If you use nesting , an exception during construction of one of the later streams ( say , GZIPOutputStream ) will leave any stream constructed by the nested calls inside it open . From JLS § 14 . 20 . 3 : # blockquote Note the word " variables " ( my emphasis ) . E . g . , don ' t do this : # pre . . . because an exception from the GZIPOutputStream ( OutputStream ) constructor ( which says it may throw IOException , and writes a header to the underlying stream ) would leave the FileOutputStream open . Since some resources have constructors that may throw and others don ' t , it ' s a good habit to just list them separately . We can double - check our interpretation of that JLS section with this program : # pre . . . which has the output : # pre Note that there are no calls to close there . If we fix main : # pre then we get the appropriate close calls : # pre ( Yes , two calls to InnerMost # close is correct ; one is from Middle , the other from try - with - resources . )

Question - 5031614 There have been some discussions here about JPA entities and which hashCode ( args ) / equals ( args ) implementation should be used for JPA entity classes . Most ( if not all ) of them depend on Hibernate , but I ' d like to discuss them JPA - implementation - neutrally ( I am using EclipseLink , by the way ) . All possible implementations are having their own advantages and disadvantages regarding : # li hashCode ( args ) / equals ( args ) contract conformity ( immutability ) for List / Set operations # li Whether identical objects ( e . g . from different sessions , dynamic proxies from lazily - loaded data structures ) can be detected # li Whether entities behave correctly in detached ( or non - persisted ) state As far I can see , there are three options : # li Do not override them ; rely on Object . equals ( args ) and Object . hashCode ( args ) # li hashCode ( args ) / equals ( args ) work # li cannot identify identical objects , problems with dynamic proxies # li no problems with detached entities # li Override them , based on the primary key # li hashCode ( args ) / equals ( args ) are broken # li correct identity ( for all managed entities ) # li problems with detached entities # li Override them , based on the Business - Id ( non - primary key fields ; what about foreign keys ? ) # li hashCode ( args ) / equals ( args ) are broken # li correct identity ( for all managed entities ) # li no problems with detached entities My questions are : # li Did I miss an option and / or pro / con point ? # li What option did you choose and why ? UPDATE 1 : By " hashCode ( args ) / equals ( args ) are broken " , I mean that successive hashCode ( args ) invocations may return differing values , which is ( when correctly implemented ) not broken in the sense of the Object API documentation , but which causes problems when trying to retrieve a changed entity from a Map , Set or other hash - based Collection . Consequently , JPA implementations ( at least EclipseLink ) will not work correctly in some cases . UPDATE 2 : Thank you for your answers - - most of them have remarkable quality . Unfortunately , I am still unsure which approach will be the best for a real - life application , or how to determine the best approach for my application . So , I ' ll keep the question open and hope for some more discussions and / or opinions .

Question - 29494800 , answer - 29500496 First of all , the cast in that line ( ( Object ) newType = = ( Object ) Object [ ] . class ) are absobuletly needed . Removing them will result in a compilation error : # pre Now to answer your question What is this line checking ? It simply verify if the given array is of object type , which is part of the answer for your other question Why Array . newInstance not good enough for both cases ? In the first case , we already know that the array is of Object type so there is no point in calling the newInstance method to retrieve the correct type , this would only result in performance loss . As for your final example , Integer [ ] nums = Arrays . copyOf ( args ) That it does compile , it is true . Because the given arguments to the method are all valids . It will certainly fail at runtime ; what would be the expected output of converting " a " to Integer type ? Now , when to use copyOf ? When you already know the both types , and already know that they are valid together . It main usage is to return a copy but truncated or padded with [ null / default values ] to the original array .

Question - 8725387 , answer - 34405789 Set and Map are non - linear data structure . List is linear data structure . The tree data structure SortedSet and SortedMap interfaces implements TreeSet and TreeMap respectively using used Red - Black tree implementation algorithm . So it ensure that there are no duplicated items ( or keys in case of Map ) . # li Tree by definition cannot contain duplicates . # li In List we can have duplicates , so there is no TreeList . So if we want to sort the list we have to use java . util . Collections . sort ( args ) .

Question - 22740464 , answer - 37436520 Just do : Stream . of ( args ) . flatMap ( args ) ; where identity ( args ) is a static import of Function . identity ( args ) . Concatenating multiple streams into one stream is the same as flattening a stream . However , unfortunately , for some reason there is no flatten ( args ) method on Stream , so you have to use flatMap ( args ) with the identity function .

Question - 18723596 , answer - 18723704 You can cast null to any reference type . You can also call methods which handle a null as an argument , e . g . System . out . println ( args ) does , but you cannot reference a null value and call a method on it . BTW There is a tricky situation where it appears you can call static methods on null values . # pre

Question - 28319064 , answer - 29000802 There is a third option - using stream ( args ) . toArray ( args ) - see comments under why didn ' t stream have a toList method . It turns out to be slower than forEach ( ) or collect ( ) , and less expressive . It might be optimised in later JDK builds , so adding it here just in case . assuming List < T > myFinalList = Arrays . asList ( args ) ; with a micro - micro benchmark , 1M entries , 20 % nulls and simple transform in doSomething ( ) # pre the results are parallel : # pre sequential : # pre parallel without nulls and filter ( so the stream is SIZED ) : toArrays has the best performance in such case , and . forEach ( args ) fails with " indexOutOfBounds " on the recepient ArrayList , had to replace with . forEachOrdered ( args ) # pre

Question - 14316487 , answer - 14316543 A very simple implementation with String . split ( ) : # pre

Question - 14846920 , answer - 14846960 From Effective Java , Item # 43 - StringLiteral demonstrates returning an empty collection and perhaps even demonstrates using these emptyList ( args ) , emptySet ( args ) , and emptyMap ( args ) methods on the Collections class to get an empty collection that also has the additional benefit of being immutable . From Item # 15 StringLiteral . From Collections - emptySet - Collections - emptyList - Collections # blockquote Note : Below code is just an example ( change it according to your use case ) : # pre These methods offer a couple of advantages : # li They ' re more concise because you don ' t need to explicitly type out the generic type of the collection - it ' s generally just inferred from the context of the method call . # li They ' re more efficient because they don ' t bother creating new objects ; they just re - use an existing empty and immutable object . This effect is generally very minor , but it ' s occasionally ( well , rarely ) important .

Question - 25850328 , answer - 31838310 The main purpose of marker interfaces is to create special types where types themselves have no behavior of their own . # pre Here save method makes sure that only the objects of classes that implement the MarkerEntity interface are saved , for other types InvalidEntityFoundException is thrown . So here MarkerEntity marker interface is defining a type that adds special behavior to the classes implementing it . Though annotations can also used now to mark classes for some special treatments but marker annotations are replacement for naming pattern not for Marker interfaces . But marker annotations can ' t fully replace the marker interfaces because ; marker interfaces are used to define type ( as already explained above ) where as marker annotations do not . Source for marker interface comment

Question - 29262002 , answer - 29262520 Basicly , new String ( args ) is an executable piece of code that actually does something ( it creates a new String and then returns it ) . The returned value can be ignored and new String ( args ) can still be used in void - return lambda to create a new String . However , StringLiteral is just a constant that doesn ' t do anything on it ' s own . The only reasonable thing to do with it in lambda body is to return it . But the lambda method would have to have return type String or Object , but it returns void , hence the String cannot be casted to void error .

Question - 14809293 , answer - 14821488 The Collections . unmodifiableList has already been mentioned - the Arrays . asList ( args ) strangely not ! My solution would also be to use the list from the outside and wrap the array as follows : # pre The problem with copying the array is : if you ' re doing it every time you access the code and the array is big , you ' ll create a lot of work for the garbage collector for sure . So the copy is a simple but really bad approach - I ' d say " cheap " , but memory - expensive ! Especially when you ' re having more than just 2 elements . If you look at the source code of Arrays . asList and Collections . unmodifiableList there is actually not much created . The first just wraps the array without copying it , the second just wraps the list , making changes to it unavailable .

Question - 15430247 The usual constructor of ArrayList is : ArrayList < T > list = new ArrayList < T > ( args ) ; But there is also an overloaded constructor with a parameter for its initial capacity : ArrayList < T > list = new ArrayList < T > ( args ) ; Why is it useful to create an ArrayList with an initial capacity when we can append to it as we please ?

Question - 16148575 , answer - 16149127 You can ' t use a primitive because HashMap use object internally for the key . So you can only use an object that inherits from Object ( that is any object ) . That is the function put ( ) in HashMap and as you can see it uses Object for K : # pre The expression " k = e . key " should make it clear . I suggest to use a wrapper like Integer and autoboxing .

Question - 14846920 , answer - 14847046 Most of the time we use a constructor to create a new empty map . But the Collections methods offer a couple of advantages to create an empty map using static method java . util . Collections . emptyMap ( args ) # blockquote

Question - 18723596 , answer - 18723666 You can cast null to any reference type without getting any exception . println method does not throw null pointer because it first checks whether the object is null or not . If null then it simply prints the string StringLiteral . Otherwise it will call the toString method of that object . Adding more details : Internally print methods call String . valueOf ( args ) method on the input object . And in valueOf method , this check helps to avoid null pointer excpeiton : return ( args ) ? StringLiteral : obj . toString ( args ) ; For rest of your confusion , calling any method on a null object should throw a null pointer exception , if not a special case .

Question - 25056607 , answer - 25056878 We can take a look into the source code of java . util . regex . Pattern which is behind String . split . Way down the rabbit hole the method public String [ ] split ( args ) is invoked . Input StringLiteral For input StringLiteral this method is called as String [ ] parts = split ( args ) ; The intersting part of this method is : # pre And that is what happens : new String [ ] { input . toString ( ) } is returned . Input StringLiteral For input StringLiteral the intersting part is # pre Here resultSize = = 0 and limit = = 0 so new String [ 0 ] is returned .

Question - 29328785 , answer - 29330741 It ' s not so hard to track down the reason for the odd behavior . The divide call goes to # pre This , internally , delegates to another divide method , based on the rounding mode : # pre In this case , the last call applies . Note that the intVal ( which is a BigInteger that is stored in the BigDecimal ) is passed directly to this method as the first argument : # pre Finally , the path to the second divideAndRound is taken here , again passing the dividend on ( which was the intVal of the original BigDecimal ) , ending up with this code : # pre And this is where the error is introduced : The mdivididend is a mutable BigInteger , that was created as a mutable view on the mag array of the BigInteger that is stored in the BigDecimal x from the original call . The division modifies the mag field , and thus , the state of the ( now not - so - immutable ) BigDecimal . This is clearly a bug in the implementation of one of the divide methods . I already started tracking the change sets of the OpenJDK , but have not yet spotted the definite culprit . ( Edit : See updates below ) ( A side note : Calling x . toString ( args ) before doing the division does not really avoid , but only hide the bug : It causes a string cache of the correct state to be created internally . The right value is printed , but the internal state is still wrong - which is concerning , to say the least . . . ) # blockquote

Question - 34172978 # pre Counter to my expectation , the collect call never returns . Setting limit before filter produces the expected result . Why ?

Question - 7488643 , answer - 7488683 You can first split them using String . split ( args ) , and then convert the returned String array to an ArrayList using Arrays . asList ( args )

Question - 29280857 , answer - 29382161 As stated previously , you should lock on both accounts , always in the same order . The key part , however , is ensuring both high granularity and singularity across the VM instance . This can be done using String . intern ( ) : # pre

Question - 5192512 , answer - 22694891 I think many of the answers here may be missing a quality method included in StringBuilder : . delete ( args ) . I know this is a late reply ; however , this should be made known ( and explained a bit more thoroughly ) . Let ' s say you have a StringBuilder table - which you wish to modify , dynamically , throughout your program ( one I am working on right now does this ) , e . g . StringBuilder table = new StringBuilder ( args ) ; If you are looping through the method and alter the content , use the content , then wish to discard the content to " clean up " the StringBuilder for the next iteration , you can delete it ' s contents , e . g . table . delete ( args ) . start and end being the indices of the chars you wish to remove . Don ' t know the length in chars and want to delete the whole thing ? table . delete ( args ) ; NOW , for the kicker . StringBuilders , as mentioned previously , take a lot of overhead when altered frequently ( and can cause safety issues with regard to threading ) ; therefore , use StringBuffer - same as StringBuilder ( with a few exceptions ) - if your StringBuilder is used for the purpose of interfacing with the user .

Question - 16635398 , answer - 16635489 The advantage comes into account when the operations can be executed in parallel . ( See # a - the section about internal and external iteration ) # li The main advantage from my point of view is that the implementation of what is to be done within the loop can be defined without having to decide if it will be executed in parallel or sequential # li If you want your loop to be executed in parallel you could simply write joins . parallelStream ( args ) . forEach ( args ) ; You will have to write some extra code for thread handling etc . Note : for my answer I assumed joins implementing the java . util . Stream interface . If joins implements only the java . util . Iterable interface this is no longer true .

Question - 16148575 , answer - 16149160 HashMap does not allow primitive data types as arguments . It can only accept objects so HashMap < T > myMap = new HashMap < T > ( args ) ; will not work . You have to change the declaration to HashMap < T > myMap = new HashMap < T > ( args ) ; so even when you do the following myMap . put ( args ) ; The primitive data type is autoboxed to an Integer object . 8 ( args ) = = = boxing = = = > 8 ( args ) You can read more on autoboxing here # a

Question - 10786042 Say I have a URL http : / / example . com / query ? q = and I have a query entered by the user such as : # blockquote I want the result to be a properly encoded URL : http : / / example . com / query ? q = random % 20word % 20 % A3500 % 20bank % 20 % 24 What ' s the best way to achieve this ? I tried URLEncoder and creating URI / URL objects but none of them come out quite right .

Question - 5439529 , answer - 15357940 Or simply mystring . matches ( args ) though it would return true for numbers larger than an int

Question - 31370403 , answer - 31466466 Idea # 1 , storing the Graphics objects simply wouldn ' t work . The Graphics should not be considered as " holding " some display memory , but rather as a handle to access an area of display memory . In the case of BufferedImage , each Graphics object will be always the handle to the same given image memory buffer , so they all will represent the same image . Even more importantly , you can ' t actually do anything with the stored Graphics : As they do not store anything , there is no way whatsoever they could " re - store " anything . Idea # 2 , cloning the BufferedImage s is a much better idea , but you ' ll indeed be wasting memory , and quickly run out of it . It helps only to store those parts of the image affected by the draw , for example using rectangular areas , but it still costs a lot of memory . Buffering those undo images to disk could help , but it will make your UI slow and unresponsive , and that ' s bad ; furthermore , it makes you application more complex and error - prone . My alternative would be to store store the image modifications in a list , rendered from first to last on top of the image . An undo operation then simply consists of removing the modification from the list . This requires you to " reify " the image modifications , i . e . create a class that implements a single modification , by providing a void draw ( args ) method which performs the actual drawing . As you said , random modifications pose an additional problem . However , the key problem is your use of Math . random ( args ) to create random numbers . Instead , perform each random modification with a Random created from a fixed seed value , so that the ( pseudo - ) random number sequences are the same on each invocation of draw ( args ) , i . e . , each draw has exactly the same effects . ( That ' s why they are called " pseudo - random " - - the generated numbers look random , but they are just as deterministic as any other function . ) In contrast to the image storing technique , which has memory problems , the problem with this technique is that many modifications may make the GUI slow , especially if the modifications are computationally intensive . To prevent this , the simplest way would be to fix an appropriate maximum size of the list of undoable modifications . If this limit would be exceeded by adding a new modification , remove the oldest modification the list and apply it to the backing BufferedImage itself . The following simple demo application shows that ( and how ) this all works together . It also includes a nice " redo " feature for redoing undone actions . # pre

Question - 13195797 , answer - 20043507 Peter Lawrey ' s answer is great because it is simple and not depending on anything special , and it ' s the way you should do it . If you need something that removes subdirectories and their contents as well , use recursion : # pre To spare subdirectories and their contents ( part of your question ) , modify as follows : # pre Or , since you wanted a one - line solution : for ( args ) if ( args ) file . delete ( args ) ; Using an external library for such a trivial task is not a good idea unless you need this library for something else anyway , in which case it is preferrable to use existing code . You appear to be using the Apache library anyway so use its FileUtils . cleanDirectory ( args ) method .

Question - 28818506 , answer - 28821352 It ' s not pretty , but this will work : return serviceA ( args ) . map ( args ) . orElseGet ( args ) . map ( args ) . orElseGet ( args ) . map ( args ) . orElseGet ( args ) ; . map ( args ) . orElseGet ( args ) is a fairly handy pattern for use with Optional . It means " If this Optional contains value v , give me func ( args ) , otherwise give me sup . get ( args ) " . In this case , we call serviceA ( args ) and get an Optional < T > . If that Optional contains value v , we want to get Optional . of ( args ) , but if it is empty , we want to get serviceB ( args ) . Rinse - repeat with more alternatives . Other uses of this pattern are # li . map ( args ) . orElseGet ( args ) # li . map ( args ) . orElseGet ( args )

Question - 17781150 , answer - 17781376 Like the others have mentioned , this is only fulfilled by Integer . MIN _ VALUE . As for proof , let me offer an easier to understand explanation other than in binary ( although it is still rooted in that ) . Note that Integer . MIN _ VALUE is equal to - 2 ^ 31 or - 2147483648 and Integer . MAX _ VALUE is equal to 2 ^ 31 - 1 or 2147483647 . - Integer . MIN _ VALUE is 2 ^ 31 , which is now too large for an Integer ( since it is past MAX _ VALUE ) thus causing an Integer overflow , making it Integer . MIN _ VALUE again . It ' s the only Integer that does this since MIN _ VALUE is the only number with no negative equivalent aside from 0 .

Question - 27888429 , answer - 27888452 Alternative to @ sol4me ' s solution : Stream . of ( args ) Of the difference between this and Arrays . stream ( args ) : it does make a difference if your array is of a primitive type . For instance , if you do : Arrays . stream ( args ) where someArray is a long [ ] , it will return a LongStream . Stream . of ( args ) , on the other hand , will return a Stream < T > with a single element .

Question - 10977992 , answer - 17939167 There are two differences : # li We can use Iterator to traverse Set and List and also Map type of Objects . While a ListIterator can be used to traverse for List - type Objects , but not for Set - type of Objects . That is , we can get a Iterator object by using Set and List , see here : By using Iterator we can retrieve the elements from Collection Object in forward direction only . Methods in Iterator : # li hasNext ( args ) # li next ( args ) # li remove ( args ) # pre # li But we get ListIterator object only from the List interface , see here : where as a ListIterator allows you to traverse in either directions ( Both forward and backward ) . So it has two more methods like hasPrevious ( args ) and previous ( args ) other than those of Iterator . Also , we can get indexes of the next or previous elements ( using nextIndex ( args ) and previousIndex ( args ) respectively ) Methods in ListIterator : # li hasNext ( ) # li next ( ) # li previous ( ) # li hasPrevious ( ) # li remove ( ) # li nextIndex ( ) # li previousIndex ( ) ListIterator listiterator = List . listIterator ( args ) ; i . e . , we can ' t get ListIterator object from Set interface .

Question - 34172978 , answer - 34173110 Flipping the limit and the filter clauses has different behaviors . If you put the limit first , the stream will first generate 10 integers [ 1 . . 10 ] , and then filter them leaving only those smaller than 5 . In the original ordering , with the filter applied first , integers are generated and filtered until you reach 10 elements . This isn ' t an infinite operator , as i in the supplier will eventually overflow , but it will take a while , especially on a slow computer , to reach MAX _ INT .

Question - 5585779 , answer - 33233407 We can use the parseInt ( args ) method of the Integer wrapper class for converting a String value to an integer value . For example : # pre The Integer class also provides the valueOf ( args ) method : # pre We can also use toInt ( args ) of NumberUtils Utility Class for the conversion : # pre

Question - 14491966 I made a class called QuickRandom , and its job is to produce random numbers quickly . It ' s really simple : just take the old value , multiply by a double , and take the decimal part . Here is my QuickRandom class in its entirety : # pre And here is the code I wrote to test it : # pre It is a very simple algorithm that simply multiplies the previous double by a " magic number " double . I threw it together pretty quickly , so I could probably make it better , but strangely , it seems to be working fine . This is sample output of the commented - out lines in the main method : # pre Hm . Pretty random . In fact , that would work for a random number generator in a game . Here is sample output of the non - commented out part : # pre Wow ! It performs almost 4 times faster than Math . random . I remember reading somewhere that Math . random used System . nanoTime ( args ) and tons of crazy modulus and division stuff . Is that really necessary ? My algorithm performs a lot faster and it seems pretty random . I have two questions : # li Is my algorithm " good enough " ( for , say , a game , where really random numbers aren ' t too important ) ? # li Why does Math . random do so much when it seems just simple multiplication and cutting out the decimal will suffice ?

Question - 16098046 , answer - 25307973 In short : If you want to get rid of trailing zeros and Locale problems , then you should use : # pre Explanation : Why other answers did not suit me : # li Double . toString ( args ) or System . out . println or FloatingDecimal . toJavaFormatString uses scientific notations if double is less than 10 ^ - 3 or greater than or equal to 10 ^ 7 # li by using % f , the default decimal precision is 6 , otherwise you can hardcode it but it results in extra zeros added if you have less decimals . Example : # pre # li by using setMaximumFractionDigits ( args ) ; or % . 0f you remove any decimal precision , which is fine for integers / longs but not for double # pre # li by using DecimalFormat , you are local dependent . In French locale , the decimal separator is a comma , not a point : # pre Using the ENGLISH locale makes sure you get a point for decimal separator , wherever your program will run Why using 340 then for setMaximumFractionDigits ? Two reasons : # li setMaximumFractionDigits accepts an integer but its implementation has a maximum digits allowed of DecimalFormat . DOUBLE _ FRACTION _ DIGITS which equals 340 # li Double . MIN _ VALUE = 4 . 9E - 324 so with 340 digits you are sure not to round your double and loose precision

Question - 32693704 , answer - 32744190 There is no actual difference in the functionality between the 2 version ' s loop . Arrays . fill does the exact same thing . So the choice to use it or not may not necessarily be considered a mistake . It is left up to the developer to decide when it comes to this kind of micromanagement . There are 2 separate concerns for each approach : # li using the Arrays . fill makes the code less verbose and more readable . # li looping directly in the HashMap code ( like version 8 ) peformance wise is actually a better option . While the overhead that inserting the Arrays class is negligible it may become less so when it comes to something as widespread as HashMap where every bit of performance enhancement has a large effect ( imagine the tiniest footprint reduce of a HashMap in fullblown webapp ) . Take into consideration the fact that the Arrays class was used only for this one loop . The change is small enough that it doesn ' t make the clear method less readable . The precise reason can ' t be found out without asking the developer who actually did this , however i suspect it ' s either a mistake or a small enhancement . better option . My opinion is it can be considered an enhancement , even if only by accident .

Question - 10631715 , answer - 10631738 You could do this : # pre Basically the . split ( ) method will split the string according to ( in this case ) delimiter you are passing and will return an array of strings . However , you seem to be after a List of Strings rather than an array , so the array must be turned into a list by using the Arrays . asList ( ) utility . Just as an FYI you could also do something like so : # pre But it is usually better practice to program to an interface rather than to an actual concrete implementation , so I would recommend the 1st option .

Question - 26549659 Google Guava has a predicate that always returns true . Does Java 8 have something similar for its Predicate ? I know I could use ( foo ) - > { return true ; } , but I want something pre - made , analogous to Collections . emptySet ( args ) .

Question - 22847105 , answer - 37354549 The way I think about it is that you use flatMap when the function you wanted to put inside of map ( args ) returns an Observable . In which case you might still try to use map ( args ) but it would be unpractical . Let me try to explain why . If in such case you decided to stick with map , you would get an Observable < T > . For example in your case , if we used an imaginary RxGson library , that returned an Observable < T > from it ' s toJson ( args ) method ( instead of simply returning a String ) it would look like this : # pre At this point it would be pretty tricky to subscribe ( args ) to such an observable . Inside of it you would get an Observable < T > to which you would again need to subscribe ( args ) to get the value . Which is not practical or nice to look at . So to make it useful one idea is to " flatten " this observable of observables ( you might start to see where the name _ flat _ Map comes from ) . RxJava provides a few ways to flatten observables and for sake of simplicity lets assume merge is what we want . Merge basically takes a bunch of observables and emits whenever any of them emits . ( Lots of people would argue switch would be a better default . But if you ' re emitting just one value , it doesn ' t matter anyway . ) So amending our previous snippet we would get : # pre This is a lot more useful , because subscribing to that ( or mapping , or filtering , or . . . ) you just get the String value . ( Also , mind you , such variant of merge ( args ) does not exist in RxJava , but if you understand the idea of merge then I hope you also understand how that would work . ) So basically because such merge ( args ) should probably only ever be useful when it succeeds a map ( args ) returning an observable and so you don ' t have to type this over and over again , flatMap ( args ) was created as a shorthand . It applies the mapping function just as a normal map ( args ) would , but later instead of emitting the returned values it also " flattens " ( or merges ) them . That ' s the general use case . It is most useful in a codebase that uses Rx allover the place and you ' ve got many methods returning observables , which you want to chain with other methods returning observables . In your use case it happens to be useful as well , because map ( args ) can only transform one value emitted in onNext ( args ) into another value emitted in onNext ( args ) . But it cannot transform it into multiple values , no value at all or an error . And as akarnokd wrote in his answer ( and mind you he ' s much smarter than me , probably in general , but at least when it comes to RxJava ) you shouldn ' t throw exceptions from your map ( args ) . So instead you can use flatMap ( args ) and return Observable . just ( args ) ; when all goes well , but return Observable . error ( args ) ; when something fails . See his answer for a complete snippet : # a

Question - 23453287 , answer - 23456085 It will be hard to find and identify " THE " answer , for the resons mentioned in the comments from @ EJP : There are roughly 2 ( + / - 2 ) people in the world who can give the definite answer at all . And in doubt , the answer might just be something like " Supporting final default methods did not seem to be worth the effort of restructuring the internal call resolution mechanisms " . This is speculation , of course , but it is at least backed by subtle evidences , like this Statement ( by one of the two persons ) in the OpenJDK mailing list : # blockquote and trivial facts like that a method is simply not considered to be a ( really ) final method when it is a default method , as currently implemented in the Method : : is _ final _ method method in the OpenJDK . Further really " authorative " information is indeed hard to find , even with excessive websearches and by reading commit logs . I thought that it might be related to potential ambiguities during the resolution of interface method calls with the invokeinterface instruction and and class method calls , corresponding to the invokevirtual instruction : For the invokevirtual instruction , there may be a simple vtable lookup , because the method must either be inherited from a superclass , or implemented by the class directly . In contrast to that , an invokeinterface call must examine the respective call site to find out which interface this call actually refers to ( this is explained in more detail in the InterfaceCalls page of the HotSpot Wiki ) . However , final methods do either not get inserted into the vtable at all , or replace existing entries in the vtable ( see klassVtable . cpp . Line 333 ) , and similarly , default methods are replacing existing entries in the vtable ( see klassVtable . cpp , Line 202 ) . So the actual reason ( and thus , the answer ) must be hidden deeper inside the ( rather complex ) method call resolution mechanisms , but maybe these references will nevertheless be considered as being helpful , be it only for others that manage to derive the actual answer from that .

Question - 17781150 , answer - 17781168 The value you are looking for is Integer . MIN _ VALUE . # blockquote That ' s off - topic for Stack Exchange . But you could do it starting from the definition of Java integers ( JLS 4 . 2 ) # blockquote and # blockquote and the definition of the Java unary ' - ' operator ( JLS 15 . 15 . 4 ) : # blockquote

Question - 31993377 Question How is it that for a scanner object the hasNextLine ( args ) method returns true while the hasNext ( args ) method returns false ? Note : Based on the input file , the hasNext ( args ) method is returning the result as expected ; the hasNextLine ( args ) does not seem to be returning the correct result . Code Here ' s the code I ' m running that ' s creating the results below : # pre Input File The following is the actual content of the file that I ' m passing to this scanner : # pre Result The following is the end of what ' s printed in the console when I run my code , and includes the portion I can ' t make sense of : # pre

Question - 7655127 , answer - 7655177 String text = String . copyValueOf ( args ) ; or String text = String . valueOf ( args ) ; is arguably better ( encapsulates the new String call ) .

