{"items": [{"body": "<p>I was reading Java's <code>ArrayList</code> source code and noticed some comparisons in if-statements.</p>\n\n<p>In Java 7, the method <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/util/ArrayList.java#ArrayList.grow%28int%29\"><code>grow(int)</code></a> uses</p>\n\n<pre><code>if (newCapacity - minCapacity &lt; 0)\n    newCapacity = minCapacity;\n</code></pre>\n\n<p>In Java 6, <code>grow</code> didn't exist. The method <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/util/ArrayList.java#ArrayList.ensureCapacity%28int%29\"><code>ensureCapacity(int)</code></a> however uses</p>\n\n<pre><code>if (newCapacity &lt; minCapacity)\n    newCapacity = minCapacity;\n</code></pre>\n\n<p>What was the reason behind the change? Was it a performance issue or just a style? </p>\n\n<p>I could imagine that comparing against zero is faster, but performing a complete subtraction just to check whether it's negative seems a bit overkill to me. Also in terms of bytecode, this would involve two instructions (<code>ISUB</code> and <code>IF_ICMPGE</code>) instead of one (<code>IFGE</code>).</p>\n", "title": "Difference between if (a - b &lt; 0) and if (a &lt; b)", "tags": ["java", "if-statement", "arraylist"], "link": "http://stackoverflow.com/questions/33147339/difference-between-if-a-b-0-and-if-a-b", "post_type": "question", "question_id": 33147339}, {"body": "<p>I have a class used for navigating back and forth through a list of ordered pages. The pages are generally but not always accessed sequentially. Sometimes one or more pages may be skipped based on certain rules.</p>\n\n<p>To manage this, I maintain two stacks, forward and backward, to track which pages have previously been visited in either direction.</p>\n\n<p>As far as the functionality of this class is concerned, there is no reason for it to expose these stacks. However, when unit testing the navigation methods, <code>first()</code>, <code>next()</code>, <code>previous()</code> and <code>last()</code>, which all reorganize the stacks and return the appropriate page, I need to check that the stacks are in the right \"state\" at the end of the process.</p>\n\n<p>For example, calling <code>first()</code> should cause the forward stack to be cleared and every other page that has previously been visited to be pushed into the backward stack.</p>\n\n<p>Is this alone a good enough reason to provide getters for the forward and backward stacks? One reason I am hesitant to do so is that I worry that this also exposes them to (perhaps inadvertent) outside manipulation that might cause the class to malfunction. What if a client clears a stack for example?</p>\n\n<p><strong>UPDATE</strong></p>\n\n<p>Some people have suggested that this question is a duplicate of the one posted <a href=\"http://stackoverflow.com/questions/7075938/making-a-private-method-public-to-unit-test-it-good-idea\">here</a>. I think the 2 questions aren't quite the same. The other question discusses the idea of <strong>refactoring a private method to make it public in order to be able to test it</strong>. This question, on the other hand, is specifically about <strong>testing public methods by examining the internal state of the object under tes</strong>t. I think there is a subtle but significant difference there, and the accepted answer clearly shows how to test the very same public methods without examining internal state.</p>\n", "title": "Is unit testing alone ever a good reason to expose private instance variables via getters?", "tags": ["java", "unit-testing"], "link": "http://stackoverflow.com/questions/31646092/is-unit-testing-alone-ever-a-good-reason-to-expose-private-instance-variables-vi", "post_type": "question", "question_id": 31646092}, {"body": "<p>I was testing boundary conditions on some code involving a <code>BigDecimal</code>, and I noticed that when a <code>BigDecimal</code> is initialized with the String <code>\"1e2147483647\"</code> it behaves unexpectedly. It seems to have a value between <code>0</code> and <code>1e-2147483647</code>. When I try calling <code>intValue()</code>, I get a <code>NegativeArraySizeException</code>. I should note that <code>2147483647</code> is the max value of an integer on my system. Am I doing something wrong, or is this a problem with <code>BigDecimal</code>?</p>\n\n<pre><code>BigDecimal test = new BigDecimal(\"1e2147483647\");\n\ntest.compareTo(new BigDecimal(0));  //Returns 1\ntest.compareTo(new BigDecimal(\"1e-2147483647\"));  //Returns -1\ntest.intValue();  //Throws NegativeArraySizeException\n</code></pre>\n", "title": "Java BigDecimal Possible Overflow Bug", "tags": ["java", "bigdecimal"], "link": "http://stackoverflow.com/questions/31170459/java-bigdecimal-possible-overflow-bug", "post_type": "question", "question_id": 31170459}, {"body": "<p>I noticed something strange in the implementation of <code>HashMap.clear()</code>. This is how it looked in <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/java/util/HashMap.java#737\" rel=\"nofollow\">OpenJDK 7u40</a>:</p>\n\n<pre><code>public void clear() {\n    modCount++;\n    Arrays.fill(table, null);\n    size = 0;\n}\n</code></pre>\n\n<p>And this is how it looks as of <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/util/HashMap.java#857\" rel=\"nofollow\">OpenJDK 8u40</a>:</p>\n\n<pre><code>public void clear() {\n    Node&lt;K,V&gt;[] tab;\n    modCount++;\n    if ((tab = table) != null &amp;&amp; size &gt; 0) {\n        size = 0;\n        for (int i = 0; i &lt; tab.length; ++i)\n            tab[i] = null;\n    }\n}\n</code></pre>\n\n<p>I understand that now the <code>table</code> can be null for empty an map, thus the additional check and caching in a local variable is required. But why was <code>Arrays.fill()</code> replaced with a for-loop?</p>\n\n<p>It seems that the change was introduced in <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/diff/d62c911aebbb/src/share/classes/java/util/HashMap.java#l1.2459\" rel=\"nofollow\">this commit</a>. Unfortunately I found no explanation for why a plain for loop might be better than <code>Arrays.fill()</code>. Is it faster? Or safer?</p>\n", "title": "Why is Arrays.fill() not used in HashMap.clear() anymore?", "tags": ["java", "arrays", "hashmap", "java-8"], "link": "http://stackoverflow.com/questions/32693704/why-is-arrays-fill-not-used-in-hashmap-clear-anymore", "post_type": "question", "question_id": 32693704}, {"body": "<p>Why was the <code>Thread</code> class implemented as a regular class and not an <strong>abstract</strong> class with <code>run()</code> method being abstract.</p>\n\n<p>Will it possibly introduce any problems? Or does it have any use in being this way?</p>\n\n<p>Also, the <code>Thread.start()</code> method is supposed to be a very specific method <strong>whose functionality cannot be implemented by any other class</strong> (If I am not wrong). And hence I guess the <code>final</code> keyword would be apt for this more than any other method.</p>\n\n<p>But I am able to override this method and use it as I like,</p>\n\n<pre><code>public class Test extends Thread {\n    public static void main (String... args) {\n        Thread test = new Test();\n        test.start();\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"New thread started...\");\n    }\n\n    @Override\n    public void start() {\n        System.out.println(\"Did anyone tell you I will spawn a new thread??\");\n    }\n}\n</code></pre>\n\n<p>It obviously only printed,</p>\n\n<blockquote>\n  <p>Did anyone tell you I will spawn a new thread??</p>\n</blockquote>\n\n<p>Is there any use in overriding other than confusing the engineer replacing you?</p>\n\n<p>If not, why was the method not declared final in Thread class?</p>\n", "title": "Why is Thread not an abstract class and start() not final?", "tags": ["java", "multithreading"], "link": "http://stackoverflow.com/questions/31202946/why-is-thread-not-an-abstract-class-and-start-not-final", "post_type": "question", "question_id": 31202946}, {"body": "<p>It has generally been the case the Java source code has been forward compatible.  Until Java 8, as far as I know, both compiled classes <em>and</em> source have been forward compatible with later JDK/JVM releases.  [Update: this is not correct, see comments re 'enum', etc, below.]  However, with the addition of default methods in Java 8 this appears to no longer be the case.</p>\n\n<p>For example, a library I have been using has an implementation of <code>java.util.List</code> which includes a <code>List&lt;V&gt; sort()</code>.  This method returns a copy of the contents of the list sorted. This library, deployed as a jar file dependency, worked fine in a project being built using JDK 1.8.</p>\n\n<p>However, later I had occasion to recompile the library itself using JDK 1.8 and\nI found the library no longer compiles: the <code>List</code>-implementing class with its own <code>sort()</code> method now conflicts with the Java 8 <code>java.util.List.sort()</code> default method.  The Java 8 <code>sort()</code> default method sorts the list in place (returns <code>void</code>); my library's <code>sort()</code> method - since it returns a new sorted list - has an incompatible signature.</p>\n\n<p>So my basic question is:</p>\n\n<ul>\n<li>Doesn't JDK 1.8 introduce a forward incompatibility for Java source code due to default methods?</li>\n</ul>\n\n<p>Also:</p>\n\n<ul>\n<li>Is this the first such forward incompatible change?</li>\n<li>Was this considered or discussed when default methods where designed and implemented?  Is it documented anywhere?</li>\n<li>Was the (admittedly small) inconvenience discounted versus the benefits?</li>\n</ul>\n\n<p>The following is an example of some code that compiles and runs under 1.7 and\nruns under 1.8 - but does not compile under 1.8:</p>\n\n<pre><code>import java.util.*;\n\npublic final class Sort8 {\n\n    public static void main(String[] args) {\n        SortableList&lt;String&gt; l = new SortableList&lt;String&gt;(Arrays.asList(args));\n        System.out.println(\"unsorted: \"+l);\n        SortableList&lt;String&gt; s = l.sort(Collections.reverseOrder());\n        System.out.println(\"sorted  : \"+s);\n    }\n\n    public static class SortableList&lt;V&gt; extends ArrayList&lt;V&gt; {\n\n        public SortableList() { super(); }\n        public SortableList(Collection&lt;? extends V&gt; col) { super(col); }\n\n        public SortableList&lt;V&gt; sort(Comparator&lt;? super V&gt; cmp) {\n            SortableList&lt;V&gt; l = new SortableList&lt;V&gt;();\n            l.addAll(this);\n            Collections.sort(l, cmp);\n            return l;\n        }\n\n    }\n\n}\n</code></pre>\n\n<p>The following shows this code being compiled (or failing to) and being run.</p>\n\n<pre><code>&gt; c:\\tools\\jdk1.7.0_10\\bin\\javac Sort8.java\n\n&gt; c:\\tools\\jdk1.7.0_10\\bin\\java Sort8 this is a test\nunsorted: [this, is, a, test]\nsorted  : [this, test, is, a]\n\n&gt; c:\\tools\\jdk1.8.0_05\\bin\\java Sort8 this is a test\nunsorted: [this, is, a, test]\nsorted  : [this, test, is, a]\n\n&gt; del Sort8*.class\n\n&gt; c:\\tools\\jdk1.8.0_05\\bin\\javac Sort8.java\nSort8.java:46: error: sort(Comparator&lt;? super V&gt;) in SortableList cannot implement sort(Comparator&lt;? super E&gt;) in List\n                public SortableList&lt;V&gt; sort(Comparator&lt;? super V&gt; cmp) {\n                                       ^\n  return type SortableList&lt;V&gt; is not compatible with void\n  where V,E are type-variables:\n    V extends Object declared in class SortableList\n    E extends Object declared in interface List\n1 error\n</code></pre>\n", "title": "Do Java 8 default methods break source compatibility?", "tags": ["java", "java-8", "default-method", "forward-compatibility"], "link": "http://stackoverflow.com/questions/31188231/do-java-8-default-methods-break-source-compatibility", "post_type": "question", "question_id": 31188231}, {"body": "<p>I am using JDK-8 (x64). For <code>Arrays.sort</code> I found the following in the Java documentation: </p>\n\n<blockquote>\n  <p>The sorting algorithm is a Dual-Pivot <strong>Quicksort</strong> by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch.`</p>\n</blockquote>\n\n<p>For <code>Collections.sort</code> I found this: </p>\n\n<blockquote>\n  <p>This implementation is a stable, adaptive, iterative <strong>mergesort</strong> ... This implementation <strong>dumps the specified list into an array, sorts the array</strong>, and iterates over the list resetting each element from the corresponding position in the array.</p>\n</blockquote>\n\n<p>If <code>Collections.sort</code> uses an array, why doesn't it just call <code>Arrays.sort</code> or use dual-pivot <strong>QuickSort</strong>? Why use <strong>Mergesort</strong>?</p>\n", "title": "Why does Collections.sort use Mergesort but Arrays.sort does not?", "tags": ["java", "arrays", "sorting", "collections", "java-8"], "link": "http://stackoverflow.com/questions/32334319/why-does-collections-sort-use-mergesort-but-arrays-sort-does-not", "post_type": "question", "question_id": 32334319}, {"body": "<p>I'm currently in the process of writing a paint program in java, designed to have flexible and comprehensive functionalities. It stemmed from my final project, that I wrote overnight the day before. Because of that, it's got tons and tons of bugs, which I've been tackling one by one (e.g. I can only save files that will be empty, my rectangles don't draw right but my circles do...).</p>\n\n<p>This time, I've been trying to add undo/redo functionality to my program. However, I can't \"undo\" something that I have done. Therefore, I got an idea to save copies of my <code>BufferedImage</code> each time a <code>mouseReleased</code> event was fired. However, with some of the images going to 1920x1080 resolution, I figured that this wouldn't be efficient: storing them would probably take gigabytes of memory.</p>\n\n<p>The reason for why I can't simply paint the same thing with the background colour to undo is because I have many different brushes, which paint based on <code>Math.random()</code>, and because there are many different layers (in a single layer).</p>\n\n<p>Then, I've considered cloning the <code>Graphics</code> objects that I use to paint to the <code>BufferedImage</code>. Like this:</p>\n\n<pre><code>ArrayList&lt;Graphics&gt; revisions = new ArrayList&lt;Graphics&gt;();\n\n@Override\npublic void mouseReleased(MouseEvent event) {\n    Graphics g = image.createGraphics();\n    revisions.add(g);\n}\n</code></pre>\n\n<p>I haven't done this before, so I have a couple questions:</p>\n\n<ul>\n<li>Would I still be wasting pointless memory by doing this, like cloning my <code>BufferedImages</code>?</li>\n<li>Is there necessarily a different way I can do this?</li>\n</ul>\n", "title": "Is storing Graphics objects a good idea?", "tags": ["java", "memory-management", "graphics", "awt", "bufferedimage"], "link": "http://stackoverflow.com/questions/31370403/is-storing-graphics-objects-a-good-idea", "post_type": "question", "question_id": 31370403}, {"body": "<p>I'm trying to determine whether the following statements are guaranteed to be true:</p>\n\n<pre><code>((Boolean)true) == Boolean.TRUE\n((Boolean)true) == Boolean.valueOf(true)\n((Integer)1) == Integer.valueOf(1)\n</code></pre>\n\n<p>I've always assumed that autoboxing was equivalent to calling <code>valueOf()</code> on the corresponding type. Every <a href=\"http://stackoverflow.com/questions/5253256/which-is-better-letting-java-do-autoboxing-or-using-valueof\">discussion</a> that I've seen on the <a href=\"http://stackoverflow.com/questions/408661/what-code-does-the-compiler-generate-for-autoboxing\">topic</a> seems to <a href=\"http://stackoverflow.com/questions/2307904/autoboxing-vs-manual-boxing-java\">support</a> my assumption. But all I could find in the JLS was the following (<a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.7-300\">\u00a75.1.7</a>):</p>\n\n<blockquote>\n  <p>If the value <code>p</code> being boxed is an integer literal of type <code>int</code> between <code>-128</code> and <code>127</code> inclusive (\u00a73.10.1), or the boolean literal <code>true</code> or <code>false</code> (\u00a73.10.3), or a character literal between <code>'\\u0000'</code> and <code>'\\u007f'</code> inclusive (\u00a73.10.4), then let <code>a</code> and <code>b</code> be the results of any two boxing conversions of <code>p</code>. It is always the case that <code>a == b</code>.</p>\n</blockquote>\n\n<p>That describes behavior identical to that of <code>valueOf()</code>. But there doesn't seem to be any guarantee that <code>valueOf()</code> is actually invoked, meaning there could theoretically be an implementation that keeps a separate, dedicated cache for autoboxed values. In such a case, there might not be identity equality between cached autoboxed values and regular cached boxed values.</p>\n\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html\">Oracle's autoboxing tutorial</a> states matter-of-factly that <code>li.add(i)</code> is compiled to <code>li.add(Integer.valueOf(i))</code>, where <code>i</code> is an <code>int</code>. But I don't know whether the tutorial should be considered an authoritative source. </p>\n", "title": "Does autoboxing call valueOf()?", "tags": ["java", "boxing", "autoboxing"], "link": "http://stackoverflow.com/questions/31445024/does-autoboxing-call-valueof", "post_type": "question", "question_id": 31445024}, {"body": "<p>I found <a href=\"http://mail.openjdk.java.net/pipermail/core-libs-dev/2010-March/003736.html\">this explanation</a>:</p>\n\n<blockquote>\n  <p>On Tue, Mar 9, 2010 at 03:02, Kevin L. Stern  wrote: <br/></p>\n  \n  <blockquote>\n    <p>I did a quick search and it appears that Java is indeed two's complement\n    based. Nonetheless, please allow me to point out that, in general, this\n    type of code worries me since I fully expect that at some point someone will\n    come along and do exactly what Dmytro suggested; that is, someone will\n    change:</p>\n\n<pre><code>if (a - b &gt; 0)\n</code></pre>\n    \n    <p>to</p>\n\n<pre><code>if (a &gt; b)\n</code></pre>\n    \n    <p>and the entire ship will sink. I, personally, like to avoid obscurities\n    such as making integer overflow an essential basis for my algorithm unless\n    there is a good reason to do so. I would, in general, prefer to avoid\n    overflow altogether and to make the overflow scenario more explicit:</p>\n\n<pre><code>if (oldCapacity &gt; RESIZE_OVERFLOW_THRESHOLD) {\n   // Do something\n} else {\n  // Do something else\n}\n</code></pre>\n  </blockquote>\n  \n  <p>It's a good point.</p>\n  \n  <p>In <code>ArrayList</code> we cannot do this (or at least not compatibly), because\n  <code>ensureCapacity</code> is a public API and effectively already accepts\n  negative numbers as requests for a positive capacity that cannot be\n  satisfied.</p>\n  \n  <p>The current API is used like this:</p>\n\n<pre><code>int newcount = count + len;\nensureCapacity(newcount);\n</code></pre>\n  \n  <p>If you want to avoid overflow, you would need to change to something\n  less natural like</p>\n\n<pre><code>ensureCapacity(count, len);\nint newcount = count + len;\n</code></pre>\n  \n  <p>Anyway, I'm keeping the overflow-conscious code, but adding more\n  warning comments, and \"out-lining\" huge array creation so that\n  <code>ArrayList</code>'s code now looks like:</p>\n\n<pre><code>/**\n * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if\n * necessary, to ensure that it can hold at least the number of elements\n * specified by the minimum capacity argument.\n *\n * @param minCapacity the desired minimum capacity\n */\npublic void ensureCapacity(int minCapacity) {\n    modCount++;\n\n    // Overflow-conscious code\n    if (minCapacity - elementData.length &gt; 0)\n        grow(minCapacity);\n}\n\n/**\n * The maximum size of array to allocate.\n * Some VMs reserve some header words in an array.\n * Attempts to allocate larger arrays may result in\n * OutOfMemoryError: Requested array size exceeds VM limit\n */\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n/**\n * Increases the capacity to ensure that it can hold at least the\n * number of elements specified by the minimum capacity argument.\n *\n * @param minCapacity the desired minimum capacity\n */\nprivate void grow(int minCapacity) {\n    // Overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);\n    if (newCapacity - minCapacity &lt; 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)\n        newCapacity = hugeCapacity(minCapacity);\n\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n\nprivate int hugeCapacity(int minCapacity) {\n    if (minCapacity &lt; 0) // overflow\n        throw new OutOfMemoryError();\n    return (minCapacity &gt; MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n}\n</code></pre>\n  \n  <p>Webrev regenerated.</p>\n  \n  <p>Martin</p>\n</blockquote>\n\n<p>In Java 6, if you use the API as:</p>\n\n<pre><code>int newcount = count + len;\nensureCapacity(newcount);\n</code></pre>\n\n<p>And <code>newCount</code> overflows (this becomes negative), <code>if (minCapacity &gt; oldCapacity)</code> will return false and you may mistakenly assume that the <code>ArrayList</code> was increased by <code>len</code>.</p>\n", "title": "Difference between if (a - b &lt; 0) and if (a &lt; b)", "tags": ["java", "if-statement", "arraylist"], "link": "http://stackoverflow.com/questions/33147339/difference-between-if-a-b-0-and-if-a-b/33147762#33147762", "post_type": "answer", "question_id": 33147339, "answer_id": 33147762}, {"body": "<p>Another related point: you can make use of the constant pool to improve the performance of string comparisons in some circumstances, by using the <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#intern--\" rel=\"nofollow\"><code>String.intern()</code></a> method.</p>\n\n<p>That method returns the instance of String with the same contents as the String on which it is invoked from the String constants pool, adding it it if is not yet present. In other words, after using <code>intern()</code>, all Strings with the same contents are guaranteed to be the same String instance as each other and as any String constants with those contents, meaning you can then use the equals operator (<code>==</code>) on them.</p>\n\n<p>This is just an example which is not very useful on its own, but it illustrates the point:</p>\n\n<pre class=\"lang-java prettyprint-override\"><code>class Key {\n    Key(String keyComponent) {\n        this.keyComponent = keyComponent.intern();\n    }\n\n    public boolean equals(Object o) {\n        // String comparison using the equals operator allowed due to the\n        // intern() in the constructor, which guarantees that all values\n        // of keyComponent with the same content will refer to the same\n        // instance of String:\n        return (o instanceof Key) &amp;&amp; (keyComponent == ((Key) o).keyComponent);\n    }\n\n    public int hashCode() {\n        return keyComponent.hashCode();\n    }\n\n    boolean isSpecialCase() {\n        // String comparison using equals operator valid due to use of\n        // intern() in constructor, which guarantees that any keyComponent\n        // with the same contents as the SPECIAL_CASE constant will\n        // refer to the same instance of String:\n        return keyComponent == SPECIAL_CASE;\n    }\n\n    private final String keyComponent;\n\n    private static final String SPECIAL_CASE = \"SpecialCase\";\n}\n</code></pre>\n\n<p>This little trick isn't worth designing your code around, but it is worth keeping in mind for the day when you notice a little more speed could be eked out of some bit of performance sensitive code by using the <code>==</code> operator on a string with judicious use of <code>intern()</code>.</p>\n", "title": "How does this Java code snippet work? (String pool and reflection)", "tags": ["java", "string", "reflection", "string-pool"], "link": "http://stackoverflow.com/questions/32623834/how-does-this-java-code-snippet-work-string-pool-and-reflection/32652449#32652449", "post_type": "answer", "question_id": 32623834, "answer_id": 32652449}, {"body": "<p>No, you appear to have a legit bug. The bug presents in JDK7 but fixed in JDK8. Your values are correctly representable as <code>BigDecimal</code>s, and should behave correctly, but don't.</p>\n\n<p>Tracing through <a href=\"http://www.docjar.com/html/api/java/math/BigDecimal.java.html#2571\">the source code of <code>BigDecimal</code></a>, on line 2585, <code>this.precision()</code> is 1, and <code>this.scale</code> is <code>-2147483647</code>.  <code>this.precision() - this.scale</code> therefore overflows, and the following overflow is not handled correctly.</p>\n\n<p>This bug <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/rev/216a4b93cee8\">has been fixed</a> in JDK8 by <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/math/BigDecimal.java#BigDecimal.compareMagnitude%28java.math.BigDecimal%29\">doing the subtraction in <code>long</code> arithmetic</a>.</p>\n", "title": "Java BigDecimal Possible Overflow Bug", "tags": ["java", "bigdecimal"], "link": "http://stackoverflow.com/questions/31170459/java-bigdecimal-possible-overflow-bug/31170506#31170506", "post_type": "answer", "question_id": 31170459, "answer_id": 31170506}, {"body": "<p>There is no actual difference in the functionality between the 2 version's loop. <code>Arrays.fill</code> does the exact same thing.</p>\n\n<p>So the choice to use it or not may not necessarily be considered a mistake. It is left up to the developer to decide when it comes to this kind of micromanagement.</p>\n\n<p>There are 2 separate concerns for each approach:</p>\n\n<ul>\n<li>using the <code>Arrays.fill</code> makes the code less verbose and more readable.</li>\n<li>looping directly in the <code>HashMap</code> code (like version 8) peformance wise is actually a better option. While the overhead that inserting the <code>Arrays</code> class is negligible it may become less so when it comes to something as widespread as <code>HashMap</code> where every bit of performance enhancement has a large effect(imagine the tiniest footprint reduce of a HashMap in fullblown webapp). Take into consideration the fact that the Arrays class was used only for this one loop. The change is small enough that it doesn't make the clear method less readable.</li>\n</ul>\n\n<p>The precise reason can't be found out without asking the developer who actually did this, however i suspect it's either a mistake or a small enhancement.\nbetter option.</p>\n\n<p>My opinion is it can be considered an enhancement, even if only by accident. </p>\n", "title": "Why is Arrays.fill() not used in HashMap.clear() anymore?", "tags": ["java", "arrays", "hashmap", "java-8"], "link": "http://stackoverflow.com/questions/32693704/why-is-arrays-fill-not-used-in-hashmap-clear-anymore/32744190#32744190", "post_type": "answer", "question_id": 32693704, "answer_id": 32744190}, {"body": "<p>For me, the reason is a likely performance inprovement, at a negligible cost in terms of code clarity.</p>\n\n<p>Note that the implementation of the <code>fill</code> method is trivial, a simple for-loop setting each array element to null. So, replacing a call to it with the actual implementation does not cause any significant degradation in the clarity/conciseness of the caller method.</p>\n\n<p>The potential performance benefits are not so insignificant, if you consider everything that is involved:</p>\n\n<ol>\n<li><p>There will be no need for the JVM to resolve the <code>Arrays</code> class, plus loading and initializing it if needed. This is a non-trivial process where the JVM performs several steps. Firstly, it checks the class loader to see if the class is already loaded, and this happens every time a method is called; there are optimizations involved here, of course, but it still takes some effort. If the class is not loaded, the JVM will need to go through the expensive process of loading it, verifying the bytecode, resolving other necessary dependencies, and finally performing static initialization of the class (which can be arbitrarily expensive). Given that <code>HashMap</code> is such a core class, and that <code>Arrays</code> is such a huge class (3600+ lines), avoiding these costs may add up to noticeable savings.</p></li>\n<li><p>Since there is no <code>Arrays.fill(...)</code> method call, the JVM won't have to decide whether/when to inline the method into the caller's body. Since <code>HashMap#clear()</code> tends to get called a lot, the JVM will eventually perform the inlining, which requires JIT recompilation of the <code>clear</code> method. With no method calls, <code>clear</code> will always run at top-speed (once initially JITed).</p></li>\n</ol>\n\n<p>Another benefit of no longer calling methods in <code>Arrays</code> is that it simplifies the dependency graph inside the <code>java.util</code> package, since one dependency is removed.</p>\n", "title": "Why is Arrays.fill() not used in HashMap.clear() anymore?", "tags": ["java", "arrays", "hashmap", "java-8"], "link": "http://stackoverflow.com/questions/32693704/why-is-arrays-fill-not-used-in-hashmap-clear-anymore/32745612#32745612", "post_type": "answer", "question_id": 32693704, "answer_id": 32745612}, {"body": "<p>I'm going to shoot in the dark here... </p>\n\n<p>My <em>guess</em> is that it might have been changed in order to prepare the ground for <a href=\"http://openjdk.java.net/jeps/218\" rel=\"nofollow\">Specialization</a> (aka generics over primitive types). <em>Maybe</em> (and I insist on <em>maybe</em>), this change is meant to make transition to Java 10 easier, in the event of specialization being part of the JDK.</p>\n\n<p>If you look at the <a href=\"http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html\" rel=\"nofollow\">State of the Specialization document</a>, <strong>Language restrictions</strong> section, it says the following:</p>\n\n<blockquote>\n  <p>Because any type variables can take on value as well as reference types, the type checking rules involving such type variables (henceforth, \"avars\"). For example, for an avar T:</p>\n  \n  <ul>\n  <li><strong>Cannot convert null to a variable whose type is T</strong></li>\n  <li>Cannot compare T to null</li>\n  <li><strong>Cannot convert T to Object</strong></li>\n  <li><strong>Cannot convert T[] to Object[]</strong></li>\n  <li>...</li>\n  </ul>\n</blockquote>\n\n<p>(Emphasis is mine).</p>\n\n<p>And ahead in the <strong>Specializer transformations</strong> section, it says:</p>\n\n<blockquote>\n  <p>When specializing an any-generic class, the specializer is going to perform a number of transformations, most localized, but some requiring a global view of a class or method, including:</p>\n  \n  <ul>\n  <li>...</li>\n  <li><strong>Type variable substitution and name mangling is performed on the signatures of all methods</strong></li>\n  <li>...</li>\n  </ul>\n</blockquote>\n\n<p>Later on, near the end of the document, in the <strong>Further investigation</strong> section, it says:</p>\n\n<blockquote>\n  <p>While our experiments have proven that specialization in this manner is practical, much more investigation is needed. Specifically, we need to perform a number of targeted experiments aimed at any-fying core JDK libraries, specifically Collections and Streams.</p>\n</blockquote>\n\n<hr>\n\n<p>Now, regarding the change...</p>\n\n<p>If the <code>Arrays.fill(Object[] array, Object value)</code> method is going to be specialized, then its signature should change to <code>Arrays.fill(T[] array, T value)</code>. However this case is specifically listed in the (already mentioned) <em>Language restrictions</em> section (it would violate the emphasized items). So <em>maybe</em> someone decided that it would be better to not use it from the <code>HashMap.clear()</code> method, especially if <code>value</code> is <code>null</code>.</p>\n", "title": "Why is Arrays.fill() not used in HashMap.clear() anymore?", "tags": ["java", "arrays", "hashmap", "java-8"], "link": "http://stackoverflow.com/questions/32693704/why-is-arrays-fill-not-used-in-hashmap-clear-anymore/32749756#32749756", "post_type": "answer", "question_id": 32693704, "answer_id": 32749756}, {"body": "<p>I will try to summarize three moreless reasonable versions which were proposed in comments.</p>\n\n<p>@Holger <a href=\"http://stackoverflow.com/questions/32693704/why-arrays-fill-is-not-used-in-hashmap-clear-anymore#comment53230781_32693704\">says</a>:</p>\n\n<blockquote>\n  <p>I guess that this is to avoid the class java.util.Arrays getting loading as a side effect of this method. For application code, this is usually not a concern.</p>\n</blockquote>\n\n<p>This is the most easy thing to test. Let's compile such program:</p>\n\n<pre><code>public class HashMapTest {\n    public static void main(String[] args) {\n        new java.util.HashMap();\n    }\n}\n</code></pre>\n\n<p>Run it with <code>java -verbose:class HashMapTest</code>. This will print the class loading events as they occur. With JDK 1.8.0_60 I see more than 400 classes loaded:</p>\n\n<pre><code>... 155 lines skipped ...\n[Loaded java.util.Set from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.util.AbstractSet from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.util.Collections$EmptySet from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.util.Collections$EmptyList from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.util.Collections$EmptyMap from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.util.Collections$UnmodifiableCollection from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.util.Collections$UnmodifiableList from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.util.Collections$UnmodifiableRandomAccessList from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded sun.reflect.Reflection from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n**[Loaded java.util.HashMap from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.util.HashMap$Node from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.lang.Class$3 from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.lang.Class$ReflectionData from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.lang.Class$Atomic from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded sun.reflect.generics.repository.AbstractRepository from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded sun.reflect.generics.repository.GenericDeclRepository from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded sun.reflect.generics.repository.ClassRepository from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.lang.Class$AnnotationData from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded sun.reflect.annotation.AnnotationType from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.util.WeakHashMap from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.lang.ClassValue$ClassValueMap from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.lang.reflect.Modifier from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded sun.reflect.LangReflectAccess from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.lang.reflect.ReflectAccess from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n**[Loaded java.util.Arrays from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n...\n</code></pre>\n\n<p>As you can see, <code>HashMap</code> is loaded long before application code and <code>Arrays</code> is loaded only 14 classes after <code>HashMap</code>. The <code>HashMap</code> load is triggered by <code>sun.reflect.Reflection</code> initialization as it has <code>HashMap</code> static fields. The <code>Arrays</code> load is likely to be triggered by <code>WeakHashMap</code> load which actually has <code>Arrays.fill</code> in the <code>clear()</code> method. The <code>WeakHashMap</code> load is triggered by <code>java.lang.ClassValue$ClassValueMap</code> which extends <code>WeakHashMap</code>. The <code>ClassValueMap</code> is present in every <code>java.lang.Class</code> instance. So to me seems that without <code>Arrays</code> class the JDK cannot be initialized at all. Also the <code>Arrays</code> static initializer is very short, it only initializes the assertion mechanism. This mechanism is used in many other classes (including, for example, <code>java.lang.Throwable</code> which is loaded very early). No other static initialization steps are performed in <code>java.util.Arrays</code>. Thus @Holger version seems incorrect to me.</p>\n\n<p>Here we also found very interesting thing. The <code>WeakHashMap.clear()</code> still uses <code>Arrays.fill</code>. It's interesting when it appeared there, but unfortunately this goes to <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/annotate/37a05a11f281/src/share/classes/java/util/WeakHashMap.java#l633\">prehistoric times</a> (it was already there in the very first public OpenJDK repository).</p>\n\n<p>Next, @MarcoTopolnik <a href=\"http://stackoverflow.com/questions/32693704/why-arrays-fill-is-not-used-in-hashmap-clear-anymore#comment53230663_32693704\">says</a>:</p>\n\n<blockquote>\n  <p>Safer surely not, but it <em>might</em> be faster when the <code>fill</code> call is not inlined and <code>tab</code> is short. On HotSpot both the loop and the explicit <code>fill</code> call will result in a fast compiler intrinsic (in a happy-day scenario). </p>\n</blockquote>\n\n<p>It was actually surprising for me that <code>Arrays.fill</code> is not directly intrinsified (see <a href=\"https://gist.github.com/apangin/7a9b7062a4bd0cd41fcc\">intrinsic list</a> generated by <a href=\"http://stackoverflow.com/users/3448419/apangin\">@apangin</a>). Seems that such loop can be recognized and vectorized by JVM without explicit intrinsic handling. So it's true that extra call can be not inlined in very specific cases (for example if <code>MaxInlineLevel</code> limit is reached). On the other hand it's very rare situation and it's only a single call, it's not a call inside loop, and it's a static, not virtual/interface call, thus the performance improvement could be only marginal and only in some specific scenarios. Not the thing the JVM developers usually care.</p>\n\n<p>Also it should be noted that even C1 'client' compiler (tier 1-3) is capable to inline <code>Arrays.fill</code> called, for example, in <code>WeakHashMap.clear()</code>, as inlining log (<code>-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining</code>) says:</p>\n\n<pre><code>36       3  java.util.WeakHashMap::clear (50 bytes)\n     !m        @ 4   java.lang.ref.ReferenceQueue::poll (28 bytes)\n                 @ 17   java.lang.ref.ReferenceQueue::reallyPoll (66 bytes)   callee is too large\n               @ 28   java.util.Arrays::fill (21 bytes)\n     !m        @ 40   java.lang.ref.ReferenceQueue::poll (28 bytes)\n                 @ 17   java.lang.ref.ReferenceQueue::reallyPoll (66 bytes)   callee is too large\n               @ 1   java.util.AbstractMap::&lt;init&gt; (5 bytes)   inline (hot)\n                 @ 1   java.lang.Object::&lt;init&gt; (1 bytes)   inline (hot)\n               @ 9   java.lang.ref.ReferenceQueue::&lt;init&gt; (27 bytes)   inline (hot)\n                 @ 1   java.lang.Object::&lt;init&gt; (1 bytes)   inline (hot)\n                 @ 10   java.lang.ref.ReferenceQueue$Lock::&lt;init&gt; (5 bytes)   unloaded signature classes\n               @ 62   java.lang.Float::isNaN (12 bytes)   inline (hot)\n               @ 112   java.util.WeakHashMap::newTable (8 bytes)   inline (hot)\n</code></pre>\n\n<p>Of course, it's also easily inlined by smart and powerful C2 'server' compiler. Thus I see no problems here. Seems that @Marco version is incorrect either.</p>\n\n<p>Finally we have a couple of <a href=\"http://stackoverflow.com/questions/32693704/why-arrays-fill-is-not-used-in-hashmap-clear-anymore/32752970#comment53251284_32693704\">comments</a> from @StuartMarks (who is JDK developer, thus some official voice):</p>\n\n<blockquote>\n  <p>Interesting. My hunch is that this is a mistake. The review thread for this changeset is <a href=\"http://mail.openjdk.java.net/pipermail/core-libs-dev/2013-August/020131.html\">here</a> and it references an <a href=\"http://mail.openjdk.java.net/pipermail/core-libs-dev/2013-July/018685.html\">earlier thread</a> that is <a href=\"http://mail.openjdk.java.net/pipermail/core-libs-dev/2013-August/019853.html\">continued here</a>. The initial message in that earlier thread points to a prototype of HashMap.java in Doug Lea's CVS repository. I don't know where this came from. It doesn't seem to match anything in the OpenJDK history.</p>\n  \n  <p>... In any case, it might have been some old snapshot; the for-loop was in the clear() method for many years. The Arrays.fill() call was introduced by <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/rev/2e3cc7f599ca\">this changeset</a>, so it was in the tree only for a few months. Note also that the power-of-two computation based on Integer.highestOneBit() introduced by <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/rev/36f4cf8872f3\">this changeset</a> also disappeared at the same time, though this was noted but dismissed during the review. Hmmm.</p>\n</blockquote>\n\n<p>Indeed the <code>HashMap.clear()</code> contained the loop many years, was <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/rev/2e3cc7f599ca#l2.156\">replaced</a> with <code>Arrays.fill</code> on Apr 10th, 2013 and stayed less one half-a-year until Sept 4th when the discussed <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/diff/d62c911aebbb/src/share/classes/java/util/HashMap.java#l1.2459\">commit</a> was introduced. The discussed commit was actually a major rewrite of the <code>HashMap</code> internals to fix <a href=\"https://bugs.openjdk.java.net/browse/JDK-8023463\">JDK-8023463</a> issue. It was a long story about possibility to poison the <code>HashMap</code> with keys having duplicating hashcodes reducing <code>HashMap</code> search speed to linear making it vulnerable to DoS-attacks. The attempts to solve this were performed in JDK-7 including some randomization of String hashCode. So seems that the <code>HashMap</code> implementation was forked from the earlier commit, developed independently, then merged into the master branch overwriting several changes introduced in-between.</p>\n\n<p>We may support this hypothesis performing a diff. Take the <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/raw-file/d62c911aebbb/src/share/classes/java/util/HashMap.java\">version</a> where <code>Arrays.fill</code> was removed (2013-09-04) and compare it with <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/raw-file/36f4cf8872f3/src/share/classes/java/util/HashMap.java\">previous version</a> (2013-07-30). The <code>diff -U0</code> output has 4341 lines. Now let's diff against the <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/raw-file/de228734b742/src/share/classes/java/util/HashMap.java\">version</a> prior to one when <code>Arrays.fill</code> was added (2013-04-01). Now <code>diff -U0</code> contains only 2680 lines. Thus the newer version actually more similar to the older than to immediate parent.</p>\n\n<p><strong>Conclusion</strong></p>\n\n<p>So to conclude I would agree with Stuart Marks. There were no concrete reason to remove <code>Arrays.fill</code>, it's just because the in-between change was overwritten by mistake. Using <code>Arrays.fill</code> is perfectly fine both in JDK code and in user applications and used, for example, in <code>WeakHashMap</code>. The <code>Arrays</code> class is loaded anyways pretty early during the JDK initialization, has very simple static initializer and <code>Arrays.fill</code> method can be easily inlined even by client compiler, so no performance drawback should be noted.</p>\n", "title": "Why is Arrays.fill() not used in HashMap.clear() anymore?", "tags": ["java", "arrays", "hashmap", "java-8"], "link": "http://stackoverflow.com/questions/32693704/why-is-arrays-fill-not-used-in-hashmap-clear-anymore/32752970#32752970", "post_type": "answer", "question_id": 32693704, "answer_id": 32752970}, {"body": "<blockquote>\n  <p>Why was the Thread class implemented as a regular class and not an\n  abstract class with run() method being abstract.</p>\n</blockquote>\n\n<p>This question actually boils down to the fact that you should always prefer composition over inheritance.</p>\n\n<p>If the <code>Thread</code> class was declared as <code>abstract</code>, the language would have to provide another class that extended from it which programmers could use to create a <code>Thread</code>. Your question would then be about why this class that <code>extends</code> from <code>Thread</code> is not <code>abstract</code>. If the language did not provide another class that <code>extends</code> from <code>Thread</code>, programmers would have to create their own class that <code>extend</code>s from <code>Thread</code> and override the <code>run()</code> method.</p>\n\n<blockquote>\n  <p>If not, why was the method not declared final in Thread class??</p>\n</blockquote>\n\n<p>The only possible explanation I can give is that the developers of the language saw some use-cases for overriding <code>start</code> when the class was introduced to the JDK. The first version of Java that I used was 1.5 and I personally have not come across a use-case where I found the need to override <code>start</code>. As JB Nizet stated in his answer</p>\n\n<blockquote>\n  <p>if Java was redesigned from scratch today, there is a good chance the design would be different</p>\n</blockquote>\n", "title": "Why is Thread not an abstract class and start() not final?", "tags": ["java", "multithreading"], "link": "http://stackoverflow.com/questions/31202946/why-is-thread-not-an-abstract-class-and-start-not-final/31203252#31203252", "post_type": "answer", "question_id": 31202946, "answer_id": 31203252}, {"body": "<p>Don't feel like you have to do <em>everything</em> in/with the stream. I would just do:</p>\n\n<pre><code>AtomicInteger index = new AtomicInteger();\nitems.stream().collect(Collectors.toMap(i -&gt; index.getAndIncrement(), i -&gt; i));\n</code></pre>\n\n<p>As long as you don't parallelise the stream this will work and it avoids potentially expensive and/or problematic (in the case of duplicates) <code>get()</code> and <code>indexOf()</code> operations.</p>\n\n<p>(You cannot use a regular <code>int</code> variable in place of the <code>AtomicInteger</code> because variables used from outside a lambda expression must be effectively final. Note that when uncontested (as in this case), <code>AtomicInteger</code> is very fast and won't pose a performance problem. But if it worries you you can use a non-thread-safe counter.)</p>\n", "title": "Java 8 list to map with stream", "tags": ["java", "dictionary", "collections", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/32859038/java-8-list-to-map-with-stream/32863263#32863263", "post_type": "answer", "question_id": 32859038, "answer_id": 32863263}, {"body": "<p>Using a third party library (<a href=\"https://github.com/poetix/protonpack\" rel=\"nofollow\">protonpack</a> for example, but there are others) you can <code>zip</code> the value with its index and voila:</p>\n\n<pre><code>StreamUtils.zipWithIndex(items.stream())\n    .collect(Collectors.toMap(Indexed::getIndex, Indexed::getValue));\n</code></pre>\n\n<p>although <code>getIndex</code> returns a <code>long</code>, so you may need to cast it using something similar to:</p>\n\n<pre><code>i -&gt; Integer.valueOf((int) i.getIndex())\n</code></pre>\n", "title": "Java 8 list to map with stream", "tags": ["java", "dictionary", "collections", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/32859038/java-8-list-to-map-with-stream/32869478#32869478", "post_type": "answer", "question_id": 32859038, "answer_id": 32869478}, {"body": "<h1>Integer a.equals( a ) can return false</h1>\n\n<p>But you have to be really evil and use reflections and Multithreading:</p>\n\n<p>If you run this code, there is a chance that a racing condition can change the internal Value of <code>myInt</code> while the comparision takes place. If you want to simulate this condition, just set a breakpoint inside of <code>Integer.intValue()</code> run the code in debug and hit continue. This will create a delay which creates the race condition artificially and the console will return false.</p>\n\n<pre><code>class IntegerEqualsTest\n{\n    public static void main( final String[] args )\n    {\n        final Integer myInt = new Integer( 420 );\n\n        new Thread() {\n            public void run() {\n                try {\n                    final Field f = Integer.class.getDeclaredField( \"value\" );\n                    f.setAccessible( true );\n                    f.setInt( myInt, 100 );\n                } catch( final Exception e ) {}\n            }; }.start();\n\n        System.out.println( myInt.equals( myInt ) );\n    }\n}\n</code></pre>\n", "title": "Can .equals be overridden such that a.equals(a) returns false?", "tags": ["java", "equals"], "link": "http://stackoverflow.com/questions/32175145/can-equals-be-overridden-such-that-a-equalsa-returns-false/32182250#32182250", "post_type": "answer", "question_id": 32175145, "answer_id": 32182250}, {"body": "<p>The <code>java.time</code> API in general <em>does</em> have nanosecond precision. For example:</p>\n\n<pre><code>DateTimeFormatter formatter = DateTimeFormatter\n    .ofPattern(\"yyyy-MM-dd'T'HH:mm:ss,nnnnnnnnnZ\");\nOffsetDateTime odt = OffsetDateTime.of(2015, 11, 2, 12, 38, 0, 123456789, ZoneOffset.UTC);\nSystem.out.println(odt.format(formatter));\n</code></pre>\n\n<p>Output:</p>\n\n<pre><code>2015-11-02T12:38:00,123456789+0000\n</code></pre>\n\n<p>However, it's the clock value returned by <code>OffsetDateTime.now()</code> which is returning a value which only has milliseconds.</p>\n\n<p>From <a href=\"https://docs.oracle.com/javase/8/docs/api/java/time/Clock.html\" rel=\"nofollow\"><code>Clock</code></a> implementation in Java 8:</p>\n\n<blockquote>\n  <p>The clock implementation provided here is based on <code>System.currentTimeMillis()</code>. That method provides little to no guarantee about the accuracy of the clock. Applications requiring a more accurate clock must implement this abstract class themselves using a different external clock, such as an NTP server.</p>\n</blockquote>\n\n<p>So there's nothing inherently imprecise here - just the default implementation of <code>Clock</code> using <code>System.currentTimeMillis()</code>. You could potentially create your own more precise subclass. However, you should note that adding more precision without adding more <em>accuracy</em> probably isn't terribly useful. (There are times when it might be, admittedly...)</p>\n", "title": "Why does the new Java 8 Date Time API not have nanosecond precision?", "tags": ["java", "java-8", "java-time"], "link": "http://stackoverflow.com/questions/33477695/why-does-the-new-java-8-date-time-api-not-have-nanosecond-precision/33477803#33477803", "post_type": "answer", "question_id": 33477695, "answer_id": 33477803}, {"body": "<p>If the very first operation that is done with an ArrayList is to pass <code>addAll</code> a collection which has more than ten elements, then any effort put into creating an initial ten-element array to hold the ArrayList's contents would be thrown out the window.  Whenever something is added to an ArrayList it's necessary to test whether the size of the resulting list will exceed the size of the backing store; allowing the initial backing store to have size zero rather than ten will cause this test to fail one extra time in the lifetime of a list whose first operation is an \"add\" which would require creating the initial ten-item array, but that cost is less than the cost of creating a ten-item array that never ends up getting used.</p>\n\n<p>That having been said, it might have been possible to improve performance further in some contexts if there were a overload of \"addAll\" which specified how many items (if any) would likely be added to the list after the present one, and which could use that to influence its allocation behavior.  In some cases code which adds the last few items to a list will have a pretty good idea that the list is never going to need any space beyond that.  There are many situations where a list will get populated once and never modified after that.  If at the point code knows that the ultimate size of a list will be 170 elements, it has 150 elements and a backing store of size 160, growing the backing store to size 320 will be unhelpful and leaving it at size 320 or trimming it to 170 will be less efficient than simply having the next allocation grow it to 170.</p>\n", "title": "In Java 8, why is the default capacity of ArrayList now zero?", "tags": ["java", "arraylist", "java-8"], "link": "http://stackoverflow.com/questions/34250207/in-java-8-why-is-the-default-capacity-of-arraylist-now-zero/34256637#34256637", "post_type": "answer", "question_id": 34250207, "answer_id": 34256637}, {"body": "<p>Ironically default methods in interfaces were introduced to allow existing libraries using those interfaces <em>not</em> to break, while introducing massive <em>new</em> functionality in the interfaces. (backward compatibility.)</p>\n\n<p>Conflicts like that <code>sort</code> method might arise. Something to pay for the extra functionality. In your case also something to investigate (should new functionality be used instead?).</p>\n\n<p>Java forward compatibility breaks are little, more in its typing system, which was constantly enlarged. First with generic types and now with inferred types from functional interfaces. From version to version and from compiler to compiler there were slight differences.</p>\n", "title": "Do Java 8 default methods break source compatibility?", "tags": ["java", "java-8", "default-method", "forward-compatibility"], "link": "http://stackoverflow.com/questions/31188231/do-java-8-default-methods-break-source-compatibility/31188818#31188818", "post_type": "answer", "question_id": 31188231, "answer_id": 31188818}, {"body": "<p>We can draw a parallel with abstract class. An abstract class is intended to be subclassed so that the abstract methods can be implemented. The abstract class itself contains concrete methods that invoke the abstract methods. The abstract class is free to evolve by adding more concrete methods; and this practice may break subclasses.</p>\n\n<p>Therefore the exact problem you described existed even before Java8. The problem is much more manifested on Collection APIs because there are a lot of subclasses out in the wild.</p>\n\n<p>While the leading motivation of default method was to add some useful methods to existing Collection APIs without breaking subclasses, they had to exercise great self-control of doing it too much, for fear of breaking subclasses. A default method is added only if it's absolutely necessary. The real question here is, why <code>List.sort</code> is considered absolutely necessary. I think that is debatable. </p>\n\n<p>Regardless of why default method was introduced in the 1st place, it is now a great tool for API designers, and we ought to treat it the same as concrete methods in abstract classes - they need to be designed carefully up front; and new ones must be introduced with great caution. </p>\n", "title": "Do Java 8 default methods break source compatibility?", "tags": ["java", "java-8", "default-method", "forward-compatibility"], "link": "http://stackoverflow.com/questions/31188231/do-java-8-default-methods-break-source-compatibility/31190722#31190722", "post_type": "answer", "question_id": 31188231, "answer_id": 31190722}, {"body": "<p>As you said internally the last concatenation is done to something similar to</p>\n\n<pre><code>String e = new StringBuilder().append(c).append(\"ender\").toString();\n</code></pre>\n\n<p>the implementation of <code>toString()</code> of <code>StringBuilder</code> <strong>creates a new String</strong>. Here is the implementation.</p>\n\n<pre><code>public String toString() {\n     // Create a copy, don't share the array\n     return new String(value, 0, count);\n}\n</code></pre>\n\n<p>Comparing strings using <code>==</code> instead of <code>.equals()</code> <strong>returns <code>true</code> only if both strings are the same</strong>. In this case <strong>they are not the same because the second string is created as a new</strong> object of type <strong><code>String</code></strong>.</p>\n\n<p>The other concatenations are performed directly by the compiler so no new String is created.</p>\n", "title": "&quot;==&quot; in case of String concatenation in Java", "tags": ["java", "string"], "link": "http://stackoverflow.com/questions/34509566/in-case-of-string-concatenation-in-java/34509655#34509655", "post_type": "answer", "question_id": 34509566, "answer_id": 34509655}, {"body": "<p>The API guarantees a <em>stable</em> sorting which Quicksort doesn\u2019t offer. However, when sorting <em>primitive values</em> by their natural order you won\u2019t notice a difference as primitive values have no identity. Therefore, Quicksort is used for primitive arrays as it is slightly more efficient.</p>\n\n<p>For objects you may notice, when objects which are deemed equal according to their <code>equals</code> implementation or the provided <code>Comparator</code> change their order. Therefore, Quicksort is not an option. So a variant of MergeSort is used, the current Java versions use <em>TimSort</em>. This applies to both, <code>Arrays.sort</code> and <code>Collections.sort</code>, though with Java\u00a08, the <code>List</code> itself may override the sort algorithms.</p>\n", "title": "Why does Collections.sort use Mergesort but Arrays.sort does not?", "tags": ["java", "arrays", "sorting", "collections", "java-8"], "link": "http://stackoverflow.com/questions/32334319/why-does-collections-sort-use-mergesort-but-arrays-sort-does-not/32334651#32334651", "post_type": "answer", "question_id": 32334319, "answer_id": 32334651}, {"body": "<p>Idea #1, storing the <code>Graphics</code> objects simply wouldn't work. The <code>Graphics</code> should not be considered as \"holding\" some display memory, but rather as a handle to access an area of display memory. In the case of <code>BufferedImage</code>, each <code>Graphics</code> object will be always the handle to the same given image memory buffer, so they all will represent the same image. Even more importantly, <strong>you can't actually do anything with the stored <code>Graphics</code>:</strong> As they do not store anything, there is no way whatsoever they could \"re-store\" anything.</p>\n\n<p>Idea #2, cloning the <code>BufferedImage</code>s is a much better idea, but you'll indeed be wasting memory, and quickly run out of it. It helps only to store those parts of the image affected by the draw, for example using rectangular areas, but it still costs a lot of memory. Buffering those undo images to disk could help, but it will make your UI slow and unresponsive, and that's <em>bad</em>; furthermore, it makes you application more <strong>complex and error-prone</strong>.</p>\n\n<p>My alternative would be to store store the image modifications in a list, rendered from first to last on top of the image. An undo operation then simply consists of removing the modification from the list.</p>\n\n<p>This requires you to <strong>\"reify\" the image modifications</strong>, i.e. create a class that implements a single modification, by providing a <code>void draw(Graphics gfx)</code> method which performs the actual drawing.</p>\n\n<p>As you said, <strong>random modifications</strong> pose an additional problem. However, the key problem is your use of <code>Math.random()</code> to create random numbers. Instead, perform each random modification with a <code>Random</code> created from a fixed seed value, so that the (pseudo-)random number sequences are the same on each invocation of <code>draw()</code>, i.e., each draw has exactly the same effects. (That's why they are called \"pseudo-random\" -- the generated numbers look random, but they are just as deterministic as any other function.)</p>\n\n<p>In contrast to the image storing technique, which has memory problems, the problem with this technique is that many modifications may make the GUI slow, especially if the modifications are computationally intensive. To prevent this, the simplest way would be to fix an appropriate <strong>maximum size of the list of undoable modifications</strong>. If this limit would be exceeded by adding a new modification, remove the oldest modification the list and apply it to the backing <code>BufferedImage</code> itself.</p>\n\n<p>The following <strong>simple demo application</strong> shows that (and how) this all works together. It also includes a nice \"redo\" feature for redoing undone actions.</p>\n\n<pre><code>package stackoverflow;\n\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.image.BufferedImage;\nimport java.util.LinkedList;\nimport java.util.Random;\nimport javax.swing.*;\n\npublic final class UndoableDrawDemo\n        implements Runnable\n{\n    public static void main(String[] args) {\n        EventQueue.invokeLater(new UndoableDrawDemo()); // execute on EDT\n    }\n\n    // holds the list of drawn modifications, rendered back to front\n    private final LinkedList&lt;ImageModification&gt; undoable = new LinkedList&lt;&gt;();\n    // holds the list of undone modifications for redo, last undone at end\n    private final LinkedList&lt;ImageModification&gt; undone = new LinkedList&lt;&gt;();\n\n    // maximum # of undoable modifications\n    private static final int MAX_UNDO_COUNT = 4;\n\n    private BufferedImage image;\n\n    public UndoableDrawDemo() {\n        image = new BufferedImage(600, 600, BufferedImage.TYPE_INT_RGB);\n    }\n\n    public void run() {\n        // create display area\n        final JPanel drawPanel = new JPanel() {\n            @Override\n            public void paintComponent(Graphics gfx) {\n                super.paintComponent(gfx);\n\n                // display backing image\n                gfx.drawImage(image, 0, 0, null);\n\n                // and render all undoable modification\n                for (ImageModification action: undoable) {\n                    action.draw(gfx, image.getWidth(), image.getHeight());\n                }\n            }\n\n            @Override\n            public Dimension getPreferredSize() {\n                return new Dimension(image.getWidth(), image.getHeight());\n            }\n        };\n\n        // create buttons for drawing new stuff, undoing and redoing it\n        JButton drawButton = new JButton(\"Draw\");\n        JButton undoButton = new JButton(\"Undo\");\n        JButton redoButton = new JButton(\"Redo\");\n\n        drawButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                // maximum number of undo's reached?\n                if (undoable.size() == MAX_UNDO_COUNT) {\n                    // remove oldest undoable action and apply it to backing image\n                    ImageModification first = undoable.removeFirst();\n\n                    Graphics imageGfx = image.getGraphics();\n                    first.draw(imageGfx, image.getWidth(), image.getHeight());\n                    imageGfx.dispose();\n                }\n\n                // add new modification\n                undoable.addLast(new ExampleRandomModification());\n\n                // we shouldn't \"redo\" the undone actions\n                undone.clear();\n\n                drawPanel.repaint();\n            }\n        });\n\n        undoButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                if (!undoable.isEmpty()) {\n                    // remove last drawn modification, and append it to undone list\n                    ImageModification lastDrawn = undoable.removeLast();\n                    undone.addLast(lastDrawn);\n\n                    drawPanel.repaint();\n                }\n            }\n        });\n\n        redoButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                if (!undone.isEmpty()) {\n                    // remove last undone modification, and append it to drawn list again\n                    ImageModification lastUndone = undone.removeLast();\n                    undoable.addLast(lastUndone);\n\n                    drawPanel.repaint();\n                }\n            }\n        });\n\n        JPanel buttonPanel = new JPanel(new FlowLayout());\n        buttonPanel.add(drawButton);\n        buttonPanel.add(undoButton);\n        buttonPanel.add(redoButton);\n\n        // create frame, add all content, and open it\n        JFrame frame = new JFrame(\"Undoable Draw Demo\");\n        frame.getContentPane().add(drawPanel);\n        frame.getContentPane().add(buttonPanel, BorderLayout.NORTH);\n        frame.pack();\n        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        frame.setLocationRelativeTo(null);\n        frame.setVisible(true);\n    }\n\n    //--- draw actions ---\n\n    // provides the seeds for the random modifications -- not for drawing itself\n    private static final Random SEEDS = new Random();\n\n    // interface for draw modifications\n    private interface ImageModification\n    {\n        void draw(Graphics gfx, int width, int height);\n    }\n\n    // example random modification, draws bunch of random lines in random color\n    private static class ExampleRandomModification implements ImageModification\n    {\n        private final long seed;\n\n        public ExampleRandomModification() {\n            // create some random seed for this modification\n            this.seed = SEEDS.nextLong();\n        }\n\n        @Override\n        public void draw(Graphics gfx, int width, int height) {\n            // create a new pseudo-random number generator with our seed...\n            Random random = new Random(seed);\n\n            // so that the random numbers generated are the same each time.\n            gfx.setColor(new Color(\n                    random.nextInt(256), random.nextInt(256), random.nextInt(256)));\n\n            for (int i = 0; i &lt; 16; i++) {\n                gfx.drawLine(\n                        random.nextInt(width), random.nextInt(height),\n                        random.nextInt(width), random.nextInt(height));\n            }\n        }\n    }\n}\n</code></pre>\n", "title": "Is storing Graphics objects a good idea?", "tags": ["java", "memory-management", "graphics", "awt", "bufferedimage"], "link": "http://stackoverflow.com/questions/31370403/is-storing-graphics-objects-a-good-idea/31466466#31466466", "post_type": "answer", "question_id": 31370403, "answer_id": 31466466}, {"body": "<p>I first tought your question was a dupe of <a href=\"http://stackoverflow.com/questions/408661/what-code-does-the-compiler-generate-for-autoboxing\">What code does the compiler generate for autoboxing?</a></p>\n\n<p>However, after your comment on @ElliottFrisch I realized it was different :</p>\n\n<blockquote>\n  <p>I know the compiler behaves that way. I'm trying to figure out whether\n  that behavior is guaranteed.</p>\n</blockquote>\n\n<p>For other readers, assume that \"behaves that way\" means using <code>valueOf</code>.</p>\n\n<p>Remember that there are multiples compilers for Java. To be \"legal\" they must follow the contract given in the <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.7\">JLS</a>. Therefore, as long as all the rules here are respected, there is no guarantee of how autoboxing is internally implemented.</p>\n\n<p>But I don't see any reason to not use <code>valueOf</code>, specially that it uses the cached values and is the recommended way as per <a href=\"https://blogs.oracle.com/darcy/entry/boxing_and_caches_integer_valueof\">this article</a> by Joseph D. Darcy.</p>\n", "title": "Does autoboxing call valueOf()?", "tags": ["java", "boxing", "autoboxing"], "link": "http://stackoverflow.com/questions/31445024/does-autoboxing-call-valueof/31445150#31445150", "post_type": "answer", "question_id": 31445024, "answer_id": 31445150}, {"body": "<p>Until the language specification mentions it, it is not guaranteed that autoboxing is equivalent to a call to the static <code>valueOf</code> methods. It is an <em>implementation</em> aspect, not part of the boxing conversion specification. An implementation is theoretically free to use another mechanism as long as it conforms to the rule you mentioned from the JLS.</p>\n\n<p>In practice, there are many Sun JDK bug reports (e.g. <a href=\"https://bugs.openjdk.java.net/browse/JDK-4990346\">JDK-4990346</a> and <a href=\"https://bugs.openjdk.java.net/browse/JDK-6628737\">JDK-6628737</a>) that clearly imply that when autoboxing was introduced in Java 5, the intention was having the compiler to rely on <code>valueOf</code> as stated in <a href=\"https://bugs.openjdk.java.net/browse/JDK-6628737\">JDK-6628737</a>:</p>\n\n<blockquote>\n  <p>The static factory methods Integer.valueOf(int), Long.valueOf(long), etc. were introduced in JDK 5 for javac to implement the caching behavior required by the autoboxing specification.</p>\n</blockquote>\n\n<p>But that's only for javac, not necessarily all compilers.</p>\n", "title": "Does autoboxing call valueOf()?", "tags": ["java", "boxing", "autoboxing"], "link": "http://stackoverflow.com/questions/31445024/does-autoboxing-call-valueof/31760309#31760309", "post_type": "answer", "question_id": 31445024, "answer_id": 31760309}, {"body": "<p>Autoboxing <strong>is</strong> absolutely implemented using <code>valueOf()</code> ...in the OpenJDK. If that's your implementation, read on... if not, skip to below.</p>\n\n<pre><code>((Boolean)true) == Boolean.TRUE\n((Boolean)true) == Boolean.valueOf(true)\n</code></pre>\n\n<p>Java documentation states that <code>Boolean.valueOf()</code> always returns <code>Boolean.TRUE</code> or <code>Boolean.FALSE</code>, therefore your reference comparisons in these cases will succeed.</p>\n\n<pre><code>((Integer)1) == Integer.valueOf(1)\n</code></pre>\n\n<p>For this particular example, under the OpenJDK implementation with default settings, it will <em>probably</em> work by virtue of the fact that you picked a value &lt; 128 which is cached at startup (although this can be overridden as a commandline arg). It <em>may</em> also work for larger values if it's frequently used enough to be cached. Unless you're working under \"safe\" assumptions about the Integer cache, don't expect the reference comparison to be an equality.</p>\n\n<p><code>Long</code>, <code>Short</code>, <code>Character</code> and <code>Byte</code> incidentally implement this caching too, but unlike <code>Integer</code>, it's not tunable. <code>Byte</code> will always work if you're comparing autobox/<code>valueOf()</code> references since obviously, you can't go out of range. <code>Float</code> and <code>Double</code> will unsurprisingly always create a new instance.</p>\n\n<hr>\n\n<p>Now, in purely generic terms? <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.7\" rel=\"nofollow\">See this section of the JLS</a> - you <strong>MUST</strong> be given equal references for <code>boolean</code> and any <code>int</code> or <code>char</code> within the -128 to 127 range. There are <strong>no guarantees</strong> for anything else.</p>\n", "title": "Does autoboxing call valueOf()?", "tags": ["java", "boxing", "autoboxing"], "link": "http://stackoverflow.com/questions/31445024/does-autoboxing-call-valueof/31871515#31871515", "post_type": "answer", "question_id": 31445024, "answer_id": 31871515}]}