{"items": [{"body": "<p>I am using <code>Scanner</code> methods <code>nextInt()</code> and <code>nextLine()</code> for reading input. Basically, it looks like this:</p>\n\n<pre><code>System.out.println(\"enter numerical value\");    \nint option;\noption = input.nextInt();//read numerical value from input\nSystem.out.println(\"enter 1st string\"); \nString string1 = input.nextLine();//read 1st string (this is skipped)\nSystem.out.println(\"enter 2nd string\");\nString string2 = input.nextLine();//read 2nd string (this appears right after reading numerical value)\n</code></pre>\n\n<p>The problem is that after entering the numerical value, the first <code>input.nextLine()</code> is skipped and the second <code>input.nextLine()</code> is executed, so that my output looks like this:</p>\n\n<pre><code>Enter numerical value\n3//this is my input\nenter 1st string//the program is supposed to stop here and wait for my input, but is skipped\nenter 2nd string//and this line is executed and waits for my input\n</code></pre>\n\n<p>I tested my application and it looks like the problem lies in using <code>input.nextInt()</code>. If I delete it, then both <code>string1 = input.nextLine()</code> and <code>string2 = input.nextLine()</code> are executed as I want them to be.</p>\n", "title": "Scanner is skipping nextLine() after using next(), nextInt() or other nextFoo() methods", "tags": ["java", "java.util.scanner"], "link": "http://stackoverflow.com/questions/13102045/scanner-is-skipping-nextline-after-using-next-nextint-or-other-nextfoo", "post_type": "question", "question_id": 13102045}, {"body": "<p>I'm trying to understand what makes the lock in concurrency so important if one can use <code>synchronized (this)</code>. In the dummy code below, I can do either:</p>\n\n<ol>\n<li>synchronized the entire method or synchronize the vulnerable area (synchronized(this){...})</li>\n<li>OR lock the vulnerable code area with a ReentrantLock .</li>\n</ol>\n\n<p>Code:</p>\n\n<pre><code>private final ReentrantLock lock =  new ReentrantLock(); \n    private static List&lt;Integer&gt; ints;\n\n    public Integer getResult(String name) { \n        .\n        .\n        .\n        lock.lock();\n        try{\n            if (ints.size()==3) {\n                ints=null;\n                return -9;\n            }   \n\n            for (int x=0; x&lt;ints.size(); x++) {\n                System.out.println(\"[\"+name+\"] \"+x+\"/\"+ints.size()+\". values &gt;&gt;&gt;&gt;\"+ints.get(x));\n            }\n\n        }finally {\n            lock.unlock();\n        } \n        return random;\n}\n</code></pre>\n", "title": "Why use a ReentrantLock if one can use synchronized(this)?", "tags": ["java", "multithreading", "concurrency", "synchronize", "reentrantlock"], "link": "http://stackoverflow.com/questions/11821801/why-use-a-reentrantlock-if-one-can-use-synchronizedthis", "post_type": "question", "question_id": 11821801}, {"body": "<p>For the first time in my life I find myself in a position where I'm writing a Java API that will be open sourced. Hopefully to be included in many other projects.</p>\n\n<p>For logging I (and indeed the people I work with) have always used JUL (java.util.logging) and never had any issues with it. However now I need to understand in more detail what I should do for my API development. I've done some research on this and with the information I've got I just get more confused. Hence this post.</p>\n\n<p>Since I come from JUL I'm biased on that. My knowledge of the rest is not that big.</p>\n\n<p>From the research I've done I've come up with these reasons why people do not like JUL:</p>\n\n<ol>\n<li><p><em>\"I started developing in Java long before Sun released JUL and it was just easier for me to continue with logging-framework-X rather than to learn something new\"</em>. Hmm. I'm not kidding, this is actually what people say. With this argument we could all be doing COBOL. (however I can certainly relate to this being a lazy dude myself)</p></li>\n<li><p><em>\"I don't like the names of the logging levels in JUL\"</em>. Ok, seriously, this is just not enough of a reason to introduce a new dependency.</p></li>\n<li><p><em>\"I don't like the standard format of the output from JUL\"</em>. Hmm. This is just configuration. You do not even have to do anything code-wise. (true, back in old days you may have had to create your own Formatter class to get it right).</p></li>\n<li><p><em>\"I use other libraries that also use logging-framework-X so I thought it easier just to use that one\"</em>. This is a cyclic argument, isn't ? Why does 'everybody' use logging-framework-X and not JUL?</p></li>\n<li><p><em>\"Everybody else is using logging-framework-X\"</em>. This to me is just a special case of the above. Majority is not always right.</p></li>\n</ol>\n\n<p>So the real big question is <strong>why not JUL?</strong>. What is it I have missed ? The raison d'\u00eatre for logging facades (SLF4J, JCL) is that multiple logging implementations have existed historically and the reason for that really goes back to the era before JUL as I see it. If JUL was perfect then logging facades wouldn't exist, or what? Rather than embracing them shouldn't we question why they were necessary in the first place? (and see if those reasons still exist)</p>\n\n<p>Ok, my research so far has led to a couple of things that I can see may be <strong>real issues</strong> with JUL:</p>\n\n<ol>\n<li><p><strong>Performance</strong>. Some say that performance in SLF4J is superior to the rest. This seems to me to be a case of premature optimization. If you need to log hundreds of megabytes per second then I'm not sure you are on the right path anyway. JUL has also evolved and the tests you did on Java 1.4 may no longer be true. You can read about it <a href=\"http://jeremymanson.blogspot.dk/2009/04/faster-logging-with-faster-logger.html\">here</a> and this fix has made it into Java 7. Many also talk about the overhead of string concatenation in logging methods. However template based logging avoids this cost and it exist also in JUL. Personally I never really write template based logging. Too lazy for that. For example if I do this with JUL:</p>\n\n<pre><code>log.finest(\"Lookup request from username=\" + username \n   + \", valueX=\" + valueX\n   + \", valueY=\" + valueY));\n</code></pre>\n\n<p>my IDE will warn me and ask permission that it should change it to:</p>\n\n<pre><code>log.log(Level.FINEST, \"Lookup request from username={0}, valueX={1}, valueY={2}\", \n   new Object[]{username, valueX, valueY});\n</code></pre>\n\n<p>.. which I will of course accept. Permission granted ! Thank you for your help.</p>\n\n<p>So I don't actually write such statements myself, that is done by the IDE.</p>\n\n<p>In conclusion on the issue of performance I haven't found anything that would suggest that JUL's performance is not ok compared to the competition.</p></li>\n<li><p><strong>Configuration from classpath</strong>. Out-of-the-box JUL cannot load a configuration file from the classpath. It is a <a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4958543\">few lines of code</a> to make it do so. I can see why this may be annoying but the solution is short and simple.</p></li>\n<li><p><strong>Availability of output handlers</strong>. JUL comes with 5 output handlers out-of-the-box: console, file stream, socket and memory. These can be extended or new ones can be written. This may for example be writing to UNIX/Linux Syslog and Windows Event Log. I have personally never had this requirement nor have I seen it used but I can certainly relate to why it may be a useful feature. Logback comes with an appender for Syslog for example. Still I would argue that</p>\n\n<ol>\n<li>99.5% of the needs for output destinations are covered by what is in JUL out-of-the-box.</li>\n<li>Special needs could be catered for by custom handlers on top of JUL rather than on top of something else. There's nothing to me that suggests that it takes more time to write a Syslog output handler for JUL than it does for another logging framework.</li>\n</ol></li>\n</ol>\n\n<p>I'm really concerned that there's something I've overlooked. The use of logging facades  and logging implementations other than JUL is so widespread that I have to come to the conclusion that it's me who just doesn't understand. That wouldn't be the first time, I'm afraid. :-)</p>\n\n<p>So what should I do with my API?  I want it to become successful.  I can of course just \"go with the flow\" and implement SLF4J (which seems the most popular these days) but for my own sake I still need to understand exactly what is wrong with the JUL of today that warrants all the fuzz?  Will I sabotage myself by choosing JUL for my library ?</p>\n\n<h2>Testing performance</h2>\n\n<p>(section added by nolan600 on 07-JUL-2012)</p>\n\n<p>There's a reference below from Ceki about SLF4J's parametrization being 10 times or more faster than JUL's. So I've started doing some simple tests. At first glance the claim is certainly correct. Here are the preliminary results (but read on!):</p>\n\n<ul>\n<li>Execution time SLF4J, backend Logback: 1515</li>\n<li>Execution time SLF4J, backend JUL: 12938</li>\n<li>Execution time JUL: 16911</li>\n</ul>\n\n<p>The numbers above are msecs so less is better. So 10 times performance difference is by first actually pretty close. My initial reaction: That is a lot !</p>\n\n<p>Here is the core of the test. As can be seen an integer and a string is construted in a loop which is then used in the log statement:</p>\n\n<pre><code>    for (int i = 0; i &lt; noOfExecutions; i++) {\n        for (char x=32; x&lt;88; x++) {\n            String someString = Character.toString(x);\n            // here we log \n        }\n    }\n</code></pre>\n\n<p>(I wanted the log statement to have both a primitive data type (in this case an int) and a more complex data type (in this case a String). Not sure it matters but there you have it.)</p>\n\n<p>The log statement for SLF4J:</p>\n\n<pre><code>logger.info(\"Logging {} and {} \", i, someString);\n</code></pre>\n\n<p>The log statement for JUL:</p>\n\n<pre><code>logger.log(Level.INFO, \"Logging {0} and {1}\", new Object[]{i, someString});\n</code></pre>\n\n<p>The JVM was 'warmed up' with the same test executed once before the actual measurement was done. Java 1.7.03 was used on Windows 7. Latest versions of SLF4J (v1.6.6) and Logback (v1.0.6) was used. Stdout and stderr was redirected to null device.</p>\n\n<p>However, careful now, it turns out JUL is spending most of its time in <code>getSourceClassName()</code> because JUL by default prints the source class name in the output, while Logback doesn't. So we are comparing apples and oranges. I have to do the test again and configure the logging implementations in a similar manner so that they actually output the same stuff. I do however suspect that SLF4J+Logback will still come out on top but far from the initial numbers as given above. Stay tuned.</p>\n\n<p>Btw: The test was first time I've actually worked with SLF4J or Logback. A pleasant experience. JUL is certainly a lot less welcoming when you are starting out.</p>\n\n<h2>Testing performance (part 2)</h2>\n\n<p>(section added by nolan600 on 08-JUL-2012)</p>\n\n<p>As it turns out it doesn't really matter for performance how you configure your pattern in JUL, i.e. whether or not it includes the source name or not. I tried with a very simple pattern:</p>\n\n<pre><code>java.util.logging.SimpleFormatter.format=\"%4$s: %5$s [%1$tc]%n\"\n</code></pre>\n\n<p>and that did not change the above timings at all. My profiler revealed that the logger still spent a lot of time in calls to <code>getSourceClassName()</code> even if this was not part of my pattern. The pattern doesn't matter.</p>\n\n<p>I'm therefore concluding on the issue of performance that at least for the tested template based log statement there seems to be roughly a factor of 10 in real performance difference between JUL (slow) and SLF4J+Logback (quick). Just like Ceki said.</p>\n\n<p>I can also see another thing namely that SLF4J's <code>getLogger()</code> call is a lot more expensive than JUL's ditto. (95 ms vs 0.3 ms if my profiler is accurate). This makes sense. SLF4J has to do some time on the binding of the underlying logging implementation. This doesn't scare me. These calls should be somewhat rare in the lifetime of an application. The fastness should be in the actual log calls.</p>\n\n<h1>Final conclusion</h1>\n\n<p>(section added by nolan600 on 08-JUL-2012)</p>\n\n<p>Thank you for all your answers. Contrary to what I initially thought I've ended up deciding to use SLF4J for my API. This is based on a number of things and your input:</p>\n\n<ol>\n<li><p>It gives flexibility to choose log implementation at deployment time.</p></li>\n<li><p>Issues with lack of flexibility of JUL's configuration when run inside an application server.</p></li>\n<li><p>SLF4J is certainly a lot faster as detailed above in particular if you couple it with Logback. Even if this was just a rough test I have reason to believe that a lot more effort has gone into optimization on SLF4J+Logback than on JUL.</p></li>\n<li><p>Documentation. The documentation for SLF4J is simply a lot more comprehensive and precise.</p></li>\n<li><p>Pattern flexibility. As I did the tests I set out to have JUL mimic the default pattern from Logback. This pattern includes the name of the thread. It turns out JUL cannot do this out of the box. Ok, I haven't missed it until now, but I don't think it is a thing that should be missing from a log framework. Period! </p></li>\n<li><p>Most (or many) Java projects today use Maven so adding a dependency is not that big a thing especially if that dependency is rather stable, i.e. doesn't constantly change its API. This seems to be true for SLF4J. Also the SLF4J jar and friends are small in size.</p></li>\n</ol>\n\n<p>So the strange thing that happened was that I actually got quite upset with JUL after having worked a bit with SLF4J. I still regret that it has to be this way with JUL. JUL is far from perfect but kind of does the job. Just not quite well enough. The same can be said about <code>Properties</code> as an example but we do not think about abstracting that so people can plug in their own configuration library and what have you. I think the reason is that <code>Properties</code> comes in just above the bar while the opposite is true for JUL of today ... and in the past it came in at zero because it didn't exist.</p>\n", "title": "Why not use java.util.logging?", "tags": ["java", "logging", "slf4j", "logback"], "link": "http://stackoverflow.com/questions/11359187/why-not-use-java-util-logging", "post_type": "question", "question_id": 11359187}, {"body": "<p>I would like to know what is the cleanest and best way to perform form validation of user inputs. I have seen some developers implement <a href=\"http://docs.spring.io/spring-framework/docs/4.2.x/javadoc-api/org/springframework/validation/Validator.html\"><code>org.springframework.validation.Validator</code></a>. A question about that: I saw it validates a class. Does the class have to be filled manually with the values from the user input, and then passed to the validator?</p>\n\n<p>I am confused about the cleanest and best way to validate the user input. I know about the traditional method of using <code>request.getParameter()</code> and then manually checking for <code>nulls</code>, but I don't want to do all the validation in my <code>Controller</code>. Some good advice on this area will be greatly appreciated. I am not using Hibernate in this application.</p>\n", "title": "Spring MVC: How to perform validation?", "tags": ["java", "spring-mvc", "validation", "user-input"], "link": "http://stackoverflow.com/questions/12146298/spring-mvc-how-to-perform-validation", "post_type": "question", "question_id": 12146298}, {"body": "<p>I write jUnit test cases for 3 purposes:</p>\n\n<ol>\n<li>To ensure that my code satisfies all of the required functionality, under all (or most of) the input combinations/values.</li>\n<li>To ensure that I can change the implementation, and rely on JUnit test cases to tell me that all my functionality is still satisfied.</li>\n<li>As a documentation of all the use cases my code handles, and act as a spec for refactoring - should the code ever need to be rewritten. (Refactor the code, and if my jUnit tests fail - you probably missed some use case).</li>\n</ol>\n\n<p>I do not understand why or when <code>Mockito.verify()</code> should be used. When I see <code>verify()</code> being called, it is telling me that my jUnit is becoming aware of the implementation. (Thus changing my implementation would break my jUnits, even though my functionality was unaffected). </p>\n\n<p>I'm looking for:</p>\n\n<ol>\n<li><p>What should be the guidelines for appropriate usage of <code>Mockito.verify()</code>?</p></li>\n<li><p>Is it fundamentally correct for jUnits to be aware of, or tightly coupled to, the implementation of the class under test?</p></li>\n</ol>\n", "title": "When to use Mockito.verify()?", "tags": ["java", "unit-testing", "junit", "mockito"], "link": "http://stackoverflow.com/questions/12539365/when-to-use-mockito-verify", "post_type": "question", "question_id": 12539365}, {"body": "<p>The Java 7 <em>try-with-resources</em> syntax (also known as ARM block (<em>Automatic Resource Management</em>)) is nice, short and straightforward when using only one <code>AutoCloseable</code> resource. However, I am not sure what is the correct idiom when I need to declare multiple resources that are dependent on each other, for example a <code>FileWriter</code> and a <code>BufferedWriter</code> that wraps it. Of course, this question concerns any case when some <code>AutoCloseable</code> resources are wrapped, not only these two specific classes.</p>\n\n<p>I came up with the three following alternatives:</p>\n\n<h2>1)</h2>\n\n<p>The naive idiom I have seen is to declare only the top-level wrapper in the ARM-managed variable:</p>\n\n<pre><code>static void printToFile1(String text, File file) {\n    try (BufferedWriter bw = new BufferedWriter(new FileWriter(file))) {\n        bw.write(text);\n    } catch (IOException ex) {\n        // handle ex\n    }\n}\n</code></pre>\n\n<p>This is nice and short, but it is broken. Because the underlying <code>FileWriter</code> is not declared in a variable, it will never be closed directly in the generated <code>finally</code> block. It will be closed only through the <code>close</code> method of the wrapping <code>BufferedWriter</code>. The problem is, that if an exception is thrown from the <code>bw</code>'s constructor, it's <code>close</code> will not be called and therefore the underlying <code>FileWriter</code> <strong>will not be closed</strong>.</p>\n\n<h2>2)</h2>\n\n<pre><code>static void printToFile2(String text, File file) {\n    try (FileWriter fw = new FileWriter(file);\n            BufferedWriter bw = new BufferedWriter(fw)) {\n        bw.write(text);\n    } catch (IOException ex) {\n        // handle ex\n    }\n}\n</code></pre>\n\n<p>Here, both the underlying and the wrapping resource are declared in the ARM-managed variables, so both of them will be certainly closed, so certainly that the underlying <code>fw.close()</code> <strong>will be called twice</strong>, first directly and for the second time through the wrapping <code>bw.close()</code>.</p>\n\n<p>This should not be a problem for these two specific classes that both implement <code>Closeable</code> (which is a subtype of <code>AutoCloseable</code>), whose contract states that multiple calls to <code>close</code> are permitted:</p>\n\n<blockquote>\n  <p>Closes this stream and releases any system resources associated with it. If the stream is already closed then invoking this method has no effect.</p>\n</blockquote>\n\n<p>However, in a general case, I can have resources that do implement only <code>AutoCloseable</code> (and not <code>Closeable</code>), which doesn't guarantee that the <code>close</code> can be called multiple times:</p>\n\n<blockquote>\n  <p>Note that unlike the close method of java.io.Closeable, this close method is not required to be idempotent. In other words, calling this close method more than once may have some visible side effect, unlike Closeable.close which is required to have no effect if called more than once. However, implementers of this interface are strongly encouraged to make their close methods idempotent.</p>\n</blockquote>\n\n<h2>3)</h2>\n\n<pre><code>static void printToFile3(String text, File file) {\n    try (FileWriter fw = new FileWriter(file)) {\n        BufferedWriter bw = new BufferedWriter(fw);\n        bw.write(text);\n    } catch (IOException ex) {\n        // handle ex\n    }\n}\n</code></pre>\n\n<p>This version should be theoretically correct, because only the <code>fw</code> represents a real resource that needs to be cleaned up. The <code>bw</code> does't itself hold any resource, it only delegates to the <code>fw</code>, so it should be sufficient to only close the underlying <code>fw</code>.</p>\n\n<p>On the other hand, the syntax is a bit irregular and also, Eclipse issues a warning, which I believe is a false alarm, but it is still a warning that one has to deal with:</p>\n\n<blockquote>\n  <p>Resource leak: 'bw' is never closed</p>\n</blockquote>\n\n<hr>\n\n<p>So, which approach to go for? Or have I missed some other idiom that is <em>the correct</em> one?</p>\n", "title": "Correct idiom for managing multiple chained resources in try-with-resources block?", "tags": ["java", "try-with-resources"], "link": "http://stackoverflow.com/questions/12552863/correct-idiom-for-managing-multiple-chained-resources-in-try-with-resources-bloc", "post_type": "question", "question_id": 12552863}, {"body": "<p>If you look in the enum api at the method <code>name()</code> it says that:</p>\n\n<blockquote>\n  <p>Returns the name of this enum constant, exactly as declared in its enum declaration. \n          Most programmers should use the toString method in preference to this one, \n          as the toString method may return a more user-friendly name.\n          This method is designed primarily for use in specialized situations where correctness depends on getting the exact name, which will not vary from release to release.</p>\n</blockquote>\n\n<p>Why is better to use <code>toString()</code>? I mean toString may be overridden when name() is already final. So if you use toString and someone overrides it to return a hard-coded value your whole application is down... Also if you look in the sources the toString() method returns exactly and just the name. It's the same thing.</p>\n", "title": "Java enum - why use toString instead of name", "tags": ["java", "enums"], "link": "http://stackoverflow.com/questions/13291076/java-enum-why-use-tostring-instead-of-name", "post_type": "question", "question_id": 13291076}, {"body": "<p>The interviewer asked me:</p>\n\n<blockquote>\n  <p>What is <code>Observer</code> and <code>Observable</code> and when should we use them?</p>\n</blockquote>\n\n<p>I wasn't aware of these terms. So, when I came back to home, then I started looking into Google about <code>Observer</code> and <code>Observable</code> and found some point from different resources :</p>\n\n<blockquote>\n  <p>1) <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Observable.html\"><code>Observable</code></a> is a class and <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Observer.html\"><code>Observer</code></a> is an interface.</p>\n  \n  <p>2) <code>Observable</code> class maintain a list of Observers.</p>\n  \n  <p>3) When an Observable object is updated, it invokes the <code>update()</code> method of each of its Observers to notify that, it is changed.</p>\n</blockquote>\n\n<p>I found this example:</p>\n\n<pre><code>import java.util.Observable;\nimport java.util.Observer;\n\nclass MessageBoard extends Observable {\n  private String message;\n\n  public String getMessage() {\n    return message;\n  }\n\n  public void changeMessage(String message) {\n    this.message = message;\n    setChanged();\n    notifyObservers(message);\n  }\n\n  public static void main(String[] args) {\n    MessageBoard board = new MessageBoard();\n    Student bob = new Student();\n    Student joe = new Student();\n    board.addObserver(bob);\n    board.addObserver(joe);\n    board.changeMessage(\"More Homework!\");\n  }\n}\n\nclass Student implements Observer {\n  public void update(Observable o, Object arg) {\n    System.out.println(\"Message board changed: \" + arg);\n  }\n}\n</code></pre>\n\n<p>But I'm still unable to figure out why do we need <code>Observer</code> and <code>Observable</code>? What are the <code>setChanged()</code> and <code>notifyObservers(message)</code> methods for?</p>\n", "title": "When should we use Observer and Observable", "tags": ["java", "observer-pattern", "observable", "observers"], "link": "http://stackoverflow.com/questions/13744450/when-should-we-use-observer-and-observable", "post_type": "question", "question_id": 13744450}, {"body": "<p>I'm trying to add header for my request using <code>HttpUrlConnection</code> but the method <code>setRequestProperty()</code> doesn't seem working. The server side doesn't receive any request with my header. Can anyone help me? Thanks in advance.</p>\n\n<pre><code>HttpURLConnection hc;\n    try {\n        String authorization = \"\";\n        URL address = new URL(url);\n        hc = (HttpURLConnection) address.openConnection();\n\n\n        hc.setDoOutput(true);\n        hc.setDoInput(true);\n        hc.setUseCaches(false);\n\n        if (username != null &amp;&amp; password != null) {\n            authorization = username + \":\" + password;\n        }\n\n        if (authorization != null) {\n            byte[] encodedBytes;\n            encodedBytes = Base64.encode(authorization.getBytes(), 0);\n            authorization = \"Basic \" + encodedBytes;\n            hc.setRequestProperty(\"Authorization\", authorization);\n        }\n</code></pre>\n", "title": "Adding header for HttpURLConnection", "tags": ["java", "http"], "link": "http://stackoverflow.com/questions/12732422/adding-header-for-httpurlconnection", "post_type": "question", "question_id": 12732422}, {"body": "<p>I have this method:</p>\n\n<pre><code>public String getRealPathFromURI(Uri contentUri) {\n    String[] proj = { MediaStore.Images.Media.DATA };\n    Cursor cursor = managedQuery(contentUri, proj, null, null, null);\n    int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);\n    cursor.moveToFirst();\n    return cursor.getString(column_index);\n}\n</code></pre>\n\n<p>Unfortunately the compiler show me a problem on:</p>\n\n<pre><code>Cursor cursor = managedQuery(contentUri, proj, null, null, null);\n</code></pre>\n\n<p>Because <code>managedQuery()</code> is deprecated.</p>\n\n<p>How could I rewrite this method without use <code>managedQuery()</code>?</p>\n", "title": "Deprecated ManagedQuery() issue", "tags": ["java", "android", "deprecated"], "link": "http://stackoverflow.com/questions/12714701/deprecated-managedquery-issue", "post_type": "question", "question_id": 12714701}]}