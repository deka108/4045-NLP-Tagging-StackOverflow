{"items": [{"body": "<p>I have a set \u2013 a HashSet I want to remove some items from it\u2026 none of the items in the \"removals\" collection will be in the original set. </p>\n\n<p>I specify the size of the \"source\" set and the size of the \"removals\" collection on the command line, and build both of them. The source set contains only non-negative integers; the removals set contains only negative integers. \nI measure how long it takes to remove all the elements using System.currentTimeMillis(), which isn\u2019t the world most accurate stopwatch but is more than adequate in this case, as you\u2019ll see. Here\u2019s the code:</p>\n\n<pre><code>import java.util.*;\npublic class Test \n{ \n public static void main(String[] args) \n { \n    int sourceSize = Integer.parseInt(args[0]); \n    int removalsSize = Integer.parseInt(args[1]); \n\n    Set&lt;Integer&gt; source = new HashSet&lt;Integer&gt;(); \n    Collection&lt;Integer&gt; removals = new ArrayList&lt;Integer&gt;(); \n\n    for (int i = 0; i &lt; sourceSize; i++) \n    { \n        source.add(i); \n    } \n    for (int i = 1; i &lt;= removalsSize; i++) \n    { \n        removals.add(-i); \n    } \n\n    long start = System.currentTimeMillis(); \n    source.removeAll(removals); \n    long end = System.currentTimeMillis(); \n    System.out.println(\"Time taken: \" + (end \u2013 start) + \"ms\"); \n} \n }\n</code></pre>\n\n<p>Let\u2019s start off by giving it an easy job: <strong>a source set of 100 items, and 100 to remove:</strong></p>\n\n<pre><code> c:UsersJonTest&gt;java Test 100 100\n Time taken: 1ms\n</code></pre>\n\n<p>Okay, That's fast as I expected. </p>\n\n<p>Next i tried source of one million items and 300,000 items to remove?</p>\n\n<pre><code>c:UsersJonTest&gt;java Test 1000000 300000\nTime taken: 38ms\n</code></pre>\n\n<p>That still seems pretty speedy.\n  Now make it a bit easier \u2013 300,000 source items and 300,000 removals:</p>\n\n<pre><code>c:UsersJonTest&gt;java Test 300000 300000\nTime taken: 178131ms\n</code></pre>\n\n<p><strong>Nearly three minutes?</strong> </p>\n\n<p>Really confused !! can some one explain why this is happening.</p>\n", "title": "HashSet removeAll method is surprisingly slow", "tags": ["java", "performance", "hashset"], "link": "http://stackoverflow.com/questions/28671903/hashset-removeall-method-is-surprisingly-slow", "post_type": "question", "question_id": 28671903}, {"body": "<p>I have a first list : <code>myListToParse</code> where i want to filter the elements and apply a method on each elements and add the result in another list : <code>myFinalList</code> </p>\n\n<p>With Java 8 I noticed that I can do it in 2 different way, I would like to know the more efficient way between them and understand why one way is better than the other one. </p>\n\n<p>I'm open for any suggestion about a third way.</p>\n\n<p>Method 1:</p>\n\n<pre><code>myListToParse.stream()\n        .filter(elt -&gt; elt != null)\n        .forEach(elt -&gt; myFinalList.add(doSomething(elt)));\n</code></pre>\n\n<p>Method 2:</p>\n\n<pre><code>myFinalList = myListToParse.stream()\n        .filter(elt -&gt; elt != null)\n        .map(elt -&gt; doSomething(elt))\n        .collect(Collectors.toList()); \n</code></pre>\n", "title": "Java 8 - Best way to transform a list: map or foreach?", "tags": ["java", "java-8"], "link": "http://stackoverflow.com/questions/28319064/java-8-best-way-to-transform-a-list-map-or-foreach", "post_type": "question", "question_id": 28319064}, {"body": "<p>Are enum names interned in Java?</p>\n\n<p>I.e. is it guaranteed that <code>enum1.name() == enum2.name()</code> in case of the same name? And is it safe to compare <code>enum.name()</code> to a String that is guaranteed to be interned.</p>\n", "title": "Are enum names interned in Java?", "tags": ["java", "enums"], "link": "http://stackoverflow.com/questions/27908213/are-enum-names-interned-in-java", "post_type": "question", "question_id": 27908213}, {"body": "<p>I'm looking at a piece of Java code right now, and it takes a path as a String and gets its URL using <code>URL resource = ClassLoader.getSystemClassLoader().getResource(pathAsString);</code>, then calls <code>String path = resource.getPath()</code> and finally executes <code>new File(path);</code>. </p>\n\n<p>Oh, and there are also calls to <code>URL url = resource.toURI();</code> and <code>String file = resource.getFile()</code>.</p>\n\n<p>I'm totally confused right now - mostly because of the terminology, I guess. Can someone please walk me through the differences, or provide a few links to Dummy-proof material? Especially URI to URL and <em>Resource to File</em>? To me, it feels like they should be the same thing, respectively...</p>\n\n<p>The difference between <strong><code>getFile()</code></strong> and <strong><code>getPath()</code></strong> is explained here: <a href=\"http://stackoverflow.com/a/11928221/2018047\">What's the difference between url.getFile() and getpath()?</a> (Interestingly they both seem to return Strings, which probably adds a whole lot to my state of mind...)</p>\n\n<p>Now, if I have a locator that references a class or package in a jar file, will those two (i.e. path an file strings) differ?</p>\n\n<p><code>resource.toString()</code> would give you <code>jar:file:/C:/path/to/my.jar!/com/example/</code>, after all (note the exclamation mark).</p>\n\n<p>Is the difference between <strong>URI</strong> and <strong>URL</strong> <em>in Java</em> that the former doesn't encode spaces? Cf. <a href=\"http://stackoverflow.com/a/6818370/2018047\">Files, URIs, and URLs conflicting in Java</a> (This answer explains the <em>general, conceptual</em> difference between the two terms fairly well: <a href=\"http://stackoverflow.com/questions/176264/whats-the-difference-between-a-uri-and-a-url/1984225#1984225\">URIs identify and URLs locate;</a>)</p>\n\n<p>Lastly - and most importantly - <strong>why do I need <code>File</code> object; why isn't a Resource (<code>URL</code>) enough?</strong> (And is there a Resource object?)</p>\n\n<p>Sorry if this question is a bit unorganized; it just reflects the confusion I have... :)</p>\n", "title": "What&#39;s the difference between a Resource, URI, URL, Path and File in Java?", "tags": ["java", "url", "terminology"], "link": "http://stackoverflow.com/questions/27845223/whats-the-difference-between-a-resource-uri-url-path-and-file-in-java", "post_type": "question", "question_id": 27845223}, {"body": "<p>Some time ago, <a href=\"http://blog.jooq.org/2014/02/28/java-8-friday-goodies-easy-as-pie-local-caching\">I've blogged about a Java 8 functional way of calculating fibonacci numbers recursively</a>, with a <code>ConcurrentHashMap</code> cache and the new, useful <code>computeIfAbsent()</code> method:</p>\n\n<pre><code>import java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class Test {\n    static Map&lt;Integer, Integer&gt; cache = new ConcurrentHashMap&lt;&gt;();\n\n    public static void main(String[] args) {\n        System.out.println(\n            \"f(\" + 8 + \") = \" + fibonacci(8));\n    }\n\n    static int fibonacci(int i) {\n        if (i == 0)\n            return i;\n\n        if (i == 1)\n            return 1;\n\n        return cache.computeIfAbsent(i, (key) -&gt; {\n            System.out.println(\n                \"Slow calculation of \" + key);\n\n            return fibonacci(i - 2) + fibonacci(i - 1);\n        });\n    }\n}\n</code></pre>\n\n<p>I chose <code>ConcurrentHashMap</code> because I was thinking of making this example even more sophisticated by introducing parallelism (which I didn't in the end).</p>\n\n<p>Now, let's increase the number from <code>8</code> to <code>25</code> and observe what happens:</p>\n\n<pre><code>        System.out.println(\n            \"f(\" + 25 + \") = \" + fibonacci(25));\n</code></pre>\n\n<p>The program never halts. Inside the method, there's a loop that just runs forever:</p>\n\n<pre><code>for (Node&lt;K,V&gt;[] tab = table;;) {\n    // ...\n}\n</code></pre>\n\n<p>I'm using:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>C:\\Users\\Lukas&gt;java -version\njava version \"1.8.0_40-ea\"\nJava(TM) SE Runtime Environment (build 1.8.0_40-ea-b23)\nJava HotSpot(TM) 64-Bit Server VM (build 25.40-b25, mixed mode)\n</code></pre>\n\n<p><a href=\"http://blog.jooq.org/2014/02/28/java-8-friday-goodies-easy-as-pie-local-caching/#comment-121821\">Matthias, a reader of that blog post also confirmed the issue (he actually found it)</a>.</p>\n\n<p>This is weird. I would have expected any of the following two:</p>\n\n<ul>\n<li>It works</li>\n<li>It throws a <code>ConcurrentModificationException</code></li>\n</ul>\n\n<p>But just never halting? That seems dangerous. Is it a bug? Or did I misunderstand some contract?</p>\n", "title": "Recursive ConcurrentHashMap.computeIfAbsent() call never terminates. Bug or &quot;feature&quot;?", "tags": ["java", "recursion", "java-8", "concurrenthashmap"], "link": "http://stackoverflow.com/questions/28840047/recursive-concurrenthashmap-computeifabsent-call-never-terminates-bug-or-fea", "post_type": "question", "question_id": 28840047}, {"body": "<p>Running the following stream example in Java8:</p>\n\n<pre><code>    System.out.println(Stream\n        .of(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")\n        .reduce(\"\", (s1, s2) -&gt; s1 + \"/\" + s2)\n    );\n</code></pre>\n\n<p>yields:</p>\n\n<pre><code>/a/b/c/d/e/f\n</code></pre>\n\n<p>Which is - of course - no surprise.\nDue to <a href=\"http://docs.oracle.com/javase/8/docs/api/index.html?overview-summary.html\">http://docs.oracle.com/javase/8/docs/api/index.html?overview-summary.html</a> it shouldn't matter whether the stream is executed sequentially or parallel: </p>\n\n<blockquote>\n  <p>Except for operations identified as explicitly nondeterministic, such as findAny(), whether a stream executes sequentially or in parallel should not change the result of the computation. </p>\n</blockquote>\n\n<p>AFAIK <code>reduce()</code> is deterministic and <code>(s1, s2) -&gt; s1 + \"/\" + s2</code> is associative, so that adding <code>parallel()</code> should yield the same result:</p>\n\n<pre><code>    System.out.println(Stream\n            .of(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")\n            .parallel()\n            .reduce(\"\", (s1, s2) -&gt; s1 + \"/\" + s2)\n    );\n</code></pre>\n\n<p>However the result on my machine is:</p>\n\n<pre><code>/a//b//c//d//e//f\n</code></pre>\n\n<p>What's wrong here?</p>\n\n<p>BTW: using (the preferred) <code>.collect(Collectors.joining(\"/\"))</code> instead of <code>reduce(...)</code> yields the same result <code>a/b/c/d/e/f</code> for sequential and parallel execution.</p>\n\n<p>JVM details:</p>\n\n<pre><code>java.specification.version: 1.8\njava.version: 1.8.0_31\njava.vm.version: 25.31-b07\njava.runtime.version: 1.8.0_31-b13\n</code></pre>\n", "title": "Java8 streams sequential and parallel execution produce different results?", "tags": ["java", "lambda", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/28724850/java8-streams-sequential-and-parallel-execution-produce-different-results", "post_type": "question", "question_id": 28724850}, {"body": "<pre><code>import java.math.BigDecimal;\nimport java.math.RoundingMode;\n\npublic class BigDecimalTest {\n\n  public static void main (String[] args) {\n\n    // 4.88...e+888 (1817 digits)\n    BigDecimal x = new BigDecimal(\"4.8832420563130171734733855852454330503023811919919497272520875234748556667894678622576481754268427107559208829679871295885797242917923401597269406065677191699322289667695163278484184288979073748578074654323955355081326227413484377691676742424283166095829482224974429868654315166151274143385980609237680132582337344627820946638217515894542788180511625488217105374918015830882194114839900966043221545533114607439892553114356192220778082796185122942407317178325055570254731781136589172583464356709469398354084238614163644229733602505332671951571644165960364672255033809137641462904872690406789293887232669588297154237004709334039097468524122773548736567569610163195984254280720739773383424940292419418795538600322135358425131164741597944425501875163782825762694824406500718290697914964822219714335320528259344719705157913218736206355811213275685167080292570345461898557739737178480700932922510537942188898832900701474604169230215866582286672118698263686941093382945779882215421032414999405126831495224267159359035083987132591639397950272617333366716471522059176764287433877865132652162238979110053714139119937420203828830308427979430335027147927304099711225033972679405835031675622271744826476172494554124259735452592820489036311645033355738586053207859638698142614469753279404304130088308403735928520706825401977138623732336487326694527108332032932321484204820451539099031068139840323111890984119271864483907126875945501867099986131423579718697889448836497435592993168391953327829695391643033262276364164246663414855044991442223872210174626308430613254236633497864858897399515832571171741522071020097519091890029843359547212185712419638040776450730043492270253991396124987467648536016180816769990203447616590740625203442076233929983869509074724986395815800482885710533831896927860285993286232937744729344906236207008084e+888\");\n    BigDecimal y = new BigDecimal(\"7.11510949782866099699296193137700951609335763543887012748548458182417747578081585833524887774072570691956766860384875364912060891737185872746005419263400444156198098581226885923291670353816772414798224148927688218647602446762953730527741703572368727049379249227044080281137229152770971832240631944592537904743732558993126e+302\");\n    BigDecimal z = x.divide(y, 0, RoundingMode.HALF_UP);\n\n    System.out.println(\"x: \" + x.toString());\n    System.out.println();\n    System.out.println(\"y: \" + y.toString());\n    System.out.println();\n    System.out.println(\"z: \" + z.toString());\n  }\n}\n</code></pre>\n\n<p>Compile</p>\n\n<pre><code>&gt;javac BigDecimalTest.java\n</code></pre>\n\n<p>Execute</p>\n\n<pre><code> &gt;java BigDecimalTest\n</code></pre>\n\n<p>Output</p>\n\n<pre><code>x: 625054983208066198204593354911415430438704792574969565088267203004781525349051886368978966454635866976757873019902352587338204709349419540445048397640668053751325307746498089964597558898932143981799355575346628545040975710892600034453462303030824526026617372479672702318775234126736309035340551798242305697053918011236108116969184203450147688710548806249178948798950602635292084669950732365353235782823866975230624679863759260425959459791169573662813659882560711299260566798548341409068343765881208298932278254261294646140590112068258200980117045324292667804864432756961810725182370437206902961756578170730203574233660279475700447597108771501423828064891010088908598454793225469099307839235742968560582894084123332587841678908692453688646424002096420169762493752403209194120933311549724412343492102761719612412226021289199823441354383529928770138627744900421912301539068635884552971941408134.8856600179050611289788749333661467630922532694031193377751928459953017059824923573892149119923856234431388706196397956490750352971729842937634895018670939708354823574625828791536366736979476766589326086875409807351989786090090279478781367082883474934694924763036804348502963946884054479650783337788950079302927905246137931881022596647890564269534539014810606033753362254652128419763750928651303475678198850650473651453073743837739070377816899469866500215337149978217017797004675976721899561358322045967266798653940112240121024238988798224822218203993329849451071671755903125554170025962201010130308257571374613023572917101445758904604655642902352167479118496542289087726701938867138026569109982914825090572482443761923819950022043159771189713669219385693445567010592510898703998395859012610071144546558746041294923614800026040585757943037935297161564798258664422461809370948330482806766116607140637816031325356147998234497034752\n\ny: 711510949782866099699296193137700951609335763543887012748548458182417747578081585833524887774072570691956766860384875364912060891737185872746005419263400444156198098581226885923291670353816772414798224148927688218647602446762953730527741703572368727049379249227044080281137229152770971832240631944592537.904743732558993126\n\nz: 6863200148645991450016700150728475158275817266239021182863526677885700921863906334312309256001619020949572592642200844420107346867400206096485382274175041601107978676753014927820457112641389679172479926134263590581506384223135957016211147412682886175625161361918270282067511320630977561140325469899962049739132122854543111824994613211802165652292305592183629295330885779837415870933600699791946039851356918600890315497940083093271504897016557099915008808164166772999720870505507779642391694002178573568389923682384862328430119487673749084566046514914589822168578412569408216619911686172\n</code></pre>\n\n<p>The value of <code>z.toString()</code> in the output is correct</p>\n\n<pre><code>4.883242e+888 / 7.115109e+302 = 6.863200e+585\n</code></pre>\n\n<p>as is the value of <code>y.toString()</code>, but notice that the value given for <code>x.toString()</code> is completely wrong.</p>\n\n<p>Why is this?</p>\n\n<p>Strangely, if the scale (i.e. desired decimal places) of the result of the division is changed </p>\n\n<pre><code>BigDecimal z = x.divide(y, 3, RoundingMode.HALF_UP);\n</code></pre>\n\n<p>then <code>x.toString()</code> will produce the correct value for <code>x</code>.</p>\n\n<p>Or, if the operands are swapped</p>\n\n<pre><code>BigDecimal z = y.divide(x, 0, RoundingMode.HALF_UP);\n</code></pre>\n\n<p>then <code>x.toString()</code> will also then produce the correct value.</p>\n\n<p>Or, if the exponent of <code>x</code> is changed from <code>e+888</code> to e.g. <code>e+878</code> then  <code>x.toString()</code> will be correct.</p>\n\n<p>Or, if another <code>x.toString()</code> call is added above the <code>divide</code> operation, then <em>both</em> <code>x.toString()</code> calls will produce the correct value!</p>\n\n<p>On the machine I'm testing this, Windows 7 64 bit, the behaviour is the same using java 7 and 8, both 32bit and 64 bit versions, but testing online at <a href=\"https://ideone.com/\">https://ideone.com/</a> produces different results for java 7 and java 8. </p>\n\n<p>Using java 7, the value of <code>x</code> is given correctly: <a href=\"http://ideone.com/P1sXQQ\">http://ideone.com/P1sXQQ</a>, but using java 8 its value is incorrect: <a href=\"http://ideone.com/OMAq7a\">http://ideone.com/OMAq7a</a>.</p>\n\n<p>Also, this behaviour is not unique to this particular value of <code>x</code>, as calling <code>toString</code> on other BigDecimals with more than about 1500 digits after passing them as the first operand to a <code>divide</code> operation will also produce incorrect values.</p>\n\n<p>What is the explanation for this? </p>\n\n<p>The <code>divide</code> operation seems to be mutating the value produced by subsequent <code>toString</code> calls on its operands.</p>\n\n<p>Does this happen on your platform?</p>\n\n<p><em>Edit:</em></p>\n\n<p>The issue seems to be with the java 8 runtime only, as the above program compiled with java 7 produces correct output when executed with the java 7 runtime, but incorrect output when executed with the java 8 runtime.</p>\n\n<p><em>Edit:</em></p>\n\n<p>I've tested with the early access <a href=\"https://jdk8.java.net/download.html\">jre1.8.0_60</a> and the bug does not appear, and according to Marco13's answer it was fixed in build 51. The Oracle JDK 8 product binaries are only at update 40 though so it may be some time before the fixed versions are widely used.</p>\n", "title": "Why does toString fail to produce the correct value on an immutable BigDecimal?", "tags": ["java", "bigdecimal"], "link": "http://stackoverflow.com/questions/29328785/why-does-tostring-fail-to-produce-the-correct-value-on-an-immutable-bigdecimal", "post_type": "question", "question_id": 29328785}, {"body": "<p>I have trouble understanding the source code of <code>Arrays.copyOf</code>.</p>\n\n<pre><code>public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) {\n    T[] copy = ((Object)newType == (Object)Object[].class)\n        ? (T[]) new Object[newLength]\n        : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n    System.arraycopy(original, 0, copy, 0,\n                     Math.min(original.length, newLength));\n    return copy;\n}\n</code></pre>\n\n<ol>\n<li><p>what is this line checking?</p>\n\n<pre><code>(Object)newType == (Object)Object[].class\n</code></pre></li>\n<li><p>What are the differences between <code>(T[]) new Object[newLength]</code> and <code>(T[]) Array.newInstance(newType.getComponentType(), newLength)</code>. why <code>Array.newInstance</code> not good enough for both cases?</p></li>\n<li><p>This following line compiles, but crashes at run time (as expected). When should I use this method?</p>\n\n<pre><code>Integer[] nums = Arrays.copyOf(new String[]{\"a\", \"b\"}, 2, Integer[].class) \n</code></pre></li>\n</ol>\n", "title": "Do not understand the source code of Arrays.copyOf", "tags": ["java", "arrays", "generics"], "link": "http://stackoverflow.com/questions/29494800/do-not-understand-the-source-code-of-arrays-copyof", "post_type": "question", "question_id": 29494800}, {"body": "<p>If you use <a href=\"http://www.eclipse.org/collections/\" rel=\"nofollow\">Eclipse Collections</a> (formerly <a href=\"https://github.com/goldmansachs/gs-collections\" rel=\"nofollow\">GS Collections</a>), you can use the <code>collectIf()</code> method.</p>\n\n<pre><code>MutableList&lt;Integer&gt; source =\n    FastList.newListWith(1, null, 2, null, 3, null, 4, null, 5);\n\nMutableList&lt;String&gt; result = source.collectIf(Objects::nonNull, String::valueOf);\n\nAssert.assertEquals(Lists.immutable.with(\"1\", \"2\", \"3\", \"4\", \"5\"), result);\n</code></pre>\n\n<p>It evaluates eagerly and should be a bit faster than using a Stream.</p>\n\n<p><strong>Note:</strong> I am a committer for Eclipse Collections.</p>\n", "title": "Java 8 - Best way to transform a list: map or foreach?", "tags": ["java", "java-8"], "link": "http://stackoverflow.com/questions/28319064/java-8-best-way-to-transform-a-list-map-or-foreach/28355204#28355204", "post_type": "answer", "question_id": 28319064, "answer_id": 28355204}, {"body": "<p>There is a third option - using <code>stream().toArray()</code> - see comments under <a href=\"http://stackoverflow.com/questions/28782165/why-didnt-stream-have-a-tolist-method\">why didn't stream have a toList method</a>. It turns out to be slower than forEach() or collect(), and less expressive. It might be optimised in later JDK builds, so adding it here just in case.</p>\n\n<p>assuming <code>List&lt;String&gt;</code></p>\n\n<pre><code>    myFinalList = Arrays.asList(\n            myListToParse.stream()\n                    .filter(Objects::nonNull)\n                    .map(this::doSomething)\n                    .toArray(String[]::new)\n    );\n</code></pre>\n\n<p>with a micro-micro benchmark, 1M entries, 20% nulls and simple transform in doSomething()</p>\n\n<pre><code>private LongSummaryStatistics benchmark(final String testName, final Runnable methodToTest, int samples) {\n    long[] timing = new long[samples];\n    for (int i = 0; i &lt; samples; i++) {\n        long start = System.currentTimeMillis();\n        methodToTest.run();\n        timing[i] = System.currentTimeMillis() - start;\n    }\n    final LongSummaryStatistics stats = Arrays.stream(timing).summaryStatistics();\n    System.out.println(testName + \": \" + stats);\n    return stats;\n}\n</code></pre>\n\n<p>the results are</p>\n\n<p>parallel:</p>\n\n<pre><code>toArray: LongSummaryStatistics{count=10, sum=3721, min=321, average=372,100000, max=535}\nforEach: LongSummaryStatistics{count=10, sum=3502, min=249, average=350,200000, max=389}\ncollect: LongSummaryStatistics{count=10, sum=3325, min=265, average=332,500000, max=368}\n</code></pre>\n\n<p>sequential:</p>\n\n<pre><code>toArray: LongSummaryStatistics{count=10, sum=5493, min=517, average=549,300000, max=569}\nforEach: LongSummaryStatistics{count=10, sum=5316, min=427, average=531,600000, max=571}\ncollect: LongSummaryStatistics{count=10, sum=5380, min=444, average=538,000000, max=557}\n</code></pre>\n\n<p>parallel without nulls and filter (so the stream is <code>SIZED</code>):\ntoArrays has the best performance in such case, and <code>.forEach()</code> fails with \"indexOutOfBounds\" on the recepient ArrayList, had to replace with <code>.forEachOrdered()</code></p>\n\n<pre><code>toArray: LongSummaryStatistics{count=100, sum=75566, min=707, average=755,660000, max=1107}\nforEach: LongSummaryStatistics{count=100, sum=115802, min=992, average=1158,020000, max=1254}\ncollect: LongSummaryStatistics{count=100, sum=88415, min=732, average=884,150000, max=1014}\n</code></pre>\n", "title": "Java 8 - Best way to transform a list: map or foreach?", "tags": ["java", "java-8"], "link": "http://stackoverflow.com/questions/28319064/java-8-best-way-to-transform-a-list-map-or-foreach/29000802#29000802", "post_type": "answer", "question_id": 28319064, "answer_id": 29000802}, {"body": "<ol>\n<li><p>It is checking if newType is array of Objects or not:</p>\n\n<pre><code>Object[] a1 = new Object[100]; -- array of Objects\n\nString[] a2 = new String[100]; -- array of Strings\n</code></pre></li>\n</ol>\n\n<p>Why to do that? Because new Object[n] is faster than Array.newInstance</p>\n\n<ol start=\"2\">\n<li><p><code>Array.newInstance(Class&lt;?&gt; componentType, int... dimensions)</code> creates an array of types defined by the first argument, eg <code>String.class</code> -> <code>String[]</code>. Note that <code>String[].class.getComponentType()</code> returns <code>String.class</code></p></li>\n<li><p>You cannot use it like that, but it can be like this</p>\n\n<pre><code>Integer[] nums = Arrays.copyOf(new Object[]{1, 2}, 2, Integer[].class);\n</code></pre></li>\n</ol>\n\n<p>in this case it depends only on actual type of elements, eg</p>\n\n<pre><code>  Arrays.copyOf(new Object[]{1L, 2}, 2, Integer[].class);\n</code></pre>\n\n<p>will fail, you cannot write in <code>Integer[]</code> anything but <code>Integer</code></p>\n", "title": "Do not understand the source code of Arrays.copyOf", "tags": ["java", "arrays", "generics"], "link": "http://stackoverflow.com/questions/29494800/do-not-understand-the-source-code-of-arrays-copyof/29495065#29495065", "post_type": "answer", "question_id": 29494800, "answer_id": 29495065}, {"body": "<blockquote>\n  <ol>\n  <li>what is this line checking?</li>\n  </ol>\n</blockquote>\n\n<pre><code>(Object)newType == (Object)Object[].class\n</code></pre>\n\n<p>It is checking whether variable <code>newType</code> holds a reference to an instance of <code>java.lang.Class</code> representing type <code>Object[]</code>.  The casts are unneeded.</p>\n\n<blockquote>\n  <ol start=\"2\">\n  <li>What are the differences between <code>(T[]) new Object[newLength]</code> and <code>(T[]) Array.newInstance(newType.getComponentType(), newLength)</code>. why <code>Array.newInstance</code> not good enough for both cases?</li>\n  </ol>\n</blockquote>\n\n<p>As far as I can tell, <code>Array.newInstance()</code> <em>could</em> be used in both cases, but non-reflective ordinary array construction is likely a bit faster.  Thus, I suppose that <code>Object[]</code> is called out as a special case for performance reasons, but I have no idea whether that case is exercised frequently enough for the optimization to be important.</p>\n\n<blockquote>\n  <ol start=\"3\">\n  <li>This following line compiles, but crashes at run time (as expected). When should I use this method?</li>\n  </ol>\n</blockquote>\n\n<pre><code>Integer[] nums = Arrays.copyOf(new String[]{\"a\", \"b\"}, 2, Integer[].class) \n</code></pre>\n\n<p>You should use it when you need to copy an array to an array with a possibly different (but compatible) element type, especially when the element types are not statically known.  If you know you want the copy to have the same element type as the original, then it's easier to use the original array's <code>clone()</code> method.</p>\n", "title": "Do not understand the source code of Arrays.copyOf", "tags": ["java", "arrays", "generics"], "link": "http://stackoverflow.com/questions/29494800/do-not-understand-the-source-code-of-arrays-copyof/29495113#29495113", "post_type": "answer", "question_id": 29494800, "answer_id": 29495113}, {"body": "<p>First of all, the cast in that line</p>\n\n<pre><code>((Object)newType == (Object)Object[].class)\n</code></pre>\n\n<p>are absobuletly needed. Removing them will result in a compilation error :</p>\n\n<pre><code>incomparable types: Class&lt;CAP#1&gt; and Class&lt;Object[]&gt;\n where CAP#1 is a fresh type-variable:\n  CAP#1 extends T[] from capture of ? extends T[]\n</code></pre>\n\n<p>Now to answer your question <strong><em>What is this line checking ?</em></strong></p>\n\n<p>It simply verify if the given array is of object type, which is part of the answer for your other question <strong><em>Why <code>Array.newInstance</code> not good enough for both cases?</em></strong></p>\n\n<p>In the first case, we already know that the array is of <code>Object</code> type so there is no point in calling the <code>newInstance</code> method to retrieve the correct type, this would only result in performance loss.</p>\n\n<p>As for your final example,</p>\n\n<pre><code>Integer[] nums = Arrays.copyOf(new String[]{\"a\", \"b\"}, 2, Integer[].class) \n</code></pre>\n\n<p>That it does compile, it is true. Because the given arguments to the method are all valids. It will certainly fail at runtime; what would be the expected output of converting \"a\" to <code>Integer</code> type ?</p>\n\n<p>Now, when to use <code>copyOf</code> ? When you already know the both types, and already know that they are valid together. </p>\n\n<p>It main usage is to return a copy but truncated or padded with [null/default values] to the original array.</p>\n", "title": "Do not understand the source code of Arrays.copyOf", "tags": ["java", "arrays", "generics"], "link": "http://stackoverflow.com/questions/29494800/do-not-understand-the-source-code-of-arrays-copyof/29500496#29500496", "post_type": "answer", "question_id": 29494800, "answer_id": 29500496}, {"body": "<blockquote>\n  <p>What is this line checking? <code>(Object)newType == (Object)Object[].class</code></p>\n</blockquote>\n\n<p>It's checking simple equality (likely for the purpose of a micro-optimization, but more on that later).</p>\n\n<p>The unusual casting is necessary because <code>Class&lt;Object[]&gt;</code> (the type of <code>Object[].class</code>) and <code>Class&lt;? extends T[]&gt;</code> are incomparable types. Basically, for an equality comparison with <code>==</code> to compile, one of the sides has to be a subtype or supertype of the other.</p>\n\n<p>I.e. we can't do:</p>\n\n<pre><code>// doesn't compile\n// this expression can never evaluate to true\n(new Integer(0) == new Float(0f))\n</code></pre>\n\n<p>The rules for generic types are a bit more complicated and there are a few cases where a comparison doesn't compile, but it may still evaluate to true.</p>\n\n<p>The reason <code>Class&lt;Object[]&gt;</code> is not a supertype of <code>Class&lt;? extends T[]&gt;</code>, despite <code>Object[]</code> being a supertype of all object array types, is that <a href=\"http://stackoverflow.com/q/2745265/2891664\">Java generics are invariant</a> without the presence of a wildcard.</p>\n\n<p>Another way to do the comparison would be:</p>\n\n<pre><code>(newType == (Class&lt;? extends Object[]&gt;)Object[].class)\n</code></pre>\n\n<blockquote>\n  <p>What are the differences between <code>(T[]) new Object[newLength]</code> and <code>(T[]) Array.newInstance(newType.getComponentType(), newLength)</code>?</p>\n</blockquote>\n\n<ul>\n<li><code>new Object[...]</code> creates an array the normal way, of a type that is statically known. Remember, the code has just checked that <code>T[]</code> is <code>Object[]</code>.</li>\n<li><code>Array.newInstance(...)</code> uses reflection to dynamically create an array of the <code>Class</code> type passed in.</li>\n</ul>\n\n<blockquote>\n  <p>Why <code>Array.newInstance</code> not good enough for both cases?</p>\n</blockquote>\n\n<p>An operation using reflection is <a href=\"http://stackoverflow.com/q/435553/2891664\">generally slower</a> than its non-reflective counterpart.</p>\n\n<p>The <a href=\"https://docs.oracle.com/javase/tutorial/reflect/\">reflection tutorial</a> says:</p>\n\n<blockquote>\n  <p>Because reflection involves types that are dynamically resolved, certain Java virtual machine optimizations can not be performed. Consequently, reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications.</p>\n</blockquote>\n\n<p>Java SE is filled with micro-optimization like this. The writers of SE try to squeeze everything they can out of it.</p>\n\n<p>But I wouldn't be worried about a performance hit in this case: <a href=\"http://hg.openjdk.java.net/jdk7u/jdk7u/hotspot/file/6e9aa487055f/src/share/vm/classfile/vmSymbols.hpp#l691\"><code>newInstance</code> and <code>copyOf</code></a> are <a href=\"http://bad-concurrency.blogspot.co.uk/2012/08/arithmetic-overflow-and-intrinsics.html\">HotSpot intrinsics</a>. This means that ideally calls to these methods get replaced with machine-specific assembly. Anecdotally, I ran some tests and found the difference between <code>new Object[...]</code> and <code>Array.newInstance(...)</code> to be negligible. The code in the question is probably a relic, although it may still be useful on less well-equipped JVMs.</p>\n\n<p>Reflection can also be disabled in certain contexts with strict security (such as an applet), but not typically for a normal desktop application.</p>\n\n\n\n<blockquote>\n  <p>When should I use this method?</p>\n</blockquote>\n\n<p>In general, you will probably never use this overload. This overload is only useful if you want to change the type of the array.</p>\n\n<ul>\n<li><p>Widening:</p>\n\n<pre><code>Object[] a = Arrays.copyOf(\n    new String[] { \"hello\", \"world\" }, 3, Object[].class);\na[2] = Character.valueOf('!');\nSystem.out.println(Arrays.toString(a));\n</code></pre></li>\n<li><p>Narrowing:</p>\n\n<pre><code>String[] a = Arrays.copyOf(\n    new Object[] { \"hello\", \"world\" }, 2, String[].class);\nSystem.out.println(String.join(\" \", a));\n</code></pre></li>\n</ul>\n\n<p>It's more typical to use <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#copyOf-T:A-int-\"><code>Arrays.copyOf(T[], int)</code></a>.</p>\n", "title": "Do not understand the source code of Arrays.copyOf", "tags": ["java", "arrays", "generics"], "link": "http://stackoverflow.com/questions/29494800/do-not-understand-the-source-code-of-arrays-copyof/29502668#29502668", "post_type": "answer", "question_id": 29494800, "answer_id": 29502668}, {"body": "<p>It's not so hard to track down the <em>reason</em> for the odd behavior. </p>\n\n<p>The <code>divide</code> call goes to </p>\n\n<pre><code>public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) {\n    return divide(divisor, scale, roundingMode.oldMode);\n}\n</code></pre>\n\n<p>This, internally, delegates to another <code>divide</code> method, based on the rounding mode:</p>\n\n<pre><code>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) {\n    if (roundingMode &lt; ROUND_UP || roundingMode &gt; ROUND_UNNECESSARY)\n        throw new IllegalArgumentException(\"Invalid rounding mode\");\n    if (this.intCompact != INFLATED) {\n        if ((divisor.intCompact != INFLATED)) {\n            return divide(this.intCompact, this.scale, divisor.intCompact, divisor.scale, scale, roundingMode);\n        } else {\n            return divide(this.intCompact, this.scale, divisor.intVal, divisor.scale, scale, roundingMode);\n        }\n    } else {\n        if ((divisor.intCompact != INFLATED)) {\n            return divide(this.intVal, this.scale, divisor.intCompact, divisor.scale, scale, roundingMode);\n        } else {\n            return divide(this.intVal, this.scale, divisor.intVal, divisor.scale, scale, roundingMode);\n        }\n    }\n}\n</code></pre>\n\n<p>In this case, the last call applies. Note that the <code>intVal</code> (which is a <code>BigInteger</code> that is stored in the <code>BigDecimal</code>) is passed directly to this method as the first argument:</p>\n\n<pre><code>private static BigDecimal divide(BigInteger dividend, int dividendScale, BigInteger divisor, int divisorScale, int scale, int roundingMode) {\n    if (checkScale(dividend,(long)scale + divisorScale) &gt; dividendScale) {\n        int newScale = scale + divisorScale;\n        int raise = newScale - dividendScale;\n        BigInteger scaledDividend = bigMultiplyPowerTen(dividend, raise);\n        return divideAndRound(scaledDividend, divisor, scale, roundingMode, scale);\n    } else {\n        int newScale = checkScale(divisor,(long)dividendScale - scale);\n        int raise = newScale - divisorScale;\n        BigInteger scaledDivisor = bigMultiplyPowerTen(divisor, raise);\n        return divideAndRound(dividend, scaledDivisor, scale, roundingMode, scale);\n    }\n}\n</code></pre>\n\n<p>Finally, the path to the <strong>second</strong> <code>divideAndRound</code> is taken here, again passing the <code>dividend</code> on (which was the <code>intVal</code> of the original <code>BigDecimal</code>), ending up with this code:</p>\n\n<pre><code>private static BigDecimal divideAndRound(BigInteger bdividend, BigInteger bdivisor, int scale, int roundingMode,\n                                         int preferredScale) {\n    boolean isRemainderZero; // record remainder is zero or not\n    int qsign; // quotient sign\n    // Descend into mutables for faster remainder checks\n    MutableBigInteger mdividend = new MutableBigInteger(bdividend.mag);\n    MutableBigInteger mq = new MutableBigInteger();\n    MutableBigInteger mdivisor = new MutableBigInteger(bdivisor.mag);\n    MutableBigInteger mr = mdividend.divide(mdivisor, mq);\n    ...\n</code></pre>\n\n<p>And this is where the error is introduced: The <code>mdivididend</code> is a <strong>mutable</strong> <code>BigInteger</code>, that was created as a mutable view on the <code>mag</code> array of the <code>BigInteger</code> that is stored in the <code>BigDecimal</code> <code>x</code> from the original call. The division modifies the <code>mag</code> field, and thus, the state of the (now not-so-immutable) <code>BigDecimal</code>.</p>\n\n<p>This is clearly a bug in the implementation of one of the <code>divide</code> methods. I already started tracking the change sets of the OpenJDK, but have not yet spotted the definite culprit. (<em>Edit: See updates below</em>)</p>\n\n<p>(A side note: Calling <code>x.toString()</code> before doing the division does not really <em>avoid</em>, but only <em>hide</em> the bug: It causes a string cache of the correct state to be created internally. The right value is printed, but the internal state is still wrong - which is concerning, to say the least...)</p>\n\n<hr>\n\n<blockquote>\n  <p><strong>Update</strong>: To confirm what <code>@MikeM</code> said: Bug has been listed on <a href=\"https://bugs.openjdk.java.net/browse/JDK-8066842\">openjdk bug list</a> and it has been resolved in <code>JDK8 Build 51</code></p>\n  \n  <p><strong>Update</strong> : Kudos to Mike and exex zian for digging out the bug reports. According to the discussion there, the bug was introduced with <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/rev/ffada2ce20e5#l1.1174\">this changeset</a>. \n  <sub>(Admittedly, while skimming through the changes, I also considered this as a hot candidate, but could not believe that this was introduced <em>four years ago</em> and remained unnoticed until now...)</sub></p>\n</blockquote>\n", "title": "Why does toString fail to produce the correct value on an immutable BigDecimal?", "tags": ["java", "bigdecimal"], "link": "http://stackoverflow.com/questions/29328785/why-does-tostring-fail-to-produce-the-correct-value-on-an-immutable-bigdecimal/29330741#29330741", "post_type": "answer", "question_id": 29328785, "answer_id": 29330741}, {"body": "<p>The Oracle documentation about Enum says (first line):</p>\n\n<blockquote>\n  <p>An enum type is a special data type that enables for a variable to be a set of predefined constants. <em>The variable must be equal to one of the values that have been predefined</em> for it. Common examples include compass directions (values of NORTH, SOUTH, EAST, and WEST) and the days of the week.</p>\n</blockquote>\n\n<p>If this is true then, yes, your <code>enum1.name() == enum2.name()</code> is guaranteed to be true if the names are the same.</p>\n\n<p>Also, in the method <code>name()</code> javadoc:</p>\n\n<blockquote>\n  <p>public final String name() \n   \n  Returns the name of this enum constant, exactly as declared in its enum declaration. Most programmers should use the toString() method in preference to this one, as the toString method may return a more user-friendly name. This method is designed primarily for use in specialized situations where correctness depends on getting the exact name, which <em>will not vary</em> from release to release.\n   \n   \n     Returns: the name of this enum constant</p>\n</blockquote>\n\n<p>For example, if you had two enums, <code>Days</code> and <code>MyDays</code>, where SUNDAY is a common value, == between the enum object values, SUNDAY will return true as you are comparing two strings - see the working example in <a href=\"http://ideone.com/U1Bmcw\" rel=\"nofollow\">http://ideone.com/U1Bmcw</a>.</p>\n\n<pre><code>/* Name of the class has to be \"Main\" only if the class is public. */\nclass Ideone\n{\n    public static enum Day{SUNDAY, MONDAY, TUESDAY};\n    public static enum MyDays{SUNDAY};\n\n    public static void main (String[] args) throws java.lang.Exception\n    {\n        MyDays m = Ideone.MyDays.SUNDAY;\n        Day d = Ideone.Day.SUNDAY;\n\n        System.out.println(d.name() == m.name());\n    }\n}\n</code></pre>\n", "title": "Are enum names interned in Java?", "tags": ["java", "enums"], "link": "http://stackoverflow.com/questions/27908213/are-enum-names-interned-in-java/27908294#27908294", "post_type": "answer", "question_id": 27908213, "answer_id": 27908294}, {"body": "<p><code>Stream</code>s are built around <code>Spliterator</code>s which are stateful, mutable objects. They don\u2019t have a \u201creset\u201d action and in fact, requiring to support such rewind action would \u201ctake away much power\u201d. How would <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Random.html#ints--\"><code>Random.ints()</code></a> be supposed to handle such a request?</p>\n\n<p>On the other hand, for <code>Stream</code>s which have a retraceable origin, it is easy to construct an equivalent <code>Stream</code> to be used again. Just put the steps made to construct the <code>Stream</code> into a reusable method. Keep in mind that repeating these steps is not an expensive operation as all these steps are lazy operations; the actual work starts with the terminal operation and depending on the actual terminal operation entirely different code might get executed.</p>\n\n<p>It would be up to you, the writer of such a method, to specify what calling the method twice implies: does it reproduce exactly the same sequence, as streams created for an unmodified array or collection do, or does it produce a stream with a similar semantics but different elements like a stream of random ints or a stream of console input lines, etc.</p>\n\n<hr>\n\n<p>By the way, to avoid confusion, a terminal operation <em>consumes</em> the <code>Stream</code> which is distinct from <em>closing</em> the <code>Stream</code> as calling <code>close()</code> on the stream does (which is required for streams having associated resources like, e.g. produced by <code>Files.lines()</code>).</p>\n\n<hr>\n\n<p>It seems that a lot of confusion stems from misguiding comparison of <code>IEnumerable</code> with <code>Stream</code>. An <code>IEnumerable</code> represents the ability to provide an actual <code>IEnumerator</code>, so its like an <code>Iterable</code> in Java. In contrast, a <code>Stream</code> is a kind of iterator and comparable to an <code>IEnumerator</code> so it\u2019s wrong to claim that this kind of data type can be used multiple times in .NET, the support for <code>IEnumerator.Reset</code> is optional. The examples discussed here rather use the fact that an <code>IEnumerable</code> can be used to fetch <em>new</em> <code>IEnumerator</code>s and that works with Java\u2019s <code>Collection</code>s  as well; you can get a new <code>Stream</code>. If the Java developers decided to add the <code>Stream</code> operations to <code>Iterable</code> directly, with intermediate operations returning another <code>Iterable</code>, it was really comparable and it could work the same way.</p>\n\n<p>However, the developers decided against it and the decision is discussed in <a href=\"http://stackoverflow.com/q/24472312/2711488\">this question</a>. The biggest point is the confusion about eager Collection operations and lazy Stream operations. By looking at the .NET API, I (yes, personally) find it justified. While it looks reasonable looking at <code>IEnumerable</code> alone, a particular Collection will have lots of methods manipulating the Collection directly and lots of methods returning a lazy <code>IEnumerable</code>, while the particular nature of a method isn\u2019t always intuitively recognizable. The worst example I found (within the few minutes I looked at it) is <a href=\"https://msdn.microsoft.com/de-de/library/b0axc2h2(v=vs.110).aspx\"><code>List.Reverse()</code></a> whose name matches <em>exactly</em> the name of the inherited (is this the right terminus for extension methods?) <a href=\"https://msdn.microsoft.com/de-de/library/bb358497(v=vs.110).aspx\"><code>Enumerable.Reverse()</code></a> while having an entirely contradicting behavior.</p>\n\n<hr>\n\n<p>Of course, these are two distinct decisions. The first one to make <code>Stream</code> a type distinct from <code>Iterable</code>/<code>Collection</code> and the second to make <code>Stream</code> a kind of one time iterator rather than another kind of iterable. But these decision were made together and it might be the case that separating these two decision never was considered. It wasn\u2019t created with being comparable to .NET\u2019s in mind.</p>\n\n<p>The actual API design decision was to add an improved type of iterator, the <code>Spliterator</code>. <code>Spliterator</code>s can be provided by the old <code>Iterable</code>s (which is the way how these were retrofitted) or entirely new implementations. Then, <code>Stream</code> was added as a high-level front-end to the rather low level <code>Spliterator</code>s. That\u2019s it. You may discuss about whether a different design would be better, but that\u2019s not productive, it won\u2019t change, given the way they are designed now.</p>\n\n<p>There is another implementation aspect you have to consider. <code>Stream</code>s are <em>not</em> immutable data structures. Each intermediate operation may return a new <code>Stream</code> instance encapsulating the old one but it may also manipulate its own instance instead and return itself (that doesn\u2019t preclude doing even both for the same operation). Commonly known examples are operations like <code>parallel</code> or <code>unordered</code> which do not add another step but manipulate the entire pipeline). Having such a mutable data structure and attempts to reuse (or even worse, using it multiple times at the same time) doesn\u2019t play well\u2026</p>\n\n<hr>\n\n<p>For completeness, here is your quicksort example translated to the Java <code>Stream</code> API. It shows that it does not really \u201ctake away much power\u201d.</p>\n\n<pre><code>static Stream&lt;Integer&gt; quickSort(Supplier&lt;Stream&lt;Integer&gt;&gt; ints) {\n\n  final Optional&lt;Integer&gt; optPivot = ints.get().findAny();\n  if(!optPivot.isPresent()) return Stream.empty();\n\n  final int pivot = optPivot.get();\n\n  Supplier&lt;Stream&lt;Integer&gt;&gt; lt = ()-&gt;ints.get().filter(i -&gt; i &lt; pivot);\n  Supplier&lt;Stream&lt;Integer&gt;&gt; gt = ()-&gt;ints.get().filter(i -&gt; i &gt; pivot);\n\n  return Stream.of(quickSort(lt), Stream.of(pivot), quickSort(gt)).flatMap(s-&gt;s);\n}\n</code></pre>\n\n<p>It can be used like</p>\n\n<pre><code>List&lt;Integer&gt; l=new Random().ints(100, 0, 1000).boxed().collect(Collectors.toList());\nSystem.out.println(l);\nSystem.out.println(quickSort(l::stream)\n    .map(Object::toString).collect(Collectors.joining(\", \")));\n</code></pre>\n\n<p>You can write it even more compact as</p>\n\n<pre><code>static Stream&lt;Integer&gt; quickSort(Supplier&lt;Stream&lt;Integer&gt;&gt; ints) {\n    return ints.get().findAny().map(pivot -&gt;\n         Stream.of(\n                   quickSort(()-&gt;ints.get().filter(i -&gt; i &lt; pivot)),\n                   Stream.of(pivot),\n                   quickSort(()-&gt;ints.get().filter(i -&gt; i &gt; pivot)))\n        .flatMap(s-&gt;s)).orElse(Stream.empty());\n}\n</code></pre>\n", "title": "Why are Java Streams once-off?", "tags": ["java", "java-8", "java-stream", "api-design"], "link": "http://stackoverflow.com/questions/28459498/why-are-java-streams-once-off/28460301#28460301", "post_type": "answer", "question_id": 28459498, "answer_id": 28460301}, {"body": "<p>I think there are very few differences between the two when you look closely enough.</p>\n\n<p>At it's face, an <code>IEnumerable</code> does appear to be a reusable construct:</p>\n\n<pre><code>IEnumerable&lt;int&gt; numbers = new int[] { 1, 2, 3, 4, 5 };\n\nforeach (var n in numbers) {\n    Console.WriteLine(n);\n}\n</code></pre>\n\n<p>However, the compiler is actually doing a little bit of work to help us out; it generates the following code:</p>\n\n<pre><code>IEnumerable&lt;int&gt; numbers = new int[] { 1, 2, 3, 4, 5 };\n\nIEnumerator&lt;int&gt; enumerator = numbers.GetEnumerator();\nwhile (enumerator.MoveNext()) {\n    Console.WriteLine(enumerator.Current);\n}\n</code></pre>\n\n<p>Each time you would actually iterate over the enumerable, the compiler creates an enumerator.  The enumerator is not reusable; further calls to <code>MoveNext</code> will just return false, and there is no way to reset it to the beginning.  If you want to iterate over the numbers again, you will need to create another enumerator instance.</p>\n\n<hr>\n\n<p>To better illustrate that the IEnumerable has (can have) the same 'feature' as a Java Stream, consider a enumerable whose source of the numbers is not a static collection.  For example, we can create an enumerable object which generates a sequence of 5 random numbers:</p>\n\n<pre><code>class Generator : IEnumerator&lt;int&gt; {\n    Random _r;\n    int _current;\n    int _count = 0;\n\n    public Generator(Random r) {\n        _r = r;\n    }\n\n    public bool MoveNext() {\n        _current= _r.Next();\n        _count++;\n        return _count &lt;= 5;\n    }\n\n    public int Current {\n        get { return _current; }\n    }\n }\n\nclass RandomNumberStream : IEnumerable&lt;int&gt; {\n    Random _r = new Random();\n    public IEnumerator&lt;int&gt; GetEnumerator() {\n        return new Generator(_r);\n    }\n    public IEnumerator IEnumerable.GetEnumerator() {\n        return this.GetEnumerator();\n    }\n}\n</code></pre>\n\n<p>Now we have very similar code to the previous array-based enumerable, but with a second iteration over <code>numbers</code>:</p>\n\n<pre><code>IEnumerable&lt;int&gt; numbers = new RandomNumberStream();\n\nforeach (var n in numbers) {\n    Console.WriteLine(n);\n}\nforeach (var n in numbers) {\n    Console.WriteLine(n);\n}\n</code></pre>\n\n<p>The second time we iterate over <code>numbers</code> we will get a different sequence of numbers, which isn't reusable in the same sense.  Or, we could have written the <code>RandomNumberStream</code> to thrown an exception if you try to iterate over it multiple times, making the enumerable actually unusable (like a Java Stream).</p>\n\n<p>Also, what does your enumerable-based quick sort mean when applied to a <code>RandomNumberStream</code>?</p>\n\n<hr>\n\n<h2>Conclusion</h2>\n\n<p>So, the biggest difference is that .NET allows you to reuse an <code>IEnumerable</code> by implicitly creating a new <code>IEnumerator</code> in the background whenever it would need to access elements in the sequence.</p>\n\n<p>This implicit behavior is often useful (and 'powerful' as you state), because we can repeatedly iterate over a collection.</p>\n\n<p>But sometimes, this implicit behavior can actually cause problems.  If your data source is not static, or is costly to access (like a database or web site), then a lot of assumptions about <code>IEnumerable</code> have to be discarded; reuse is not that straight-forward</p>\n", "title": "Why are Java Streams once-off?", "tags": ["java", "java-8", "java-stream", "api-design"], "link": "http://stackoverflow.com/questions/28459498/why-are-java-streams-once-off/28465634#28465634", "post_type": "answer", "question_id": 28459498, "answer_id": 28465634}, {"body": "<p>I have some recollections from the early design of the Streams API that might shed some light on the design rationale.</p>\n\n<p>Back in 2012, we were adding lambdas to the language, and we wanted a collections-oriented or \"bulk data\" set of operations, programmed using lambdas, that would facilitate parallelism. The idea of lazily chaining operations together was well established by this point. We also didn't want the intermediate operations to store results.</p>\n\n<p>The main issues we needed to decide were what the objects in the chain looked like in the API and how they hooked up to data sources. The sources were often collections, but we also wanted to support data coming from a file or the network, or data generated on-the-fly, e.g., from a random number generator.</p>\n\n<p>There were many influences of existing work on the design. Among the more influential were Google's <a href=\"https://code.google.com/p/guava-libraries/\">Guava</a> library and the Scala collections library. (If anybody is surprised about the influence from Guava, note that <a href=\"http://stackoverflow.com/users/202214/kevin-bourrillion\">Kevin Bourrillion</a>, Guava lead developer, was on the <a href=\"https://jcp.org/en/jsr/detail?id=335\">JSR-335 Lambda</a> expert group.) On Scala collections, we found this talk by Martin Odersky to be of particular interest: <a href=\"http://youtu.be/HoIOIluNFzQ\">Future-Proofing Scala Collections: from Mutable to Persistent to Parallel</a>. (Stanford EE380, 2011 June 1.)</p>\n\n<p>Our prototype design at the time was based around <code>Iterable</code>. The familiar operations <code>filter</code>, <code>map</code>, and so forth were extension (default) methods on <code>Iterable</code>. Calling one added an operation to the chain and returned another <code>Iterable</code>. A terminal operation like <code>count</code> would call <code>iterator()</code> up the chain to the source, and the operations were implemented within each stage's Iterator.</p>\n\n<p>Since these are Iterables, you can call the <code>iterator()</code> method more than once. What should happen then?</p>\n\n<p>If the source is a collection, this mostly works fine. Collections are Iterable, and each call to <code>iterator()</code> produces a distinct Iterator instance that is independent of any other active instances, and each traverses the collection independently. Great.</p>\n\n<p>Now what if the source is one-shot, like reading lines from a file? Maybe the first Iterator should get all the values but the second and subsequent ones should be empty. Maybe the values should be interleaved among the Iterators. Or maybe each Iterator should get all the same values. Then, what if you have two iterators and one gets farther ahead of the other? Somebody will have to buffer up the values in the second Iterator until they're read. Worse, what if you get one Iterator and read all the values, and only <em>then</em> get a second Iterator. Where do the values come from now? Is there a requirement for them all to be buffered up <em>just in case</em> somebody wants a second Iterator?</p>\n\n<p>Clearly, allowing multiple Iterators over a one-shot source raises a lot of questions. We didn't have good answers for them. We wanted consistent, predictable behavior for what happens if you call <code>iterator()</code> twice. This pushed us toward disallowing multiple traversals, making the pipelines one-shot.</p>\n\n<p>We also observed others bumping into these issues. In the JDK, most Iterables are collections or collection-like objects, which allow multiple traversal. It isn't specified anywhere, but there seemed to be an unwritten expectation that Iterables allow multiple traversal. A notable exception is the NIO <a href=\"http://docs.oracle.com/javase/8/docs/api/java/nio/file/DirectoryStream.html\">DirectoryStream</a> interface. Its specification includes this interesting warning:</p>\n\n<blockquote>\n  <p><strong>While DirectoryStream extends Iterable, it is not a general-purpose Iterable as it supports only a single Iterator; invoking the iterator method to obtain a second or subsequent iterator throws IllegalStateException.</strong></p>\n</blockquote>\n\n<p>[bold in original]</p>\n\n<p>This seemed unusual and unpleasant enough that we didn't want to create a whole bunch of new Iterables that might be once-only. This pushed us away from using Iterable.</p>\n\n<p>About this time, an <a href=\"http://www.artima.com/weblogs/viewpost.jsp?thread=339521\">article by Bruce Eckel</a> appeared that described a spot of trouble he'd had with Scala. He'd written this code:</p>\n\n<pre><code>// Scala\nval lines = fromString(data).getLines\nval registrants = lines.map(Registrant)\nregistrants.foreach(println)\nregistrants.foreach(println)\n</code></pre>\n\n<p>It's pretty straightforward. It parses lines of text into <code>Registrant</code> objects and prints them out twice. Except that it actually only prints them out once. It turns out that he thought that <code>registrants</code> was a collection, when in fact it's an iterator. The second call to <code>foreach</code> encounters an empty iterator, from which all values have been exhausted, so it prints nothing.</p>\n\n<p>This kind of experience convinced us that it was very important to have clearly predictable results if multiple traversal is attempted. It also highlighted the importance of distinguishing between lazy pipeline-like structures from actual collections that store data. This in turn drove the separation of the lazy pipeline operations into the new Stream interface and keeping only eager, mutative operations directly on Collections. <a href=\"http://stackoverflow.com/a/24472635/1441122\">Brian Goetz has explained</a> the rationale for that.</p>\n\n<p>What about allowing multiple traversal for collection-based pipelines but disallowing it for non-collection-based pipelines? It's inconsistent, but it's sensible. If you're reading values from the network, <em>of course</em> you can't traverse them again. If you want to traverse them multiple times, you have to pull them into a collection explicitly.</p>\n\n<p>But let's explore allowing multiple traversal from collections-based pipelines. Let's say you did this:</p>\n\n<pre><code>Iterable&lt;?&gt; it = source.filter(...).map(...).filter(...).map(...);\nit.into(dest1);\nit.into(dest2);\n</code></pre>\n\n<p>(The <code>into</code> operation is now spelled <code>collect(toList())</code>.)</p>\n\n<p>If source is a collection, then the first <code>into()</code> call will create a chain of Iterators back to the source, execute the pipeline operations, and send the results into the destination. The second call to <code>into()</code> will create another chain of Iterators, and execute the pipeline operations <strong>again</strong>. This isn't obviously wrong but it does have the effect of performing all the filter and map operations a second time for each element. I think many programmers would have been surprised by this behavior.</p>\n\n<p>As I mentioned above, we had been talking to the Guava developers. One of the cool things they have is an <a href=\"https://code.google.com/p/guava-libraries/wiki/IdeaGraveyard\">Idea Graveyard</a> where they describe features that they decided <strong>not</strong> to implement along with the reasons. The idea of lazy collections sounds pretty cool, but here's what they have to say about it. Consider a <code>List.filter()</code> operation that returns a <code>List</code>:</p>\n\n<blockquote>\n  <p>The biggest concern here is that too many operations become expensive, linear-time propositions. If you want to filter a list and get a list back, and not just a Collection or an Iterable, you can use <code>ImmutableList.copyOf(Iterables.filter(list, predicate))</code>, which \"states up front\" what it's doing and how expensive it is.</p>\n</blockquote>\n\n<p>To take a specific example, what's the cost of <code>get(0)</code> or <code>size()</code> on a List? For commonly used classes like <code>ArrayList</code>, they're O(1). But if you call one of these on a lazily-filtered list, it has to run the filter over the backing list, and all of a sudden these operations are O(n). Worse, it has to traverse the backing list on <strong>every</strong> operation.</p>\n\n<p>This seemed to us to be <em>too much</em> laziness. It's one thing to set up some operations and defer actual execution until you so \"Go\". It's another to set things up in such a way that hides a potentially large amount of recomputation.</p>\n\n<p>In proposing to disallow non-linear or \"no-reuse\" streams, <a href=\"http://stackoverflow.com/users/4042945/paul-sandoz\">Paul Sandoz</a> described the <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-experts/2012-November/000412.html\">potential consequences</a> of allowing them as giving rise to \"unexpected or confusing results.\" He also mentioned that parallel execution would make things even trickier. Finally, I'd add that a pipeline operation with side effects would lead to difficult and obscure bugs if the operation were unexpectedly executed multiple times, or at least a different number of times than the programmer expected. (But Java programmers don't write lambda expressions with side effects, do they? DO THEY??)</p>\n\n<p>So that's the basic rationale for the Java 8 Streams API design that allows one-shot traversal and that requires a strictly linear (no branching) pipeline. It provides consistent behavior across multiple different stream sources, it clearly separates lazy from eager operations, and it provides a straightforward execution model.</p>\n\n<hr>\n\n<p>With regard to <code>IEnumerable</code>, I am far from an expert on C# and .NET, so I would appreciate being corrected (gently) if I draw any incorrect conclusions. It does appear, however, that <code>IEnumerable</code> permits multiple traversal to behave differently with different sources; and it permits a branching structure of nested <code>IEnumerable</code> operations, which may result in some significant recomputation. While I appreciate that different systems make different tradeoffs, these are two characteristics that we sought to avoid in the design of the Java 8 Streams API.</p>\n\n<p>The quicksort example given by the OP is interesting, puzzling, and I'm sorry to say, somewhat horrifying. Calling <code>QuickSort</code> takes an <code>IEnumerable</code> and returns an <code>IEnumerable</code>, so no sorting is actually done until the final <code>IEnumerable</code> is traversed. What the call seems to do, though, is build up a tree structure of <code>IEnumerables</code> that reflects the partitioning that quicksort would do, without actually doing it. (This is lazy computation, after all.) If the source has N elements, the tree will be N elements wide at its widest, and it will be lg(N) levels deep.</p>\n\n<p>It seems to me -- and once again, I'm not a C# or .NET expert -- that this will cause certain innocuous-looking calls, such as pivot selection via <code>ints.First()</code>, to be more expensive than they look. At the first level, of course, it's O(1). But consider a partition deep in the tree, at the right-hand edge. To compute the first element of this partition, the entire source has to be traversed, an O(N) operation. But since the partitions above are lazy, they must be recomputed, requiring O(lg N) comparisons. So selecting the pivot would be an O(N lg N) operation, which is as expensive as an entire sort.</p>\n\n<p>But we don't actually sort until we traverse the returned <code>IEnumerable</code>. In the standard quicksort algorithm, each level of partitioning doubles the number of partitions. Each partition is only half the size, so each level remains at O(N) complexity. The tree of partitions is O(lg N) high, so the total work is O(N lg N).</p>\n\n<p>With the tree of lazy IEnumerables, at the bottom of the tree there are N partitions. Computing each partition requires a traversal of N elements, each of which requires lg(N) comparisons up the tree. To compute all the partitions at the bottom of the tree, then, requires O(N^2 lg N) comparisons.</p>\n\n<p>(Is this right? I can hardly believe this. Somebody please check this for me.)</p>\n\n<p>In any case, it is indeed cool that <code>IEnumerable</code> can be used this way to build up complicated structures of computation. But if it does increase the computational complexity as much as I think it does, it would seem that programming this way is something that should be avoided unless one is extremely careful.</p>\n", "title": "Why are Java Streams once-off?", "tags": ["java", "java-8", "java-stream", "api-design"], "link": "http://stackoverflow.com/questions/28459498/why-are-java-streams-once-off/28513908#28513908", "post_type": "answer", "question_id": 28459498, "answer_id": 28513908}, {"body": "<p>In my free <a href=\"https://github.com/amaembo/streamex\" rel=\"nofollow\">StreamEx</a> library I introduced the short-circuiting collectors. When collecting sequential stream with short-circuiting collector (like <a href=\"http://amaembo.github.io/streamex/javadoc/javax/util/streamex/MoreCollectors.html#first--\" rel=\"nofollow\"><code>MoreCollectors.first()</code></a>) exactly one element is consumed from the source. Internally it's implemented in quite dirty way: using a custom exception to break the control flow. Using my library your sample could be rewritten in this way:</p>\n\n<pre><code>System.out.println(\n        \"Result: \" +\n                StreamEx.of(1, 2, 3)\n                .flatMap(i -&gt; Stream.of(i - 1, i, i + 1))\n                .flatMap(i -&gt; Stream.of(i - 1, i, i + 1))\n                .filter(i -&gt; {\n                    System.out.println(i);\n                    return true;\n                })\n                .collect(MoreCollectors.first())\n                .get()\n        );\n</code></pre>\n\n<p>The result is the following:</p>\n\n<pre><code>-1\nResult: -1\n</code></pre>\n", "title": "Why filter() after flatMap() is &quot;not completely&quot; lazy in Java streams?", "tags": ["java", "lambda", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/29229373/why-filter-after-flatmap-is-not-completely-lazy-in-java-streams/33839551#33839551", "post_type": "answer", "question_id": 29229373, "answer_id": 33839551}, {"body": "<p>The first form is called <a href=\"http://en.wikipedia.org/wiki/Javadoc\">Javadoc</a>.  You use this when you're writing formal APIs for your code, which are generated by the <code>javadoc</code> tool.  For an example, <a href=\"http://docs.oracle.com/javase/7/docs/api/\">the Java 7 API page</a> uses Javadoc and was generated by that tool.</p>\n\n<p>Some common elements you'd see in Javadoc include:</p>\n\n<ul>\n<li><p><code>@param</code>:  this is used to indicate what parameters are being passed to a method, and what value they're expected to have</p></li>\n<li><p><code>@return</code>:  this is used to indicate what result the method is going to give back</p></li>\n<li><p><code>@throws</code>:  this is used to indicate that a method throws an exception or error in case of certain input</p></li>\n<li><p><code>@since</code>:  this is used to indicate the earliest Java version this class or function was available in</p></li>\n</ul>\n\n<p>As an example, here's Javadoc for the <code>compare</code> method of <code>Integer</code>:</p>\n\n<pre><code>/**\n * Compares two {@code int} values numerically.\n * The value returned is identical to what would be returned by:\n * &lt;pre&gt;\n *    Integer.valueOf(x).compareTo(Integer.valueOf(y))\n * &lt;/pre&gt;\n *\n * @param  x the first {@code int} to compare\n * @param  y the second {@code int} to compare\n * @return the value {@code 0} if {@code x == y};\n *         a value less than {@code 0} if {@code x &lt; y}; and\n *         a value greater than {@code 0} if {@code x &gt; y}\n * @since 1.7\n */\npublic static int compare(int x, int y) {\n    return (x &lt; y) ? -1 : ((x == y) ? 0 : 1);\n}\n</code></pre>\n\n<p>The second form is a block (multi-line) comment.  You use this if you want to have multiple lines in a comment.</p>\n\n<p>I will say that you'd only want to use the latter form <em>sparingly</em>; that is, you don't want to overburden your code with block comments that don't describe what behaviors the method/complex function is supposed to have.</p>\n\n<p>Since Javadoc is the more descriptive of the two, and you can generate actual documentation as a result of using it, using Javadoc would be more preferable to simple block comments.</p>\n", "title": "/** and /* in Java Comments", "tags": ["java", "comments", "javadoc"], "link": "http://stackoverflow.com/questions/29815636/and-in-java-comments/29815698#29815698", "post_type": "answer", "question_id": 29815636, "answer_id": 29815698}, {"body": "<h1>Background</h1>\n\n<p>All Java objects have a <code>toString()</code> method, which is invoked when you try and print the object. </p>\n\n<pre><code>System.out.println(myObject);  // invokes myObject.toString()\n</code></pre>\n\n<p>This method is defined in the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html\"><code>Object</code></a> class (the superclass of all Java objects). The <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString--\"><code>Object.toString()</code></a> method returns a fairly ugly looking string, composed of the name of the class, an <code>@</code> symbol and the <a href=\"http://stackoverflow.com/questions/3563847/what-is-the-use-of-hashcode-in-java\">hashcode</a> of the object in hexadecimal. The code for this looks like:</p>\n\n<pre><code>// Code of Object.toString()\npublic String toString() {\n    return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n}\n</code></pre>\n\n<p>A result such as <code>com.foo.MyType@2f92e0f4</code> can therefore be explained as:</p>\n\n<ul>\n<li><code>com.foo.MyType</code>  - the name of the class, i.e. the class is <code>MyType</code> in the package <code>com.foo</code>.</li>\n<li><code>@</code> - joins the string together</li>\n<li><code>2f92e0f4</code> the hashcode of the object.</li>\n</ul>\n\n<p>The name of array classes look a little different, which is explained well in the Javadocs for <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getName--\"><code>Class.getName()</code></a>. For instance, <code>[Ljava.lang.String</code> means:</p>\n\n<ul>\n<li><code>[</code> - an single-dimensional array (as opposed to <code>[[</code> or <code>[[[</code> etc.)</li>\n<li><code>L</code> - the array contains a class or interface</li>\n<li><code>java.lang.String</code> - the type of objects in the array</li>\n</ul>\n\n<hr>\n\n<h1>Customizing the Output</h1>\n\n<p>To print something different when you call <code>System.out.println(myObject)</code>, you must <a href=\"https://docs.oracle.com/javase/tutorial/java/IandI/override.html\">override</a> the <code>toString()</code> method in your own class. Here's a simple example:</p>\n\n<pre><code>public class Person {\n\n  private String name;\n\n  // constructors and other methods omitted\n\n  @Override\n  public String toString() {\n    return name;\n  }\n}\n</code></pre>\n\n<p>Now if we print a <code>Person</code>, we see their name rather than <code>com.foo.Person@12345678</code>.</p>\n\n<p>Bear in mind that <code>toString()</code> is just <em>one</em> way for an object to be converted to a string. Typically this output should fully describe your object in a clear and concise manner. A better <code>toString()</code> for our <code>Person</code> class might be:</p>\n\n<pre><code>@Override\npublic String toString() {\n  return getClass().getSimpleName() + \"[name=\" + name + \"]\";\n}\n</code></pre>\n\n<p>Which would print, e.g., <code>Person[name=Henry]</code>. That's a really useful piece of data for debugging/testing.</p>\n\n<p>If you want to focus on just one aspect of your object or include a lot of jazzy formatting, you might be better to define a separate method instead, e.g. <code>String toElegantReport() {...}</code>.</p>\n\n<hr>\n\n<h1>Auto-generating the Output</h1>\n\n<p>Many <a href=\"http://en.wikipedia.org/wiki/Integrated_development_environment\">IDEs</a> offer support for auto-generating a <code>toString()</code> method, based on the fields in the class. See docs for <a href=\"http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fref-dialog-tostring.htm\">Eclipse</a> and <a href=\"https://plugins.jetbrains.com/plugin/182?pr=idea\">IntelliJ</a>, for example. </p>\n\n<p>Several popular Java libraries offer this feature as well. Some examples include:</p>\n\n<ul>\n<li><p><a href=\"http://commons.apache.org/proper/commons-lang/javadocs/api-release/org/apache/commons/lang3/builder/ToStringBuilder.html\"><code>ToStringBuilder</code></a> from <a href=\"http://commons.apache.org/proper/commons-lang/\">Apache Commons Lang</a></p></li>\n<li><p><a href=\"http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/base/MoreObjects.html#toStringHelper(java.lang.Object)\"><code>MoreObjects.ToStringHelper</code></a> from <a href=\"https://github.com/google/guava\">Google Guava</a></p></li>\n<li><p><a href=\"http://projectlombok.org/features/ToString.html\"><code>@ToString</code></a> annotation from <a href=\"http://projectlombok.org/\">Project Lombok</a></p></li>\n</ul>\n\n<hr>\n\n<h1>Printing groups of objects</h1>\n\n<p>So you've created a nice <code>toString()</code> for your class. What happens if that class is placed into an array or a collection?</p>\n\n<h2>Arrays</h2>\n\n<p>If you have an array of objects, you can call <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#toString-java.lang.Object:A-\"><code>Arrays.toString()</code></a> to produce a simple representation of the contents of the array. For instance, consider this array of <code>Person</code> objects:</p>\n\n<pre><code>Person[] people = { new Person(\"Fred\"), new Person(\"Mike\") };\nSystem.out.println(Arrays.toString(people));\n\n// Prints: [Fred, Mike]\n</code></pre>\n\n<p>Note:  this is a call to a <em>static</em> method called <code>toString()</code> in the Arrays class, which is different to what we've been discussing above.</p>\n\n<p>If you have a <strong>multi-dimensional array</strong>, you can use <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#deepToString-java.lang.Object:A-\"><code>Arrays.deepToString()</code></a> to achieve the same sort of output.</p>\n\n<h2>Collections</h2>\n\n<p>Most collections will produce a pretty output based on calling <code>.toString()</code> on every element.</p>\n\n<pre><code>List&lt;Person&gt; people = new ArrayList&lt;&gt;();\npeople.add(new Person(\"Alice\"));\npeople.add(new Person(\"Bob\"));    \nSystem.out.println(people);\n\n// Prints [Alice, Bob]\n</code></pre>\n\n<p>So you just need to ensure your list elements define a nice <code>toString()</code> as discussed above.</p>\n", "title": "How do I print my Java object without getting &quot;SomeType@2f92e0f4&quot;?", "tags": ["java", "string", "object", "tostring"], "link": "http://stackoverflow.com/questions/29140402/how-do-i-print-my-java-object-without-getting-sometype2f92e0f4/29140403#29140403", "post_type": "answer", "question_id": 29140402, "answer_id": 29140403}, {"body": "<p>Every class in java has <code>toString()</code> method in it by default, which is called by <code>System.out.println()</code> if you pass some object of a class to it. When you try to print object of a class, the <code>System.out.println()</code> method will call <code>toString()</code> of the class which returns the className@hashcode of that object.</p>\n\n<pre><code>{\n    SomeClass sc = new SomeClass();\n    // Class @ followed by hashcode of object in Hexadecimal\n    System.out.println(sc);\n}\n</code></pre>\n\n<p>You can override the toString method of a class to get different output. See this example</p>\n\n<pre><code>class A {\n    String s = \"I am just a object\";\n    @Override\n    public String toString()\n    {\n        return s;\n    }\n}\n\nclass B {\n    public static void main(String args[])\n    {\n        A obj = new A();\n        System.out.println(obj);\n    }\n}\n</code></pre>\n", "title": "How do I print my Java object without getting &quot;SomeType@2f92e0f4&quot;?", "tags": ["java", "string", "object", "tostring"], "link": "http://stackoverflow.com/questions/29140402/how-do-i-print-my-java-object-without-getting-sometype2f92e0f4/29141638#29141638", "post_type": "answer", "question_id": 29140402, "answer_id": 29141638}, {"body": "<p>Why this should be problem in the first place is kind of nebulous to me. I suspect you've instead misunderstood something about the ways in which the type system is useful.</p>\n\n<p>What can we do with a <code>&lt;T&gt;&nbsp;void&nbsp;x(T&nbsp;a,&nbsp;T&nbsp;b)</code>? Well, not a whole lot. Inside the body of <code>x</code>, <code>T</code> is the same as <code>Object</code>, so we could only do something like call <code>toString</code> on <code>a</code> and <code>b</code> to print them.</p>\n\n<p>There's really no practical <em>reason</em> <code>a</code> and <code>b</code> must have the same type. Just that they have some type in common, and that type is <code>Object</code> or a subtype of it. In fact, there's no clear reason why <code>&lt;T&gt;&nbsp;void&nbsp;x(T&nbsp;a,&nbsp;T&nbsp;b)</code> actually needs to be generic at all.</p>\n\n<ul>\n<li>The method body doesn't care what the actual types of <code>a</code> and <code>b</code> are because it couldn't use them anyway.</li>\n<li>The call site doesn't care what the actual types of <code>a</code> and <code>b</code> are because <code>x</code> is a <code>void</code> method so it's a black hole.</li>\n</ul>\n\n<p>It's more typical for a method to have a result, like <code>&lt;T&gt;&nbsp;List&lt;T&gt;&nbsp;Arrays.asList(T...)</code>:</p>\n\n<pre><code>// This will cause a compile error because\n// the type inferred must be compatible\n// with the return assignment.\nList&lt;Integer&gt; r = Arrays.asList(1, 1.0);\n</code></pre>\n\n<p>Or a bound:</p>\n\n<pre><code>// We don't care what the actual types of\n// a and b are, just that we can call bar()\n// on them.\n// Note: this method does not need to be generic.\n&lt;T extends Foo&gt; void x(T a, T b) {\n    a.bar();\n    a.bar();\n}\n</code></pre>\n\n<p>Or a bound which asserts some kind of relation:</p>\n\n<pre><code>// We don't care what the actual types of\n// a and b are, just that we can compare\n// them to each other.\n&lt;T extends Comparable&lt;T&gt;&gt; T max(T a, T b) {\n    return (a.compareTo(b) &lt; 0) ? b : a;\n}\n</code></pre>\n", "title": "Can the generic type of a generic Java method be used to enforce the type of arguments?", "tags": ["java", "generics", "types"], "link": "http://stackoverflow.com/questions/30217236/can-the-generic-type-of-a-generic-java-method-be-used-to-enforce-the-type-of-arg/30219144#30219144", "post_type": "answer", "question_id": 30217236, "answer_id": 30219144}, {"body": "<p>You can close the outer most stream, in fact you don't need to retain all the streams wrapped and you can use Java 7 try-with-resources.</p>\n\n<pre><code>try (BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(\n                     new GZIPOutputStream(new FileOutputStream(createdFile)))) {\n     // write to the buffered writer\n}\n</code></pre>\n\n<hr>\n\n<p>If you subscribe to YAGNI, or you-aint-gonna-need-it, you should be only adding code you actually need. You shouldn't be adding code you imagine you might need but in reality doesn't do anything useful.</p>\n\n<p>Take this example and imagine what could possibly go wrong if you didn't do this and what the impact would be?</p>\n\n<pre><code>try (\n    OutputStream outputStream = new FileOutputStream(createdFile);\n    GZIPOutputStream gzipOutputStream = new GZIPOutputStream(outputStream);\n    OutputStreamWriter osw = new OutputStreamWriter(gzipOutputStream);\n    BufferedWriter bw = new BufferedWriter(osw)\n    ) {\n    // ...\n}\n</code></pre>\n\n<p>Lets start with FileOutputStream which calls <code>open</code> to do all the real work.</p>\n\n<pre><code>/**\n * Opens a file, with the specified name, for overwriting or appending.\n * @param name name of file to be opened\n * @param append whether the file is to be opened in append mode\n */\nprivate native void open(String name, boolean append)\n    throws FileNotFoundException;\n</code></pre>\n\n<p>If the file is not found, there is no underlying resource to close, so closing it won't make any difference.  If The file exists, it should be throwing a FileNotFoundException. So there is nothing to be gained by trying to close the resource from this line alone.</p>\n\n<p>The reason you need to close the file is when the file is opened successfully, but you later get an error.</p>\n\n<p>Lets look at the next stream <code>GZIPOutputStream</code></p>\n\n<p>There is code which can throw an exception</p>\n\n<pre><code>private void writeHeader() throws IOException {\n    out.write(new byte[] {\n                  (byte) GZIP_MAGIC,        // Magic number (short)\n                  (byte)(GZIP_MAGIC &gt;&gt; 8),  // Magic number (short)\n                  Deflater.DEFLATED,        // Compression method (CM)\n                  0,                        // Flags (FLG)\n                  0,                        // Modification time MTIME (int)\n                  0,                        // Modification time MTIME (int)\n                  0,                        // Modification time MTIME (int)\n                  0,                        // Modification time MTIME (int)\n                  0,                        // Extra flags (XFLG)\n                  0                         // Operating system (OS)\n              });\n}\n</code></pre>\n\n<p>This writes the header of the file.  Now it would be very unusual for you to be able to open a file for writing but not be able to write even 8 bytes to it, but lets imagine this could happen and we don't close the file afterwards.  What does happen to a file if it is not closed?  </p>\n\n<p>You don't get any unflushed writes, they are discarded and in this case, there is no successfully written bytes to the stream which isn't buffered at this point anyway.  But a file which is not closed doesn't live forever, instead FileOutputStream has</p>\n\n<pre><code>protected void finalize() throws IOException {\n    if (fd != null) {\n        if (fd == FileDescriptor.out || fd == FileDescriptor.err) {\n            flush();\n        } else {\n            /* if fd is shared, the references in FileDescriptor\n             * will ensure that finalizer is only called when\n             * safe to do so. All references using the fd have\n             * become unreachable. We can call close()\n             */\n            close();\n        }\n    }\n}\n</code></pre>\n\n<p>If you don't close a file at all, it gets closed anyway, just not immediately (and like I said, data which is left in a buffer will be lost this way, but there is none at this point)</p>\n\n<p>What is the consequence of not closing the file immediately?  Under normal conditions, you potentially lose some data, and you potentially run out of file descriptors.  But if you have a system where you can create files but you can't write anything to them, you have a bigger problem. i.e. it hard to imagine why you are repeatedly trying to create this file despite the fact you are failing.</p>\n\n<p>Both OutputStreamWriter and BufferedWriter don't throw IOException in their constructors, so it not clear what problem they would cause.  In The case of BufferedWriter, you could get an OutOfMemoryError.  In this case it will immediately trigger a GC, which as we have seen will close the file anyway.</p>\n", "title": "Is it necessary to close each nested OutputStream and Writer separately?", "tags": ["java", "file-io", "outputstream", "writer"], "link": "http://stackoverflow.com/questions/28276423/is-it-necessary-to-close-each-nested-outputstream-and-writer-separately/28276493#28276493", "post_type": "answer", "question_id": 28276423, "answer_id": 28276493}, {"body": "<p>No, the topmost level <code>Stream</code> or <code>reader</code> will ensure that all <em>underlying</em> streams / readers are closed. </p>\n\n<p>Check the <code>close()</code> method <em>implementation</em> of your topmost level stream.</p>\n", "title": "Is it necessary to close each nested OutputStream and Writer separately?", "tags": ["java", "file-io", "outputstream", "writer"], "link": "http://stackoverflow.com/questions/28276423/is-it-necessary-to-close-each-nested-outputstream-and-writer-separately/28276497#28276497", "post_type": "answer", "question_id": 28276423, "answer_id": 28276497}, {"body": "<p>Assuming all the streams get created okay, yes, just closing <code>bw</code> is fine <em>with those stream implementations</em>; but that's a big assumption.</p>\n\n<p>I'd use <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/language/try-with-resources.html\">try-with-resources</a> (<a href=\"http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html\">tutorial</a>) so that any issues constructing the subsequent streams that throw exceptions don't leave the previous streams hanging, and so you don't have to rely on the stream implementation having the call to close the underlying stream:</p>\n\n<pre><code>try (\n    OutputStream outputStream = new FileOutputStream(createdFile);\n    GZIPOutputStream gzipOutputStream = new GZIPOutputStream(outputStream);\n    OutputStreamWriter osw = new OutputStreamWriter(gzipOutputStream);\n    BufferedWriter bw = new BufferedWriter(osw)\n    ) {\n    // ...\n}\n</code></pre>\n\n<p>Note you no longer call <code>close</code> at all.</p>\n\n<p><strong>Important note</strong>: To have try-with-resources close them, you <em>must</em> assign the streams to variables as you open them, you cannot use nesting. If you use nesting, an exception during construction of one of the later streams (say, <code>GZIPOutputStream</code>) will leave any stream constructed by the nested calls inside it open. From <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.20.3\">JLS \u00a714.20.3</a>:</p>\n\n<blockquote>\n  <p>A try-with-resources statement is parameterized with <strong>variables</strong> (known as resources) that are initialized before execution of the <code>try</code> block and closed automatically, in the reverse order from which they were initialized, after execution of the <code>try</code> block.</p>\n</blockquote>\n\n<p>Note the word \"variables\" <em>(my emphasis)</em>.</p>\n\n<p>E.g., don't do this:</p>\n\n<pre><code>// DON'T DO THIS\ntry (BufferedWriter bw = new BufferedWriter(\n        new OutputStreamWriter(\n        new GZIPOutputStream(\n        new FileOutputStream(createdFile))))) {\n    // ...\n}\n</code></pre>\n\n<p>...because an exception from the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/zip/GZIPOutputStream.html#GZIPOutputStream-java.io.OutputStream-\"><code>GZIPOutputStream(OutputStream)</code></a> constructor (which says it may throw <code>IOException</code>, and writes a header to the underlying stream) would leave the <code>FileOutputStream</code> open. Since some resources have constructors that may throw and others don't, it's a good habit to just list them separately.</p>\n\n<p>We can double-check our interpretation of that JLS section with this program:</p>\n\n<pre><code>public class Example {\n\n    private static class InnerMost implements AutoCloseable {\n        public InnerMost() throws Exception {\n            System.out.println(\"Constructing \" + this.getClass().getName());\n        }\n\n        @Override\n        public void close() throws Exception {\n            System.out.println(this.getClass().getName() + \" closed\");\n        }\n    }\n\n    private static class Middle implements AutoCloseable {\n        private AutoCloseable c;\n\n        public Middle(AutoCloseable c) {\n            System.out.println(\"Constructing \" + this.getClass().getName());\n            this.c = c;\n        }\n\n        @Override\n        public void close() throws Exception {\n            System.out.println(this.getClass().getName() + \" closed\");\n            c.close();\n        }\n    }\n\n    private static class OuterMost implements AutoCloseable {\n        private AutoCloseable c;\n\n        public OuterMost(AutoCloseable c) throws Exception {\n            System.out.println(\"Constructing \" + this.getClass().getName());\n            throw new Exception(this.getClass().getName() + \" failed\");\n        }\n\n        @Override\n        public void close() throws Exception {\n            System.out.println(this.getClass().getName() + \" closed\");\n            c.close();\n        }\n    }\n\n    public static final void main(String[] args) {\n        // DON'T DO THIS\n        try (OuterMost om = new OuterMost(\n                new Middle(\n                    new InnerMost()\n                    )\n                )\n            ) {\n            System.out.println(\"In try block\");\n        }\n        catch (Exception e) {\n            System.out.println(\"In catch block\");\n        }\n        finally {\n            System.out.println(\"In finally block\");\n        }\n        System.out.println(\"At end of main\");\n    }\n}\n</code></pre>\n\n<p>...which has the output:</p>\n\n<pre>\nConstructing Example$InnerMost\nConstructing Example$Middle\nConstructing Example$OuterMost\nIn catch block\nIn finally block\nAt end of main\n</pre>\n\n<p>Note that there are no calls to <code>close</code> there.</p>\n\n<p>If we fix <code>main</code>:</p>\n\n<pre><code>public static final void main(String[] args) {\n    try (\n        InnerMost im = new InnerMost();\n        Middle m = new Middle(im);\n        OuterMost om = new OuterMost(m)\n        ) {\n        System.out.println(\"In try block\");\n    }\n    catch (Exception e) {\n        System.out.println(\"In catch block\");\n    }\n    finally {\n        System.out.println(\"In finally block\");\n    }\n    System.out.println(\"At end of main\");\n}\n</code></pre>\n\n<p>then we get the appropriate <code>close</code> calls:</p>\n\n<pre>\nConstructing Example$InnerMost\nConstructing Example$Middle\nConstructing Example$OuterMost\nExample$Middle closed\nExample$InnerMost closed\nExample$InnerMost closed\nIn catch block\nIn finally block\nAt end of main\n</pre>\n\n<p>(Yes, two calls to <code>InnerMost#close</code> is correct; one is from <code>Middle</code>, the other from try-with-resources.)</p>\n", "title": "Is it necessary to close each nested OutputStream and Writer separately?", "tags": ["java", "file-io", "outputstream", "writer"], "link": "http://stackoverflow.com/questions/28276423/is-it-necessary-to-close-each-nested-outputstream-and-writer-separately/28276498#28276498", "post_type": "answer", "question_id": 28276423, "answer_id": 28276498}, {"body": "<p>This is of course a <em>\"feature\"</em>. The <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html#computeIfAbsent-K-java.util.function.Function-\"><code>ConcurrentHashMap.computeIfAbsent()</code></a> Javadoc reads:</p>\n\n<blockquote>\n  <p>If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless null. The entire method invocation is performed atomically, so the function is applied at most once per key. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and <strong><em>must not attempt to update any other mappings of this map</em></strong>.</p>\n</blockquote>\n\n<p>The <em>\"must not\"</em> wording is a clear contract, which my algorithm violated, although not for the same concurrency reasons.</p>\n\n<p>What's still interesting is that there is no <code>ConcurrentModificationException</code>. Instead, the program just never halts - which still is a rather dangerous bug in my opinion (i.e. <a href=\"http://blog.jooq.org/2015/01/16/infinite-loops-or-anything-that-can-possibly-go-wrong-does/\">infinite loops. or: anything that can possibly go wrong, does</a>).</p>\n\n<p>The simplest use-site solution for this concrete problem would be to not use a <code>ConcurrentHashMap</code>, but just a <code>HashMap</code> instead:</p>\n\n<pre><code>static Map&lt;Integer, Integer&gt; cache = new HashMap&lt;&gt;();\n</code></pre>\n\n<p>Now, everything works fine.</p>\n\n<h3>Note:</h3>\n\n<p>The <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html#computeIfAbsent-K-java.util.function.Function-\"><code>HashMap.computeIfAbsent()</code></a> or <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Map.html#computeIfAbsent-K-java.util.function.Function-\"><code>Map.computeIfAbsent()</code></a> Javadoc don't forbid such recursive computation, which is of course ridiculous as the type of the cache is <code>Map&lt;Integer, Integer&gt;</code>, not <code>ConcurrentHashMap&lt;Integer, Integer&gt;</code>. It is very dangerous for subtypes to drastically re-define super type contracts (<code>Set</code> vs. <code>SortedSet</code> is greeting). <strong>It should thus be forbidden also in super types, to perform such recursion.</strong></p>\n", "title": "Recursive ConcurrentHashMap.computeIfAbsent() call never terminates. Bug or &quot;feature&quot;?", "tags": ["java", "recursion", "java-8", "concurrenthashmap"], "link": "http://stackoverflow.com/questions/28840047/recursive-concurrenthashmap-computeifabsent-call-never-terminates-bug-or-fea/28840048#28840048", "post_type": "answer", "question_id": 28840047, "answer_id": 28840048}, {"body": "<p>Three questions: three-part answer:</p>\n\n<h3>Is it okay from a design point of view?</h3>\n\n<p>Absolutely. Nothing wrong with it. If you need to do lots of iterating over your enum, the stream API is the clean way to go and hiding the boiler plate behind a little method is fine. Although I\u2019d consider <a href=\"http://stackoverflow.com/users/823393/oldcurmudgeon\">OldCumudgeon</a>\u2019s <a href=\"http://stackoverflow.com/a/29922602/66686\">version</a> even better.</p>\n\n<h3>Is it okay from a performance point of view?</h3>\n\n<p>It most likely doesn\u2019t matter. Most of the time, enums are not that big. Therefore, whatever overhead there is for one method or the other probably doesn\u2019t matter in 99.9% of the cases.</p>\n\n<p>Of course, there are the 0.1% where it does. In that case: measure properly, with your real-world data and consumers.</p>\n\n<p>If I had to bet, I\u2019d expect the <code>for each</code> loop to be faster, since it maps more directly to the memory model, but don\u2019t guess when talking performance, and don\u2019t tune before there is actual need for tuning. Write your code in a way that is correct first, easy to read second and only then worry about performance of code style.</p>\n\n<h3>Why aren\u2019t Enums properly integrated into the Stream API?</h3>\n\n<p>If you compare Java\u2019s Stream API to the equivalent in many other languages, it appears seriously limited. There are various pieces that are missing (reusable Streams and Optionals as Streams, for example). On the other hand, implementing the Stream API was certainly a huge change for the API. It was postponed multiple times for a reason. So I guess Oracle wanted to limit the changes to the most important use cases. Enums aren\u2019t used that much anyway. Sure, every project has a couple of them, but they\u2019re nothing compared to the number of Lists and other Collections. Even when you have an Enum, in many cases you  won\u2019t ever iterate over it. Lists and Sets, on the other hand, are probably iterated over almost every time. I assume that these were the reasons why the Enums didn\u2019t get their own adapter to the Stream world. We\u2019ll see whether more of this gets added in future versions. And until then you always can use <code>Arrays.stream</code>.</p>\n", "title": "Java 8 way to work with an enum", "tags": ["java", "design", "enums", "java-8"], "link": "http://stackoverflow.com/questions/29922296/java-8-way-to-work-with-an-enum/29922831#29922831", "post_type": "answer", "question_id": 29922296, "answer_id": 29922831}, {"body": "<p>I think the shortest code to get a <code>Stream</code> of enum constants is <code>Stream.of(Letter.values())</code>. It's not as nice as <code>Letter.values().stream()</code> but that's an issue with arrays, not specifically enums.</p>\n\n<blockquote>\n  <p>Moreover, why don't enums have a <code>stream()</code> method?</p>\n</blockquote>\n\n<p>You are right that the nicest possible call would be <code>Letter.stream()</code>. Unfortunately a class cannot have two methods with the same signature, so it would not be possible to implicitly add a static method <code>stream()</code> to every enum (in the same way that every enum has an implicitly added static method <code>values()</code>) as this would break every existing enum that already has a static or instance method without parameters called <code>stream()</code>.</p>\n\n<blockquote>\n  <p>Is this approach OK?</p>\n</blockquote>\n\n<p>I think so. The drawback is that <code>stream</code> is a static method, so there is no way to avoid code duplication; it would have to be added to every enum separately.</p>\n", "title": "Java 8 way to work with an enum", "tags": ["java", "design", "enums", "java-8"], "link": "http://stackoverflow.com/questions/29922296/java-8-way-to-work-with-an-enum/29923793#29923793", "post_type": "answer", "question_id": 29922296, "answer_id": 29923793}, {"body": "<p>From the <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html\">docs</a></p>\n\n<blockquote>\n  <p>Reduction operations\n  A reduction operation (also called a fold) takes a sequence of input elements and combines them into a single summary result by repeated application of a combining operation, such as finding the sum or maximum of a set of numbers, or accumulating elements into a list. The streams classes have multiple forms of general reduction operations, called reduce() and collect(), as well as multiple specialized reduction forms such as sum(), max(), or count().</p>\n  \n  <p>Of course, such operations can be readily implemented as simple sequential loops, as in:</p>\n\n<pre><code>int sum = 0;\nfor (int x : numbers) {\n   sum += x;\n}\n</code></pre>\n  \n  <p>However, there are good reasons to prefer a reduce operation over a mutative accumulation such as the above. Not only is a reduction \"more abstract\" -- it operates on the stream as a whole rather than individual elements -- but a properly constructed reduce operation is inherently parallelizable, so long as the function(s) used to process the elements are associative and stateless. For example, given a stream of numbers for which we want to find the sum, we can write:</p>\n\n<pre><code>int sum = numbers.stream().reduce(0, (x,y) -&gt; x+y);\n</code></pre>\n  \n  <p>or:</p>\n\n<pre><code>int sum = numbers.stream().reduce(0, Integer::sum);\n</code></pre>\n  \n  <p>These reduction operations can run safely in parallel with almost no modification:</p>\n\n<pre><code>int sum = numbers.parallelStream().reduce(0, Integer::sum);\n</code></pre>\n</blockquote>\n\n<p>So, for a map you would use:</p>\n\n<pre><code>integers.values().stream().mapToInt(i -&gt; i).reduce(0, (x,y) -&gt; x+y);\n</code></pre>\n\n<p>Or:</p>\n\n<pre><code>integers.values().stream().reduce(0, Integer::sum);\n</code></pre>\n", "title": "How to sum a list of integers with java streams?", "tags": ["java", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/30125296/how-to-sum-a-list-of-integers-with-java-streams/30125423#30125423", "post_type": "answer", "question_id": 30125296, "answer_id": 30125423}, {"body": "<p>The short answer is: it's safe if you use them safely :)  </p>\n\n<p>The snarky answer: tell me what <em>you</em> mean by traits, and maybe I'll give you a better answer :)  </p>\n\n<p>In all seriousness, the term \"trait\" is not well-defined.  Many Java developers are most familiar with traits as they are expressed in Scala, but Scala is far from the first language to have traits, either in name or in effect.  </p>\n\n<p>For example, in Scala, traits are stateful (can have <code>var</code> variables); in Fortress they are pure behavior.  Java's interfaces with default methods are stateless; does this mean they are not traits?  (Hint: that was a trick question.)  </p>\n\n<p>Again, in Scala, traits are composed through linearization; if class <code>A</code> extends traits <code>X</code> and <code>Y</code>, then the order in which <code>X</code> and <code>Y</code> are mixed in determines how conflicts between <code>X</code> and <code>Y</code> are resolved.  In Java, this linearization mechanism is not present (it was rejected, in part, because it was too \"un-Java-like\".)  </p>\n\n<p>The proximate reason for adding default methods to interfaces was to support <em>interface evolution</em>, but we were well aware that we were going beyond that.  Whether you consider that to be \"interface evolution++\" or \"traits--\" is a matter of personal interpretation.  So, to answer your question about safety ... so long as you stick to what the mechanism actually supports, rather than trying to wishfully stretch it to something it does not support, you should be fine.</p>\n\n<p>A key design goal was that, from the perspective of the <em>client</em> of an interface, default methods should be indistinguishable from \"regular\" interface methods.  The default-ness of a method, therefore, is only interesting to the <em>designer</em> and <em>implementor</em> of the interface.  </p>\n\n<p>Here are some use cases that are well within the design goals:</p>\n\n<ul>\n<li><p>Interface evolution.  Here, we are adding a new method to an existing interface, which has a sensible default implementation in terms of existing methods on that interface.  An example would be adding the <code>forEach</code> method to <code>Collection</code>, where the default implementation is written in terms of the <code>iterator()</code> method.  </p></li>\n<li><p>\"Optional\" methods.  Here, the designer of an interface is saying \"Implementors need not implement this method if they are willing to live with the limitations in functionality that entails\".  For example, <code>Iterator.remove</code> was given a default which throws <code>UnsupportedOperationException</code>; since the vast majority of implementations of <code>Iterator</code> have this behavior anyway, the default makes this method essentially optional.  (If the behavior from <code>AbstractCollection</code> were expressed as defaults on <code>Collection</code>, we might do the same for the mutative methods.)  </p></li>\n<li><p>Convenience methods.  These are methods that are strictly for convenience, again generally implemented in terms of non-default methods on the class.  The <code>logger()</code> method in your first example is a reasonable illustration of this.</p></li>\n<li><p>Combinators.  These are compositional methods that instantiate new instances of the interface based on the current instance.  For example, the methods <code>Predicate.and()</code> or <code>Comparator.thenComparing()</code> are examples of combinators.  </p></li>\n</ul>\n\n<p>If you provide a default implementation, you should also provide some specification for the default (in the JDK, we use the <code>@implSpec</code> javadoc tag for this) to aid implementors in understanding whether they want to override the method or not.  Some defaults, like convenience methods and combinators, are almost never overridden; others, like optional methods, are often overridden.  You need to provide enough specification (not just documentation) about what the default promises to do, so the implementor can make a sensible decision about whether they need to override it.</p>\n", "title": "Java 8 default methods as traits : safe?", "tags": ["java", "java-8", "trait", "default-method"], "link": "http://stackoverflow.com/questions/28681737/java-8-default-methods-as-traits-safe/28684917#28684917", "post_type": "answer", "question_id": 28681737, "answer_id": 28684917}, {"body": "<p>You can use Arrays.stream E.g.</p>\n\n<pre><code>Arrays.stream(array);\n</code></pre>\n\n<p>You can also use <code>Stream.of</code> as mentioned by @fge , which looks like</p>\n\n<pre><code>public static&lt;T&gt; Stream&lt;T&gt; of(T... values) {\n    return Arrays.stream(values);\n}\n</code></pre>\n\n<p>But note <code>Stream.of(intArray)</code> will return <code>Stream&lt;int[]&gt;</code> whereas <code>Arrays.stream(intArr)</code> will return <code>IntStream</code> providing you pass an array of type <code>int[]</code>. So in a nutshell for primitives type you can observe the difference between 2 methods E.g.</p>\n\n<pre><code>int[] arr = {1, 2};\nStream&lt;int[]&gt; arr1 = Stream.of(arr);\n\nIntStream stream2 = Arrays.stream(arr); \n</code></pre>\n\n<p>When you pass primitive array to <code>Arrays.stream</code>, the following code is invoked</p>\n\n<pre><code>public static IntStream stream(int[] array) {\n    return stream(array, 0, array.length);\n}\n</code></pre>\n\n<p>and when you pass primitive array to <code>Stream.of</code> the following code is invoked</p>\n\n<pre><code> public static&lt;T&gt; Stream&lt;T&gt; of(T t) {\n     return StreamSupport.stream(new Streams.StreamBuilderImpl&lt;&gt;(t), false);\n }\n</code></pre>\n\n<p>Hence you get different results.</p>\n\n<p><strong>Updated</strong>: As mentioned by <a href=\"http://stackoverflow.com/users/1441122/stuart-marks\">Stuart Marks</a> comment\nThe subrange overload of <code>Arrays.stream</code> is preferable to using <code>Stream.of(array).skip(n).limit(m)</code> because the former results in a SIZED stream whereas the latter does not. The reason is that <code>limit(m)</code> doesn't know whether the size is m or less than m, whereas <code>Arrays.stream</code> does range checks and knows the exact size of the stream\nYou can read the source code for stream implementation returned by <code>Arrays.stream(array,start,end)</code>  <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/ReferencePipeline.java#ReferencePipeline.Head\">here</a>, whereas for stream implementation returned by <code>Stream.of(array).skip().limit()</code> is within <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/SliceOps.java#SliceOps.makeRef%28java.util.stream.AbstractPipeline%2Clong%2Clong%29\">this method</a>.</p>\n", "title": "How can I create a stream from an array?", "tags": ["java", "arrays", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/27888429/how-can-i-create-a-stream-from-an-array/27888447#27888447", "post_type": "answer", "question_id": 27888429, "answer_id": 27888447}, {"body": "<p>Alternative to @sol4me's solution:</p>\n\n<pre><code>Stream.of(theArray)\n</code></pre>\n\n<p>Of the difference between this and <code>Arrays.stream()</code>: it <em>does</em> make a difference if your array is of a primitive type. For instance, if you do:</p>\n\n<pre><code>Arrays.stream(someArray)\n</code></pre>\n\n<p>where <code>someArray</code> is a <code>long[]</code>, it will return a <code>LongStream</code>. <code>Stream.of()</code>, on the other hand, will return a <code>Stream&lt;long[]&gt;</code> with a single element.</p>\n", "title": "How can I create a stream from an array?", "tags": ["java", "arrays", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/27888429/how-can-i-create-a-stream-from-an-array/27888452#27888452", "post_type": "answer", "question_id": 27888429, "answer_id": 27888452}, {"body": "<pre><code>Stream.of(\"foo\", \"bar\", \"baz\")\n</code></pre>\n\n<p>Or, if you are already have an array, you can also do </p>\n\n<pre><code>Stream.of(array) \n</code></pre>\n\n<p>For primitive types use <code>IntStream.of</code> or <code>LongStream.of</code> etc.</p>\n", "title": "How can I create a stream from an array?", "tags": ["java", "arrays", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/27888429/how-can-i-create-a-stream-from-an-array/27888481#27888481", "post_type": "answer", "question_id": 27888429, "answer_id": 27888481}, {"body": "<p>As stated previously, you should lock on both accounts, always in the same order. The key part, however, is ensuring both high granularity and singularity across the VM instance. This can be done using <a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#intern()\" rel=\"nofollow\"><code>String.intern()</code></a>:</p>\n\n<pre><code>public boolean transfer(Account from, Account to, BigDecimal amount) {\n    String fromAccountId = from.id.toString().intern();\n    String toAccountId = to.id.toString().intern();\n    String lock1, lock2;\n\n    if (from.id &lt; to.id) {\n       lock1 = fromAccountId;\n       lock2 = toAccountId;\n    } else {\n       lock1 = toAccountId;\n       lock2 = fromAccountId;\n    }\n\n    // synchronizing from this point, since balances are checked\n    synchronized(lock1) {\n        synchronized(lock2) {\n            BigDecimal fromValue = from.getAmount();\n            if (amount.compareTo(fromValue) &lt; 0)\n                 return false;\n            BigDecimal toValue = to.getAmount();\n            from.setAmount(fromValue.add(amount.negate()));\n            to.setAmount(toValue.add(amount));\n            return true;\n        }\n    }\n}\n</code></pre>\n", "title": "Java synchronisation: atomically moving money across account pairs?", "tags": ["java", "multithreading"], "link": "http://stackoverflow.com/questions/29280857/java-synchronisation-atomically-moving-money-across-account-pairs/29382161#29382161", "post_type": "answer", "question_id": 29280857, "answer_id": 29382161}, {"body": "<p>The best answer is already given (XOR-ing the elements), this is to provide an alternative, more general way.</p>\n\n<p>If the input array would be sorted (we can make it sorted), we could simply iterate over the elements in pairs (stepping by 2) and if the elements of the \"pair\" are different, we're done:</p>\n\n<pre><code>public static int findSingle(int[] arr) {\n    Arrays.sort(arr);\n    for (int i = 0, max = arr.length - 1; i &lt; max; i += 2)\n        if (arr[i] != arr[i + 1])\n            return arr[i];\n    return arr[arr.length - 1]; // Single element is the last\n}\n</code></pre>\n\n<p><strong>Note:</strong> This solution sorts the input array; if this is unwanted or not allowed, it can be cloned first:</p>\n\n<pre><code>arr = arr.clone();\n</code></pre>\n\n<p>If input array is sorted, the <code>Arrays.sort(arr)</code> call can be left out of course.</p>\n\n<h3>Generalization</h3>\n\n<p>The advantage of this solution is that it can be applied to all types which are comparable and therefore can be sorted (types which implement <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html\" rel=\"nofollow\"><code>Comparable</code></a>), for example <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\" rel=\"nofollow\"><code>String</code></a> or <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Date.html\" rel=\"nofollow\"><code>Date</code></a>. The <code>XOR</code> solution is limited to numbers only.</p>\n\n<p>Here is a slightly modified version which takes an input array of any element type which is comparable:</p>\n\n<pre><code>public static &lt;E extends Comparable&lt;E&gt;&gt; E findSingle(E[] arr) {\n    Arrays.sort(arr);\n    for (int i = 0, max = arr.length - 1; i &lt; max; i += 2)\n        if (arr[i].compareTo(arr[i + 1]) != 0)\n            return arr[i];\n    return arr[arr.length - 1]; // Single element is the last\n}\n</code></pre>\n\n<p><em>Note: In most cases you could also use <code>arr[i].equals(arr[i + 1])</code> to compare elements instead of using <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo-T-\" rel=\"nofollow\"><code>Comparable.compareTo()</code></a>. For details read the linked javadoc. Quoting the relevant part:</em></p>\n\n<blockquote>\n  <p>It is strongly recommended, but <em>not</em> strictly required that <code>(x.compareTo(y)==0) == (x.equals(y))</code>. Generally speaking, any class that implements the <code>Comparable</code> interface and violates this condition should clearly indicate this fact. The recommended language is \"Note: this class has a natural ordering that is inconsistent with equals.\"</p>\n</blockquote>\n\n<p>Now you can call this with a <code>String[]</code> for example:</p>\n\n<pre><code>System.out.println(findSingle(new String[] { \"1\", \"2\", \"3\", \"1\", \"3\" }));\n</code></pre>\n\n<p>Output:</p>\n\n<pre><code>2\n</code></pre>\n\n<p><strong>Final notes:</strong></p>\n\n<p>Starting from the problem statement it is not checked whether there are more than 2 occurrences of the elements, and neither is whether the array length is odd. Also the second example doesn't check for <code>null</code> values, these are to be added if necessary.</p>\n", "title": "How to find the only number in an array that doesn&#39;t occur twice", "tags": ["java", "arrays", "algorithm"], "link": "http://stackoverflow.com/questions/29333689/how-to-find-the-only-number-in-an-array-that-doesnt-occur-twice/29341981#29341981", "post_type": "answer", "question_id": 29333689, "answer_id": 29341981}]}