{"items": [{"body": "<p>In this code when I create an Object in the <code>main</code> method and then call that objects method: <code>ff.twentyDivCount(i)</code>(runs in 16010 ms) , it runs much faster than calling it using this annotation: <code>twentyDivCount(i)</code>(runs in 59516 ms). Of course, when I run it without creating an object, I make the method static, so it can be called in the main.</p>\n\n<pre><code>public class ProblemFive {\n\n    // Counts the number of numbers that the entry is evenly divisible by, as max is 20\n    int twentyDivCount(int a) {    // Change to static int.... when using it directly\n        int count = 0;\n        for (int i = 1; i&lt;21; i++) {\n\n            if (a % i == 0) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        long startT = System.currentTimeMillis();;\n        int start = 500000000;\n        int result = start;\n\n        ProblemFive ff = new ProblemFive();\n\n        for (int i = start; i &gt; 0; i--) {\n\n            int temp = ff.twentyDivCount(i); // Faster way\n                       // twentyDivCount(i) - slower\n\n            if (temp == 20) {\n                result = i;\n                System.out.println(result);\n            }\n        }\n\n        System.out.println(result);\n\n        long end = System.currentTimeMillis();;\n        System.out.println((end - startT) + \" ms\");\n    }\n}\n</code></pre>\n\n<p>EDIT: So far it seems that different machines produce different results, but using JRE 1.8.* is where the original result seems to be consistently reproduced.</p>\n", "title": "Large difference in speed of equivalent static and non static methods", "tags": ["java", "performance", "object", "methods", "static"], "link": "http://stackoverflow.com/questions/30454904/large-difference-in-speed-of-equivalent-static-and-non-static-methods", "post_type": "question", "question_id": 30454904}, {"body": "<p>Is it a safe practice to use <strong>default methods as a poor's man version of traits</strong> in Java 8?</p>\n\n<p><a href=\"http://zeroturnaround.com/rebellabs/how-your-addiction-to-java-8-default-methods-may-make-pandas-sad-and-your-teammates-angry/\">Some claim it may make pandas sad</a> if you use them just for the sake of it, because it's cool, but that's not my intention. It is also often reminded that default methods were introduced to support API evolution and backward compatibility, which is true, but this does not make it wrong or twisted to use them as traits per se.</p>\n\n<p>I have <a href=\"http://www.opencredo.com/2015/01/30/traits-java-8-default-methods/\">the following practical use case</a> in mind:</p>\n\n<pre><code>public interface Loggable {\n    default Logger logger() {\n        return LoggerFactory.getLogger(this.getClass());\n    }\n}\n</code></pre>\n\n<p>Or perhaps, define a <code>PeriodTrait</code>:</p>\n\n<pre><code>public interface PeriodeTrait {\n    Date getStartDate();\n    Date getEndDate();\n    default isValid(Date atDate) {\n        ...\n    }\n}\n</code></pre>\n\n<p>Admitedly, composition could be used (or even helper classes) but it seems more verbose and cluttered and does not allow to benefit from polymorphism.</p>\n\n<p>So, <strong>is it ok/safe to use default methods as basic traits</strong>, or should I be worried about unforeseen side effects?</p>\n\n<p><a href=\"http://stackoverflow.com/search?q=java+default+method+trait\">Several questions</a> on SO are related to Java vs Scala traits; that's not the point here. I'm not asking merely for opinions either. Instead, I'm looking for an authoritative answer or at least field insight: if you've used default methods as traits on your corporate project, did it turn out to be a timebomb?</p>\n", "title": "Java 8 default methods as traits : safe?", "tags": ["java", "java-8", "trait", "default-method"], "link": "http://stackoverflow.com/questions/28681737/java-8-default-methods-as-traits-safe", "post_type": "question", "question_id": 28681737}, {"body": "<p>I just stumbled upon something. At first I thought it might be a case of branch misprediction like it is <a href=\"http://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-an-unsorted-array\">in this case</a>, but I cannot explain why branch misprediction should cause this phenomenon. I implemented two versions of Bubble Sort in Java and did some performance tests:</p>\n\n<pre><code>import java.util.Random;\n\npublic class BubbleSortAnnomaly {\n\n    public static void main(String... args) {\n        final int ARRAY_SIZE = Integer.parseInt(args[0]);\n        final int LIMIT = Integer.parseInt(args[1]);\n        final int RUNS = Integer.parseInt(args[2]);\n\n        int[] a = new int[ARRAY_SIZE];\n        int[] b = new int[ARRAY_SIZE];\n        Random r = new Random();\n        for (int run = 0; RUNS &gt; run; ++run) {\n            for (int i = 0; i &lt; ARRAY_SIZE; i++) {\n                a[i] = r.nextInt(LIMIT);\n                b[i] = a[i];\n            }\n\n            System.out.print(\"Sorting with sortA: \");\n            long start = System.nanoTime();\n            int swaps = bubbleSortA(a);\n\n            System.out.println(  (System.nanoTime() - start) + \" ns. \"\n                               + \"It used \" + swaps + \" swaps.\");\n\n            System.out.print(\"Sorting with sortB: \");\n            start = System.nanoTime();\n            swaps = bubbleSortB(b);\n\n            System.out.println(  (System.nanoTime() - start) + \" ns. \"\n                               + \"It used \" + swaps + \" swaps.\");\n        }\n    }\n\n    public static int bubbleSortA(int[] a) {\n        int counter = 0;\n        for (int i = a.length - 1; i &gt;= 0; --i) {\n            for (int j = 0; j &lt; i; ++j) {\n                if (a[j] &gt; a[j + 1]) {\n                    swap(a, j, j + 1);\n                    ++counter;\n                }\n            }\n        }\n        return (counter);\n    }\n\n    public static int bubbleSortB(int[] a) {\n        int counter = 0;\n        for (int i = a.length - 1; i &gt;= 0; --i) {\n            for (int j = 0; j &lt; i; ++j) {\n                if (a[j] &gt;= a[j + 1]) {\n                    swap(a, j, j + 1);\n                    ++counter;\n                }\n            }\n        }\n        return (counter);\n    }\n\n    private static void swap(int[] a, int j, int i) {\n        int h = a[i];\n        a[i] = a[j];\n        a[j] = h;\n    }\n}\n</code></pre>\n\n<p>As you can see, the only difference between those two sorting methods is the <code>&gt;</code> vs. <code>&gt;=</code>. When running the program with <code>java BubbleSortAnnomaly 50000 10 10</code>, you would obviously expect that <code>sortB</code> is slower than <code>sortA</code>. But I got the following (or similar) output on three different machines:</p>\n\n<pre><code>Sorting with sortA: 4.214 seconds. It used  564960211 swaps.\nSorting with sortB: 2.278 seconds. It used 1249750569 swaps.\nSorting with sortA: 4.199 seconds. It used  563355818 swaps.\nSorting with sortB: 2.254 seconds. It used 1249750348 swaps.\nSorting with sortA: 4.189 seconds. It used  560825110 swaps.\nSorting with sortB: 2.264 seconds. It used 1249749572 swaps.\nSorting with sortA: 4.17  seconds. It used  561924561 swaps.\nSorting with sortB: 2.256 seconds. It used 1249749766 swaps.\nSorting with sortA: 4.198 seconds. It used  562613693 swaps.\nSorting with sortB: 2.266 seconds. It used 1249749880 swaps.\nSorting with sortA: 4.19  seconds. It used  561658723 swaps.\nSorting with sortB: 2.281 seconds. It used 1249751070 swaps.\nSorting with sortA: 4.193 seconds. It used  564986461 swaps.\nSorting with sortB: 2.266 seconds. It used 1249749681 swaps.\nSorting with sortA: 4.203 seconds. It used  562526980 swaps.\nSorting with sortB: 2.27  seconds. It used 1249749609 swaps.\nSorting with sortA: 4.176 seconds. It used  561070571 swaps.\nSorting with sortB: 2.241 seconds. It used 1249749831 swaps.\nSorting with sortA: 4.191 seconds. It used  559883210 swaps.\nSorting with sortB: 2.257 seconds. It used 1249749371 swaps.\n</code></pre>\n\n<p>When you set the parameter for <code>LIMIT</code> to, e.g., <code>50000</code> (<code>java BubbleSortAnnomaly 50000 50000 10</code>), you get the expected results:</p>\n\n<pre><code>Sorting with sortA: 3982697438 ns. It used 625941897 swaps.\nSorting with sortB: 4657909823 ns. It used 789391382 swaps.\n</code></pre>\n\n<p>I ported the program to C++ to determine whether this problem is Java-specific. Here is the C++ code.</p>\n\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n\n#include &lt;omp.h&gt;\n\n#ifndef ARRAY_SIZE\n#define ARRAY_SIZE 50000\n#endif\n\n#ifndef LIMIT\n#define LIMIT 10\n#endif\n\n#ifndef RUNS\n#define RUNS 10\n#endif\n\nvoid swap(int * a, int i, int j)\n{\n    int h = a[i];\n    a[i] = a[j];\n    a[j] = h;\n}\n\nint bubbleSortA(int * a)\n{\n    const int LAST = ARRAY_SIZE - 1;\n    int counter = 0;\n    for (int i = LAST; i &gt; 0; --i)\n    {\n        for (int j = 0; j &lt; i; ++j)\n        {\n            int next = j + 1;\n            if (a[j] &gt; a[next])\n            {\n                swap(a, j, next);\n                ++counter;\n            }\n        }\n    }\n    return (counter);\n}\n\nint bubbleSortB(int * a)\n{\n    const int LAST = ARRAY_SIZE - 1;\n    int counter = 0;\n    for (int i = LAST; i &gt; 0; --i)\n    {\n        for (int j = 0; j &lt; i; ++j)\n        {\n            int next = j + 1;\n            if (a[j] &gt;= a[next])\n            {\n                swap(a, j, next);\n                ++counter;\n            }\n        }\n    }\n    return (counter);\n}\n\nint main()\n{\n    int * a = (int *) malloc(ARRAY_SIZE * sizeof(int));\n    int * b = (int *) malloc(ARRAY_SIZE * sizeof(int));\n    for (int run = 0; RUNS &gt; run; ++run)\n    {\n        for (int idx = 0; idx &lt; ARRAY_SIZE; ++idx)\n        {\n            a[idx] = std::rand() % LIMIT;\n            b[idx] = a[idx];\n        }\n\n        std::cout &lt;&lt; \"Sorting with sortA: \";\n        double start = omp_get_wtime();\n        int swaps = bubbleSortA(a);\n\n        std::cout &lt;&lt; (omp_get_wtime() - start) &lt;&lt; \" seconds. It used \" &lt;&lt; swaps\n                  &lt;&lt; \" swaps.\" &lt;&lt; std::endl;\n\n        std::cout &lt;&lt; \"Sorting with sortB: \";\n        start = omp_get_wtime();\n        swaps = bubbleSortB(b);\n\n        std::cout &lt;&lt; (omp_get_wtime() - start) &lt;&lt; \" seconds. It used \" &lt;&lt; swaps\n                  &lt;&lt; \" swaps.\" &lt;&lt; std::endl;\n    }\n\n    free(a);\n    free(b);\n\n    return (0);\n}\n</code></pre>\n\n<p>This program shows the same behaviour. Can someone explain, what exactly is going on here?</p>\n\n<p>Executing <code>sortB</code> first and then <code>sortA</code> does not change the results.</p>\n", "title": "&gt; vs. &gt;= causes significant performance difference", "tags": ["java", "c++", "performance", "optimization"], "link": "http://stackoverflow.com/questions/30223441/vs-causes-significant-performance-difference", "post_type": "question", "question_id": 30223441}, {"body": "<p>Of course, the main difference is - method can use static fields, not only method parameters.\nBut there is additional one - polymorphism! \nResults of evaluation Class A.doTheSameStaticMethod() and ClassB.doTheSameStaticMehod() will be depends of class. In this case function is impotent.</p>\n", "title": "Why is a static method considered a method?", "tags": ["java", "methods", "static", "terminology"], "link": "http://stackoverflow.com/questions/30402169/why-is-a-static-method-considered-a-method/30486215#30486215", "post_type": "answer", "question_id": 30402169, "answer_id": 30486215}, {"body": "<h1>Background</h1>\n\n<p>While the question appears simple, the actual answer requires some background to make sense. If you want to skip to the conclusion, scroll down...</p>\n\n<h2>Pick your comparison point - Basic functionality</h2>\n\n<p>Using basic concepts, C#'s <code>IEnumerable</code> concept is more closely related to <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html\">Java's <code>Iterable</code></a>, which is able to create as many <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\">Iterators</a> as you want. <a href=\"https://msdn.microsoft.com/en-us/library/System.Collections.IEnumerable(v=vs.110).aspx\"><code>IEnumerables</code></a> create <a href=\"https://msdn.microsoft.com/en-us/library/system.collections.ienumerator(v=vs.110).aspx\"><code>IEnumerators</code></a>. Java's <code>Iterable</code> create <code>Iterators</code></p>\n\n<p>The history of each concept is similar, in that both <code>IEnumerable</code> and <code>Iterable</code> have a basic motivation to allow 'for-each' style looping over the members of data collections. That's an oversimplification as they both allow more than just that, and they also arrived at that stage via different progressions, but it is a significant common feature regardless.</p>\n\n<p>Let's compare that feature: in both languages, if a class implements the <code>IEnumerable</code>/<code>Iterable</code>, then that class must implement at least a single method (for C#, it's <code>GetEnumerator</code> and for Java it's <code>iterator()</code>). In each case, the instance returned from that (<code>IEnumerator</code>/<code>Iterator</code>) allows you to access the current and subsequent members of the data. This feature is used in the for-each language syntax.</p>\n\n<h2>Pick your comparison point - Enhanced functionality</h2>\n\n<p><code>IEnumerable</code> in C# has been extended to allow a number of other language features (<a href=\"https://msdn.microsoft.com/en-us/library/vstudio/system.linq.enumerable(v=vs.100).aspx\">mostly related to Linq</a>). Features added include selections, projections, aggregations, etc. These extensions have a strong motivation from use in set-theory, similar to SQL and Relational Database concepts.</p>\n\n<p>Java 8 has also had functionality added to enable a degree of functional programming using Streams and Lambdas. Note that Java 8 streams are not primarily motivated by set theory, but by functional programming. Regardless, there are a lot of parallels.</p>\n\n<p>So, this is the second point. The enhancements made to C# were implemented as an enhancement to the <code>IEnumerable</code> concept. In Java, though, the enhancements made were implemented by creating new base concepts of Lambdas and Streams, and then also creating a relatively trivial way to convert from <code>Iterators</code> and <code>Iterables</code> to Streams, and visa-versa.</p>\n\n<p>So, comparing IEnumerable to Java's Stream concept is incomplete. You need to compare it to the combined Streams and Collections API's in Java.</p>\n\n<h2>In Java, Streams are not the same as Iterables, or Iterators</h2>\n\n<p>Streams are not designed to solve problems the same way that iterators are:</p>\n\n<ul>\n<li>Iterators are a way of describing the sequence of data.</li>\n<li>Streams are a way of describing a sequence of data transformations.</li>\n</ul>\n\n<p>With an <code>Iterator</code>, you get a data value, process it, and then get another data value.</p>\n\n<p>With Streams, you chain a sequence of functions together, then you feed an input value to the stream, and get the output value from the combined sequence. Note, in Java terms, each function is encapsulated in a single <code>Stream</code> instance. The Streams API allows you to link a sequence of <code>Stream</code> instances in a way that chains a sequence of transformation expressions.</p>\n\n<p>In order to complete the <code>Stream</code> concept, you need a source of data to feed the stream, and a terminal function that consumes the stream.</p>\n\n<p>The way you feed values in to the stream may in fact be from an <code>Iterable</code>, but the <code>Stream</code> sequence itself is not an <code>Iterable</code>, it is a compound function.</p>\n\n<p>A <code>Stream</code> is also intended to be lazy, in the sense that it only does work when you request a value from it.</p>\n\n<p>Note these significant assumptions and features of Streams:</p>\n\n<ul>\n<li>A <code>Stream</code> in Java is a transformation engine, it transforms a data item in one state, to being in another state.</li>\n<li>streams have no concept of the data order or position, the simply transform whatever they are asked to.</li>\n<li>streams can be supplied with data from many sources, including other streams, Iterators, Iterables, Collections, </li>\n<li>you cannot \"reset\" a stream, that would be like \"reprogramming the transformation\". Resetting the data source is probably what you want.</li>\n<li>there is logically only 1 data item 'in flight' in the stream at any time (unless the stream is a parallel stream, at which point, there is 1 item per thread). This is independent of the data source which may have more than the current items 'ready' to be supplied to the stream, or the stream collector which  may need to aggregate and reduce multiple values.</li>\n<li>Streams can be unbound (infinite), limited only by the data source, or collector (which can be infinite too).</li>\n<li>Streams are 'chainable', the output of filtering one stream, is another stream. Values input to and transformed by a stream can in turn be supplied to another stream which does a different transformation. The data, in its transformed state flows from one stream to the next. You do not need to intervene and pull the data from one stream and plug it in to the next.</li>\n</ul>\n\n<h2>C# Comparison</h2>\n\n<p>When you consider that a Java Stream is just a part of a supply, stream, and collect system, and that Streams and Iterators are often used together with Collections, then it is no wonder that it is hard to relate to the same concepts which are almost all embedded in to a single <code>IEnumerable</code> concept in C#.</p>\n\n<p>Parts of IEnumerable (and close related concepts) are apparent in all of the Java Iterator, Iterable, Lambda, and Stream concepts.</p>\n\n<p>There are small things that the Java concepts can do that are harder in IEnumerable, and visa-versa.</p>\n\n<hr>\n\n<h1>Conclusion</h1>\n\n<ul>\n<li>There's no design problem here, just a problem in matching concepts between the languages.</li>\n<li>Streams solve problems in a different way</li>\n<li>Streams add functionality to Java (they add a different way of doing things, they do not take functionality away)</li>\n</ul>\n\n<p>Adding Streams gives you more choices when solving problems, which is fair to classify as 'enhancing power', not 'reducing', 'taking away', or 'restricting' it.</p>\n\n<h3>Why are Java Streams once-off?</h3>\n\n<p>This question is misguided, because streams are function sequences, not data. Depending on the data source that feeds the stream, you can reset the data source, and feed the same, or different stream.</p>\n\n<h3>Unlike C#'s IEnumerable, where an execution pipeline can be executed as many times as we want, in Java a stream can be 'iterated' only once.</h3>\n\n<p>Comparing an <code>IEnumerable</code> to a <code>Stream</code> is misguided. The context you are using to say <code>IEnumerable</code> can be executed as many times as you want, is best compared to Java <code>Iterables</code>, which can be iterated as many times as you want. A Java <code>Stream</code> represents a subset of the <code>IEnumerable</code> concept, and not the subset that supplies data, and thus cannot be 'rerun'.</p>\n\n<h3>Any call to a terminal operation closes the stream, rendering it unusable. This 'feature' takes away a lot of power.</h3>\n\n<p>The first statement is true, in a sense. The 'takes away power' statement is not. You are still comparing Streams it IEnumerables. The terminal operation in the stream is like a 'break' clause in a for loop. You are always free to have another stream, if you want, and if you can re-supply the data you need. Again, if you consider the <code>IEnumerable</code> to be more like an <code>Iterable</code>, for this statement, Java does it just fine.</p>\n\n<h3>I imagine the reason for this is not technical. What were the design considerations behind this strange restriction?</h3>\n\n<p>The reason is technical, and for the simple reason that a Stream a subset of what think it is. The stream subset does not control the data supply, so you should reset the supply, not the stream. In that context, it is not so strange.</p>\n\n<h3>QuickSort example</h3>\n\n<p>Your quicksort example has the signature:</p>\n\n<pre><code>IEnumerable&lt;int&gt; QuickSort(IEnumerable&lt;int&gt; ints)\n</code></pre>\n\n<p>You are treating the input <code>IEnumerable</code> as a data source:</p>\n\n<pre><code>IEnumerable&lt;int&gt; lt = ints.Where(i =&gt; i &lt; pivot);\n</code></pre>\n\n<p>Additionally, return value is <code>IEnumerable</code> too, which is a supply of data, and since this is a Sort operation, the order of that supply is significant. If you consider the Java <code>Iterable</code> class to be the appropriate match for this, specifically the <code>List</code> specialization of <code>Iterable</code>, since List is a supply of data which has a guaranteed order or iteration, then the equivalent Java code to your code would be:</p>\n\n<pre><code>Stream&lt;Integer&gt; quickSort(List&lt;Integer&gt; ints) {\n    // Using a stream to access the data, instead of the simpler ints.isEmpty()\n    if (!ints.stream().findAny().isPresent()) {\n        return Stream.of();\n    }\n\n    // treating the ints as a data collection, just like the C#\n    final Integer pivot = ints.get(0);\n\n    // Using streams to get the two partitions\n    List&lt;Integer&gt; lt = ints.stream().filter(i -&gt; i &lt; pivot).collect(Collectors.toList());\n    List&lt;Integer&gt; gt = ints.stream().filter(i -&gt; i &gt; pivot).collect(Collectors.toList());\n\n    return Stream.concat(Stream.concat(quickSort(lt), Stream.of(pivot)),quickSort(gt));\n}    \n</code></pre>\n\n<p>Note there is a bug (which I have reproduced), in that the sort does not handle duplicate values gracefully, it is a 'unique value' sort.</p>\n\n<p>Also note how the Java code uses data source (<code>List</code>), and stream concepts at different point, and that in C# those two 'personalities' can be expressed in just <code>IEnumerable</code>. Also, although I have use <code>List</code> as the base type, I could have used the more general <code>Collection</code>, and with a small iterator-to-Stream conversion, I could have used the even more general <code>Iterable</code></p>\n", "title": "Why are Java Streams once-off?", "tags": ["java", "java-8", "java-stream", "api-design"], "link": "http://stackoverflow.com/questions/28459498/why-are-java-streams-once-off/28459604#28459604", "post_type": "answer", "question_id": 28459498, "answer_id": 28459604}, {"body": "<p><code>Stream</code>s are built around <code>Spliterator</code>s which are stateful, mutable objects. They don\u2019t have a \u201creset\u201d action and in fact, requiring to support such rewind action would \u201ctake away much power\u201d. How would <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Random.html#ints--\"><code>Random.ints()</code></a> be supposed to handle such a request?</p>\n\n<p>On the other hand, for <code>Stream</code>s which have a retraceable origin, it is easy to construct an equivalent <code>Stream</code> to be used again. Just put the steps made to construct the <code>Stream</code> into a reusable method. Keep in mind that repeating these steps is not an expensive operation as all these steps are lazy operations; the actual work starts with the terminal operation and depending on the actual terminal operation entirely different code might get executed.</p>\n\n<p>It would be up to you, the writer of such a method, to specify what calling the method twice implies: does it reproduce exactly the same sequence, as streams created for an unmodified array or collection do, or does it produce a stream with a similar semantics but different elements like a stream of random ints or a stream of console input lines, etc.</p>\n\n<hr>\n\n<p>By the way, to avoid confusion, a terminal operation <em>consumes</em> the <code>Stream</code> which is distinct from <em>closing</em> the <code>Stream</code> as calling <code>close()</code> on the stream does (which is required for streams having associated resources like, e.g. produced by <code>Files.lines()</code>).</p>\n\n<hr>\n\n<p>It seems that a lot of confusion stems from misguiding comparison of <code>IEnumerable</code> with <code>Stream</code>. An <code>IEnumerable</code> represents the ability to provide an actual <code>IEnumerator</code>, so its like an <code>Iterable</code> in Java. In contrast, a <code>Stream</code> is a kind of iterator and comparable to an <code>IEnumerator</code> so it\u2019s wrong to claim that this kind of data type can be used multiple times in .NET, the support for <code>IEnumerator.Reset</code> is optional. The examples discussed here rather use the fact that an <code>IEnumerable</code> can be used to fetch <em>new</em> <code>IEnumerator</code>s and that works with Java\u2019s <code>Collection</code>s  as well; you can get a new <code>Stream</code>. If the Java developers decided to add the <code>Stream</code> operations to <code>Iterable</code> directly, with intermediate operations returning another <code>Iterable</code>, it was really comparable and it could work the same way.</p>\n\n<p>However, the developers decided against it and the decision is discussed in <a href=\"http://stackoverflow.com/q/24472312/2711488\">this question</a>. The biggest point is the confusion about eager Collection operations and lazy Stream operations. By looking at the .NET API, I (yes, personally) find it justified. While it looks reasonable looking at <code>IEnumerable</code> alone, a particular Collection will have lots of methods manipulating the Collection directly and lots of methods returning a lazy <code>IEnumerable</code>, while the particular nature of a method isn\u2019t always intuitively recognizable. The worst example I found (within the few minutes I looked at it) is <a href=\"https://msdn.microsoft.com/de-de/library/b0axc2h2(v=vs.110).aspx\"><code>List.Reverse()</code></a> whose name matches <em>exactly</em> the name of the inherited (is this the right terminus for extension methods?) <a href=\"https://msdn.microsoft.com/de-de/library/bb358497(v=vs.110).aspx\"><code>Enumerable.Reverse()</code></a> while having an entirely contradicting behavior.</p>\n\n<hr>\n\n<p>Of course, these are two distinct decisions. The first one to make <code>Stream</code> a type distinct from <code>Iterable</code>/<code>Collection</code> and the second to make <code>Stream</code> a kind of one time iterator rather than another kind of iterable. But these decision were made together and it might be the case that separating these two decision never was considered. It wasn\u2019t created with being comparable to .NET\u2019s in mind.</p>\n\n<p>The actual API design decision was to add an improved type of iterator, the <code>Spliterator</code>. <code>Spliterator</code>s can be provided by the old <code>Iterable</code>s (which is the way how these were retrofitted) or entirely new implementations. Then, <code>Stream</code> was added as a high-level front-end to the rather low level <code>Spliterator</code>s. That\u2019s it. You may discuss about whether a different design would be better, but that\u2019s not productive, it won\u2019t change, given the way they are designed now.</p>\n\n<p>There is another implementation aspect you have to consider. <code>Stream</code>s are <em>not</em> immutable data structures. Each intermediate operation may return a new <code>Stream</code> instance encapsulating the old one but it may also manipulate its own instance instead and return itself (that doesn\u2019t preclude doing even both for the same operation). Commonly known examples are operations like <code>parallel</code> or <code>unordered</code> which do not add another step but manipulate the entire pipeline). Having such a mutable data structure and attempts to reuse (or even worse, using it multiple times at the same time) doesn\u2019t play well\u2026</p>\n\n<hr>\n\n<p>For completeness, here is your quicksort example translated to the Java <code>Stream</code> API. It shows that it does not really \u201ctake away much power\u201d.</p>\n\n<pre><code>static Stream&lt;Integer&gt; quickSort(Supplier&lt;Stream&lt;Integer&gt;&gt; ints) {\n\n  final Optional&lt;Integer&gt; optPivot = ints.get().findAny();\n  if(!optPivot.isPresent()) return Stream.empty();\n\n  final int pivot = optPivot.get();\n\n  Supplier&lt;Stream&lt;Integer&gt;&gt; lt = ()-&gt;ints.get().filter(i -&gt; i &lt; pivot);\n  Supplier&lt;Stream&lt;Integer&gt;&gt; gt = ()-&gt;ints.get().filter(i -&gt; i &gt; pivot);\n\n  return Stream.of(quickSort(lt), Stream.of(pivot), quickSort(gt)).flatMap(s-&gt;s);\n}\n</code></pre>\n\n<p>It can be used like</p>\n\n<pre><code>List&lt;Integer&gt; l=new Random().ints(100, 0, 1000).boxed().collect(Collectors.toList());\nSystem.out.println(l);\nSystem.out.println(quickSort(l::stream)\n    .map(Object::toString).collect(Collectors.joining(\", \")));\n</code></pre>\n\n<p>You can write it even more compact as</p>\n\n<pre><code>static Stream&lt;Integer&gt; quickSort(Supplier&lt;Stream&lt;Integer&gt;&gt; ints) {\n    return ints.get().findAny().map(pivot -&gt;\n         Stream.of(\n                   quickSort(()-&gt;ints.get().filter(i -&gt; i &lt; pivot)),\n                   Stream.of(pivot),\n                   quickSort(()-&gt;ints.get().filter(i -&gt; i &gt; pivot)))\n        .flatMap(s-&gt;s)).orElse(Stream.empty());\n}\n</code></pre>\n", "title": "Why are Java Streams once-off?", "tags": ["java", "java-8", "java-stream", "api-design"], "link": "http://stackoverflow.com/questions/28459498/why-are-java-streams-once-off/28460301#28460301", "post_type": "answer", "question_id": 28459498, "answer_id": 28460301}, {"body": "<p>I think there are very few differences between the two when you look closely enough.</p>\n\n<p>At it's face, an <code>IEnumerable</code> does appear to be a reusable construct:</p>\n\n<pre><code>IEnumerable&lt;int&gt; numbers = new int[] { 1, 2, 3, 4, 5 };\n\nforeach (var n in numbers) {\n    Console.WriteLine(n);\n}\n</code></pre>\n\n<p>However, the compiler is actually doing a little bit of work to help us out; it generates the following code:</p>\n\n<pre><code>IEnumerable&lt;int&gt; numbers = new int[] { 1, 2, 3, 4, 5 };\n\nIEnumerator&lt;int&gt; enumerator = numbers.GetEnumerator();\nwhile (enumerator.MoveNext()) {\n    Console.WriteLine(enumerator.Current);\n}\n</code></pre>\n\n<p>Each time you would actually iterate over the enumerable, the compiler creates an enumerator.  The enumerator is not reusable; further calls to <code>MoveNext</code> will just return false, and there is no way to reset it to the beginning.  If you want to iterate over the numbers again, you will need to create another enumerator instance.</p>\n\n<hr>\n\n<p>To better illustrate that the IEnumerable has (can have) the same 'feature' as a Java Stream, consider a enumerable whose source of the numbers is not a static collection.  For example, we can create an enumerable object which generates a sequence of 5 random numbers:</p>\n\n<pre><code>class Generator : IEnumerator&lt;int&gt; {\n    Random _r;\n    int _current;\n    int _count = 0;\n\n    public Generator(Random r) {\n        _r = r;\n    }\n\n    public bool MoveNext() {\n        _current= _r.Next();\n        _count++;\n        return _count &lt;= 5;\n    }\n\n    public int Current {\n        get { return _current; }\n    }\n }\n\nclass RandomNumberStream : IEnumerable&lt;int&gt; {\n    Random _r = new Random();\n    public IEnumerator&lt;int&gt; GetEnumerator() {\n        return new Generator(_r);\n    }\n    public IEnumerator IEnumerable.GetEnumerator() {\n        return this.GetEnumerator();\n    }\n}\n</code></pre>\n\n<p>Now we have very similar code to the previous array-based enumerable, but with a second iteration over <code>numbers</code>:</p>\n\n<pre><code>IEnumerable&lt;int&gt; numbers = new RandomNumberStream();\n\nforeach (var n in numbers) {\n    Console.WriteLine(n);\n}\nforeach (var n in numbers) {\n    Console.WriteLine(n);\n}\n</code></pre>\n\n<p>The second time we iterate over <code>numbers</code> we will get a different sequence of numbers, which isn't reusable in the same sense.  Or, we could have written the <code>RandomNumberStream</code> to thrown an exception if you try to iterate over it multiple times, making the enumerable actually unusable (like a Java Stream).</p>\n\n<p>Also, what does your enumerable-based quick sort mean when applied to a <code>RandomNumberStream</code>?</p>\n\n<hr>\n\n<h2>Conclusion</h2>\n\n<p>So, the biggest difference is that .NET allows you to reuse an <code>IEnumerable</code> by implicitly creating a new <code>IEnumerator</code> in the background whenever it would need to access elements in the sequence.</p>\n\n<p>This implicit behavior is often useful (and 'powerful' as you state), because we can repeatedly iterate over a collection.</p>\n\n<p>But sometimes, this implicit behavior can actually cause problems.  If your data source is not static, or is costly to access (like a database or web site), then a lot of assumptions about <code>IEnumerable</code> have to be discarded; reuse is not that straight-forward</p>\n", "title": "Why are Java Streams once-off?", "tags": ["java", "java-8", "java-stream", "api-design"], "link": "http://stackoverflow.com/questions/28459498/why-are-java-streams-once-off/28465634#28465634", "post_type": "answer", "question_id": 28459498, "answer_id": 28465634}, {"body": "<p>I have some recollections from the early design of the Streams API that might shed some light on the design rationale.</p>\n\n<p>Back in 2012, we were adding lambdas to the language, and we wanted a collections-oriented or \"bulk data\" set of operations, programmed using lambdas, that would facilitate parallelism. The idea of lazily chaining operations together was well established by this point. We also didn't want the intermediate operations to store results.</p>\n\n<p>The main issues we needed to decide were what the objects in the chain looked like in the API and how they hooked up to data sources. The sources were often collections, but we also wanted to support data coming from a file or the network, or data generated on-the-fly, e.g., from a random number generator.</p>\n\n<p>There were many influences of existing work on the design. Among the more influential were Google's <a href=\"https://code.google.com/p/guava-libraries/\">Guava</a> library and the Scala collections library. (If anybody is surprised about the influence from Guava, note that <a href=\"http://stackoverflow.com/users/202214/kevin-bourrillion\">Kevin Bourrillion</a>, Guava lead developer, was on the <a href=\"https://jcp.org/en/jsr/detail?id=335\">JSR-335 Lambda</a> expert group.) On Scala collections, we found this talk by Martin Odersky to be of particular interest: <a href=\"http://youtu.be/HoIOIluNFzQ\">Future-Proofing Scala Collections: from Mutable to Persistent to Parallel</a>. (Stanford EE380, 2011 June 1.)</p>\n\n<p>Our prototype design at the time was based around <code>Iterable</code>. The familiar operations <code>filter</code>, <code>map</code>, and so forth were extension (default) methods on <code>Iterable</code>. Calling one added an operation to the chain and returned another <code>Iterable</code>. A terminal operation like <code>count</code> would call <code>iterator()</code> up the chain to the source, and the operations were implemented within each stage's Iterator.</p>\n\n<p>Since these are Iterables, you can call the <code>iterator()</code> method more than once. What should happen then?</p>\n\n<p>If the source is a collection, this mostly works fine. Collections are Iterable, and each call to <code>iterator()</code> produces a distinct Iterator instance that is independent of any other active instances, and each traverses the collection independently. Great.</p>\n\n<p>Now what if the source is one-shot, like reading lines from a file? Maybe the first Iterator should get all the values but the second and subsequent ones should be empty. Maybe the values should be interleaved among the Iterators. Or maybe each Iterator should get all the same values. Then, what if you have two iterators and one gets farther ahead of the other? Somebody will have to buffer up the values in the second Iterator until they're read. Worse, what if you get one Iterator and read all the values, and only <em>then</em> get a second Iterator. Where do the values come from now? Is there a requirement for them all to be buffered up <em>just in case</em> somebody wants a second Iterator?</p>\n\n<p>Clearly, allowing multiple Iterators over a one-shot source raises a lot of questions. We didn't have good answers for them. We wanted consistent, predictable behavior for what happens if you call <code>iterator()</code> twice. This pushed us toward disallowing multiple traversals, making the pipelines one-shot.</p>\n\n<p>We also observed others bumping into these issues. In the JDK, most Iterables are collections or collection-like objects, which allow multiple traversal. It isn't specified anywhere, but there seemed to be an unwritten expectation that Iterables allow multiple traversal. A notable exception is the NIO <a href=\"http://docs.oracle.com/javase/8/docs/api/java/nio/file/DirectoryStream.html\">DirectoryStream</a> interface. Its specification includes this interesting warning:</p>\n\n<blockquote>\n  <p><strong>While DirectoryStream extends Iterable, it is not a general-purpose Iterable as it supports only a single Iterator; invoking the iterator method to obtain a second or subsequent iterator throws IllegalStateException.</strong></p>\n</blockquote>\n\n<p>[bold in original]</p>\n\n<p>This seemed unusual and unpleasant enough that we didn't want to create a whole bunch of new Iterables that might be once-only. This pushed us away from using Iterable.</p>\n\n<p>About this time, an <a href=\"http://www.artima.com/weblogs/viewpost.jsp?thread=339521\">article by Bruce Eckel</a> appeared that described a spot of trouble he'd had with Scala. He'd written this code:</p>\n\n<pre><code>// Scala\nval lines = fromString(data).getLines\nval registrants = lines.map(Registrant)\nregistrants.foreach(println)\nregistrants.foreach(println)\n</code></pre>\n\n<p>It's pretty straightforward. It parses lines of text into <code>Registrant</code> objects and prints them out twice. Except that it actually only prints them out once. It turns out that he thought that <code>registrants</code> was a collection, when in fact it's an iterator. The second call to <code>foreach</code> encounters an empty iterator, from which all values have been exhausted, so it prints nothing.</p>\n\n<p>This kind of experience convinced us that it was very important to have clearly predictable results if multiple traversal is attempted. It also highlighted the importance of distinguishing between lazy pipeline-like structures from actual collections that store data. This in turn drove the separation of the lazy pipeline operations into the new Stream interface and keeping only eager, mutative operations directly on Collections. <a href=\"http://stackoverflow.com/a/24472635/1441122\">Brian Goetz has explained</a> the rationale for that.</p>\n\n<p>What about allowing multiple traversal for collection-based pipelines but disallowing it for non-collection-based pipelines? It's inconsistent, but it's sensible. If you're reading values from the network, <em>of course</em> you can't traverse them again. If you want to traverse them multiple times, you have to pull them into a collection explicitly.</p>\n\n<p>But let's explore allowing multiple traversal from collections-based pipelines. Let's say you did this:</p>\n\n<pre><code>Iterable&lt;?&gt; it = source.filter(...).map(...).filter(...).map(...);\nit.into(dest1);\nit.into(dest2);\n</code></pre>\n\n<p>(The <code>into</code> operation is now spelled <code>collect(toList())</code>.)</p>\n\n<p>If source is a collection, then the first <code>into()</code> call will create a chain of Iterators back to the source, execute the pipeline operations, and send the results into the destination. The second call to <code>into()</code> will create another chain of Iterators, and execute the pipeline operations <strong>again</strong>. This isn't obviously wrong but it does have the effect of performing all the filter and map operations a second time for each element. I think many programmers would have been surprised by this behavior.</p>\n\n<p>As I mentioned above, we had been talking to the Guava developers. One of the cool things they have is an <a href=\"https://code.google.com/p/guava-libraries/wiki/IdeaGraveyard\">Idea Graveyard</a> where they describe features that they decided <strong>not</strong> to implement along with the reasons. The idea of lazy collections sounds pretty cool, but here's what they have to say about it. Consider a <code>List.filter()</code> operation that returns a <code>List</code>:</p>\n\n<blockquote>\n  <p>The biggest concern here is that too many operations become expensive, linear-time propositions. If you want to filter a list and get a list back, and not just a Collection or an Iterable, you can use <code>ImmutableList.copyOf(Iterables.filter(list, predicate))</code>, which \"states up front\" what it's doing and how expensive it is.</p>\n</blockquote>\n\n<p>To take a specific example, what's the cost of <code>get(0)</code> or <code>size()</code> on a List? For commonly used classes like <code>ArrayList</code>, they're O(1). But if you call one of these on a lazily-filtered list, it has to run the filter over the backing list, and all of a sudden these operations are O(n). Worse, it has to traverse the backing list on <strong>every</strong> operation.</p>\n\n<p>This seemed to us to be <em>too much</em> laziness. It's one thing to set up some operations and defer actual execution until you so \"Go\". It's another to set things up in such a way that hides a potentially large amount of recomputation.</p>\n\n<p>In proposing to disallow non-linear or \"no-reuse\" streams, <a href=\"http://stackoverflow.com/users/4042945/paul-sandoz\">Paul Sandoz</a> described the <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-experts/2012-November/000412.html\">potential consequences</a> of allowing them as giving rise to \"unexpected or confusing results.\" He also mentioned that parallel execution would make things even trickier. Finally, I'd add that a pipeline operation with side effects would lead to difficult and obscure bugs if the operation were unexpectedly executed multiple times, or at least a different number of times than the programmer expected. (But Java programmers don't write lambda expressions with side effects, do they? DO THEY??)</p>\n\n<p>So that's the basic rationale for the Java 8 Streams API design that allows one-shot traversal and that requires a strictly linear (no branching) pipeline. It provides consistent behavior across multiple different stream sources, it clearly separates lazy from eager operations, and it provides a straightforward execution model.</p>\n\n<hr>\n\n<p>With regard to <code>IEnumerable</code>, I am far from an expert on C# and .NET, so I would appreciate being corrected (gently) if I draw any incorrect conclusions. It does appear, however, that <code>IEnumerable</code> permits multiple traversal to behave differently with different sources; and it permits a branching structure of nested <code>IEnumerable</code> operations, which may result in some significant recomputation. While I appreciate that different systems make different tradeoffs, these are two characteristics that we sought to avoid in the design of the Java 8 Streams API.</p>\n\n<p>The quicksort example given by the OP is interesting, puzzling, and I'm sorry to say, somewhat horrifying. Calling <code>QuickSort</code> takes an <code>IEnumerable</code> and returns an <code>IEnumerable</code>, so no sorting is actually done until the final <code>IEnumerable</code> is traversed. What the call seems to do, though, is build up a tree structure of <code>IEnumerables</code> that reflects the partitioning that quicksort would do, without actually doing it. (This is lazy computation, after all.) If the source has N elements, the tree will be N elements wide at its widest, and it will be lg(N) levels deep.</p>\n\n<p>It seems to me -- and once again, I'm not a C# or .NET expert -- that this will cause certain innocuous-looking calls, such as pivot selection via <code>ints.First()</code>, to be more expensive than they look. At the first level, of course, it's O(1). But consider a partition deep in the tree, at the right-hand edge. To compute the first element of this partition, the entire source has to be traversed, an O(N) operation. But since the partitions above are lazy, they must be recomputed, requiring O(lg N) comparisons. So selecting the pivot would be an O(N lg N) operation, which is as expensive as an entire sort.</p>\n\n<p>But we don't actually sort until we traverse the returned <code>IEnumerable</code>. In the standard quicksort algorithm, each level of partitioning doubles the number of partitions. Each partition is only half the size, so each level remains at O(N) complexity. The tree of partitions is O(lg N) high, so the total work is O(N lg N).</p>\n\n<p>With the tree of lazy IEnumerables, at the bottom of the tree there are N partitions. Computing each partition requires a traversal of N elements, each of which requires lg(N) comparisons up the tree. To compute all the partitions at the bottom of the tree, then, requires O(N^2 lg N) comparisons.</p>\n\n<p>(Is this right? I can hardly believe this. Somebody please check this for me.)</p>\n\n<p>In any case, it is indeed cool that <code>IEnumerable</code> can be used this way to build up complicated structures of computation. But if it does increase the computational complexity as much as I think it does, it would seem that programming this way is something that should be avoided unless one is extremely careful.</p>\n", "title": "Why are Java Streams once-off?", "tags": ["java", "java-8", "java-stream", "api-design"], "link": "http://stackoverflow.com/questions/28459498/why-are-java-streams-once-off/28513908#28513908", "post_type": "answer", "question_id": 28459498, "answer_id": 28513908}, {"body": "<p>This question is closely related to <a href=\"https://en.wikipedia.org/wiki/Aspect-oriented_programming\" rel=\"nofollow\">aspect-oriented programming</a>. AspectJ is an AOP extension of Java and you may give it a look to get some ispiration.</p>\n\n<p>As far as I know there is no direct support for AOP in Java. There are some GOF patterns that relate to it, like for instance <a href=\"https://en.wikipedia.org/wiki/Template_method_pattern\" rel=\"nofollow\">Template Method</a> and <a href=\"https://en.wikipedia.org/wiki/Strategy_pattern\" rel=\"nofollow\">Strategy</a> but it will not really save you lines of code.</p>\n\n<p>In Java and most other languages you could define the recurrent logic you need in functions and adopt a so-called disciplined coding approach in which you call them at the right time.</p>\n\n<pre><code>public void checkBalance() {\n    checkSomePrecondition();\n    ...\n    checkSomePostcondition();\n}\n</code></pre>\n\n<p>However this would not fit your case because you would like the factored-out code to be able to return from <code>checkBalance</code>. In languages that support macros (like C/C++) you could define <code>checkSomePrecondition</code> and <code>checkSomePostcondition</code> as macros and they would simply be replaced by the preprocessor before the compiler is even invoked:</p>\n\n<pre><code>#define checkSomePrecondition \\\n    if (!fooIsEnabled) return;\n</code></pre>\n\n<p>Java does not have this out of the box. This may offend someone but I did use automatic code generation and template engines to automate repetitive coding tasks in the past. If you process your Java files before compiling them with a suitable preprocessor, for instance Jinja2, you could do something similar to what is possible in C.</p>\n\n<h2>Possible pure Java approach</h2>\n\n<p>If you are looking for a pure Java solution, what you may find is probably not going to be concise. But, it could still factor out common parts of your program and avoid code duplication and bugs. You could do something like this (it's some sort of <a href=\"https://en.wikipedia.org/wiki/Strategy_pattern\" rel=\"nofollow\">Strategy</a>-inspired pattern). Note that in C# and Java 8, and in other languages in which functions are a little easier to handle, this approach may actually look nice.</p>\n\n<pre><code>public interface Code {\n    void execute();\n}\n\n...\n\npublic class Foo {\n  private bool fooIsEnabled;\n\n  private void protect(Code c) {\n      if (!fooIsEnabled) return;\n      c.execute();\n  }\n\n  public void bar() {\n    protect(new Code {\n      public void execute() {\n        System.out.println(\"bar\");\n      }\n    });\n  }\n\n  public void baz() {\n    protect(new Code {\n      public void execute() {\n        System.out.println(\"baz\");\n      }\n    });\n  }\n\n  public void bat() {\n    protect(new Code {\n      public void execute() {\n        System.out.println(\"bat\");\n      }\n    });\n  }\n}\n</code></pre>\n\n<h1>Kinda of a real-world scenario</h1>\n\n<p>You are developing a class to send data frames to an industrial robot. The robot takes time to complete a command. Once the command is completed, it sends you a control frame back. The robot may get damaged if it receives a new command while the previous is still being executed. Your program uses a <code>DataLink</code> class to send and receive frames to and from the robot. You need to protect access to the <code>DataLink</code> instance.</p>\n\n<p>The user interface thread calls <code>RobotController.left</code>, <code>right</code>, <code>up</code> or <code>down</code> when the user clicks the buttons, but also calls <code>BaseController.tick</code> at regular intervals, in order to reenable command forwarding to the private <code>DataLink</code> instance.</p>\n\n<pre><code>interface Code {\n    void ready(DataLink dataLink);\n}\n\nclass BaseController {\n    private DataLink mDataLink;\n    private boolean mReady = false;\n    private Queue&lt;Code&gt; mEnqueued = new LinkedList&lt;Code&gt;();\n\n    public BaseController(DataLink dl) {\n        mDataLink = dl;\n    }\n\n    protected void protect(Code c) {\n        if (mReady) {\n            mReady = false;\n            c.ready(mDataLink);\n        }\n        else {\n            mEnqueue.add(c);\n        }\n    }\n\n    public void tick() {\n        byte[] frame = mDataLink.readWithTimeout(/* Not more than 50 ms */);\n\n        if (frame != null &amp;&amp; /* Check that it's an ACK frame */) {\n          if (mEnqueued.isEmpty()) {\n              mReady = true;\n          }\n          else {\n              Code c = mEnqueued.remove();\n              c.ready(mDataLink);\n          }\n        }\n    }\n}\n\nclass RobotController extends BaseController {\n    public void left(float amount) {\n        protect(new Code() { public void ready(DataLink dataLink) {\n            dataLink.write(/* Create a byte[] that means 'left' by amount */);\n        }});\n    }\n\n    public void right(float amount) {\n        protect(new Code() { public void ready(DataLink dataLink) {\n            dataLink.write(/* Create a byte[] that means 'right' by amount */);\n        }});\n    }\n\n    public void up(float amount) {\n        protect(new Code() { public void ready(DataLink dataLink) {\n            dataLink.write(/* Create a byte[] that means 'up' by amount */);\n        }});\n    }\n\n    public void down(float amount) {\n        protect(new Code() { public void ready(DataLink dataLink) {\n            dataLink.write(/* Create a byte[] that means 'down' by amount */);\n        }});\n    }\n}\n</code></pre>\n", "title": "Is there an elegant way to make every method in a class start with a certain block of code?", "tags": ["java", "design-patterns"], "link": "http://stackoverflow.com/questions/31121513/is-there-an-elegant-way-to-make-every-method-in-a-class-start-with-a-certain-blo/31122066#31122066", "post_type": "answer", "question_id": 31121513, "answer_id": 31122066}, {"body": "<p>I don't know about elegant, but here is a working implementation using Java's built-in <code>java.lang.reflect.Proxy</code> that <strong><em>enforces</em></strong> that all method invocations on <code>Foo</code> begin by checking the <code>enabled</code> state.</p>\n\n<p><code>main</code> method:</p>\n\n<pre><code>public static void main(String[] args) {\n    Foo foo = Foo.newFoo();\n    foo.setEnabled(false);\n    foo.bar(); // won't print anything.\n    foo.setEnabled(true);\n    foo.bar(); // prints \"Executing method bar\"\n}\n</code></pre>\n\n<p><code>Foo</code> interface:</p>\n\n<pre><code>public interface Foo {\n    boolean getEnabled();\n    void setEnabled(boolean enable);\n\n    void bar();\n    void baz();\n    void bat();\n\n    // Needs Java 8 to have this convenience method here.\n    static Foo newFoo() {\n        FooFactory fooFactory = new FooFactory();\n        return fooFactory.makeFoo();\n    }\n}\n</code></pre>\n\n<p><code>FooFactory</code> class:</p>\n\n<pre><code>import java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class FooFactory {\n\n    public Foo makeFoo() {\n        return (Foo) Proxy.newProxyInstance(\n                this.getClass().getClassLoader(),\n                new Class[]{Foo.class},\n                new FooInvocationHandler(new FooImpl()));\n    }\n\n    private static class FooImpl implements Foo {\n        private boolean enabled = false;\n\n        @Override\n        public boolean getEnabled() {\n            return this.enabled;\n        }\n\n        @Override\n        public void setEnabled(boolean enable) {\n            this.enabled = enable;\n        }\n\n        @Override\n        public void bar() {\n            System.out.println(\"Executing method bar\");\n        }\n\n        @Override\n        public void baz() {\n            System.out.println(\"Executing method baz\");\n        }\n\n        @Override\n        public void bat() {\n            System.out.println(\"Executing method bat\");\n        }\n\n    }\n\n    private static class FooInvocationHandler implements InvocationHandler {\n\n        private FooImpl fooImpl;\n\n        public FooInvocationHandler(FooImpl fooImpl) {\n            this.fooImpl = fooImpl;\n        }\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            if (method.getDeclaringClass() == Foo.class &amp;&amp;\n                !method.getName().equals(\"getEnabled\") &amp;&amp;\n                !method.getName().equals(\"setEnabled\")) {\n\n                if (!this.fooImpl.getEnabled()) {\n                    return null;\n                }\n            }\n\n            return method.invoke(this.fooImpl, args);\n        }\n    }\n}\n</code></pre>\n\n<p>As others have pointed out, it does seem like overkill for what you need if you only have a handful of methods to worry about.</p>\n\n<p>That said, there certainly are benefits:</p>\n\n<ul>\n<li>A certain separation of concerns is achieved, because <code>Foo</code>'s method implementations don't have to worry about the <code>enabled</code> check cross-cutting concern. Instead, the method's code only needs to worry about what the method's primary purpose is, nothing more.</li>\n<li>There is no way for an innocent developer to add a new method to the <code>Foo</code> class and mistakenly \"forget\" to add the <code>enabled</code> check.  The <code>enabled</code> check behavior is automatically inherited by any newly added method.</li>\n<li>If you need to add another cross-cutting concern, or if you need to enhance the <code>enabled</code> check, it's very easy to do so safely and in one place.</li>\n<li>It is kind of nice that you can get this AOP-like behavior with built-in Java functionality. You are not forced into having to integrate some other framework like <code>Spring</code>, though they can definitely be good options too.</li>\n</ul>\n\n<p>To be fair, some of the downsides are:</p>\n\n<ul>\n<li>Some of the implementation code that handles the proxy invocations is ugly. Some would also say that having inner classes to prevent instantiation of the <code>FooImpl</code> class is ugly.</li>\n<li>If you want to add a new method to <code>Foo</code>, you have to make a change in 2 spots: the implementation class and the interface.  Not a big deal, but it's still a bit more work.</li>\n<li>Proxy invocations are not free. There is a certain performance overhead. For general use though, it won't be noticeable. See <a href=\"http://stackoverflow.com/questions/1856242/performance-cost-of-java-dynamic-proxy\">here</a> for more information.</li>\n</ul>\n\n<p><strong>EDIT:</strong></p>\n\n<p>Fabian Streitel's comment got me thinking about 2 annoyances with my above solution that, I'll admit, I'm not happy about myself:</p>\n\n<ol>\n<li>The invocation handler uses magic strings to skip the \"enabled-check\" on the \"getEnabled\" and \"setEnabled\" methods. This can easily break if the method names are refactored.</li>\n<li>If there was a case where new methods need to be added that should not inherit the \"enabled-check\" behavior, then it can be pretty easy for the developer to get this wrong, and at the very least, it would mean adding more magic strings.</li>\n</ol>\n\n<p>To resolve point #1, and to at least ease the problem with point #2, I would create an annotation <code>BypassCheck</code> (or something similar) that I could use to mark the methods in the <code>Foo</code> interface for which I don't want to perform the \"enabled check\".  This way, I don't need magic strings at all, and it becomes a lot easier for a developer to correctly add a new method in this special case.</p>\n\n<p>Using the annotation solution, the code would look like this:</p>\n\n<p><code>main</code> method:</p>\n\n<pre><code>public static void main(String[] args) {\n    Foo foo = Foo.newFoo();\n    foo.setEnabled(false);\n    foo.bar(); // won't print anything.\n    foo.setEnabled(true);\n    foo.bar(); // prints \"Executing method bar\"\n}\n</code></pre>\n\n<p><code>BypassCheck</code> annotation:</p>\n\n<pre><code>import java.lang.annotation.*;\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface BypassCheck {\n}\n</code></pre>\n\n<p><code>Foo</code> interface:</p>\n\n<pre><code>public interface Foo {\n    @BypassCheck boolean getEnabled();\n    @BypassCheck void setEnabled(boolean enable);\n\n    void bar();\n    void baz();\n    void bat();\n\n    // Needs Java 8 to have this convenience method here.\n    static Foo newFoo() {\n        FooFactory fooFactory = new FooFactory();\n        return fooFactory.makeFoo();\n    }\n}\n</code></pre>\n\n<p><code>FooFactory</code> class:</p>\n\n<pre><code>import java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class FooFactory {\n\n    public Foo makeFoo() {\n        return (Foo) Proxy.newProxyInstance(\n                this.getClass().getClassLoader(),\n                new Class[]{Foo.class},\n                new FooInvocationHandler(new FooImpl()));\n    }\n\n    private static class FooImpl implements Foo {\n\n        private boolean enabled = false;\n\n        @Override\n        public boolean getEnabled() {\n            return this.enabled;\n        }\n\n        @Override\n        public void setEnabled(boolean enable) {\n            this.enabled = enable;\n        }\n\n        @Override\n        public void bar() {\n            System.out.println(\"Executing method bar\");\n        }\n\n        @Override\n        public void baz() {\n            System.out.println(\"Executing method baz\");\n        }\n\n        @Override\n        public void bat() {\n            System.out.println(\"Executing method bat\");\n        }\n\n    }\n\n    private static class FooInvocationHandler implements InvocationHandler {\n\n        private FooImpl fooImpl;\n\n        public FooInvocationHandler(FooImpl fooImpl) {\n            this.fooImpl = fooImpl;\n        }\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            if (method.getDeclaringClass() == Foo.class\n                    &amp;&amp; !method.isAnnotationPresent(BypassCheck.class) // no magic strings\n                    &amp;&amp; !this.fooImpl.getEnabled()) {\n\n                return null;\n            }\n\n            return method.invoke(this.fooImpl, args);\n        }\n    }\n}\n</code></pre>\n", "title": "Is there an elegant way to make every method in a class start with a certain block of code?", "tags": ["java", "design-patterns"], "link": "http://stackoverflow.com/questions/31121513/is-there-an-elegant-way-to-make-every-method-in-a-class-start-with-a-certain-blo/31122247#31122247", "post_type": "answer", "question_id": 31121513, "answer_id": 31122247}, {"body": "<p>In a similar functional approach to @Colin's answer, with <a href=\"http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html\" rel=\"nofollow\">Java 8's lambda functions</a>, it is possible to wrap the conditional feature toggle enable / disable code into a guard method (<code>executeIfEnabled</code>) which accepts the action lambda, to which code to be conditionally executed can be passed.</p>\n\n<p>Although in your case, this approach won't save any lines of code, by DRYing this up, you now have the option to centralize other feature toggle concerns, plus AOP or debugging concerns like logging, diagnostics, profiling et al.</p>\n\n<p>One benefit of using lambdas here is that closures can be used to avoid the need to overload the <code>executeIfEnabled</code> method.</p>\n\n<p>For example:</p>\n\n<pre><code>class Foo {\n    private Boolean _fooIsEnabled;\n\n    public Foo(Boolean isEnabled) {\n        _fooIsEnabled = isEnabled;\n    }\n\n    private void executeIfEnabled(java.util.function.Consumer someAction) {\n        // Conditional toggle short circuit\n        if (!_fooIsEnabled) return;\n\n        // Invoke action\n        someAction.accept(null);\n    }\n\n    // Wrap the conditionally executed code in a lambda\n    public void bar() {\n        executeIfEnabled((x) -&gt; {\n            System.out.println(\"Bar invoked\");\n        });\n    }\n\n    // Demo with closure arguments and locals\n    public void baz(int y) {\n        executeIfEnabled((x) -&gt; {\n            System.out.printf(\"Baz invoked %d \\n\", y);\n        });\n    }\n\n    public void bat() {\n        int z = 5;\n        executeIfEnabled((x) -&gt; {\n            System.out.printf(\"Bat invoked %d \\n\", z);\n        });\n    }\n</code></pre>\n\n<p>With a test:</p>\n\n<pre><code>public static void main(String args[]){\n    Foo enabledFoo = new Foo(true);\n    enabledFoo.bar();\n    enabledFoo.baz(33);\n    enabledFoo.bat();\n\n    Foo disabledFoo = new Foo(false);\n    disabledFoo.bar();\n    disabledFoo.baz(66);\n    disabledFoo.bat();\n}\n</code></pre>\n", "title": "Is there an elegant way to make every method in a class start with a certain block of code?", "tags": ["java", "design-patterns"], "link": "http://stackoverflow.com/questions/31121513/is-there-an-elegant-way-to-make-every-method-in-a-class-start-with-a-certain-blo/31469539#31469539", "post_type": "answer", "question_id": 31121513, "answer_id": 31469539}, {"body": "<p>The first form is called <a href=\"http://en.wikipedia.org/wiki/Javadoc\">Javadoc</a>.  You use this when you're writing formal APIs for your code, which are generated by the <code>javadoc</code> tool.  For an example, <a href=\"http://docs.oracle.com/javase/7/docs/api/\">the Java 7 API page</a> uses Javadoc and was generated by that tool.</p>\n\n<p>Some common elements you'd see in Javadoc include:</p>\n\n<ul>\n<li><p><code>@param</code>:  this is used to indicate what parameters are being passed to a method, and what value they're expected to have</p></li>\n<li><p><code>@return</code>:  this is used to indicate what result the method is going to give back</p></li>\n<li><p><code>@throws</code>:  this is used to indicate that a method throws an exception or error in case of certain input</p></li>\n<li><p><code>@since</code>:  this is used to indicate the earliest Java version this class or function was available in</p></li>\n</ul>\n\n<p>As an example, here's Javadoc for the <code>compare</code> method of <code>Integer</code>:</p>\n\n<pre><code>/**\n * Compares two {@code int} values numerically.\n * The value returned is identical to what would be returned by:\n * &lt;pre&gt;\n *    Integer.valueOf(x).compareTo(Integer.valueOf(y))\n * &lt;/pre&gt;\n *\n * @param  x the first {@code int} to compare\n * @param  y the second {@code int} to compare\n * @return the value {@code 0} if {@code x == y};\n *         a value less than {@code 0} if {@code x &lt; y}; and\n *         a value greater than {@code 0} if {@code x &gt; y}\n * @since 1.7\n */\npublic static int compare(int x, int y) {\n    return (x &lt; y) ? -1 : ((x == y) ? 0 : 1);\n}\n</code></pre>\n\n<p>The second form is a block (multi-line) comment.  You use this if you want to have multiple lines in a comment.</p>\n\n<p>I will say that you'd only want to use the latter form <em>sparingly</em>; that is, you don't want to overburden your code with block comments that don't describe what behaviors the method/complex function is supposed to have.</p>\n\n<p>Since Javadoc is the more descriptive of the two, and you can generate actual documentation as a result of using it, using Javadoc would be more preferable to simple block comments.</p>\n", "title": "/** and /* in Java Comments", "tags": ["java", "comments", "javadoc"], "link": "http://stackoverflow.com/questions/29815636/and-in-java-comments/29815698#29815698", "post_type": "answer", "question_id": 29815636, "answer_id": 29815698}, {"body": "<h1>Background</h1>\n\n<p>All Java objects have a <code>toString()</code> method, which is invoked when you try and print the object. </p>\n\n<pre><code>System.out.println(myObject);  // invokes myObject.toString()\n</code></pre>\n\n<p>This method is defined in the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html\"><code>Object</code></a> class (the superclass of all Java objects). The <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString--\"><code>Object.toString()</code></a> method returns a fairly ugly looking string, composed of the name of the class, an <code>@</code> symbol and the <a href=\"http://stackoverflow.com/questions/3563847/what-is-the-use-of-hashcode-in-java\">hashcode</a> of the object in hexadecimal. The code for this looks like:</p>\n\n<pre><code>// Code of Object.toString()\npublic String toString() {\n    return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n}\n</code></pre>\n\n<p>A result such as <code>com.foo.MyType@2f92e0f4</code> can therefore be explained as:</p>\n\n<ul>\n<li><code>com.foo.MyType</code>  - the name of the class, i.e. the class is <code>MyType</code> in the package <code>com.foo</code>.</li>\n<li><code>@</code> - joins the string together</li>\n<li><code>2f92e0f4</code> the hashcode of the object.</li>\n</ul>\n\n<p>The name of array classes look a little different, which is explained well in the Javadocs for <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getName--\"><code>Class.getName()</code></a>. For instance, <code>[Ljava.lang.String</code> means:</p>\n\n<ul>\n<li><code>[</code> - an single-dimensional array (as opposed to <code>[[</code> or <code>[[[</code> etc.)</li>\n<li><code>L</code> - the array contains a class or interface</li>\n<li><code>java.lang.String</code> - the type of objects in the array</li>\n</ul>\n\n<hr>\n\n<h1>Customizing the Output</h1>\n\n<p>To print something different when you call <code>System.out.println(myObject)</code>, you must <a href=\"https://docs.oracle.com/javase/tutorial/java/IandI/override.html\">override</a> the <code>toString()</code> method in your own class. Here's a simple example:</p>\n\n<pre><code>public class Person {\n\n  private String name;\n\n  // constructors and other methods omitted\n\n  @Override\n  public String toString() {\n    return name;\n  }\n}\n</code></pre>\n\n<p>Now if we print a <code>Person</code>, we see their name rather than <code>com.foo.Person@12345678</code>.</p>\n\n<p>Bear in mind that <code>toString()</code> is just <em>one</em> way for an object to be converted to a string. Typically this output should fully describe your object in a clear and concise manner. A better <code>toString()</code> for our <code>Person</code> class might be:</p>\n\n<pre><code>@Override\npublic String toString() {\n  return getClass().getSimpleName() + \"[name=\" + name + \"]\";\n}\n</code></pre>\n\n<p>Which would print, e.g., <code>Person[name=Henry]</code>. That's a really useful piece of data for debugging/testing.</p>\n\n<p>If you want to focus on just one aspect of your object or include a lot of jazzy formatting, you might be better to define a separate method instead, e.g. <code>String toElegantReport() {...}</code>.</p>\n\n<hr>\n\n<h1>Auto-generating the Output</h1>\n\n<p>Many <a href=\"http://en.wikipedia.org/wiki/Integrated_development_environment\">IDEs</a> offer support for auto-generating a <code>toString()</code> method, based on the fields in the class. See docs for <a href=\"http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fref-dialog-tostring.htm\">Eclipse</a> and <a href=\"https://plugins.jetbrains.com/plugin/182?pr=idea\">IntelliJ</a>, for example. </p>\n\n<p>Several popular Java libraries offer this feature as well. Some examples include:</p>\n\n<ul>\n<li><p><a href=\"http://commons.apache.org/proper/commons-lang/javadocs/api-release/org/apache/commons/lang3/builder/ToStringBuilder.html\"><code>ToStringBuilder</code></a> from <a href=\"http://commons.apache.org/proper/commons-lang/\">Apache Commons Lang</a></p></li>\n<li><p><a href=\"http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/base/MoreObjects.html#toStringHelper(java.lang.Object)\"><code>MoreObjects.ToStringHelper</code></a> from <a href=\"https://github.com/google/guava\">Google Guava</a></p></li>\n<li><p><a href=\"http://projectlombok.org/features/ToString.html\"><code>@ToString</code></a> annotation from <a href=\"http://projectlombok.org/\">Project Lombok</a></p></li>\n</ul>\n\n<hr>\n\n<h1>Printing groups of objects</h1>\n\n<p>So you've created a nice <code>toString()</code> for your class. What happens if that class is placed into an array or a collection?</p>\n\n<h2>Arrays</h2>\n\n<p>If you have an array of objects, you can call <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#toString-java.lang.Object:A-\"><code>Arrays.toString()</code></a> to produce a simple representation of the contents of the array. For instance, consider this array of <code>Person</code> objects:</p>\n\n<pre><code>Person[] people = { new Person(\"Fred\"), new Person(\"Mike\") };\nSystem.out.println(Arrays.toString(people));\n\n// Prints: [Fred, Mike]\n</code></pre>\n\n<p>Note:  this is a call to a <em>static</em> method called <code>toString()</code> in the Arrays class, which is different to what we've been discussing above.</p>\n\n<p>If you have a <strong>multi-dimensional array</strong>, you can use <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#deepToString-java.lang.Object:A-\"><code>Arrays.deepToString()</code></a> to achieve the same sort of output.</p>\n\n<h2>Collections</h2>\n\n<p>Most collections will produce a pretty output based on calling <code>.toString()</code> on every element.</p>\n\n<pre><code>List&lt;Person&gt; people = new ArrayList&lt;&gt;();\npeople.add(new Person(\"Alice\"));\npeople.add(new Person(\"Bob\"));    \nSystem.out.println(people);\n\n// Prints [Alice, Bob]\n</code></pre>\n\n<p>So you just need to ensure your list elements define a nice <code>toString()</code> as discussed above.</p>\n", "title": "How do I print my Java object without getting &quot;SomeType@2f92e0f4&quot;?", "tags": ["java", "string", "object", "tostring"], "link": "http://stackoverflow.com/questions/29140402/how-do-i-print-my-java-object-without-getting-sometype2f92e0f4/29140403#29140403", "post_type": "answer", "question_id": 29140402, "answer_id": 29140403}, {"body": "<p>Every class in java has <code>toString()</code> method in it by default, which is called by <code>System.out.println()</code> if you pass some object of a class to it. When you try to print object of a class, the <code>System.out.println()</code> method will call <code>toString()</code> of the class which returns the className@hashcode of that object.</p>\n\n<pre><code>{\n    SomeClass sc = new SomeClass();\n    // Class @ followed by hashcode of object in Hexadecimal\n    System.out.println(sc);\n}\n</code></pre>\n\n<p>You can override the toString method of a class to get different output. See this example</p>\n\n<pre><code>class A {\n    String s = \"I am just a object\";\n    @Override\n    public String toString()\n    {\n        return s;\n    }\n}\n\nclass B {\n    public static void main(String args[])\n    {\n        A obj = new A();\n        System.out.println(obj);\n    }\n}\n</code></pre>\n", "title": "How do I print my Java object without getting &quot;SomeType@2f92e0f4&quot;?", "tags": ["java", "string", "object", "tostring"], "link": "http://stackoverflow.com/questions/29140402/how-do-i-print-my-java-object-without-getting-sometype2f92e0f4/29141638#29141638", "post_type": "answer", "question_id": 29140402, "answer_id": 29141638}, {"body": "<p>In Eclipse,\nGo to your class,\nRight click->source->Generate toString();\nIt will override the toString() method and print the object of that class.</p>\n", "title": "How do I print my Java object without getting &quot;SomeType@2f92e0f4&quot;?", "tags": ["java", "string", "object", "tostring"], "link": "http://stackoverflow.com/questions/29140402/how-do-i-print-my-java-object-without-getting-sometype2f92e0f4/36771568#36771568", "post_type": "answer", "question_id": 29140402, "answer_id": 36771568}, {"body": "<p>In intellij you can auto generate toString method by  pressing alt+inset and then selecting toString() here is an out put for a test class:</p>\n\n<pre><code>public class test  {\nint a;\nchar b;\nString c;\nTest2 test2;\n\n@Override\npublic String toString() {\n    return \"test{\" +\n            \"a=\" + a +\n            \", b=\" + b +\n            \", c='\" + c + '\\'' +\n            \", test2=\" + test2 +\n            '}';\n }\n}\n</code></pre>\n\n<p>As you can see, it generates a String by concatenating, several attributes of the class, for primitives it will print their values and for reference types it will use their class type (in this case to string method of Test2).   </p>\n", "title": "How do I print my Java object without getting &quot;SomeType@2f92e0f4&quot;?", "tags": ["java", "string", "object", "tostring"], "link": "http://stackoverflow.com/questions/29140402/how-do-i-print-my-java-object-without-getting-sometype2f92e0f4/38628203#38628203", "post_type": "answer", "question_id": 29140402, "answer_id": 38628203}, {"body": "<p>You can close the outer most stream, in fact you don't need to retain all the streams wrapped and you can use Java 7 try-with-resources.</p>\n\n<pre><code>try (BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(\n                     new GZIPOutputStream(new FileOutputStream(createdFile)))) {\n     // write to the buffered writer\n}\n</code></pre>\n\n<hr>\n\n<p>If you subscribe to YAGNI, or you-aint-gonna-need-it, you should be only adding code you actually need. You shouldn't be adding code you imagine you might need but in reality doesn't do anything useful.</p>\n\n<p>Take this example and imagine what could possibly go wrong if you didn't do this and what the impact would be?</p>\n\n<pre><code>try (\n    OutputStream outputStream = new FileOutputStream(createdFile);\n    GZIPOutputStream gzipOutputStream = new GZIPOutputStream(outputStream);\n    OutputStreamWriter osw = new OutputStreamWriter(gzipOutputStream);\n    BufferedWriter bw = new BufferedWriter(osw)\n    ) {\n    // ...\n}\n</code></pre>\n\n<p>Lets start with FileOutputStream which calls <code>open</code> to do all the real work.</p>\n\n<pre><code>/**\n * Opens a file, with the specified name, for overwriting or appending.\n * @param name name of file to be opened\n * @param append whether the file is to be opened in append mode\n */\nprivate native void open(String name, boolean append)\n    throws FileNotFoundException;\n</code></pre>\n\n<p>If the file is not found, there is no underlying resource to close, so closing it won't make any difference.  If The file exists, it should be throwing a FileNotFoundException. So there is nothing to be gained by trying to close the resource from this line alone.</p>\n\n<p>The reason you need to close the file is when the file is opened successfully, but you later get an error.</p>\n\n<p>Lets look at the next stream <code>GZIPOutputStream</code></p>\n\n<p>There is code which can throw an exception</p>\n\n<pre><code>private void writeHeader() throws IOException {\n    out.write(new byte[] {\n                  (byte) GZIP_MAGIC,        // Magic number (short)\n                  (byte)(GZIP_MAGIC &gt;&gt; 8),  // Magic number (short)\n                  Deflater.DEFLATED,        // Compression method (CM)\n                  0,                        // Flags (FLG)\n                  0,                        // Modification time MTIME (int)\n                  0,                        // Modification time MTIME (int)\n                  0,                        // Modification time MTIME (int)\n                  0,                        // Modification time MTIME (int)\n                  0,                        // Extra flags (XFLG)\n                  0                         // Operating system (OS)\n              });\n}\n</code></pre>\n\n<p>This writes the header of the file.  Now it would be very unusual for you to be able to open a file for writing but not be able to write even 8 bytes to it, but lets imagine this could happen and we don't close the file afterwards.  What does happen to a file if it is not closed?  </p>\n\n<p>You don't get any unflushed writes, they are discarded and in this case, there is no successfully written bytes to the stream which isn't buffered at this point anyway.  But a file which is not closed doesn't live forever, instead FileOutputStream has</p>\n\n<pre><code>protected void finalize() throws IOException {\n    if (fd != null) {\n        if (fd == FileDescriptor.out || fd == FileDescriptor.err) {\n            flush();\n        } else {\n            /* if fd is shared, the references in FileDescriptor\n             * will ensure that finalizer is only called when\n             * safe to do so. All references using the fd have\n             * become unreachable. We can call close()\n             */\n            close();\n        }\n    }\n}\n</code></pre>\n\n<p>If you don't close a file at all, it gets closed anyway, just not immediately (and like I said, data which is left in a buffer will be lost this way, but there is none at this point)</p>\n\n<p>What is the consequence of not closing the file immediately?  Under normal conditions, you potentially lose some data, and you potentially run out of file descriptors.  But if you have a system where you can create files but you can't write anything to them, you have a bigger problem. i.e. it hard to imagine why you are repeatedly trying to create this file despite the fact you are failing.</p>\n\n<p>Both OutputStreamWriter and BufferedWriter don't throw IOException in their constructors, so it not clear what problem they would cause.  In The case of BufferedWriter, you could get an OutOfMemoryError.  In this case it will immediately trigger a GC, which as we have seen will close the file anyway.</p>\n", "title": "Is it necessary to close each nested OutputStream and Writer separately?", "tags": ["java", "file-io", "outputstream", "writer"], "link": "http://stackoverflow.com/questions/28276423/is-it-necessary-to-close-each-nested-outputstream-and-writer-separately/28276493#28276493", "post_type": "answer", "question_id": 28276423, "answer_id": 28276493}, {"body": "<p>No, the topmost level <code>Stream</code> or <code>reader</code> will ensure that all <em>underlying</em> streams / readers are closed. </p>\n\n<p>Check the <code>close()</code> method <em>implementation</em> of your topmost level stream.</p>\n", "title": "Is it necessary to close each nested OutputStream and Writer separately?", "tags": ["java", "file-io", "outputstream", "writer"], "link": "http://stackoverflow.com/questions/28276423/is-it-necessary-to-close-each-nested-outputstream-and-writer-separately/28276497#28276497", "post_type": "answer", "question_id": 28276423, "answer_id": 28276497}, {"body": "<p>Assuming all the streams get created okay, yes, just closing <code>bw</code> is fine <em>with those stream implementations</em>; but that's a big assumption.</p>\n\n<p>I'd use <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/language/try-with-resources.html\">try-with-resources</a> (<a href=\"http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html\">tutorial</a>) so that any issues constructing the subsequent streams that throw exceptions don't leave the previous streams hanging, and so you don't have to rely on the stream implementation having the call to close the underlying stream:</p>\n\n<pre><code>try (\n    OutputStream outputStream = new FileOutputStream(createdFile);\n    GZIPOutputStream gzipOutputStream = new GZIPOutputStream(outputStream);\n    OutputStreamWriter osw = new OutputStreamWriter(gzipOutputStream);\n    BufferedWriter bw = new BufferedWriter(osw)\n    ) {\n    // ...\n}\n</code></pre>\n\n<p>Note you no longer call <code>close</code> at all.</p>\n\n<p><strong>Important note</strong>: To have try-with-resources close them, you <em>must</em> assign the streams to variables as you open them, you cannot use nesting. If you use nesting, an exception during construction of one of the later streams (say, <code>GZIPOutputStream</code>) will leave any stream constructed by the nested calls inside it open. From <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.20.3\">JLS \u00a714.20.3</a>:</p>\n\n<blockquote>\n  <p>A try-with-resources statement is parameterized with <strong>variables</strong> (known as resources) that are initialized before execution of the <code>try</code> block and closed automatically, in the reverse order from which they were initialized, after execution of the <code>try</code> block.</p>\n</blockquote>\n\n<p>Note the word \"variables\" <em>(my emphasis)</em>.</p>\n\n<p>E.g., don't do this:</p>\n\n<pre><code>// DON'T DO THIS\ntry (BufferedWriter bw = new BufferedWriter(\n        new OutputStreamWriter(\n        new GZIPOutputStream(\n        new FileOutputStream(createdFile))))) {\n    // ...\n}\n</code></pre>\n\n<p>...because an exception from the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/zip/GZIPOutputStream.html#GZIPOutputStream-java.io.OutputStream-\"><code>GZIPOutputStream(OutputStream)</code></a> constructor (which says it may throw <code>IOException</code>, and writes a header to the underlying stream) would leave the <code>FileOutputStream</code> open. Since some resources have constructors that may throw and others don't, it's a good habit to just list them separately.</p>\n\n<p>We can double-check our interpretation of that JLS section with this program:</p>\n\n<pre><code>public class Example {\n\n    private static class InnerMost implements AutoCloseable {\n        public InnerMost() throws Exception {\n            System.out.println(\"Constructing \" + this.getClass().getName());\n        }\n\n        @Override\n        public void close() throws Exception {\n            System.out.println(this.getClass().getName() + \" closed\");\n        }\n    }\n\n    private static class Middle implements AutoCloseable {\n        private AutoCloseable c;\n\n        public Middle(AutoCloseable c) {\n            System.out.println(\"Constructing \" + this.getClass().getName());\n            this.c = c;\n        }\n\n        @Override\n        public void close() throws Exception {\n            System.out.println(this.getClass().getName() + \" closed\");\n            c.close();\n        }\n    }\n\n    private static class OuterMost implements AutoCloseable {\n        private AutoCloseable c;\n\n        public OuterMost(AutoCloseable c) throws Exception {\n            System.out.println(\"Constructing \" + this.getClass().getName());\n            throw new Exception(this.getClass().getName() + \" failed\");\n        }\n\n        @Override\n        public void close() throws Exception {\n            System.out.println(this.getClass().getName() + \" closed\");\n            c.close();\n        }\n    }\n\n    public static final void main(String[] args) {\n        // DON'T DO THIS\n        try (OuterMost om = new OuterMost(\n                new Middle(\n                    new InnerMost()\n                    )\n                )\n            ) {\n            System.out.println(\"In try block\");\n        }\n        catch (Exception e) {\n            System.out.println(\"In catch block\");\n        }\n        finally {\n            System.out.println(\"In finally block\");\n        }\n        System.out.println(\"At end of main\");\n    }\n}\n</code></pre>\n\n<p>...which has the output:</p>\n\n<pre>\nConstructing Example$InnerMost\nConstructing Example$Middle\nConstructing Example$OuterMost\nIn catch block\nIn finally block\nAt end of main\n</pre>\n\n<p>Note that there are no calls to <code>close</code> there.</p>\n\n<p>If we fix <code>main</code>:</p>\n\n<pre><code>public static final void main(String[] args) {\n    try (\n        InnerMost im = new InnerMost();\n        Middle m = new Middle(im);\n        OuterMost om = new OuterMost(m)\n        ) {\n        System.out.println(\"In try block\");\n    }\n    catch (Exception e) {\n        System.out.println(\"In catch block\");\n    }\n    finally {\n        System.out.println(\"In finally block\");\n    }\n    System.out.println(\"At end of main\");\n}\n</code></pre>\n\n<p>then we get the appropriate <code>close</code> calls:</p>\n\n<pre>\nConstructing Example$InnerMost\nConstructing Example$Middle\nConstructing Example$OuterMost\nExample$Middle closed\nExample$InnerMost closed\nExample$InnerMost closed\nIn catch block\nIn finally block\nAt end of main\n</pre>\n\n<p>(Yes, two calls to <code>InnerMost#close</code> is correct; one is from <code>Middle</code>, the other from try-with-resources.)</p>\n", "title": "Is it necessary to close each nested OutputStream and Writer separately?", "tags": ["java", "file-io", "outputstream", "writer"], "link": "http://stackoverflow.com/questions/28276423/is-it-necessary-to-close-each-nested-outputstream-and-writer-separately/28276498#28276498", "post_type": "answer", "question_id": 28276423, "answer_id": 28276498}, {"body": "<p>Yep, the cache in the c++ version takes a hammering. It seems the JIT is better equipped to handle this. </p>\n\n<p>If you change the outer <code>for</code> in isUpdateNeeded() to shorter snippets. The difference goes away. </p>\n\n<p>The sample below produces a 4x speedup. </p>\n\n<pre><code>void isUpdateNeeded() {\n    for (int i = 0; i &lt; numberOfCells; ++i) {\n        h[i] =  h[i] + 1;\n        floodedCells[i] =  !floodedCells[i];\n        floodedCellsTimeInterval[i] =  !floodedCellsTimeInterval[i];\n        qInflow[i] =  qInflow[i] + 1;\n        qStartTime[i] =  qStartTime[i] + 1;\n        qEndTime[i] =  qEndTime[i] + 1;\n    }\n\n    for (int i = 0; i &lt; numberOfCells; ++i) {\n        lowerFloorCells[i] =  lowerFloorCells[i] + 1;\n        cellLocationX[i] =  cellLocationX[i] + 1;\n        cellLocationY[i] =  cellLocationY[i] + 1;\n        cellLocationZ[i] =  cellLocationZ[i] + 1;\n        levelOfCell[i] =  levelOfCell[i] + 1;\n        valueOfCellIds[i] =  valueOfCellIds[i] + 1;\n        h0[i] =  h0[i] + 1;\n        vU[i] =  vU[i] + 1;\n        vV[i] =  vV[i] + 1;\n        vUh[i] =  vUh[i] + 1;\n        vVh[i] =  vVh[i] + 1;\n    }\n    for (int i = 0; i &lt; numberOfCells; ++i) {\n        vUh0[i] =  vUh0[i] + 1;\n        vVh0[i] =  vVh0[i] + 1;\n        ghh[i] =  ghh[i] + 1;\n        sfx[i] =  sfx[i] + 1;\n        sfy[i] =  sfy[i] + 1;\n        qIn[i] =  qIn[i] + 1;\n        for(int j = 0; j &lt; nEdges; ++j) {\n            neighborIds[i * nEdges + j] = neighborIds[i * nEdges + j] + 1;\n        }\n        for(int j = 0; j &lt; nEdges; ++j) {\n            typeInterface[i * nEdges + j] = typeInterface[i * nEdges + j] + 1;\n        }\n    }\n\n}\n</code></pre>\n\n<p>This shows to a reasonable degree that cache misses are the reason for the slowdown. It is also important to note that the variables are not dependent so a threaded solution is easily created. </p>\n\n<h1>Order restored</h1>\n\n<p>As per stefans comment I tried grouping them in a struct using the original sizes. This removes the immediate cache pressure in a similar fashion. The result is that the c++ (CCFLAG -O3) version is about 15% faster than the java version. </p>\n\n<p><em>Varning neither short nor pretty.</em></p>\n\n<pre><code>#include &lt;vector&gt;\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n\n\n\nclass FloodIsolation {\n    struct item{\n      char floodedCells;\n      char floodedCellsTimeInterval;\n      double valueOfCellIds;\n      double h;\n      double h0;\n      double vU;\n      double vV;\n      double vUh;\n      double vVh;\n      double vUh0;\n      double vVh0;\n      double sfx;\n      double sfy;\n      double qInflow;\n      double qStartTime;\n      double qEndTime;\n      double qIn;\n      double nx;\n      double ny;\n      double ghh;\n      double floorLevels;\n      int lowerFloorCells;\n      char flagInterface;\n      char floorCompletelyFilled;\n      double cellLocationX;\n      double cellLocationY;\n      double cellLocationZ;\n      int levelOfCell;\n    };\n    struct inner_item{\n      int typeInterface;\n      int neighborIds;\n    };\n\n    std::vector&lt;inner_item&gt; inner_data;\n    std::vector&lt;item&gt; data;\n\npublic:\n    FloodIsolation() :\n            numberOfCells(20000), inner_data(numberOfCells * nEdges), data(numberOfCells)\n   {\n\n    }\n    ~FloodIsolation(){\n    }\n\n    void isUpdateNeeded() {\n        for (int i = 0; i &lt; numberOfCells; ++i) {\n            data[i].h = data[i].h + 1;\n            data[i].floodedCells = !data[i].floodedCells;\n            data[i].floodedCellsTimeInterval = !data[i].floodedCellsTimeInterval;\n            data[i].qInflow = data[i].qInflow + 1;\n            data[i].qStartTime = data[i].qStartTime + 1;\n            data[i].qEndTime = data[i].qEndTime + 1;\n            data[i].lowerFloorCells = data[i].lowerFloorCells + 1;\n            data[i].cellLocationX = data[i].cellLocationX + 1;\n            data[i].cellLocationY = data[i].cellLocationY + 1;\n            data[i].cellLocationZ = data[i].cellLocationZ + 1;\n            data[i].levelOfCell = data[i].levelOfCell + 1;\n            data[i].valueOfCellIds = data[i].valueOfCellIds + 1;\n            data[i].h0 = data[i].h0 + 1;\n            data[i].vU = data[i].vU + 1;\n            data[i].vV = data[i].vV + 1;\n            data[i].vUh = data[i].vUh + 1;\n            data[i].vVh = data[i].vVh + 1;\n            data[i].vUh0 = data[i].vUh0 + 1;\n            data[i].vVh0 = data[i].vVh0 + 1;\n            data[i].ghh = data[i].ghh + 1;\n            data[i].sfx = data[i].sfx + 1;\n            data[i].sfy = data[i].sfy + 1;\n            data[i].qIn = data[i].qIn + 1;\n            for(int j = 0; j &lt; nEdges; ++j) {\n                inner_data[i * nEdges + j].neighborIds = inner_data[i * nEdges + j].neighborIds + 1;\n                inner_data[i * nEdges + j].typeInterface = inner_data[i * nEdges + j].typeInterface + 1;\n            }\n        }\n\n    }\n\n    static const int nEdges;\nprivate:\n\n    const int numberOfCells;\n\n};\n\nconst int FloodIsolation::nEdges = 6;\n\nint main() {\n    FloodIsolation isolation;\n    clock_t start = clock();\n    for (int i = 0; i &lt; 4400; ++i) {\n        if(i % 100 == 0) {\n            std::cout &lt;&lt; i &lt;&lt; \"\\n\";\n        }\n        isolation.isUpdateNeeded();\n    }\n\n    clock_t stop = clock();\n    std::cout &lt;&lt; \"Time: \" &lt;&lt; difftime(stop, start) / 1000 &lt;&lt; \"\\n\";\n}\n</code></pre>\n\n<p>My result differs slightly from Jerry Coffins for the original sizes. For me the differences remains.  It might well be my java version, 1.7.0_75. </p>\n", "title": "Java 8 times faster with arrays than std::vector in C++. What did I do wrong?", "tags": ["java", "c++", "arrays", "performance", "stdvector"], "link": "http://stackoverflow.com/questions/29656648/java-8-times-faster-with-arrays-than-stdvector-in-c-what-did-i-do-wrong/29657336#29657336", "post_type": "answer", "question_id": 29656648, "answer_id": 29657336}, {"body": "<p>Others' answers are pretty good explained the reason. I just add something to summarize <code>synchronized</code>:</p>\n\n<pre><code>public class A {\n    public synchronized void fun1() {}\n\n    public synchronized void fun2() {}\n\n    public void fun3() {}\n\n    public static synchronized void fun4() {}\n\n    public static void fun5() {}\n}\n\nA a1 = new A();\n</code></pre>\n\n<p><code>synchronized</code> on <code>fun1</code> and <code>fun2</code> is synchronized on instance object level. <code>synchronized</code> on <code>fun4</code> is synchronized on class object level. Which means:</p>\n\n<ol>\n<li>When 2 threads call <code>a1.fun1()</code> at same time, latter call will be blocked.</li>\n<li>When thread 1 call <code>a1.fun1()</code> and thread 2 call <code>a1.fun2()</code> at same time, latter call will be blocked.</li>\n<li>When thread 1 call <code>a1.fun1()</code> and thread 2 call <code>a1.fun3()</code> at same time, no blocking, the 2 methods will be executed at same time.</li>\n<li>When thread 1 call <code>A.fun4()</code>, if other threads call <code>A.fun4()</code> or <code>A.fun5()</code> at same time, latter calls will be blocked since <code>synchronized</code> on <code>fun4</code> is class level.</li>\n<li>When thread 1 call <code>A.fun4()</code>, thread 2 call <code>a1.fun1()</code> at same time, no blocking, the 2 methods will be executed at same time.</li>\n</ol>\n", "title": "Why is this class not thread safe?", "tags": ["java", "multithreading", "thread-safety"], "link": "http://stackoverflow.com/questions/30208524/why-is-this-class-not-thread-safe/30283730#30283730", "post_type": "answer", "question_id": 30208524, "answer_id": 30283730}, {"body": "<p>As explained in other answers, your code is <strong><em>not Thread safe</em></strong> since static method <code>increment()</code> locks Class monitor and  non-static method <code>decrement()</code> locks Object monitor. </p>\n\n<p>For this code example, better solution exists without <code>synchronzed</code> keyword usage. \nYou have to use <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html\" rel=\"nofollow\">AtomicInteger</a>  to achieve Thread safety.</p>\n\n<p>Thread safe using <code>AtomicInteger</code>:</p>\n\n<pre><code>import java.util.concurrent.atomic.AtomicInteger;\n\nclass ThreadSafeClass extends Thread {\n\n    private static AtomicInteger count = new AtomicInteger(0);\n\n    public static void increment() {\n        count.incrementAndGet();\n    }\n\n    public static void decrement() {\n        count.decrementAndGet();\n    }\n\n    public static int value() {\n        return count.get();\n    }\n\n}\n</code></pre>\n", "title": "Why is this class not thread safe?", "tags": ["java", "multithreading", "thread-safety"], "link": "http://stackoverflow.com/questions/30208524/why-is-this-class-not-thread-safe/37353170#37353170", "post_type": "answer", "question_id": 30208524, "answer_id": 37353170}, {"body": "<p>Check if you call setContentView() after super.onCreate(), and not before. This helped in my case.</p>\n", "title": "java.lang.IllegalArgumentException: AppCompat does not support the current theme features", "tags": ["java", "android", "eclipse", "android-studio"], "link": "http://stackoverflow.com/questions/29784124/java-lang-illegalargumentexception-appcompat-does-not-support-the-current-theme/29819543#29819543", "post_type": "answer", "question_id": 29784124, "answer_id": 29819543}, {"body": "<p>The JLS describes a few special behaviors of what it calls <em>constant variables</em>, which are <code>final</code> variables (whether <code>static</code> or not) which are initialized with constant expressions of <code>String</code> or primitive type.</p>\n\n<p>Constant variables have a major difference with respect to binary compatibility: the <em>values</em> of constant variables become part of the class's API, as far as the compiler is concerned.</p>\n\n<p>An example:</p>\n\n<pre><code>class X {\n    public static final String XFOO = \"xfoo\";\n}\n\nclass Y {\n    public static final String YFOO;\n    static { YFOO = \"yfoo\"; }\n}\n\nclass Z {\n    public static void main(String[] args) {\n        System.out.println(X.XFOO);\n        System.out.println(Y.YFOO);\n    }\n}\n</code></pre>\n\n<p>Here, <code>XFOO</code> is a \"constant variable\" and <code>YFOO</code> is not, but they are otherwise equivalent. Class <code>Z</code> prints out each of them. Compile those classes, then disassemble them with <code>javap -v X Y Z</code>, and here is the output:</p>\n\n<p>Class X:</p>\n\n<pre><code>Constant pool:\n   #1 = Methodref          #3.#11         //  java/lang/Object.\"&lt;init&gt;\":()V\n   #2 = Class              #12            //  X\n   #3 = Class              #13            //  java/lang/Object\n   #4 = Utf8               XFOO\n   #5 = Utf8               Ljava/lang/String;\n   #6 = Utf8               ConstantValue\n   #7 = String             #14            //  xfoo\n   #8 = Utf8               &lt;init&gt;\n   #9 = Utf8               ()V\n  #10 = Utf8               Code\n  #11 = NameAndType        #8:#9          //  \"&lt;init&gt;\":()V\n  #12 = Utf8               X\n  #13 = Utf8               java/lang/Object\n  #14 = Utf8               xfoo\n{\n  public static final java.lang.String XFOO;\n    descriptor: Ljava/lang/String;\n    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL\n    ConstantValue: String xfoo\n\n\n  X();\n    descriptor: ()V\n    flags:\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"&lt;init&gt;\":()V\n         4: return\n}\n</code></pre>\n\n<p>Class Y:</p>\n\n<pre><code>Constant pool:\n   #1 = Methodref          #5.#12         //  java/lang/Object.\"&lt;init&gt;\":()V\n   #2 = String             #13            //  yfoo\n   #3 = Fieldref           #4.#14         //  Y.YFOO:Ljava/lang/String;\n   #4 = Class              #15            //  Y\n   #5 = Class              #16            //  java/lang/Object\n   #6 = Utf8               YFOO\n   #7 = Utf8               Ljava/lang/String;\n   #8 = Utf8               &lt;init&gt;\n   #9 = Utf8               ()V\n  #10 = Utf8               Code\n  #11 = Utf8               &lt;clinit&gt;\n  #12 = NameAndType        #8:#9          //  \"&lt;init&gt;\":()V\n  #13 = Utf8               yfoo\n  #14 = NameAndType        #6:#7          //  YFOO:Ljava/lang/String;\n  #15 = Utf8               Y\n  #16 = Utf8               java/lang/Object\n{\n  public static final java.lang.String YFOO;\n    descriptor: Ljava/lang/String;\n    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL\n\n\n  Y();\n    descriptor: ()V\n    flags:\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"&lt;init&gt;\":()V\n         4: return\n\n  static {};\n    descriptor: ()V\n    flags: ACC_STATIC\n    Code:\n      stack=1, locals=0, args_size=0\n         0: ldc           #2                  // String yfoo\n         2: putstatic     #3                  // Field YFOO:Ljava/lang/String;\n         5: return\n}\n</code></pre>\n\n<p>Class Z:</p>\n\n<pre><code>Constant pool:\n   #1 = Methodref          #8.#14         //  java/lang/Object.\"&lt;init&gt;\":()V\n   #2 = Fieldref           #15.#16        //  java/lang/System.out:Ljava/io/PrintStream;\n   #3 = Class              #17            //  X\n   #4 = String             #18            //  xfoo\n   #5 = Methodref          #19.#20        //  java/io/PrintStream.println:(Ljava/lang/String;)V\n   #6 = Fieldref           #21.#22        //  Y.YFOO:Ljava/lang/String;\n   #7 = Class              #23            //  Z\n   #8 = Class              #24            //  java/lang/Object\n   #9 = Utf8               &lt;init&gt;\n  #10 = Utf8               ()V\n  #11 = Utf8               Code\n  #12 = Utf8               main\n  #13 = Utf8               ([Ljava/lang/String;)V\n  #14 = NameAndType        #9:#10         //  \"&lt;init&gt;\":()V\n  #15 = Class              #25            //  java/lang/System\n  #16 = NameAndType        #26:#27        //  out:Ljava/io/PrintStream;\n  #17 = Utf8               X\n  #18 = Utf8               xfoo\n  #19 = Class              #28            //  java/io/PrintStream\n  #20 = NameAndType        #29:#30        //  println:(Ljava/lang/String;)V\n  #21 = Class              #31            //  Y\n  #22 = NameAndType        #32:#33        //  YFOO:Ljava/lang/String;\n  #23 = Utf8               Z\n  #24 = Utf8               java/lang/Object\n  #25 = Utf8               java/lang/System\n  #26 = Utf8               out\n  #27 = Utf8               Ljava/io/PrintStream;\n  #28 = Utf8               java/io/PrintStream\n  #29 = Utf8               println\n  #30 = Utf8               (Ljava/lang/String;)V\n  #31 = Utf8               Y\n  #32 = Utf8               YFOO\n  #33 = Utf8               Ljava/lang/String;\n{\n  Z();\n    descriptor: ()V\n    flags:\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"&lt;init&gt;\":()V\n         4: return\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         3: ldc           #4                  // String xfoo\n         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n         8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n        11: getstatic     #6                  // Field Y.YFOO:Ljava/lang/String;\n        14: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n        17: return\n}\n</code></pre>\n\n<p>Things to notice in the disassembly, which tell you the differences between <code>X</code> and <code>Y</code> run deeper than syntactic sugar:</p>\n\n<ul>\n<li><p><code>XFOO</code> has a <a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.2\"><code>ConstantValue</code></a> attribute, signifying that its value is a compile-time constant. Whereas <code>YFOO</code> does not, and uses a <code>static</code> block with a <code>putstatic</code> instruction to initialize the value at runtime.</p></li>\n<li><p><strong>The <code>String</code> constant <code>\"xfoo\"</code> has become part of class <code>Z</code>'s constant pool</strong>, but <code>\"yfoo\"</code> has not.</p></li>\n<li><p><code>Z.main</code> uses the <code>ldc</code> (load constant) instruction to load <code>\"xfoo\"</code> onto the stack directly from its own constant pool, but it uses a <code>getstatic</code> instruction to load the value of <code>Y.YFOO</code>.</p></li>\n</ul>\n\n<p>Other differences you will find:</p>\n\n<ul>\n<li><p>If you change the value of <code>XFOO</code> and recompile <code>X.java</code> but not <code>Z.java</code>, you have a problem: class <code>Z</code> is still using the old value. If you change the value of <code>YFOO</code> and recompile <code>Y.java</code>, class <code>Z</code> uses the new value whether you recompile <code>Z.java</code> or not.</p></li>\n<li><p>If you delete the <code>X.class</code> file entirely, class <code>Z</code> still runs correctly. <strong><code>Z</code> has no runtime dependency on <code>X</code>.</strong> Whereas if you delete the <code>Y.class</code> file, class <code>Z</code> fails to initialize with a <code>ClassNotFoundException: Y</code>.</p></li>\n<li><p>If you generate documentation for the classes with javadoc, the \"Constant Field Values\" page will document the value of <code>XFOO</code>, but not the value of <code>YFOO</code>.</p></li>\n</ul>\n\n<p>The JLS describes the above effects constant variables have on compiled class files in <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1\">\u00a713.1.3</a>:</p>\n\n<blockquote>\n  <p>A reference to a field that is a constant variable (\u00a74.12.4) must be resolved at compile time to the value V denoted by the constant variable's initializer.</p>\n  \n  <p>If such a field is <code>static</code>, then no reference to the field should be present in the code in a binary file, including the class or interface which declared the field. Such a field must always appear to have been initialized (\u00a712.4.2); the default initial value for the field (if different than V) must never be observed.</p>\n  \n  <p>If such a field is non-<code>static</code>, then no reference to the field should be present in the code in a binary file, except in the class containing the field. (It will be a class rather than an interface, since an interface has only <code>static</code> fields.) The class should have code to set the field's value to V during instance creation (\u00a712.5).</p>\n</blockquote>\n\n<p>And in <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.4.9\">\u00a713.4.9</a>:</p>\n\n<blockquote>\n  <p>If a field is a constant variable (\u00a74.12.4), and moreover is <code>static</code>, then deleting the keyword <code>final</code> or changing its value will not break compatibility with pre-existing binaries by causing them not to run, but they will not see any new value for a usage of the field unless they are recompiled.</p>\n  \n  <p>[...]</p>\n  \n  <p>The best way to avoid problems with \"inconstant constants\" in widely-distributed code is to use <code>static</code> constant variables only for values which truly are unlikely ever to change. Other than for true mathematical constants, we recommend that source code make very sparing use of <code>static</code> constant variables. </p>\n</blockquote>\n\n<p>The upshot is that if your public library exposes any constant variables, you <strong>must never</strong> change their values if your new library version is otherwise supposed to be compatible with code compiled against old versions of the library. It won't necessarily cause an error, but the existing code will probably malfunction since it will have outdated ideas about the values of constants. (If your new library version needs for classes which use it to be recompiled anyway, then changing constants doesn't cause this problem.)</p>\n\n<p>Thus, initializing a constant with a block gives you more freedom to change its value, because it prevents the compiler embedding the value into other classes.</p>\n", "title": "Difference between static modifier and static block", "tags": ["java", "static", "modifier"], "link": "http://stackoverflow.com/questions/29691513/difference-between-static-modifier-and-static-block/29727412#29727412", "post_type": "answer", "question_id": 29691513, "answer_id": 29727412}, {"body": "<p>The JLS specify that</p>\n\n<blockquote>\n  <p>If the function type's result is void, the lambda body is either a\n  statement expression (\u00a714.8) or a void-compatible block.</p>\n</blockquote>\n\n<p>Now let's see that in detail,</p>\n\n<p>Since your <code>takeBiConsumer</code> method is of void type, the lambda receiving <code>new String(\"hi\")</code> will interpret it as a block like</p>\n\n<pre><code>{\n    new String(\"hi\");\n}\n</code></pre>\n\n<p>which is valid in a void, hence the first case compile.</p>\n\n<p>However, in the case where the lambda is <code>-&gt; \"hi\"</code>, a block such as</p>\n\n<pre><code>{\n    \"hi\";\n}\n</code></pre>\n\n<p>is not valid syntax in java. Therefore the only thing to do with \"hi\" is to try and return it.</p>\n\n<pre><code>{\n    return \"hi\";\n}\n</code></pre>\n\n<p>which is not valid in a void and explain the error message</p>\n\n<pre><code>incompatible types: bad return type in lambda expression\n    java.lang.String cannot be converted to void\n</code></pre>\n\n<p>For a better understanding, note that if you change the type of <code>takeBiConsumer</code> to a String, <code>-&gt; \"hi\"</code> will be valid as it will simply try to directly return the string.</p>\n\n<hr>\n\n<p>Note that at first I tought the error was caused by the lambda being in a wrong invocation context, so I'll share this possibility with the community :</p>\n\n<p><a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27\" rel=\"nofollow\">JLS 15.27</a></p>\n\n<blockquote>\n  <p>It is a compile-time error if a lambda expression occurs in a program\n  in someplace other than an assignment context (\u00a75.2), an invocation\n  context (\u00a75.3), or a casting context (\u00a75.5).</p>\n</blockquote>\n\n<p>However in our case, we are in an <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.3\" rel=\"nofollow\"><em>invocation context</em></a> which is correct.</p>\n", "title": "Why does this Java 8 lambda fail to compile?", "tags": ["java", "lambda", "compiler-errors", "java-8", "void"], "link": "http://stackoverflow.com/questions/29262002/why-does-this-java-8-lambda-fail-to-compile/29262126#29262126", "post_type": "answer", "question_id": 29262002, "answer_id": 29262126}, {"body": "<p>The short answer is: it's safe if you use them safely :)  </p>\n\n<p>The snarky answer: tell me what <em>you</em> mean by traits, and maybe I'll give you a better answer :)  </p>\n\n<p>In all seriousness, the term \"trait\" is not well-defined.  Many Java developers are most familiar with traits as they are expressed in Scala, but Scala is far from the first language to have traits, either in name or in effect.  </p>\n\n<p>For example, in Scala, traits are stateful (can have <code>var</code> variables); in Fortress they are pure behavior.  Java's interfaces with default methods are stateless; does this mean they are not traits?  (Hint: that was a trick question.)  </p>\n\n<p>Again, in Scala, traits are composed through linearization; if class <code>A</code> extends traits <code>X</code> and <code>Y</code>, then the order in which <code>X</code> and <code>Y</code> are mixed in determines how conflicts between <code>X</code> and <code>Y</code> are resolved.  In Java, this linearization mechanism is not present (it was rejected, in part, because it was too \"un-Java-like\".)  </p>\n\n<p>The proximate reason for adding default methods to interfaces was to support <em>interface evolution</em>, but we were well aware that we were going beyond that.  Whether you consider that to be \"interface evolution++\" or \"traits--\" is a matter of personal interpretation.  So, to answer your question about safety ... so long as you stick to what the mechanism actually supports, rather than trying to wishfully stretch it to something it does not support, you should be fine.</p>\n\n<p>A key design goal was that, from the perspective of the <em>client</em> of an interface, default methods should be indistinguishable from \"regular\" interface methods.  The default-ness of a method, therefore, is only interesting to the <em>designer</em> and <em>implementor</em> of the interface.  </p>\n\n<p>Here are some use cases that are well within the design goals:</p>\n\n<ul>\n<li><p>Interface evolution.  Here, we are adding a new method to an existing interface, which has a sensible default implementation in terms of existing methods on that interface.  An example would be adding the <code>forEach</code> method to <code>Collection</code>, where the default implementation is written in terms of the <code>iterator()</code> method.  </p></li>\n<li><p>\"Optional\" methods.  Here, the designer of an interface is saying \"Implementors need not implement this method if they are willing to live with the limitations in functionality that entails\".  For example, <code>Iterator.remove</code> was given a default which throws <code>UnsupportedOperationException</code>; since the vast majority of implementations of <code>Iterator</code> have this behavior anyway, the default makes this method essentially optional.  (If the behavior from <code>AbstractCollection</code> were expressed as defaults on <code>Collection</code>, we might do the same for the mutative methods.)  </p></li>\n<li><p>Convenience methods.  These are methods that are strictly for convenience, again generally implemented in terms of non-default methods on the class.  The <code>logger()</code> method in your first example is a reasonable illustration of this.</p></li>\n<li><p>Combinators.  These are compositional methods that instantiate new instances of the interface based on the current instance.  For example, the methods <code>Predicate.and()</code> or <code>Comparator.thenComparing()</code> are examples of combinators.  </p></li>\n</ul>\n\n<p>If you provide a default implementation, you should also provide some specification for the default (in the JDK, we use the <code>@implSpec</code> javadoc tag for this) to aid implementors in understanding whether they want to override the method or not.  Some defaults, like convenience methods and combinators, are almost never overridden; others, like optional methods, are often overridden.  You need to provide enough specification (not just documentation) about what the default promises to do, so the implementor can make a sensible decision about whether they need to override it.</p>\n", "title": "Java 8 default methods as traits : safe?", "tags": ["java", "java-8", "trait", "default-method"], "link": "http://stackoverflow.com/questions/28681737/java-8-default-methods-as-traits-safe/28684917#28684917", "post_type": "answer", "question_id": 28681737, "answer_id": 28684917}, {"body": "<p>You can use Arrays.stream E.g.</p>\n\n<pre><code>Arrays.stream(array);\n</code></pre>\n\n<p>You can also use <code>Stream.of</code> as mentioned by @fge , which looks like</p>\n\n<pre><code>public static&lt;T&gt; Stream&lt;T&gt; of(T... values) {\n    return Arrays.stream(values);\n}\n</code></pre>\n\n<p>But note <code>Stream.of(intArray)</code> will return <code>Stream&lt;int[]&gt;</code> whereas <code>Arrays.stream(intArr)</code> will return <code>IntStream</code> providing you pass an array of type <code>int[]</code>. So in a nutshell for primitives type you can observe the difference between 2 methods E.g.</p>\n\n<pre><code>int[] arr = {1, 2};\nStream&lt;int[]&gt; arr1 = Stream.of(arr);\n\nIntStream stream2 = Arrays.stream(arr); \n</code></pre>\n\n<p>When you pass primitive array to <code>Arrays.stream</code>, the following code is invoked</p>\n\n<pre><code>public static IntStream stream(int[] array) {\n    return stream(array, 0, array.length);\n}\n</code></pre>\n\n<p>and when you pass primitive array to <code>Stream.of</code> the following code is invoked</p>\n\n<pre><code> public static&lt;T&gt; Stream&lt;T&gt; of(T t) {\n     return StreamSupport.stream(new Streams.StreamBuilderImpl&lt;&gt;(t), false);\n }\n</code></pre>\n\n<p>Hence you get different results.</p>\n\n<p><strong>Updated</strong>: As mentioned by <a href=\"http://stackoverflow.com/users/1441122/stuart-marks\">Stuart Marks</a> comment\nThe subrange overload of <code>Arrays.stream</code> is preferable to using <code>Stream.of(array).skip(n).limit(m)</code> because the former results in a SIZED stream whereas the latter does not. The reason is that <code>limit(m)</code> doesn't know whether the size is m or less than m, whereas <code>Arrays.stream</code> does range checks and knows the exact size of the stream\nYou can read the source code for stream implementation returned by <code>Arrays.stream(array,start,end)</code>  <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/ReferencePipeline.java#ReferencePipeline.Head\">here</a>, whereas for stream implementation returned by <code>Stream.of(array).skip().limit()</code> is within <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/SliceOps.java#SliceOps.makeRef%28java.util.stream.AbstractPipeline%2Clong%2Clong%29\">this method</a>.</p>\n", "title": "How can I create a stream from an array?", "tags": ["java", "arrays", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/27888429/how-can-i-create-a-stream-from-an-array/27888447#27888447", "post_type": "answer", "question_id": 27888429, "answer_id": 27888447}, {"body": "<p>Alternative to @sol4me's solution:</p>\n\n<pre><code>Stream.of(theArray)\n</code></pre>\n\n<p>Of the difference between this and <code>Arrays.stream()</code>: it <em>does</em> make a difference if your array is of a primitive type. For instance, if you do:</p>\n\n<pre><code>Arrays.stream(someArray)\n</code></pre>\n\n<p>where <code>someArray</code> is a <code>long[]</code>, it will return a <code>LongStream</code>. <code>Stream.of()</code>, on the other hand, will return a <code>Stream&lt;long[]&gt;</code> with a single element.</p>\n", "title": "How can I create a stream from an array?", "tags": ["java", "arrays", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/27888429/how-can-i-create-a-stream-from-an-array/27888452#27888452", "post_type": "answer", "question_id": 27888429, "answer_id": 27888452}, {"body": "<pre><code>Stream.of(\"foo\", \"bar\", \"baz\")\n</code></pre>\n\n<p>Or, if you are already have an array, you can also do </p>\n\n<pre><code>Stream.of(array) \n</code></pre>\n\n<p>For primitive types use <code>IntStream.of</code> or <code>LongStream.of</code> etc.</p>\n", "title": "How can I create a stream from an array?", "tags": ["java", "arrays", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/27888429/how-can-i-create-a-stream-from-an-array/27888481#27888481", "post_type": "answer", "question_id": 27888429, "answer_id": 27888481}, {"body": "<p><strong>TL;DR: You should not put BLIND trust into anything.</strong></p>\n\n<p>First things first: it is important to verify the experimental data before jumping to the conclusions from them. Just claiming something is 3x faster/slower is odd, because you really need to follow up on the reason for the performance difference, not just trust the numbers. This is especially important for nano-benchmarks like you have.</p>\n\n<p>Second, the experimenters should clearly understand what they control and what they don't. In your particular example, you are returning the value from <code>@Benchmark</code> methods, but can you be reasonably sure the callers outside will do the same thing for primitive and the reference? If you ask yourself this question, then you'll realize you are basically measuring the test infrastructure.</p>\n\n<p>Down to the point. On my machine (i5-4210U, Linux x86_64, JDK 8u40), the test yields:</p>\n\n<pre><code>Benchmark                    (value)   Mode  Samples  Score   Error   Units\n...benchmarkReturnOrdinal          3  thrpt        5  0.876 \u00b1 0.023  ops/ns\n...benchmarkReturnOrdinal          2  thrpt        5  0.876 \u00b1 0.009  ops/ns\n...benchmarkReturnOrdinal          1  thrpt        5  0.832 \u00b1 0.048  ops/ns\n...benchmarkReturnReference        3  thrpt        5  0.292 \u00b1 0.006  ops/ns\n...benchmarkReturnReference        2  thrpt        5  0.286 \u00b1 0.024  ops/ns\n...benchmarkReturnReference        1  thrpt        5  0.293 \u00b1 0.008  ops/ns\n</code></pre>\n\n<p>Okay, so reference tests appear 3x slower. But wait, it uses an old JMH (1.1.1), let's update to current latest (1.7.1):</p>\n\n<pre><code>Benchmark                    (value)   Mode  Cnt  Score   Error   Units\n...benchmarkReturnOrdinal          3  thrpt    5  0.326 \u00b1 0.010  ops/ns\n...benchmarkReturnOrdinal          2  thrpt    5  0.329 \u00b1 0.004  ops/ns\n...benchmarkReturnOrdinal          1  thrpt    5  0.329 \u00b1 0.004  ops/ns\n...benchmarkReturnReference        3  thrpt    5  0.288 \u00b1 0.005  ops/ns\n...benchmarkReturnReference        2  thrpt    5  0.288 \u00b1 0.005  ops/ns\n...benchmarkReturnReference        1  thrpt    5  0.288 \u00b1 0.002  ops/ns\n</code></pre>\n\n<p>Oops, now they are only barely slower. BTW, this also tells us the test is infrastructure-bound. Okay, can we see what really happens?</p>\n\n<p>If you build the benchmarks, and look around what exactly calls your <code>@Benchmark</code> methods, then you'll see something like:</p>\n\n<pre><code>public void benchmarkReturnOrdinal_thrpt_jmhStub(InfraControl control, RawResults result, ReturnEnumObjectVersusPrimitiveBenchmark_jmh l_returnenumobjectversusprimitivebenchmark0_0, Blackhole_jmh l_blackhole1_1) throws Throwable {\n    long operations = 0;\n    long realTime = 0;\n    result.startTime = System.nanoTime();\n    do {\n        l_blackhole1_1.consume(l_longname.benchmarkReturnOrdinal());\n        operations++;\n    } while(!control.isDone);\n    result.stopTime = System.nanoTime();\n    result.realTime = realTime;\n    result.measuredOps = operations;\n}\n</code></pre>\n\n<p>That <code>l_blackhole1_1</code> has a <code>consume</code> method, which \"consumes\" the values (see <code>Blackhole</code> for rationale). <code>Blackhole.consume</code> has overloads for <a href=\"http://hg.openjdk.java.net/code-tools/jmh/file/96d8047fbf9a/jmh-core/src/main/java/org/openjdk/jmh/infra/Blackhole.java#l298\">references</a> and <a href=\"http://hg.openjdk.java.net/code-tools/jmh/file/96d8047fbf9a/jmh-core/src/main/java/org/openjdk/jmh/infra/Blackhole.java#l384\">primitives</a>, and that alone is enough to justify the performance difference.</p>\n\n<p>There is a rationale why these methods look different: they are trying to be as fast as possible for their types of argument. They do not necessarily exhibit the same performance characteristics, even though we try to match them, hence the more symmetric result with newer JMH. Now, you can even go to <code>-prof perfasm</code> to see the generated code for your tests and see why the performance is different, but that's beyond the point here.</p>\n\n<p>If you really <em>want</em> to understand how returning the primitive and/or reference differs performance-wise, you would need to enter a <strong><em>big scary grey zone</em></strong> of nuanced performance benchmarking. E.g. something like this test:</p>\n\n<pre><code>@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n@Fork(5)\npublic class PrimVsRef {\n\n    @Benchmark\n    public void prim() {\n        doPrim();\n    }\n\n    @Benchmark\n    public void ref() {\n        doRef();\n    }\n\n    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n    private int doPrim() {\n        return 42;\n    }\n\n    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n    private Object doRef() {\n        return this;\n    }\n\n}\n</code></pre>\n\n<p>...which yields the same result for primitives and references:</p>\n\n<pre><code>Benchmark       Mode  Cnt  Score   Error  Units\nPrimVsRef.prim  avgt   25  2.637 \u00b1 0.017  ns/op\nPrimVsRef.ref   avgt   25  2.634 \u00b1 0.005  ns/op\n</code></pre>\n\n<p>As I said above, these tests <em>require</em> following up on the reasons for the results. In this case, the generated code for both is almost the same, and that explains the result.</p>\n\n<p><strong>prim:</strong></p>\n\n<pre><code>                  [Verified Entry Point]\n 12.69%    1.81%    0x00007f5724aec100: mov    %eax,-0x14000(%rsp)\n  0.90%    0.74%    0x00007f5724aec107: push   %rbp\n  0.01%    0.01%    0x00007f5724aec108: sub    $0x30,%rsp         \n 12.23%   16.00%    0x00007f5724aec10c: mov    $0x2a,%eax   ; load \"42\"\n  0.95%    0.97%    0x00007f5724aec111: add    $0x30,%rsp\n           0.02%    0x00007f5724aec115: pop    %rbp\n 37.94%   54.70%    0x00007f5724aec116: test   %eax,0x10d1aee4(%rip)        \n  0.04%    0.02%    0x00007f5724aec11c: retq  \n</code></pre>\n\n<p><strong>ref:</strong></p>\n\n<pre><code>                  [Verified Entry Point]\n 13.52%    1.45%    0x00007f1887e66700: mov    %eax,-0x14000(%rsp)\n  0.60%    0.37%    0x00007f1887e66707: push   %rbp\n           0.02%    0x00007f1887e66708: sub    $0x30,%rsp         \n 13.63%   16.91%    0x00007f1887e6670c: mov    %rsi,%rax     ; load \"this\"\n  0.50%    0.49%    0x00007f1887e6670f: add    $0x30,%rsp\n  0.01%             0x00007f1887e66713: pop    %rbp\n 39.18%   57.65%    0x00007f1887e66714: test   %eax,0xe3e78e6(%rip)\n  0.02%             0x00007f1887e6671a: retq   \n</code></pre>\n\n<p>[sarcasm] See how easy it is! [/sarcasm]</p>\n\n<p>The pattern is: the simpler the question, the more you have to work out to make a plausible and reliable answer.</p>\n", "title": "Why is returning a Java object reference so much slower than returning a primitive", "tags": ["java", "low-latency", "jmh"], "link": "http://stackoverflow.com/questions/29472797/why-is-returning-a-java-object-reference-so-much-slower-than-returning-a-primiti/29476911#29476911", "post_type": "answer", "question_id": 29472797, "answer_id": 29476911}, {"body": "<p>I think this can indeed be explained by branch misprediction.</p>\n\n<p>Consider, for example, LIMIT=11, and <code>sortB</code>. On first iteration of the outer loop, it will very quickly stumble upon one of elements equal to 10. So it will have <code>a[j]=10</code>, and therefore definitely <code>a[j]</code> will be <code>&gt;=a[next]</code>, as there are no elements that are greater than 10. Therefore, it will perform a swap, then do one step in <code>j</code> only to find that <code>a[j]=10</code> once again (the same swapped value). So once again it will be <code>a[j]&gt;=a[next]</code>, and so one. Every comparison except several at the very beginning will be true. Similarly it will run on the next iterations of the outer loop.</p>\n\n<p>Not the same for <code>sortA</code>. It will start roughly the same way, stumble upon <code>a[j]=10</code>, do some swaps in a similar manner, but only to a point when it finds <code>a[next]=10</code> too. Then the condition will be false, and no swap will be done. An so on: every time it stumbles on <code>a[next]=10</code>, the condition is false and no swaps are done. Therefore, this condition is true 10 times out of 11 (values of <code>a[next]</code> from 0 to 9), and false in 1 case out of 11. Nothing strange that branch prediction fails.</p>\n", "title": "&gt; vs. &gt;= causes significant performance difference", "tags": ["java", "c++", "performance", "optimization"], "link": "http://stackoverflow.com/questions/30223441/vs-causes-significant-performance-difference/30223822#30223822", "post_type": "answer", "question_id": 30223441, "answer_id": 30223822}]}