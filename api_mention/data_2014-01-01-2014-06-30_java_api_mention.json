{"items": [{"body": "<p>I generated two matrices of <code>1000</code> x <code>1000</code>:</p>\n\n<p>First Matrix: <code>O</code> and <code>#</code>.<br>\nSecond Matrix: <code>O</code> and <code>B</code>.</p>\n\n<p>Using the following code, the first matrix took 8.52 seconds to complete:</p>\n\n<pre><code>Random r = new Random();\nfor (int i = 0; i &lt; 1000; i++) {\n    for (int j = 0; j &lt; 1000; j++) {\n        if(r.nextInt(4) == 0) {\n            System.out.print(\"O\");\n        } else {\n            System.out.print(\"#\");\n        }\n    }\n\n   System.out.println(\"\");\n }\n</code></pre>\n\n<p>With this code, the second matrix took 259.152 seconds to complete:</p>\n\n<pre><code>Random r = new Random();\nfor (int i = 0; i &lt; 1000; i++) {\n    for (int j = 0; j &lt; 1000; j++) {\n        if(r.nextInt(4) == 0) {\n            System.out.print(\"O\");\n        } else {\n            System.out.print(\"B\"); //only line changed\n        }\n    }\n\n    System.out.println(\"\");\n}\n</code></pre>\n\n<p>What is the reason behind the dramatically different run times?</p>\n\n<hr>\n\n<p>As suggested in the comments, printing only <code>System.out.print(\"#\");</code> takes 7.8871 seconds, whereas <code>System.out.print(\"B\");</code> gives <code>still printing...</code>.</p>\n\n<p>As others who pointed out that it works for them normally, I tried <a href=\"http://ideone.com\">Ideone.com</a> for instance, and both pieces of code execute at the same speed.</p>\n\n<p>Test Conditions:</p>\n\n<ul>\n<li>I ran this test from Netbeans 7.2, with the output into its console</li>\n<li>I used <code>System.nanoTime()</code> for measurements</li>\n</ul>\n", "title": "Why is printing &quot;B&quot; dramatically slower than printing &quot;#&quot;?", "tags": ["java", "performance", "system.out"], "link": "http://stackoverflow.com/questions/21947452/why-is-printing-b-dramatically-slower-than-printing", "post_type": "question", "question_id": 21947452}, {"body": "<p>One of the most useful features of Java 8 are the new <code>default</code> methods on interfaces. There are essentially two reasons (there may be others) why they have been introduced:</p>\n\n<ul>\n<li>Providing actual default implementations. Example: <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html#remove--\"><code>Iterator.remove()</code></a></li>\n<li>Allowing for JDK API evolution. Example: <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html#forEach-java.util.function.Consumer-\"><code>Iterable.forEach()</code></a></li>\n</ul>\n\n<p>From an API designer's perspective, I would have liked to be able to use other modifiers on interface methods, e.g. <code>final</code>. This would be useful when adding convenience methods, preventing \"accidental\" overrides in implementing classes:</p>\n\n<pre><code>interface Sender {\n\n    // Convenience method to send an empty message\n    default final void send() {\n        send(null);\n    }\n\n    // Implementations should only implement this method\n    void send(String message);\n}\n</code></pre>\n\n<p>The above is already common practice if <code>Sender</code> were a class:</p>\n\n<pre><code>abstract class Sender {\n\n    // Convenience method to send an empty message\n    final void send() {\n        send(null);\n    }\n\n    // Implementations should only implement this method\n    abstract void send(String message);\n}\n</code></pre>\n\n<p>Now, <code>default</code> and <code>final</code> are obviously contradicting keywords, but the default keyword itself <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2012-August/005393.html\">would not have been strictly required</a>, so I'm assuming that this contradiction is deliberate, to reflect the subtle differences between <em>\"class methods with body\"</em> (just methods) and <em>\"interface methods with body\"</em> (default methods), i.e. differences which I have not yet understood.</p>\n\n<p>At some point of time, support for modifiers like <code>static</code> and <code>final</code> on interface methods was not yet fully explored, <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2011-December/004430.html\">citing Brian Goetz</a>:</p>\n\n<blockquote>\n  <p>The other part is how far we're going to go to support class-building \n  tools in interfaces, such as final methods, private methods, protected \n  methods, static methods, etc.  The answer is: we don't know yet</p>\n</blockquote>\n\n<p>Since that time in late 2011, obviously, support for <code>static</code> methods in interfaces was added. Clearly, this added a lot of value to the JDK libraries themselves, such as with <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#comparing-java.util.function.Function-\"><code>Comparator.comparing()</code></a>.</p>\n\n<h3>Question:</h3>\n\n<p>What is the reason <code>final</code> (and also <code>static final</code>) never made it to Java 8 interfaces?</p>\n", "title": "Why is &quot;final&quot; not allowed in Java 8 interface methods?", "tags": ["java", "language-design", "java-8", "default-method", "jsr335"], "link": "http://stackoverflow.com/questions/23453287/why-is-final-not-allowed-in-java-8-interface-methods", "post_type": "question", "question_id": 23453287}, {"body": "<p>What is the best way to convert a <code>java.util.Date</code> object to the new JDK 8/JSR-310 <code>java.time.LocalDate</code>?</p>\n\n<pre><code>Date input = new Date();\nLocalDate date = ???\n</code></pre>\n", "title": "Convert java.util.Date to java.time.LocalDate", "tags": ["java", "datetime", "java-8", "java-time"], "link": "http://stackoverflow.com/questions/21242110/convert-java-util-date-to-java-time-localdate", "post_type": "question", "question_id": 21242110}, {"body": "<p>While investigating for a <a href=\"http://stackoverflow.com/q/23748186/507519\">little debate</a> w.r.t. using <code>\"\" + n</code> and <a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#toString%28int%29\"><code>Integer.toString(int)</code></a> to convert an integer primitive to a string I wrote this <a href=\"http://openjdk.java.net/projects/code-tools/jmh/\">JMH</a> microbenchmark:</p>\n\n<pre><code>@Fork(1)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\npublic class IntStr {\n    protected int counter;\n\n\n    @GenerateMicroBenchmark\n    public String integerToString() {\n        return Integer.toString(this.counter++);\n    }\n\n    @GenerateMicroBenchmark\n    public String stringBuilder0() {\n        return new StringBuilder().append(this.counter++).toString();\n    }\n\n    @GenerateMicroBenchmark\n    public String stringBuilder1() {\n        return new StringBuilder().append(\"\").append(this.counter++).toString();\n    }\n\n    @GenerateMicroBenchmark\n    public String stringBuilder2() {\n        return new StringBuilder().append(\"\").append(Integer.toString(this.counter++)).toString();\n    }\n\n    @GenerateMicroBenchmark\n    public String stringFormat() {\n        return String.format(\"%d\", this.counter++);\n    }\n\n    @Setup(Level.Iteration)\n    public void prepareIteration() {\n        this.counter = 0;\n    }\n}\n</code></pre>\n\n<p>I ran it with the default JMH options with both Java VMs that exist on my Linux machine (up-to-date Mageia 4 64-bit, Intel i7-3770 CPU, 32GB RAM). The first JVM was the one supplied with Oracle JDK\n8u5 64-bit:</p>\n\n<pre><code>java version \"1.8.0_05\"\nJava(TM) SE Runtime Environment (build 1.8.0_05-b13)\nJava HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)\n</code></pre>\n\n<p>With this JVM I got pretty much what I expected:</p>\n\n<pre><code>Benchmark                    Mode   Samples         Mean   Mean error    Units\nb.IntStr.integerToString    thrpt        20    32317.048      698.703   ops/ms\nb.IntStr.stringBuilder0     thrpt        20    28129.499      421.520   ops/ms\nb.IntStr.stringBuilder1     thrpt        20    28106.692     1117.958   ops/ms\nb.IntStr.stringBuilder2     thrpt        20    20066.939     1052.937   ops/ms\nb.IntStr.stringFormat       thrpt        20     2346.452       37.422   ops/ms\n</code></pre>\n\n<p>I.e. using the <code>StringBuilder</code> class is slower due to the additional overhead of creating the <code>StringBuilder</code> object and appending an empty string. Using <code>String.format(String, ...)</code> is even slower, by an order of magnitude or so.</p>\n\n<p>The distribution-provided compiler, on the other hand, is based on OpenJDK 1.7:</p>\n\n<pre><code>java version \"1.7.0_55\"\nOpenJDK Runtime Environment (mageia-2.4.7.1.mga4-x86_64 u55-b13)\nOpenJDK 64-Bit Server VM (build 24.51-b03, mixed mode)\n</code></pre>\n\n<p>The results here were <em>interesting</em>:</p>\n\n<pre><code>Benchmark                    Mode   Samples         Mean   Mean error    Units\nb.IntStr.integerToString    thrpt        20    31249.306      881.125   ops/ms\nb.IntStr.stringBuilder0     thrpt        20    39486.857      663.766   ops/ms\nb.IntStr.stringBuilder1     thrpt        20    41072.058      484.353   ops/ms\nb.IntStr.stringBuilder2     thrpt        20    20513.913      466.130   ops/ms\nb.IntStr.stringFormat       thrpt        20     2068.471       44.964   ops/ms\n</code></pre>\n\n<p>Why does <code>StringBuilder.append(int)</code> appear so much faster with this JVM? Looking at the <code>StringBuilder</code> class source code revealed nothing particularly interesting - the method in question is almost identical to <code>Integer#toString(int)</code>. Interestingly enough, appending the result of <code>Integer.toString(int)</code> (the <code>stringBuilder2</code> microbenchmark) does not appear to be faster.</p>\n\n<p>Is this performance discrepancy an issue with the testing harness? Or does my OpenJDK JVM contain optimizations that would affect this particular code (anti)-pattern?</p>\n\n<p><strong>EDIT:</strong></p>\n\n<p>For a more straight-forward comparison, I installed Oracle JDK 1.7u55:</p>\n\n<pre><code>java version \"1.7.0_55\"\nJava(TM) SE Runtime Environment (build 1.7.0_55-b13)\nJava HotSpot(TM) 64-Bit Server VM (build 24.55-b03, mixed mode)\n</code></pre>\n\n<p>The results are similar to those of OpenJDK:</p>\n\n<pre><code>Benchmark                    Mode   Samples         Mean   Mean error    Units\nb.IntStr.integerToString    thrpt        20    32502.493      501.928   ops/ms\nb.IntStr.stringBuilder0     thrpt        20    39592.174      428.967   ops/ms\nb.IntStr.stringBuilder1     thrpt        20    40978.633      544.236   ops/ms\n</code></pre>\n\n<p>It seems that this is a more general Java 7 vs Java 8 issue. Perhaps Java 7 had more aggressive string optimizations?</p>\n\n<p><strong>EDIT 2</strong>:</p>\n\n<p>For completeness, here are the string-related VM options for both of these JVMs:</p>\n\n<p>For Oracle JDK 8u5:</p>\n\n<pre><code>$ /usr/java/default/bin/java -XX:+PrintFlagsFinal 2&gt;/dev/null | grep String\n     bool OptimizeStringConcat                      = true            {C2 product}\n     intx PerfMaxStringConstLength                  = 1024            {product}\n     bool PrintStringTableStatistics                = false           {product}\n    uintx StringTableSize                           = 60013           {product}\n</code></pre>\n\n<p>For OpenJDK 1.7:</p>\n\n<pre><code>$ java -XX:+PrintFlagsFinal 2&gt;/dev/null | grep String\n     bool OptimizeStringConcat                      = true            {C2 product}        \n     intx PerfMaxStringConstLength                  = 1024            {product}           \n     bool PrintStringTableStatistics                = false           {product}           \n    uintx StringTableSize                           = 60013           {product}           \n     bool UseStringCache                            = false           {product}   \n</code></pre>\n\n<p>The <code>UseStringCache</code> option was removed in Java 8 with no replacement, so I doubt that makes any difference. The rest of the options appear to have the same settings.</p>\n\n<p><strong>EDIT 3:</strong></p>\n\n<p>A side-by-side comparison of the source code of the <code>AbstractStringBuilder</code>, <code>StringBuilder</code> and <code>Integer</code> classes from the <code>src.zip</code> file of reveals nothing noteworty. Apart from a whole lot of cosmetic and documentation changes, <code>Integer</code> now has some support for unsigned integers and <code>StringBuilder</code> has been slightly refactored to share more code with <code>StringBuffer</code>. None of these changes seem to affect the code paths used by <code>StringBuilder#append(int)</code>, although I may have missed something.</p>\n\n<p>A comparison of the assembly code generated for <code>IntStr#integerToString()</code> and <code>IntStr#stringBuilder0()</code> is far more interesting. The basic layout of the code generated for <code>IntStr#integerToString()</code> was similar for both JVMs, although Oracle JDK 8u5 seemed to be more aggressive w.r.t. inlining some calls within the <code>Integer#toString(int)</code> code. There was a clear correspondence with the Java source code, even for someone with minimal assembly experience.</p>\n\n<p>The assembly code for <code>IntStr#stringBuilder0()</code>, however, was radically different. The code generated by Oracle JDK 8u5 was once again directly related to the Java source code - I could easily recognise the same layout. On the contrary, the code generated by OpenJDK 7 was almost unrecognisable to the untrained eye (like mine). The <code>new StringBuilder()</code> call was seemingly removed, as was the creation of the array in the <code>StringBuilder</code> constructor. Additionaly, the disassembler plugin was not able to provide as many references to the source code as it did in JDK 8.</p>\n\n<p>I assume that this is either the result of a much more aggressive optimization pass in OpenJDK 7, or more probably the result of inserting hand-written low-level code for certain <code>StringBuilder</code> operations. I am unsure why this optimization does not happen in my JVM 8 implementation or why the same optimizations were not implemented for <code>Integer#toString(int)</code> in JVM 7. I guess someone familiar with the related parts of the JRE source code would have to answer these questions...</p>\n", "title": "Why is StringBuilder#append(int) faster in Java 7 than in Java 8?", "tags": ["java", "performance", "java-7", "java-8", "jmh"], "link": "http://stackoverflow.com/questions/23756966/why-is-stringbuilderappendint-faster-in-java-7-than-in-java-8", "post_type": "question", "question_id": 23756966}, {"body": "<p><code>String</code> is immutable* but this only means you cannot change it using its public API. </p>\n\n<p>What you are doing here is circumventing the normal API, using reflection. The same way, you can change the values of enums, change the lookup table used in Integer autoboxing etc.</p>\n\n<p>Now, the reason <code>s1</code> and <code>s2</code> change value, is that they both refer to the same interned string. The compiler does this (as mentioned by other answers). </p>\n\n<p>The reason <code>s3</code> does <em>not</em> was actually a bit surprising to me, as I thought it would share the <code>value</code> array (<a href=\"http://java-performance.info/changes-to-string-java-1-7-0_06/\">it did in earlier version of Java</a>, before Java 7u6). However, looking at the source code of <code>String</code>, we can see that the <code>value</code> character array for a substring is actually copied (using <code>Arrays.copyOfRange(..)</code>). This is why it goes unchanged.</p>\n\n<p>You can install a <code>SecurityManager</code>, to avoid malicious code to do such things. But keep in mind that some libraries depend on using these kind of reflection tricks (typically ORM tools, AOP libraries etc).</p>\n\n<p>*) I initially wrote that <code>String</code>s aren't really immutable, just \"effective immutable\". This might be misleading in the current implementation of <code>String</code>, where the <code>value</code> array is indeed marked <code>private final</code>. It's still worth noting, though, that there is no way to declare an array in Java as immutable, so care must be taken not to expose it outside its class, even with the proper access modifiers.</p>\n\n<hr>\n\n<p>As this topic seems overwhelmingly popular, here's some suggested further reading: <a href=\"http://www.javaspecialists.eu/talks/oslo09/ReflectionMadness.pdf\">Heinz Kabutz's Reflection Madness talk</a> from JavaZone 2009, which covers a lot of the issues in the OP, along with other reflection... well... madness. </p>\n\n<p>It covers why this is sometimes useful. And why, most of the time, you should avoid it. :-)</p>\n", "title": "Is a Java string really immutable?", "tags": ["java", "string", "reflection", "immutability"], "link": "http://stackoverflow.com/questions/20945049/is-a-java-string-really-immutable/20945113#20945113", "post_type": "answer", "question_id": 20945049, "answer_id": 20945113}, {"body": "<p>Better way is:</p>\n\n<pre><code>Date date = ...;\nInstant.ofEpochMilli(date.getTime()).atZone(ZoneId.systemDefault()).toLocalDate()\n</code></pre>\n\n<p>Advantages of this version:</p>\n\n<ul>\n<li><p>works regardless the input is an instance of <code>java.util.Date</code> or it's subclass <code>java.sql.Date</code> (unlike @JodaStephen's way). This is common with JDBC originated data. <code>java.sql.Date.toInstant()</code> always throws an exception.</p></li>\n<li><p>it's the same for JDK8 and JDK7 with JSR-310 backport</p></li>\n</ul>\n\n<p>I personally use an utility class (but this is not backport-compatible):</p>\n\n<pre><code>/**\n * Utilities for conversion between the old and new JDK date types \n * (between {@code java.util.Date} and {@code java.time.*}).\n * \n * &lt;p&gt;\n * All methods are null-safe.\n */\npublic class DateConvertUtils {\n\n    /**\n     * Calls {@link #asLocalDate(Date, ZoneId)} with the system default time zone.\n     */\n    public static LocalDate asLocalDate(java.util.Date date) {\n        return asLocalDate(date, ZoneId.systemDefault());\n    }\n\n    /**\n     * Creates {@link LocalDate} from {@code java.util.Date} or it's subclasses. Null-safe.\n     */\n    public static LocalDate asLocalDate(java.util.Date date, ZoneId zone) {\n        if (date == null)\n            return null;\n\n        if (date instanceof java.sql.Date)\n            return ((java.sql.Date) date).toLocalDate();\n        else\n            return Instant.ofEpochMilli(date.getTime()).atZone(zone).toLocalDate();\n    }\n\n    /**\n     * Calls {@link #asLocalDateTime(Date, ZoneId)} with the system default time zone.\n     */\n    public static LocalDateTime asLocalDateTime(java.util.Date date) {\n        return asLocalDateTime(date, ZoneId.systemDefault());\n    }\n\n    /**\n     * Creates {@link LocalDateTime} from {@code java.util.Date} or it's subclasses. Null-safe.\n     */\n    public static LocalDateTime asLocalDateTime(java.util.Date date, ZoneId zone) {\n        if (date == null)\n            return null;\n\n        if (date instanceof java.sql.Timestamp)\n            return ((java.sql.Timestamp) date).toLocalDateTime();\n        else\n            return Instant.ofEpochMilli(date.getTime()).atZone(zone).toLocalDateTime();\n    }\n\n    /**\n     * Calls {@link #asUtilDate(Object, ZoneId)} with the system default time zone.\n     */\n    public static java.util.Date asUtilDate(Object date) {\n        return asUtilDate(date, ZoneId.systemDefault());\n    }\n\n    /**\n     * Creates a {@link java.util.Date} from various date objects. Is null-safe. Currently supports:&lt;ul&gt;\n     * &lt;li&gt;{@link java.util.Date}\n     * &lt;li&gt;{@link java.sql.Date}\n     * &lt;li&gt;{@link java.sql.Timestamp}\n     * &lt;li&gt;{@link java.time.LocalDate}\n     * &lt;li&gt;{@link java.time.LocalDateTime}\n     * &lt;li&gt;{@link java.time.ZonedDateTime}\n     * &lt;li&gt;{@link java.time.Instant}\n     * &lt;/ul&gt;\n     * \n     * @param zone Time zone, used only if the input object is LocalDate or LocalDateTime.\n     * \n     * @return {@link java.util.Date} (exactly this class, not a subclass, such as java.sql.Date)\n     */\n    public static java.util.Date asUtilDate(Object date, ZoneId zone) {\n        if (date == null)\n            return null;\n\n        if (date instanceof java.sql.Date || date instanceof java.sql.Timestamp)\n            return new java.util.Date(((java.util.Date) date).getTime());\n        if (date instanceof java.util.Date)\n            return (java.util.Date) date;\n        if (date instanceof LocalDate)\n            return java.util.Date.from(((LocalDate) date).atStartOfDay(zone).toInstant());\n        if (date instanceof LocalDateTime)\n            return java.util.Date.from(((LocalDateTime) date).atZone(zone).toInstant());\n        if (date instanceof ZonedDateTime)\n            return java.util.Date.from(((ZonedDateTime) date).toInstant());\n        if (date instanceof Instant)\n            return java.util.Date.from((Instant) date);\n\n        throw new UnsupportedOperationException(\"Don't know hot to convert \" + date.getClass().getName() + \" to java.util.Date\");\n    }\n\n    /**\n     * Creates an {@link Instant} from {@code java.util.Date} or it's subclasses. Null-safe.\n     */\n    public static Instant asInstant(Date date) {\n        if (date == null)\n            return null;\n        else\n            return Instant.ofEpochMilli(date.getTime());\n    }\n\n    /**\n     * Calls {@link #asZonedDateTime(Date, ZoneId)} with the system default time zone.\n     */\n    public static ZonedDateTime asZonedDateTime(Date date) {\n        return asZonedDateTime(date, ZoneId.systemDefault());\n    }\n\n    /**\n     * Creates {@link ZonedDateTime} from {@code java.util.Date} or it's subclasses. Null-safe.\n     */\n    public static ZonedDateTime asZonedDateTime(Date date, ZoneId zone) {\n        if (date == null)\n            return null;\n        else\n            return asInstant(date).atZone(zone);\n    }\n\n}\n</code></pre>\n\n<p>The <code>asLocalDate()</code> method here is null-safe, uses <code>toLocalDate()</code>, if input is <code>java.sql.Date</code> (it may be overriden by the JDBC driver to avoid timezone problems or unnecessary calculations), otherwise uses the abovementioned method.</p>\n", "title": "Convert java.util.Date to java.time.LocalDate", "tags": ["java", "datetime", "java-8", "java-time"], "link": "http://stackoverflow.com/questions/21242110/convert-java-util-date-to-java-time-localdate/27378709#27378709", "post_type": "answer", "question_id": 21242110, "answer_id": 27378709}, {"body": "<p>Integer objects caches between -128 and 127 of 256 Integer</p>\n\n<p>You should not compare object references with <strong>==</strong> or <strong>!=</strong>. You should use .<strong>equals(..)</strong> instead, or better - use the primitive int rather than Integer.</p>\n\n<p><strong>parseInt</strong>: Parses the string argument as a signed decimal integer. The characters in the string must all be decimal digits, except that the first character may be an ASCII minus sign '-' ('\\u002D') to indicate a negative value. The resulting integer value is returned, exactly as if the argument and the radix 10 were given as arguments to the parseInt(java.lang.String, int) method.</p>\n\n<p><strong>valueOf</strong>\nReturns an Integer object holding the value extracted from the specified String when parsed with the radix given by the second argument. The first argument is interpreted as representing a signed integer in the radix specified by the second argument, exactly as if the arguments were given to the parseInt(java.lang.String, int) method. The result is an Integer object that represents the integer value specified by the string.</p>\n\n<p>equivalent to </p>\n\n<pre><code>new Integer(Integer.parseInt(s, radix))\n</code></pre>\n\n<p>radix - the radix to be used in interpreting s</p>\n\n<p>so if you equal <code>Integer.valueOf()</code> for the integer inbetween </p>\n\n<p>-128 to 127 it returns true in your condition</p>\n\n<p>for  <code>lesser than</code> -128 and <code>greater than</code> 127 it gives <code>false</code></p>\n", "title": "Why do == comparisons with Integer.valueOf(String) give different results for 127 and 128?", "tags": ["java", "integer", "comparison"], "link": "http://stackoverflow.com/questions/20877086/why-do-comparisons-with-integer-valueofstring-give-different-results-for-12/20877161#20877161", "post_type": "answer", "question_id": 20877086, "answer_id": 20877161}, {"body": "<p>The parallel streams use the default ForkJoinPool which <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html\">by default has one less threads as you have processors</a>, as returned by <code>Runtime.getRuntime().availableProcessors()</code> (so parallel streams use all your processors because they also use the main thread):</p>\n\n<blockquote>\n  <p>For applications that require separate or custom pools, a ForkJoinPool may be constructed with a given target parallelism level; by default, equal to the number of available processors.</p>\n</blockquote>\n\n<p>To change the way parallel streams are executed, you can either</p>\n\n<ul>\n<li>submit the parallel stream execution to your own ForkJoinPool: <code>yourFJP.submit(() -&gt; stream.parallel().forEach(soSomething));</code> or</li>\n<li>you can change the size of the common pool using system properties: <code>System.setProperty(\"java.util.concurrent.ForkJoinPool.common.parallelism\", \"20\")</code> for a target parallelism of 20 threads.</li>\n</ul>\n\n<hr>\n\n<p>Example of the latter on my machine which has 8 processors. If I run the following program:</p>\n\n<pre><code>long start = System.currentTimeMillis();\nIntStream s = IntStream.range(0, 20);\n//System.setProperty(\"java.util.concurrent.ForkJoinPool.common.parallelism\", \"20\");\ns.parallel().forEach(i -&gt; {\n    try { Thread.sleep(100); } catch (Exception ignore) {}\n    System.out.print((System.currentTimeMillis() - start) + \" \");\n});\n</code></pre>\n\n<p>The output is:</p>\n\n<blockquote>\n  <p>215 216 216 216 216 216 216 216 315 316 316 316 316 316 316 316 415 416 416 416</p>\n</blockquote>\n\n<p>So you can see that the parallel stream processes 8 items at a time, i.e. it uses 8 threads. However if I uncomment the commented line, the output is:</p>\n\n<blockquote>\n  <p>215 215 215 215 215 216 216 216 216 216 216 216 216 216 216 216 216 216 216 216</p>\n</blockquote>\n\n<p>This time the parallel stream has used 20 threads and all 20 elements in the stream have been processed comcurrently.</p>\n", "title": "Custom thread pool in Java 8 parallel stream", "tags": ["java", "concurrency", "parallel-processing", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/21163108/custom-thread-pool-in-java-8-parallel-stream/21172732#21172732", "post_type": "answer", "question_id": 21163108, "answer_id": 21172732}, {"body": "<h2>Made up example</h2>\n\n<p>Imagine that you want to create the following sequence: 1, 2, 2, 3, 3, 3, 4, 4, 4, 4 etc. (in other words: 1x1, 2x2, 3x3 etc.)</p>\n\n<p>With <code>flatMap</code> it could look like:</p>\n\n<pre><code>IntStream sequence = IntStream.rangeClosed(1, 4)\n                          .flatMap(i -&gt; IntStream.iterate(i, identity()).limit(i));\nsequence.forEach(System.out::println);\n</code></pre>\n\n<p>where:</p>\n\n<ul>\n<li><code>IntStream.rangeClosed(1, 4)</code> creates a stream of <code>int</code> from 1 to 4, inclusive</li>\n<li><code>IntStream.iterate(i, identity()).limit(i)</code> creates a stream of length i of <code>int</code> i - so applied to <code>i = 4</code> it creates a stream: <code>4, 4, 4, 4</code></li>\n<li><code>flatMap</code> \"flattens\" the stream and \"concatenates\" it to the original stream</li>\n</ul>\n\n<p>With Java &lt; 8 you would need two nested loops:</p>\n\n<pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nfor (int i = 1; i &lt;= 4; i++) {\n    for (int j = 0; j &lt; i; j++) {\n        list.add(i);\n    }\n}\n</code></pre>\n\n<h2>Real world example</h2>\n\n<p>Let's say I have a <code>List&lt;TimeSeries&gt;</code> where each <code>TimeSeries</code> is essentially a <code>Map&lt;LocalDate, Double&gt;</code>. I want to get a list of all dates for which at least one of the time series has a value. <code>flatMap</code> to the rescue:</p>\n\n<pre><code>list.stream().parallel()\n    .flatMap(ts -&gt; ts.dates().stream()) // for each TS, stream dates and flatmap\n    .distinct()                         // remove duplicates\n    .sorted()                           // sort ascending\n    .collect(toList());\n</code></pre>\n\n<p>Not only is it readable, but if you suddenly need to process 100k elements, simply adding <code>parallel()</code> will improve performance without you writing any concurrent code.</p>\n", "title": "Java 8 Streams FlatMap method example", "tags": ["java", "java-8", "java-stream", "flatmap"], "link": "http://stackoverflow.com/questions/22382453/java-8-streams-flatmap-method-example/22384113#22384113", "post_type": "answer", "question_id": 22382453, "answer_id": 22384113}, {"body": "<p>You can use <a href=\"http://www.eclipse.org/collections/javadoc/7.0.0/org/eclipse/collections/impl/block/factory/Predicates.html\" rel=\"nofollow\">Predicates</a> from <a href=\"http://www.eclipse.org/collections/\" rel=\"nofollow\">Eclipse Collections</a></p>\n\n<pre><code>MutableList&lt;String&gt; strings = Lists.mutable.empty();\nint nonEmptyStrings = strings.count(Predicates.not(String::isEmpty));\n</code></pre>\n\n<p>If you can't change the strings from <code>List</code>:</p>\n\n<pre><code>List&lt;String&gt; strings = new ArrayList&lt;&gt;();\nint nonEmptyStrings = ListAdapter.adapt(strings).count(Predicates.not(String::isEmpty));\n</code></pre>\n\n<p>If you only need a negation of <code>String.isEmpty()</code> you can also use <code>StringPredicates.notEmpty()</code>.</p>\n\n<p>Note: I am a contributor to Eclipse Collections.</p>\n", "title": "How to negate a method reference predicate", "tags": ["java", "predicate", "java-8", "negate"], "link": "http://stackoverflow.com/questions/21488056/how-to-negate-a-method-reference-predicate/36242382#36242382", "post_type": "answer", "question_id": 21488056, "answer_id": 36242382}]}