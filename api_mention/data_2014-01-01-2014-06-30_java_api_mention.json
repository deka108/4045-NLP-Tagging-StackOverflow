{"items": [{"body": "<p>I generated two matrices of <code>1000</code> x <code>1000</code>:</p>\n\n<p>First Matrix: <code>O</code> and <code>#</code>.<br>\nSecond Matrix: <code>O</code> and <code>B</code>.</p>\n\n<p>Using the following code, the first matrix took 8.52 seconds to complete:</p>\n\n<pre><code>Random r = new Random();\nfor (int i = 0; i &lt; 1000; i++) {\n    for (int j = 0; j &lt; 1000; j++) {\n        if(r.nextInt(4) == 0) {\n            System.out.print(\"O\");\n        } else {\n            System.out.print(\"#\");\n        }\n    }\n\n   System.out.println(\"\");\n }\n</code></pre>\n\n<p>With this code, the second matrix took 259.152 seconds to complete:</p>\n\n<pre><code>Random r = new Random();\nfor (int i = 0; i &lt; 1000; i++) {\n    for (int j = 0; j &lt; 1000; j++) {\n        if(r.nextInt(4) == 0) {\n            System.out.print(\"O\");\n        } else {\n            System.out.print(\"B\"); //only line changed\n        }\n    }\n\n    System.out.println(\"\");\n}\n</code></pre>\n\n<p>What is the reason behind the dramatically different run times?</p>\n\n<hr>\n\n<p>As suggested in the comments, printing only <code>System.out.print(\"#\");</code> takes 7.8871 seconds, whereas <code>System.out.print(\"B\");</code> gives <code>still printing...</code>.</p>\n\n<p>As others who pointed out that it works for them normally, I tried <a href=\"http://ideone.com\">Ideone.com</a> for instance, and both pieces of code execute at the same speed.</p>\n\n<p>Test Conditions:</p>\n\n<ul>\n<li>I ran this test from Netbeans 7.2, with the output into its console</li>\n<li>I used <code>System.nanoTime()</code> for measurements</li>\n</ul>\n", "title": "Why is printing &quot;B&quot; dramatically slower than printing &quot;#&quot;?", "tags": ["java", "performance", "system.out"], "link": "http://stackoverflow.com/questions/21947452/why-is-printing-b-dramatically-slower-than-printing", "post_type": "question", "question_id": 21947452}, {"body": "<p>One of the most useful features of Java 8 are the new <code>default</code> methods on interfaces. There are essentially two reasons (there may be others) why they have been introduced:</p>\n\n<ul>\n<li>Providing actual default implementations. Example: <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html#remove--\"><code>Iterator.remove()</code></a></li>\n<li>Allowing for JDK API evolution. Example: <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html#forEach-java.util.function.Consumer-\"><code>Iterable.forEach()</code></a></li>\n</ul>\n\n<p>From an API designer's perspective, I would have liked to be able to use other modifiers on interface methods, e.g. <code>final</code>. This would be useful when adding convenience methods, preventing \"accidental\" overrides in implementing classes:</p>\n\n<pre><code>interface Sender {\n\n    // Convenience method to send an empty message\n    default final void send() {\n        send(null);\n    }\n\n    // Implementations should only implement this method\n    void send(String message);\n}\n</code></pre>\n\n<p>The above is already common practice if <code>Sender</code> were a class:</p>\n\n<pre><code>abstract class Sender {\n\n    // Convenience method to send an empty message\n    final void send() {\n        send(null);\n    }\n\n    // Implementations should only implement this method\n    abstract void send(String message);\n}\n</code></pre>\n\n<p>Now, <code>default</code> and <code>final</code> are obviously contradicting keywords, but the default keyword itself <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2012-August/005393.html\">would not have been strictly required</a>, so I'm assuming that this contradiction is deliberate, to reflect the subtle differences between <em>\"class methods with body\"</em> (just methods) and <em>\"interface methods with body\"</em> (default methods), i.e. differences which I have not yet understood.</p>\n\n<p>At some point of time, support for modifiers like <code>static</code> and <code>final</code> on interface methods was not yet fully explored, <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2011-December/004430.html\">citing Brian Goetz</a>:</p>\n\n<blockquote>\n  <p>The other part is how far we're going to go to support class-building \n  tools in interfaces, such as final methods, private methods, protected \n  methods, static methods, etc.  The answer is: we don't know yet</p>\n</blockquote>\n\n<p>Since that time in late 2011, obviously, support for <code>static</code> methods in interfaces was added. Clearly, this added a lot of value to the JDK libraries themselves, such as with <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#comparing-java.util.function.Function-\"><code>Comparator.comparing()</code></a>.</p>\n\n<h3>Question:</h3>\n\n<p>What is the reason <code>final</code> (and also <code>static final</code>) never made it to Java 8 interfaces?</p>\n", "title": "Why is &quot;final&quot; not allowed in Java 8 interface methods?", "tags": ["java", "language-design", "java-8", "default-method", "jsr335"], "link": "http://stackoverflow.com/questions/23453287/why-is-final-not-allowed-in-java-8-interface-methods", "post_type": "question", "question_id": 23453287}, {"body": "<p>What is the best way to convert a <code>java.util.Date</code> object to the new JDK 8/JSR-310 <code>java.time.LocalDate</code>?</p>\n\n<pre><code>Date input = new Date();\nLocalDate date = ???\n</code></pre>\n", "title": "Convert java.util.Date to java.time.LocalDate", "tags": ["java", "datetime", "java-8", "java-time"], "link": "http://stackoverflow.com/questions/21242110/convert-java-util-date-to-java-time-localdate", "post_type": "question", "question_id": 21242110}, {"body": "<p>Note: this question originates from a dead link which was a previous SO question, but here goes...</p>\n\n<p>See this code (note: I do know that this code won't \"work\" and that <code>Integer::compare</code> should be used -- I just extracted it from the linked question):</p>\n\n<pre><code>final ArrayList &lt;Integer&gt; list \n    = IntStream.rangeClosed(1, 20).boxed().collect(Collectors.toList());\n\nSystem.out.println(list.stream().max(Integer::max).get());\nSystem.out.println(list.stream().min(Integer::min).get());\n</code></pre>\n\n<p>According to the javadoc of <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#min-java.util.Comparator-\"><code>.min()</code></a> and <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#max-java.util.Comparator-\"><code>.max()</code></a>, the argument of both should be a <code>Comparator</code>. Yet here the method references are to static methods of the <a href=\"http://download.java.net/jdk8/docs/api/java/lang/Integer.html\"><code>Integer</code></a> class.</p>\n\n<p>So, why does this compile at all?</p>\n", "title": "Java 8 stream&#39;s .min() and .max(): why does this compile?", "tags": ["java", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/22561614/java-8-streams-min-and-max-why-does-this-compile", "post_type": "question", "question_id": 22561614}, {"body": "<p>I am wondering why the <code>Iterable</code> interface does not provide the <code>stream()</code> and <code>parallelStream()</code> methods. Consider the following class:</p>\n\n<pre><code>public class Hand implements Iterable&lt;Card&gt; {\n    private final List&lt;Card&gt; list = new ArrayList&lt;&gt;();\n    private final int capacity;\n\n    //...\n\n    @Override\n    public Iterator&lt;Card&gt; iterator() {\n        return list.iterator();\n    }\n}\n</code></pre>\n\n<p>It is an implementation of a <em>Hand</em> as you can have cards in your hand while playing a Trading Card Game.</p>\n\n<p>Essentially it wraps a <code>List&lt;Card&gt;</code>, ensures a maximum capacity and offers some other useful features. It is better as implementing it directly as a <code>List&lt;Card&gt;</code>.</p>\n\n<p>Now, for convienience I thought it would be nice to implement <code>Iterable&lt;Card&gt;</code>, such that you can use enhanced for-loops if you want to loop over it. (My <code>Hand</code> class also provides a <code>get(int index)</code> method, hence the <code>Iterable&lt;Card&gt;</code> is justified in my opinion.)</p>\n\n<p>The <code>Iterable</code> interface provides the following (left out javadoc):</p>\n\n<pre><code>public interface Iterable&lt;T&gt; {\n    Iterator&lt;T&gt; iterator();\n\n    default void forEach(Consumer&lt;? super T&gt; action) {\n        Objects.requireNonNull(action);\n        for (T t : this) {\n            action.accept(t);\n        }\n    }\n\n    default Spliterator&lt;T&gt; spliterator() {\n        return Spliterators.spliteratorUnknownSize(iterator(), 0);\n    }\n}\n</code></pre>\n\n<p>Now can you obtain a stream with:</p>\n\n<pre><code>Stream&lt;Hand&gt; stream = StreamSupport.stream(hand.spliterator(), false);\n</code></pre>\n\n<p>So onto the real question:</p>\n\n<ul>\n<li>Why does <code>Iterable&lt;T&gt;</code> not provide a default methods that implement <code>stream()</code> and <code>parallelStream()</code>, I see nothing that would make this impossible or unwanted?</li>\n</ul>\n\n<p>A related question I found is the following though: <a href=\"http://stackoverflow.com/questions/20129762/why-does-streamt-not-implement-iterablet\">Why does Stream&lt;T&gt; not implement Iterable&lt;T&gt;?</a><br>\nWhich is oddly enough suggesting it to do it somewhat the other way around.</p>\n", "title": "Why does Iterable&lt;T&gt; not provide stream() and parallelStream() methods?", "tags": ["java", "java-8"], "link": "http://stackoverflow.com/questions/23114015/why-does-iterablet-not-provide-stream-and-parallelstream-methods", "post_type": "question", "question_id": 23114015}, {"body": "<p>The new Java 8 stream framework and friends make for some very concise java code, but I have come across a seemingly-simple situation that is tricky to do concisely.</p>\n\n<p>Consider a <code>List&lt;Thing&gt; things</code> and method <code>Optional&lt;Other&gt; resolve(Thing thing)</code>. I want to map the <code>Thing</code>s to <code>Optional&lt;Other&gt;</code>s and get the first <code>Other</code>. The obvious solution would be to use <code>things.stream().flatMap(this::resolve).findFirst()</code>, but <code>flatMap</code> requires that you return a stream, and <code>Optional</code> doesn't have a <code>stream()</code> method (or is it a <code>Collection</code> or provide a method to convert it to or view it as a <code>Collection</code>).</p>\n\n<p>The best I can come up with is this:</p>\n\n<pre><code>things.stream()\n    .map(this::resolve)\n    .filter(Optional::isPresent)\n    .map(Optional::get)\n    .findFirst();\n</code></pre>\n\n<p>But that seems awfully long-winded for what seems like a very common case. Anyone have a better idea?</p>\n", "title": "Using Java 8&#39;s Optional with Stream::flatMap", "tags": ["java", "lambda", "java-8"], "link": "http://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap", "post_type": "question", "question_id": 22725537}, {"body": "<p>I'm looking at the docs for the <code>IntStream</code>, and I see an <code>toArray</code> method, but no way to go directly to a <code>List&lt;Integer&gt;</code></p>\n\n<p>Surely there is a way to convert a <code>Stream</code> to a <code>List</code>?</p>\n", "title": "How do I convert a Java 8 IntStream to a List?", "tags": ["java", "java-8"], "link": "http://stackoverflow.com/questions/23674624/how-do-i-convert-a-java-8-intstream-to-a-list", "post_type": "question", "question_id": 23674624}, {"body": "<p>In Java 8, there is a new method <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html#chars--\"><code>String.chars()</code></a> which returns a stream of <code>int</code>s (<code>IntStream</code>) that represent the character codes. I guess many people would expect a stream of <code>char</code>s here instead. What was the motivation to design the API this way?</p>\n", "title": "Why is String.chars() a stream of ints in Java 8?", "tags": ["java", "string", "java-8"], "link": "http://stackoverflow.com/questions/22435833/why-is-string-chars-a-stream-of-ints-in-java-8", "post_type": "question", "question_id": 22435833}, {"body": "<p>While investigating for a <a href=\"http://stackoverflow.com/q/23748186/507519\">little debate</a> w.r.t. using <code>\"\" + n</code> and <a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#toString%28int%29\"><code>Integer.toString(int)</code></a> to convert an integer primitive to a string I wrote this <a href=\"http://openjdk.java.net/projects/code-tools/jmh/\">JMH</a> microbenchmark:</p>\n\n<pre><code>@Fork(1)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\npublic class IntStr {\n    protected int counter;\n\n\n    @GenerateMicroBenchmark\n    public String integerToString() {\n        return Integer.toString(this.counter++);\n    }\n\n    @GenerateMicroBenchmark\n    public String stringBuilder0() {\n        return new StringBuilder().append(this.counter++).toString();\n    }\n\n    @GenerateMicroBenchmark\n    public String stringBuilder1() {\n        return new StringBuilder().append(\"\").append(this.counter++).toString();\n    }\n\n    @GenerateMicroBenchmark\n    public String stringBuilder2() {\n        return new StringBuilder().append(\"\").append(Integer.toString(this.counter++)).toString();\n    }\n\n    @GenerateMicroBenchmark\n    public String stringFormat() {\n        return String.format(\"%d\", this.counter++);\n    }\n\n    @Setup(Level.Iteration)\n    public void prepareIteration() {\n        this.counter = 0;\n    }\n}\n</code></pre>\n\n<p>I ran it with the default JMH options with both Java VMs that exist on my Linux machine (up-to-date Mageia 4 64-bit, Intel i7-3770 CPU, 32GB RAM). The first JVM was the one supplied with Oracle JDK\n8u5 64-bit:</p>\n\n<pre><code>java version \"1.8.0_05\"\nJava(TM) SE Runtime Environment (build 1.8.0_05-b13)\nJava HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)\n</code></pre>\n\n<p>With this JVM I got pretty much what I expected:</p>\n\n<pre><code>Benchmark                    Mode   Samples         Mean   Mean error    Units\nb.IntStr.integerToString    thrpt        20    32317.048      698.703   ops/ms\nb.IntStr.stringBuilder0     thrpt        20    28129.499      421.520   ops/ms\nb.IntStr.stringBuilder1     thrpt        20    28106.692     1117.958   ops/ms\nb.IntStr.stringBuilder2     thrpt        20    20066.939     1052.937   ops/ms\nb.IntStr.stringFormat       thrpt        20     2346.452       37.422   ops/ms\n</code></pre>\n\n<p>I.e. using the <code>StringBuilder</code> class is slower due to the additional overhead of creating the <code>StringBuilder</code> object and appending an empty string. Using <code>String.format(String, ...)</code> is even slower, by an order of magnitude or so.</p>\n\n<p>The distribution-provided compiler, on the other hand, is based on OpenJDK 1.7:</p>\n\n<pre><code>java version \"1.7.0_55\"\nOpenJDK Runtime Environment (mageia-2.4.7.1.mga4-x86_64 u55-b13)\nOpenJDK 64-Bit Server VM (build 24.51-b03, mixed mode)\n</code></pre>\n\n<p>The results here were <em>interesting</em>:</p>\n\n<pre><code>Benchmark                    Mode   Samples         Mean   Mean error    Units\nb.IntStr.integerToString    thrpt        20    31249.306      881.125   ops/ms\nb.IntStr.stringBuilder0     thrpt        20    39486.857      663.766   ops/ms\nb.IntStr.stringBuilder1     thrpt        20    41072.058      484.353   ops/ms\nb.IntStr.stringBuilder2     thrpt        20    20513.913      466.130   ops/ms\nb.IntStr.stringFormat       thrpt        20     2068.471       44.964   ops/ms\n</code></pre>\n\n<p>Why does <code>StringBuilder.append(int)</code> appear so much faster with this JVM? Looking at the <code>StringBuilder</code> class source code revealed nothing particularly interesting - the method in question is almost identical to <code>Integer#toString(int)</code>. Interestingly enough, appending the result of <code>Integer.toString(int)</code> (the <code>stringBuilder2</code> microbenchmark) does not appear to be faster.</p>\n\n<p>Is this performance discrepancy an issue with the testing harness? Or does my OpenJDK JVM contain optimizations that would affect this particular code (anti)-pattern?</p>\n\n<p><strong>EDIT:</strong></p>\n\n<p>For a more straight-forward comparison, I installed Oracle JDK 1.7u55:</p>\n\n<pre><code>java version \"1.7.0_55\"\nJava(TM) SE Runtime Environment (build 1.7.0_55-b13)\nJava HotSpot(TM) 64-Bit Server VM (build 24.55-b03, mixed mode)\n</code></pre>\n\n<p>The results are similar to those of OpenJDK:</p>\n\n<pre><code>Benchmark                    Mode   Samples         Mean   Mean error    Units\nb.IntStr.integerToString    thrpt        20    32502.493      501.928   ops/ms\nb.IntStr.stringBuilder0     thrpt        20    39592.174      428.967   ops/ms\nb.IntStr.stringBuilder1     thrpt        20    40978.633      544.236   ops/ms\n</code></pre>\n\n<p>It seems that this is a more general Java 7 vs Java 8 issue. Perhaps Java 7 had more aggressive string optimizations?</p>\n\n<p><strong>EDIT 2</strong>:</p>\n\n<p>For completeness, here are the string-related VM options for both of these JVMs:</p>\n\n<p>For Oracle JDK 8u5:</p>\n\n<pre><code>$ /usr/java/default/bin/java -XX:+PrintFlagsFinal 2&gt;/dev/null | grep String\n     bool OptimizeStringConcat                      = true            {C2 product}\n     intx PerfMaxStringConstLength                  = 1024            {product}\n     bool PrintStringTableStatistics                = false           {product}\n    uintx StringTableSize                           = 60013           {product}\n</code></pre>\n\n<p>For OpenJDK 1.7:</p>\n\n<pre><code>$ java -XX:+PrintFlagsFinal 2&gt;/dev/null | grep String\n     bool OptimizeStringConcat                      = true            {C2 product}        \n     intx PerfMaxStringConstLength                  = 1024            {product}           \n     bool PrintStringTableStatistics                = false           {product}           \n    uintx StringTableSize                           = 60013           {product}           \n     bool UseStringCache                            = false           {product}   \n</code></pre>\n\n<p>The <code>UseStringCache</code> option was removed in Java 8 with no replacement, so I doubt that makes any difference. The rest of the options appear to have the same settings.</p>\n\n<p><strong>EDIT 3:</strong></p>\n\n<p>A side-by-side comparison of the source code of the <code>AbstractStringBuilder</code>, <code>StringBuilder</code> and <code>Integer</code> classes from the <code>src.zip</code> file of reveals nothing noteworty. Apart from a whole lot of cosmetic and documentation changes, <code>Integer</code> now has some support for unsigned integers and <code>StringBuilder</code> has been slightly refactored to share more code with <code>StringBuffer</code>. None of these changes seem to affect the code paths used by <code>StringBuilder#append(int)</code>, although I may have missed something.</p>\n\n<p>A comparison of the assembly code generated for <code>IntStr#integerToString()</code> and <code>IntStr#stringBuilder0()</code> is far more interesting. The basic layout of the code generated for <code>IntStr#integerToString()</code> was similar for both JVMs, although Oracle JDK 8u5 seemed to be more aggressive w.r.t. inlining some calls within the <code>Integer#toString(int)</code> code. There was a clear correspondence with the Java source code, even for someone with minimal assembly experience.</p>\n\n<p>The assembly code for <code>IntStr#stringBuilder0()</code>, however, was radically different. The code generated by Oracle JDK 8u5 was once again directly related to the Java source code - I could easily recognise the same layout. On the contrary, the code generated by OpenJDK 7 was almost unrecognisable to the untrained eye (like mine). The <code>new StringBuilder()</code> call was seemingly removed, as was the creation of the array in the <code>StringBuilder</code> constructor. Additionaly, the disassembler plugin was not able to provide as many references to the source code as it did in JDK 8.</p>\n\n<p>I assume that this is either the result of a much more aggressive optimization pass in OpenJDK 7, or more probably the result of inserting hand-written low-level code for certain <code>StringBuilder</code> operations. I am unsure why this optimization does not happen in my JVM 8 implementation or why the same optimizations were not implemented for <code>Integer#toString(int)</code> in JVM 7. I guess someone familiar with the related parts of the JRE source code would have to answer these questions...</p>\n", "title": "Why is StringBuilder#append(int) faster in Java 7 than in Java 8?", "tags": ["java", "performance", "java-7", "java-8", "jmh"], "link": "http://stackoverflow.com/questions/23756966/why-is-stringbuilderappendint-faster-in-java-7-than-in-java-8", "post_type": "question", "question_id": 23756966}, {"body": "<p><em>Pure speculation</em> is that you're using a terminal that attempts to do <a href=\"http://en.wikipedia.org/wiki/Word_wrap\">word-wrapping</a> rather than character-wrapping, and treats <code>B</code> as a word character but <code>#</code> as a non-word character. So when it reaches the end of a line and searches for a place to break the line, it sees a <code>#</code> almost immediately and happily breaks there; whereas with the <code>B</code>, it has to keep searching for longer, and may have more text to wrap (which may be expensive on some terminals, e.g., outputting backspaces, then outputting spaces to overwrite the letters being wrapped).</p>\n\n<p>But that's pure speculation.</p>\n", "title": "Why is printing &quot;B&quot; dramatically slower than printing &quot;#&quot;?", "tags": ["java", "performance", "system.out"], "link": "http://stackoverflow.com/questions/21947452/why-is-printing-b-dramatically-slower-than-printing/21947627#21947627", "post_type": "answer", "question_id": 21947452, "answer_id": 21947627}, {"body": "<p>I performed tests on Eclipse vs Netbeans 8.0.2, both with Java version 1.8;\nI used <code>System.nanoTime()</code> for measurements.</p>\n\n<h2>Eclipse:</h2>\n\n<p>I got the <strong>same time on both cases</strong> - around <strong>1.564 seconds</strong>.</p>\n\n<h2>Netbeans:</h2>\n\n<ul>\n<li>Using \"#\": <strong>1.536 seconds</strong></li>\n<li>Using \"B\": <strong>44.164 seconds</strong></li>\n</ul>\n\n<p>So, it looks like Netbeans has bad performance on print to console.</p>\n\n<p>After more research I realized that the problem is <a href=\"http://en.wikipedia.org/wiki/Line_wrap_and_word_wrap\">line-wrapping</a> of the max buffer of Netbeans (it's not restricted to <code>System.out.println</code> command), demonstrated by this code:</p>\n\n<pre><code>for (int i = 0; i &lt; 1000; i++) {\n    long t1 = System.nanoTime();\n    System.out.print(\"BBB......BBB\"); \\\\&lt;-contain 1000 \"B\"\n    long t2 = System.nanoTime();\n    System.out.println(t2-t1);\n    System.out.println(\"\");\n}\n</code></pre>\n\n<p>The time results are less then 1 millisecond every iteration except <strong>every fifth iteration</strong>, when the time result is around 225 millisecond. Something like (in nanoseconds):</p>\n\n<pre><code>BBB...31744\nBBB...31744\nBBB...31744\nBBB...31744\nBBB...226365807\nBBB...31744\nBBB...31744\nBBB...31744\nBBB...31744\nBBB...226365807\n.\n.\n.\n</code></pre>\n\n<p>And so on..</p>\n\n<h2>Summary:</h2>\n\n<ol>\n<li>Eclipse works perfectly with \"B\"</li>\n<li>Netbeans has a line-wrapping problem that can be solved (because the problem does not occur in eclipse)(without adding space after B (\"B \")).</li>\n</ol>\n", "title": "Why is printing &quot;B&quot; dramatically slower than printing &quot;#&quot;?", "tags": ["java", "performance", "system.out"], "link": "http://stackoverflow.com/questions/21947452/why-is-printing-b-dramatically-slower-than-printing/29434641#29434641", "post_type": "answer", "question_id": 21947452, "answer_id": 29434641}, {"body": "<p>You cannot do it more concise as you are already doing.</p>\n\n<p>You claim that you do not want <code>.filter(Optional::isPresent)</code> <em>and</em> <code>.map(Optional::get)</code>.</p>\n\n<p>This has been resolved by the method @StuartMarks describes, however as a result you now map it to an <code>Optional&lt;T&gt;</code>, so now you need to use <code>.flatMap(this::streamopt)</code> and a <code>get()</code> in the end.</p>\n\n<p>So it still consists of two statements and you can now get exceptions with the new method! Because, what if every optional is empty? Then the <code>findFirst()</code> will return an empty optional and your <code>get()</code> will fail!</p>\n\n<p>So what you have:</p>\n\n<pre><code>things.stream()\n    .map(this::resolve)\n    .filter(Optional::isPresent)\n    .map(Optional::get)\n    .findFirst();\n</code></pre>\n\n<p><strong>is</strong> actually the best way to accomplish what you want, and that is you want to save the result as a <code>T</code>, not as an <code>Optional&lt;T&gt;</code>.</p>\n\n<p>I took the liberty of creating a <code>CustomOptional&lt;T&gt;</code> class that wraps the <code>Optional&lt;T&gt;</code> and provides an extra method, <code>flatStream()</code>. Note that you cannot extend <code>Optional&lt;T&gt;</code>:</p>\n\n<pre><code>class CustomOptional&lt;T&gt; {\n    private final Optional&lt;T&gt; optional;\n\n    private CustomOptional() {\n        this.optional = Optional.empty();\n    }\n\n    private CustomOptional(final T value) {\n        this.optional = Optional.of(value);\n    }\n\n    private CustomOptional(final Optional&lt;T&gt; optional) {\n        this.optional = optional;\n    }\n\n    public Optional&lt;T&gt; getOptional() {\n        return optional;\n    }\n\n    public static &lt;T&gt; CustomOptional&lt;T&gt; empty() {\n        return new CustomOptional&lt;&gt;();\n    }\n\n    public static &lt;T&gt; CustomOptional&lt;T&gt; of(final T value) {\n        return new CustomOptional&lt;&gt;(value);\n    }\n\n    public static &lt;T&gt; CustomOptional&lt;T&gt; ofNullable(final T value) {\n        return (value == null) ? empty() : of(value);\n    }\n\n    public T get() {\n        return optional.get();\n    }\n\n    public boolean isPresent() {\n        return optional.isPresent();\n    }\n\n    public void ifPresent(final Consumer&lt;? super T&gt; consumer) {\n        optional.ifPresent(consumer);\n    }\n\n    public CustomOptional&lt;T&gt; filter(final Predicate&lt;? super T&gt; predicate) {\n        return new CustomOptional&lt;&gt;(optional.filter(predicate));\n    }\n\n    public &lt;U&gt; CustomOptional&lt;U&gt; map(final Function&lt;? super T, ? extends U&gt; mapper) {\n        return new CustomOptional&lt;&gt;(optional.map(mapper));\n    }\n\n    public &lt;U&gt; CustomOptional&lt;U&gt; flatMap(final Function&lt;? super T, ? extends CustomOptional&lt;U&gt;&gt; mapper) {\n        return new CustomOptional&lt;&gt;(optional.flatMap(mapper.andThen(cu -&gt; cu.getOptional())));\n    }\n\n    public T orElse(final T other) {\n        return optional.orElse(other);\n    }\n\n    public T orElseGet(final Supplier&lt;? extends T&gt; other) {\n        return optional.orElseGet(other);\n    }\n\n    public &lt;X extends Throwable&gt; T orElseThrow(final Supplier&lt;? extends X&gt; exceptionSuppier) throws X {\n        return optional.orElseThrow(exceptionSuppier);\n    }\n\n    public Stream&lt;T&gt; flatStream() {\n        if (!optional.isPresent()) {\n            return Stream.empty();\n        }\n        return Stream.of(get());\n    }\n\n    public T getTOrNull() {\n        if (!optional.isPresent()) {\n            return null;\n        }\n        return get();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        return optional.equals(obj);\n    }\n\n    @Override\n    public int hashCode() {\n        return optional.hashCode();\n    }\n\n    @Override\n    public String toString() {\n        return optional.toString();\n    }\n}\n</code></pre>\n\n<p>You will see that I added <code>flatStream()</code>, as here:</p>\n\n<pre><code>public Stream&lt;T&gt; flatStream() {\n    if (!optional.isPresent()) {\n        return Stream.empty();\n    }\n    return Stream.of(get());\n}\n</code></pre>\n\n<p>Used as:</p>\n\n<pre><code>String result = Stream.of(\"a\", \"b\", \"c\", \"de\", \"fg\", \"hij\")\n        .map(this::resolve)\n        .flatMap(CustomOptional::flatStream)\n        .findFirst()\n        .get();\n</code></pre>\n\n<p>You <em>still</em> will need to return a <code>Stream&lt;T&gt;</code> here, as you cannot return <code>T</code>, because if <code>!optional.isPresent()</code>, then <code>T == null</code> if you declare it such, but then your <code>.flatMap(CustomOptional::flatStream)</code> would attempt to add <code>null</code> to a stream and that is not possible.</p>\n\n<p>As example:</p>\n\n<pre><code>public T getTOrNull() {\n    if (!optional.isPresent()) {\n        return null;\n    }\n    return get();\n}\n</code></pre>\n\n<p>Used as:</p>\n\n<pre><code>String result = Stream.of(\"a\", \"b\", \"c\", \"de\", \"fg\", \"hij\")\n        .map(this::resolve)\n        .map(CustomOptional::getTOrNull)\n        .findFirst()\n        .get();\n</code></pre>\n\n<p>Will now throw a <code>NullPointerException</code> inside the stream operations.</p>\n\n<h1>Conclusion</h1>\n\n<p>The method you used, is actually the best method.</p>\n", "title": "Using Java 8&#39;s Optional with Stream::flatMap", "tags": ["java", "lambda", "java-8"], "link": "http://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap/22735184#22735184", "post_type": "answer", "question_id": 22725537, "answer_id": 22735184}, {"body": "<p><code>String</code> is immutable* but this only means you cannot change it using its public API. </p>\n\n<p>What you are doing here is circumventing the normal API, using reflection. The same way, you can change the values of enums, change the lookup table used in Integer autoboxing etc.</p>\n\n<p>Now, the reason <code>s1</code> and <code>s2</code> change value, is that they both refer to the same interned string. The compiler does this (as mentioned by other answers). </p>\n\n<p>The reason <code>s3</code> does <em>not</em> was actually a bit surprising to me, as I thought it would share the <code>value</code> array (<a href=\"http://java-performance.info/changes-to-string-java-1-7-0_06/\">it did in earlier version of Java</a>, before Java 7u6). However, looking at the source code of <code>String</code>, we can see that the <code>value</code> character array for a substring is actually copied (using <code>Arrays.copyOfRange(..)</code>). This is why it goes unchanged.</p>\n\n<p>You can install a <code>SecurityManager</code>, to avoid malicious code to do such things. But keep in mind that some libraries depend on using these kind of reflection tricks (typically ORM tools, AOP libraries etc).</p>\n\n<p>*) I initially wrote that <code>String</code>s aren't really immutable, just \"effective immutable\". This might be misleading in the current implementation of <code>String</code>, where the <code>value</code> array is indeed marked <code>private final</code>. It's still worth noting, though, that there is no way to declare an array in Java as immutable, so care must be taken not to expose it outside its class, even with the proper access modifiers.</p>\n\n<hr>\n\n<p>As this topic seems overwhelmingly popular, here's some suggested further reading: <a href=\"http://www.javaspecialists.eu/talks/oslo09/ReflectionMadness.pdf\">Heinz Kabutz's Reflection Madness talk</a> from JavaZone 2009, which covers a lot of the issues in the OP, along with other reflection... well... madness. </p>\n\n<p>It covers why this is sometimes useful. And why, most of the time, you should avoid it. :-)</p>\n", "title": "Is a Java string really immutable?", "tags": ["java", "string", "reflection", "immutability"], "link": "http://stackoverflow.com/questions/20945049/is-a-java-string-really-immutable/20945113#20945113", "post_type": "answer", "question_id": 20945049, "answer_id": 20945113}, {"body": "<p>The way I think about it is that you use <code>flatMap</code> when the function you wanted to put inside of <code>map()</code> returns an <code>Observable</code>. In which case you might still try to use <code>map()</code> but it would be unpractical. Let me try to explain why.</p>\n\n<p>If in such case you decided to stick with <code>map</code>, you would get an <code>Observable&lt;Observable&lt;Something&gt;&gt;</code>. For example in your case, if we used an imaginary RxGson library, that returned an <code>Observable&lt;String&gt;</code> from it's <code>toJson()</code> method (instead of simply returning a <code>String</code>) it would look like this:</p>\n\n<pre><code>Observable.from(jsonFile).map(new Func1&lt;File, Observable&lt;String&gt;&gt;() {\n    @Override public Observable&lt;String&gt;&gt; call(File file) {\n        return new RxGson().toJson(new FileReader(file), Object.class);\n    }\n}); // you get Observable&lt;Observable&lt;String&gt;&gt; here\n</code></pre>\n\n<p>At this point it would be pretty tricky to <code>subscribe()</code> to such an observable. Inside of it you would get an <code>Observable&lt;String&gt;</code> to which you would again need to <code>subscribe()</code> to get the value. Which is not practical or nice to look at.</p>\n\n<p>So to make it useful one idea is to \"flatten\" this observable of observables (you might start to see where the name _flat_Map comes from). RxJava provides a few ways to flatten observables and for sake of simplicity lets assume <a href=\"http://reactivex.io/documentation/operators/merge.html\" rel=\"nofollow\">merge</a> is what we want. Merge basically takes a bunch of observables and emits whenever any of them emits. (Lots of people would argue <a href=\"http://reactivex.io/documentation/operators/switch.html\" rel=\"nofollow\">switch</a> would be a better default. But if you're emitting just one value, it doesn't matter anyway.)</p>\n\n<p>So amending our previous snippet we would get:</p>\n\n<pre><code>Observable.from(jsonFile).map(new Func1&lt;File, Observable&lt;String&gt;&gt;() {\n    @Override public Observable&lt;String&gt;&gt; call(File file) {\n        return new RxGson().toJson(new FileReader(file), Object.class);\n    }\n}).merge(); // you get Observable&lt;String&gt; here\n</code></pre>\n\n<p>This is a lot more useful, because subscribing to that (or mapping, or filtering, or...) you just get the <code>String</code> value. (Also, mind you, such variant of <code>merge()</code> does not exist in RxJava, but if you understand the idea of merge then I hope you also understand how that would work.)</p>\n\n<p>So basically because such <code>merge()</code> should probably only ever be useful when it succeeds a <code>map()</code> returning an observable and so you don't have to type this over and over again, <code>flatMap()</code> was created as a shorthand. It applies the mapping function just as a normal <code>map()</code> would, but later instead of emitting the returned values it also \"flattens\" (or merges) them.</p>\n\n<p>That's the general use case. It is most useful in a codebase that uses Rx allover the place and you've got many methods returning observables, which you want to chain with other methods returning observables.</p>\n\n<p>In your use case it happens to be useful as well, because <code>map()</code> can only transform one value emitted in <code>onNext()</code> into another value emitted in <code>onNext()</code>. But it cannot transform it into multiple values, no value at all or an error. And as <a href=\"http://stackoverflow.com/users/61158/akarnokd\">akarnokd</a> wrote in his answer (and mind you he's much smarter than me, probably in general, but at least when it comes to RxJava) you shouldn't throw exceptions from your <code>map()</code>. So instead you can use <code>flatMap()</code> and</p>\n\n<pre><code>return Observable.just(value);\n</code></pre>\n\n<p>when all goes well, but </p>\n\n<pre><code>return Observable.error(exception);\n</code></pre>\n\n<p>when something fails.<br>\nSee his answer for a complete snippet: <a href=\"http://stackoverflow.com/a/30330772/1402641\">http://stackoverflow.com/a/30330772/1402641</a></p>\n", "title": "When do you use map vs flatMap in RxJava?", "tags": ["java", "mapping", "rx-java", "flatmap"], "link": "http://stackoverflow.com/questions/22847105/when-do-you-use-map-vs-flatmap-in-rxjava/37354549#37354549", "post_type": "answer", "question_id": 22847105, "answer_id": 37354549}, {"body": "<p>This <strong>is</strong> possible for <code>forEach()</code>. The solution is not nice, but it <strong>is</strong> possible.</p>\n\n<p><em>WARNING</em>: You should not use it for controlling business logic, but purely for handling an exceptional situation which occurs during the execution of the <code>forEach()</code>. Such as a resource suddenly stops being accessible, one of the processed objects is violating a contract (e.g. contract says that all the elements in the stream must not be <code>null</code> but suddenly and unexpectedly one of them is <code>null</code>) etc.</p>\n\n<p>According to the documentation for <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html#forEach-java.util.function.Consumer-\" rel=\"nofollow\"><code>Iterable.forEach()</code></a>:</p>\n\n<blockquote>\n  <p>Performs the given action for each element of the <code>Iterable</code> <strong>until</strong> all elements have been processed or <strong>the action throws an exception</strong>... Exceptions thrown by the action are relayed to the caller.</p>\n</blockquote>\n\n<p>So you throw an exception which will immediately break the internal loop.</p>\n\n<p>The code will be something like this - <strong>I cannot say I like it</strong> but it works. You create your own class <code>BreakException</code> which extends <code>RuntimeException</code>.</p>\n\n<pre><code>try {\n    someObjects.forEach(obj -&gt; {\n        // some useful code here\n        if(some_exceptional_condition_met) {\n            throw new BreakException();\n       }\n    }\n}\ncatch (BreakException e) {\n    // here you know that your condition has been met at least once\n}\n</code></pre>\n\n<p>Notice that the <code>try...catch</code> is <em>not</em> around the lambda expression, but rather around the whole <code>forEach()</code> method. To make it more visible, see the following transcription of the code which shows it more clearly:</p>\n\n<pre><code>Consumer&lt;? super SomeObject&gt; action = obj -&gt; {\n    // some useful code here\n    if(some_exceptional_condition_met) {\n        throw new BreakException();\n    }\n});\n\ntry {\n    someObjects.forEach(action);\n}\ncatch (BreakException e) {\n    // here you know that your condition has been met at least once\n}\n</code></pre>\n", "title": "How to break or return from Java8 Lambda forEach?", "tags": ["java", "foreach", "lambda", "java-8"], "link": "http://stackoverflow.com/questions/23308193/how-to-break-or-return-from-java8-lambda-foreach/32566745#32566745", "post_type": "answer", "question_id": 23308193, "answer_id": 32566745}, {"body": "<p>The Java libraries are heavily optimized around the constraint that any <code>String</code> object is immutable, regardless of how that object is constructed. Even if you create your <code>b</code> using <code>new</code>, other code that you pass that instance to will treat the value as immutable. This is an example of the Value Object pattern, and all of the advantages (thread-safety, no need to make private copies) apply.</p>\n\n<p>The empty string <code>\"\"</code> is a legitimate <code>String</code> object just like anything else, it just happens to have no internal contents, and since all compile-time constant strings are interned, I'll virtually guarantee that some runtime library has already caused it to be added to the pool.</p>\n", "title": "Is &quot;new String()&quot; immutable as well?", "tags": ["java", "string", "immutability"], "link": "http://stackoverflow.com/questions/21375659/is-new-string-immutable-as-well/21375710#21375710", "post_type": "answer", "question_id": 21375659, "answer_id": 21375710}, {"body": "<p>Better way is:</p>\n\n<pre><code>Date date = ...;\nInstant.ofEpochMilli(date.getTime()).atZone(ZoneId.systemDefault()).toLocalDate()\n</code></pre>\n\n<p>Advantages of this version:</p>\n\n<ul>\n<li><p>works regardless the input is an instance of <code>java.util.Date</code> or it's subclass <code>java.sql.Date</code> (unlike @JodaStephen's way). This is common with JDBC originated data. <code>java.sql.Date.toInstant()</code> always throws an exception.</p></li>\n<li><p>it's the same for JDK8 and JDK7 with JSR-310 backport</p></li>\n</ul>\n\n<p>I personally use an utility class (but this is not backport-compatible):</p>\n\n<pre><code>/**\n * Utilities for conversion between the old and new JDK date types \n * (between {@code java.util.Date} and {@code java.time.*}).\n * \n * &lt;p&gt;\n * All methods are null-safe.\n */\npublic class DateConvertUtils {\n\n    /**\n     * Calls {@link #asLocalDate(Date, ZoneId)} with the system default time zone.\n     */\n    public static LocalDate asLocalDate(java.util.Date date) {\n        return asLocalDate(date, ZoneId.systemDefault());\n    }\n\n    /**\n     * Creates {@link LocalDate} from {@code java.util.Date} or it's subclasses. Null-safe.\n     */\n    public static LocalDate asLocalDate(java.util.Date date, ZoneId zone) {\n        if (date == null)\n            return null;\n\n        if (date instanceof java.sql.Date)\n            return ((java.sql.Date) date).toLocalDate();\n        else\n            return Instant.ofEpochMilli(date.getTime()).atZone(zone).toLocalDate();\n    }\n\n    /**\n     * Calls {@link #asLocalDateTime(Date, ZoneId)} with the system default time zone.\n     */\n    public static LocalDateTime asLocalDateTime(java.util.Date date) {\n        return asLocalDateTime(date, ZoneId.systemDefault());\n    }\n\n    /**\n     * Creates {@link LocalDateTime} from {@code java.util.Date} or it's subclasses. Null-safe.\n     */\n    public static LocalDateTime asLocalDateTime(java.util.Date date, ZoneId zone) {\n        if (date == null)\n            return null;\n\n        if (date instanceof java.sql.Timestamp)\n            return ((java.sql.Timestamp) date).toLocalDateTime();\n        else\n            return Instant.ofEpochMilli(date.getTime()).atZone(zone).toLocalDateTime();\n    }\n\n    /**\n     * Calls {@link #asUtilDate(Object, ZoneId)} with the system default time zone.\n     */\n    public static java.util.Date asUtilDate(Object date) {\n        return asUtilDate(date, ZoneId.systemDefault());\n    }\n\n    /**\n     * Creates a {@link java.util.Date} from various date objects. Is null-safe. Currently supports:&lt;ul&gt;\n     * &lt;li&gt;{@link java.util.Date}\n     * &lt;li&gt;{@link java.sql.Date}\n     * &lt;li&gt;{@link java.sql.Timestamp}\n     * &lt;li&gt;{@link java.time.LocalDate}\n     * &lt;li&gt;{@link java.time.LocalDateTime}\n     * &lt;li&gt;{@link java.time.ZonedDateTime}\n     * &lt;li&gt;{@link java.time.Instant}\n     * &lt;/ul&gt;\n     * \n     * @param zone Time zone, used only if the input object is LocalDate or LocalDateTime.\n     * \n     * @return {@link java.util.Date} (exactly this class, not a subclass, such as java.sql.Date)\n     */\n    public static java.util.Date asUtilDate(Object date, ZoneId zone) {\n        if (date == null)\n            return null;\n\n        if (date instanceof java.sql.Date || date instanceof java.sql.Timestamp)\n            return new java.util.Date(((java.util.Date) date).getTime());\n        if (date instanceof java.util.Date)\n            return (java.util.Date) date;\n        if (date instanceof LocalDate)\n            return java.util.Date.from(((LocalDate) date).atStartOfDay(zone).toInstant());\n        if (date instanceof LocalDateTime)\n            return java.util.Date.from(((LocalDateTime) date).atZone(zone).toInstant());\n        if (date instanceof ZonedDateTime)\n            return java.util.Date.from(((ZonedDateTime) date).toInstant());\n        if (date instanceof Instant)\n            return java.util.Date.from((Instant) date);\n\n        throw new UnsupportedOperationException(\"Don't know hot to convert \" + date.getClass().getName() + \" to java.util.Date\");\n    }\n\n    /**\n     * Creates an {@link Instant} from {@code java.util.Date} or it's subclasses. Null-safe.\n     */\n    public static Instant asInstant(Date date) {\n        if (date == null)\n            return null;\n        else\n            return Instant.ofEpochMilli(date.getTime());\n    }\n\n    /**\n     * Calls {@link #asZonedDateTime(Date, ZoneId)} with the system default time zone.\n     */\n    public static ZonedDateTime asZonedDateTime(Date date) {\n        return asZonedDateTime(date, ZoneId.systemDefault());\n    }\n\n    /**\n     * Creates {@link ZonedDateTime} from {@code java.util.Date} or it's subclasses. Null-safe.\n     */\n    public static ZonedDateTime asZonedDateTime(Date date, ZoneId zone) {\n        if (date == null)\n            return null;\n        else\n            return asInstant(date).atZone(zone);\n    }\n\n}\n</code></pre>\n\n<p>The <code>asLocalDate()</code> method here is null-safe, uses <code>toLocalDate()</code>, if input is <code>java.sql.Date</code> (it may be overriden by the JDBC driver to avoid timezone problems or unnecessary calculations), otherwise uses the abovementioned method.</p>\n", "title": "Convert java.util.Date to java.time.LocalDate", "tags": ["java", "datetime", "java-8", "java-time"], "link": "http://stackoverflow.com/questions/21242110/convert-java-util-date-to-java-time-localdate/27378709#27378709", "post_type": "answer", "question_id": 21242110, "answer_id": 27378709}, {"body": "<p>To complement the given answers, also take note of the following:</p>\n\n<pre><code>public class Test { \n    public static void main(String... args) { \n        Integer a = new Integer(129);\n        Integer b = new Integer(129);\n        System.out.println(a == b);\n    }\n}\n</code></pre>\n\n<p>This code will also print: <code>false</code></p>\n\n<p>As user <a href=\"http://stackoverflow.com/users/103206/jay\">Jay</a> has claimed in a comment for the accepted answer, care must be taken when using operator <code>==</code> on objects, here you're checking if both references are the same, which is not, because they are different objets, although they represent the very same value. To compare objects, you should use the <code>equals</code>  method instead:</p>\n\n<pre><code>Integer a = new Integer(128);\nInteger b = new Integer(128);\nSystem.out.println(a.equals(b));\n</code></pre>\n\n<p>This will print: <code>true</code></p>\n\n<p>You may ask, <em>But then why the first line printed <code>true</code>?</em>. Checking the source code for the <code>Integer.valueOf</code> method, you can see the following:</p>\n\n<pre><code>public static Integer valueOf(String s) throws NumberFormatException {\n    return Integer.valueOf(parseInt(s, 10));\n}\n\npublic static Integer valueOf(int i) {\n    assert IntegerCache.high &gt;= 127;\n    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n</code></pre>\n\n<p>If the param is an integer between <code>IntegerCache.low</code> (defaulted to -128) and <code>IntegerCache.high</code> (calculated at runtime with minimum value 127) then a pre-allocated (cached) object is returned. So when you use 127 as parameter, you're getting two references to same cached object and getting <code>true</code> in the comparison of the references.</p>\n", "title": "Why do == comparisons with Integer.valueOf(String) give different results for 127 and 128?", "tags": ["java", "integer", "comparison"], "link": "http://stackoverflow.com/questions/20877086/why-do-comparisons-with-integer-valueofstring-give-different-results-for-12/20889556#20889556", "post_type": "answer", "question_id": 20877086, "answer_id": 20889556}, {"body": "<p>For simple cases such as the one illustrated, they are mostly the same. However, there are a number of subtle differences that might be significant.</p>\n\n<p>One issue is with ordering. With <code>Stream.forEach</code>, the order is <strong>undefined</strong>. It's unlikely to occur with sequential streams, still, it's within the specification for <code>Stream.forEach</code> to execute in some arbitrary order. This does occur frequently in parallel streams. By contrast, <code>Iterable.forEach</code> is always executed in the iteration order of the <code>Iterable</code>, if one is specified.</p>\n\n<p>Another issue is with side effects. The action specified in <code>Stream.forEach</code> is required to be <strong>non-interfering</strong>. (See the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#NonInterference\">java.util.stream package doc</a>.) <code>Iterable.forEach</code> potentially has fewer restrictions. For the collections in <code>java.util</code>, <code>Iterable.forEach</code> will generally use that collection's <code>Iterator</code>, most of which are designed to be <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#fail-fast\">fail-fast</a> and which will throw <code>ConcurrentModificationException</code> if the collection is structurally modified during the iteration. However, modifications that aren't structural <strong>are</strong> allowed during iteration. For example, the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html\">ArrayList class documentation</a> says \"merely setting the value of an element is not a structural modification.\" Thus, the action for <code>ArrayList.forEach</code> is allowed to set values in the underlying <code>ArrayList</code> without problems.</p>\n\n<p>The concurrent collections are yet again different. Instead of fail-fast, they are designed to be <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#Weakly\">weakly consistent</a>. The full definition is at that link. Briefly, though, consider <code>ConcurrentLinkedDeque</code>. The action passed to its <code>forEach</code> method <strong>is</strong> allowed to modify the underlying deque, even structurally, and <code>ConcurrentModificationException</code> is never thrown. However, the modification that occurs might or might not be visible in this iteration. (Hence the \"weak\" consistency.)</p>\n\n<p>Still another difference is visible if <code>Iterable.forEach</code> is iterating over a synchronized collection. On such a collection, <code>Iterable.forEach</code> takes the collection's lock once and holds it across all the calls to the action method. The <code>Stream.forEach</code> call uses the collection's spliterator, which does not lock, and which relies on the prevailing rule of non-interference. The collection backing the stream could be modified during iteration, and if it is, a <code>ConcurrentModificationException</code> or inconsistent behavior could result.</p>\n", "title": "What is difference between Collection.stream().forEach() and Collection.forEach()?", "tags": ["java", "collections", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/23218874/what-is-difference-between-collection-stream-foreach-and-collection-foreach/23232560#23232560", "post_type": "answer", "question_id": 23218874, "answer_id": 23232560}, {"body": "<p>Technically there's an ugly 'workaround' that involves <code>peek()</code> and an <code>AtomicInteger</code>, but really you shouldn't be using that.</p>\n\n<p>What I do in these cases is just collecting it in a list, like this:</p>\n\n<pre><code>LinkedList&lt;User&gt; users = new LinkedList&lt;&gt;();\nusers.add(new User(1, \"User1\"));\nusers.add(new User(2, \"User2\"));\nusers.add(new User(3, \"User3\"));\nList&lt;User&gt; resultUserList = users.stream()\n        .filter(user -&gt; user.getId() == 1)\n        .collect(Collectors.toList());\nif (resultUserList.size() != 1) {\n    throw new IllegalStateException();\n}\nUser resultUser = resultUserList.get(0);\n</code></pre>\n\n<p>I am not aware of a way to do this in the API, meanwhile I will work on another example involving a custom element.</p>\n\n<p><strong>Update</strong>, You should create your own <code>Collector</code> for this:</p>\n\n<pre><code>public static &lt;T&gt; Collector&lt;T, List&lt;T&gt;, T&gt; singletonCollector() {\n    return Collector.of(\n            ArrayList::new,\n            List::add,\n            (left, right) -&gt; { left.addAll(right); return left; },\n            list -&gt; {\n                if (list.size() != 1) {\n                    throw new IllegalStateException();\n                }\n                return list.get(0);\n            }\n    );\n}\n</code></pre>\n\n<p>What it does is:</p>\n\n<ul>\n<li>It mimicks the <code>Collectors.toList()</code> collector.</li>\n<li>It applies an extra finisher at the end, that throws an exception, or if no exception, returns the first element of the list.</li>\n</ul>\n\n<p>Used as:</p>\n\n<pre><code>User resultUser = users.stream()\n        .filter(user -&gt; user.getId() &gt; 0)\n        .collect(singletonCollector());\n</code></pre>\n\n<p>You can then customize this <code>singletonCollector</code> as much as you want, for example give the exception as argument in the constructor, tweak it to allow two values, and more.</p>\n\n<p><strong>New update</strong>, I revised my old answer once more for <code>singletonCollector()</code>, it can actually be obtained like this:</p>\n\n<pre><code>public static &lt;T&gt; Collector&lt;T, ?, T&gt; singletonCollector() {\n    return Collectors.collectingAndThen(\n            Collectors.toList(),\n            list -&gt; {\n                if (list.size() != 1) {\n                    throw new IllegalStateException();\n                }\n                return list.get(0);\n            }\n    );\n}\n</code></pre>\n", "title": "Filter Java Stream to 1 and only 1 element", "tags": ["java", "lambda", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/22694884/filter-java-stream-to-1-and-only-1-element/22695031#22695031", "post_type": "answer", "question_id": 22694884, "answer_id": 22695031}, {"body": "<p>The <a href=\"http://stackoverflow.com/a/22436638/1441122\">answer from skiwi</a> covered many of the major points already. I'll fill in a bit more background.</p>\n\n<p>The design of any API is a series of tradeoffs. In Java, one of the difficult issues is dealing with design decisions that were made long ago.</p>\n\n<p>Primitives have been in Java since 1.0. They make Java an \"impure\" object-oriented language, since the primitives are not objects. The addition of primitives was, I believe, a pragmatic decision to improve performance at the expense of object-oriented purity.</p>\n\n<p>This is a tradeoff we're still living with today, nearly 20 years later. The autoboxing feature added in Java 5 mostly eliminated the need to clutter source code with boxing and unboxing method calls, but the overhead is still there. In many cases it's not noticeable. However, if you were to perform boxing or unboxing within an inner loop, you'd see that it can impose significant CPU and garbage collection overhead.</p>\n\n<p>When designing the Streams API, it was clear that we had to support primitives. The boxing/unboxing overhead would kill any performance benefit from parallelism. We didn't want to support <strong>all</strong> of the primitives, though, since that would have added a huge amount of clutter to the API. (Can you really see a use for a <code>ShortStream</code>?) \"All\" or \"none\" are comfortable places for a design to be, yet neither was acceptable. So we had to find a reasonable value of \"some\". We ended up with primitive specializations for <code>int</code>, <code>long</code>, and <code>double</code>. (Personally I would have left out <code>int</code> but that's just me.)</p>\n\n<p>For <code>CharSequence.chars()</code> we considered returning <code>Stream&lt;Character&gt;</code> (an early prototype might have implemented this) but it was rejected because of boxing overhead. Considering that a String has <code>char</code> values as primitives, it would seem to be a mistake to impose boxing unconditionally when the caller would probably just do a bit of processing on the value and unbox it right back into a string.</p>\n\n<p>We also considered a <code>CharStream</code> primitive specialization, but its use would seem to be quite narrow compared to the amount of bulk it would add to the API. It didn't seem worthwhile to add it.</p>\n\n<p>The penalty this imposes on callers is that they have to know that the <code>IntStream</code> contains <code>char</code> values represented as <code>ints</code> and that casting must be done at the proper place. This is doubly confusing because there are overloaded API calls like <code>PrintStream.print(char)</code> and <code>PrintStream.print(int)</code> that differ markedly in their behavior. An additional point of confusion possibly arises because the <code>codePoints()</code> call also returns an <code>IntStream</code> but the values it contains are quite different.</p>\n\n<p>So, this boils down to choosing pragmatically among several alternatives:</p>\n\n<ol>\n<li><p>We could provide no primitive specializations, resulting in a simple, elegant, consistent API, but which imposes a high performance and GC overhead;</p></li>\n<li><p>we could provide a complete set of primitive specializations, at the cost of cluttering up the API and imposing a maintenance burden on JDK developers; or</p></li>\n<li><p>we could provide a subset of primitive specializations, giving a moderately sized, high performing API that imposes a relatively small burden on callers in a fairly narrow range of use cases (char processing).</p></li>\n</ol>\n\n<p>We chose the last one.</p>\n", "title": "Why is String.chars() a stream of ints in Java 8?", "tags": ["java", "string", "java-8"], "link": "http://stackoverflow.com/questions/22435833/why-is-string-chars-a-stream-of-ints-in-java-8/22497858#22497858", "post_type": "answer", "question_id": 22435833, "answer_id": 22497858}, {"body": "<p>You can use <code>java.sql.Date.valueOf()</code> method as:</p>\n\n<pre><code>Date date = java.sql.Date.valueOf(localDate);\n</code></pre>\n\n<p>No need to add time and time zone info here because they are taken implicitly.<br>\nSee <a href=\"http://stackoverflow.com/questions/33066904/simpliest-java8-localdate-to-java-util-date-conversion-and-vice-versa\">Simpliest java8 LocalDate to java.util.Date conversion and vice versa?</a></p>\n", "title": "Convert java.time.LocalDate into java.util.Date type", "tags": ["java", "java-8", "java-time"], "link": "http://stackoverflow.com/questions/22929237/convert-java-time-localdate-into-java-util-date-type/28564046#28564046", "post_type": "answer", "question_id": 22929237, "answer_id": 28564046}, {"body": "<p>This works because <code>Integer::min</code> resolves to an implementation of the <code>Comparable&lt;Integer&gt;</code> interface.</p>\n\n<p>The method reference of <code>Integer::min</code> resolves to <code>Integer.min(int a, int b)</code>, resolved to <code>IntBinaryOperator</code>, and presumably autoboxing occurs somewhere making it a <code>BinaryOperator&lt;Integer&gt;</code>.</p>\n\n<p>And the <code>min()</code> resp <code>max()</code> methods of the <code>Stream&lt;Integer&gt;</code> ask the <code>Comparable&lt;Integer&gt;</code> interface to be implemented.<br>\nNow this resolves to the single method <code>Integer compareTo(Integer o1, Integer o2)</code>. Which is of type <code>BinaryOperator&lt;Integer&gt;</code>.</p>\n\n<p>And thus the magic has happened as both methods are a <code>BinaryOperator&lt;Integer&gt;</code>.</p>\n", "title": "Java 8 stream&#39;s .min() and .max(): why does this compile?", "tags": ["java", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/22561614/java-8-streams-min-and-max-why-does-this-compile/22561687#22561687", "post_type": "answer", "question_id": 22561614, "answer_id": 22561687}, {"body": "<p>Let me explain what is happening here, because it isn't obvious!</p>\n\n<p>First, <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#max-java.util.Comparator-\"><code>Stream.max()</code></a> accepts an instance of <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html\"><code>Comparator</code></a> so that items in the stream can be compared against each other to find the minimum or maximum, in some optimal order that you don't need to worry too much about.</p>\n\n<p>So the question is, of course, why is <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#max-int-int-\"><code>Integer::max</code></a> accepted?  After all it's not a comparator!</p>\n\n<p>The answer is in the way that the new lambda functionality works in Java 8.  It relies on a concept which is informally known as \"single abstract method\" interfaces, or \"SAM\" interfaces.  The idea is that any interface with one abstract method can be automatically implemented by any lambda - or method reference - whose method signature is a match for the one method on the interface.  So examining the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html\"><code>Comparator</code></a> interface (simple version):</p>\n\n<pre><code>public Comparator&lt;T&gt; {\n    int compare(T o1, T o2);\n}\n</code></pre>\n\n<p>If a method is looking for a <code>Comparator&lt;Integer&gt;</code>, then it's essentially looking for this signature:</p>\n\n<pre><code>int xxx(Integer o1, Integer o2);\n</code></pre>\n\n<p>I use \"xxx\" <strong>because the method name is not used for matching purposes</strong>.</p>\n\n<p>Therefore, both <code>Integer.min(int a, int b)</code> and <code>Integer.max(int a, int b)</code> are close enough that autoboxing will allow this to appear as a <code>Comparator&lt;Integer&gt;</code> in a method context.</p>\n", "title": "Java 8 stream&#39;s .min() and .max(): why does this compile?", "tags": ["java", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/22561614/java-8-streams-min-and-max-why-does-this-compile/22561853#22561853", "post_type": "answer", "question_id": 22561614, "answer_id": 22561853}, {"body": "<blockquote>\n  <p>However this seems inefficient to me, as the filter will scan the whole list</p>\n</blockquote>\n\n<p>No it won't - it will \"break\" as soon as the first element satisfying the predicate is found. You can read more about laziness in the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html\">stream package javadoc</a>, in particular (emphasis mine):</p>\n\n<blockquote>\n  <p>Many stream operations, such as filtering, mapping, or duplicate removal, can be implemented lazily, exposing opportunities for optimization. For example, \"find the first String with three consecutive vowels\" need not examine all the input strings. Stream operations are divided into intermediate (Stream-producing) operations and terminal (value- or side-effect-producing) operations. <strong><em>Intermediate operations are always lazy.</em></strong></p>\n</blockquote>\n", "title": "Java 8 find first element by predicate", "tags": ["java", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/23696317/java-8-find-first-element-by-predicate/23696598#23696598", "post_type": "answer", "question_id": 23696317, "answer_id": 23696598}, {"body": "<p>Just do:</p>\n\n<pre><code>Stream.of(stream1, stream2, Stream.of(element)).flatMap(identity());\n</code></pre>\n\n<p>where <code>identity()</code> is a static import of <code>Function.identity()</code>.</p>\n\n<p>Concatenating multiple streams into one stream is the same as flattening a stream.</p>\n\n<p>However, unfortunately, for some reason there is no <code>flatten()</code> method on <code>Stream</code>, so you have to use <code>flatMap()</code> with the identity function.</p>\n", "title": "Adding two Java 8 streams, or an extra element to a stream", "tags": ["java", "concat", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/22740464/adding-two-java-8-streams-or-an-extra-element-to-a-stream/37436520#37436520", "post_type": "answer", "question_id": 22740464, "answer_id": 37436520}, {"body": "<h2>Made up example</h2>\n\n<p>Imagine that you want to create the following sequence: 1, 2, 2, 3, 3, 3, 4, 4, 4, 4 etc. (in other words: 1x1, 2x2, 3x3 etc.)</p>\n\n<p>With <code>flatMap</code> it could look like:</p>\n\n<pre><code>IntStream sequence = IntStream.rangeClosed(1, 4)\n                          .flatMap(i -&gt; IntStream.iterate(i, identity()).limit(i));\nsequence.forEach(System.out::println);\n</code></pre>\n\n<p>where:</p>\n\n<ul>\n<li><code>IntStream.rangeClosed(1, 4)</code> creates a stream of <code>int</code> from 1 to 4, inclusive</li>\n<li><code>IntStream.iterate(i, identity()).limit(i)</code> creates a stream of length i of <code>int</code> i - so applied to <code>i = 4</code> it creates a stream: <code>4, 4, 4, 4</code></li>\n<li><code>flatMap</code> \"flattens\" the stream and \"concatenates\" it to the original stream</li>\n</ul>\n\n<p>With Java &lt; 8 you would need two nested loops:</p>\n\n<pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nfor (int i = 1; i &lt;= 4; i++) {\n    for (int j = 0; j &lt; i; j++) {\n        list.add(i);\n    }\n}\n</code></pre>\n\n<h2>Real world example</h2>\n\n<p>Let's say I have a <code>List&lt;TimeSeries&gt;</code> where each <code>TimeSeries</code> is essentially a <code>Map&lt;LocalDate, Double&gt;</code>. I want to get a list of all dates for which at least one of the time series has a value. <code>flatMap</code> to the rescue:</p>\n\n<pre><code>list.stream().parallel()\n    .flatMap(ts -&gt; ts.dates().stream()) // for each TS, stream dates and flatmap\n    .distinct()                         // remove duplicates\n    .sorted()                           // sort ascending\n    .collect(toList());\n</code></pre>\n\n<p>Not only is it readable, but if you suddenly need to process 100k elements, simply adding <code>parallel()</code> will improve performance without you writing any concurrent code.</p>\n", "title": "Java 8 Streams FlatMap method example", "tags": ["java", "java-8", "java-stream", "flatmap"], "link": "http://stackoverflow.com/questions/22382453/java-8-streams-flatmap-method-example/22384113#22384113", "post_type": "answer", "question_id": 22382453, "answer_id": 22384113}, {"body": "<p>A subsequent post by the same user in the same conversation:</p>\n\n<blockquote>\n  <p>new T is a broken program. It is isomorphic to the claim \"all propositions are true.\" I am not big into this.</p>\n</blockquote>\n\n<p>(This was in response to a statement by another user, namely that \"it seems in some situations 'new T' would be better\", the idea being that <code>new T()</code> is impossible due to type erasure. (This is debatable &mdash; even if <code>T</code> were available at runtime, it could be an abstract class or interface, or it could be <code>Void</code>, or it could lack a no-arg constructor, or its no-arg constructor could be private (e.g., because it's supposed to be a singleton class), or its no-arg constructor could specify a checked exception that the generic method does not catch or specify &mdash; but that was the premise. Regardless, it's true that without erasure you could at least write <code>T.class.newInstance()</code>, which handles those issues.))</p>\n\n<p>This view, that types are isomorphic to propositions, suggests that the user has a background in formal type theory. (S)he very likely does not like \"dynamic types\" or \"runtime-types\" and would prefer a Java without downcasts and <code>instanceof</code> and reflection and so on. (Think of a language like Standard ML, which has a very rich (static) type system and whose dynamic semantics do not depend on any type information whatsoever.)</p>\n\n<p>It's worth keeping in mind, by the way, that the user is trolling: while (s)he likely sincerely prefers (statically) typed languages, (s)he is <em>not</em> sincerely trying to persuade others of that view. Rather, the main purpose of the original tweet was to mock those who disagree, and after some of those disagree-ers chimed in, the user posted follow-up tweets such as \"the reason java has type erasure is that Wadler et al know what they are doing, unlike users of java\". Unfortunately, this makes it hard to find out what (s)he's actually thinking; but fortunately, it also likely means that it's not very important to do so. People with actual depth to their views don't generally resort to trolls that are <em>quite</em> this content-free.</p>\n", "title": "What are the benefits of Java&#39;s types erasure?", "tags": ["java", "type-erasure"], "link": "http://stackoverflow.com/questions/20918650/what-are-the-benefits-of-javas-types-erasure/20918709#20918709", "post_type": "answer", "question_id": 20918650, "answer_id": 20918709}, {"body": "<p>You can use <a href=\"http://www.eclipse.org/collections/javadoc/7.0.0/org/eclipse/collections/impl/block/factory/Predicates.html\" rel=\"nofollow\">Predicates</a> from <a href=\"http://www.eclipse.org/collections/\" rel=\"nofollow\">Eclipse Collections</a></p>\n\n<pre><code>MutableList&lt;String&gt; strings = Lists.mutable.empty();\nint nonEmptyStrings = strings.count(Predicates.not(String::isEmpty));\n</code></pre>\n\n<p>If you can't change the strings from <code>List</code>:</p>\n\n<pre><code>List&lt;String&gt; strings = new ArrayList&lt;&gt;();\nint nonEmptyStrings = ListAdapter.adapt(strings).count(Predicates.not(String::isEmpty));\n</code></pre>\n\n<p>If you only need a negation of <code>String.isEmpty()</code> you can also use <code>StringPredicates.notEmpty()</code>.</p>\n\n<p>Note: I am a contributor to Eclipse Collections.</p>\n", "title": "How to negate a method reference predicate", "tags": ["java", "predicate", "java-8", "negate"], "link": "http://stackoverflow.com/questions/21488056/how-to-negate-a-method-reference-predicate/36242382#36242382", "post_type": "answer", "question_id": 21488056, "answer_id": 36242382}, {"body": "<p>The behavior of <code>String.split</code> (which calls <code>Pattern.split</code>) changes between Java 7 and Java 8.</p>\n\n<h1>Documentation</h1>\n\n<p>Comparing between the documentation of <code>Pattern.split</code> in <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#split%28java.lang.CharSequence,%20int%29\">Java 7</a> and <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#split-java.lang.CharSequence-int-\">Java 8</a>, we observe the following clause being added:</p>\n\n<blockquote>\n  <p>When there is a positive-width match at the beginning of the input sequence then an empty leading substring is included at the beginning of the resulting array. A zero-width match at the beginning however never produces such empty leading substring.</p>\n</blockquote>\n\n<p>The same clause is also added to <code>String.split</code> in <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-int-\">Java 8</a>, compared to <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#split%28java.lang.CharSequence,%20int%29\">Java 7</a>.</p>\n\n<h1>Reference implementation</h1>\n\n<p>Let us compare the code of <code>Pattern.split</code> of the reference implemetation in Java 7 and Java 8. The code is retrieved from grepcode, for version 7u40-b43 and 8-b132.</p>\n\n<h2>Java 7</h2>\n\n<pre><code>public String[] split(CharSequence input, int limit) {\n    int index = 0;\n    boolean matchLimited = limit &gt; 0;\n    ArrayList&lt;String&gt; matchList = new ArrayList&lt;&gt;();\n    Matcher m = matcher(input);\n\n    // Add segments before each match found\n    while(m.find()) {\n        if (!matchLimited || matchList.size() &lt; limit - 1) {\n            String match = input.subSequence(index, m.start()).toString();\n            matchList.add(match);\n            index = m.end();\n        } else if (matchList.size() == limit - 1) { // last one\n            String match = input.subSequence(index,\n                                             input.length()).toString();\n            matchList.add(match);\n            index = m.end();\n        }\n    }\n\n    // If no match was found, return this\n    if (index == 0)\n        return new String[] {input.toString()};\n\n    // Add remaining segment\n    if (!matchLimited || matchList.size() &lt; limit)\n        matchList.add(input.subSequence(index, input.length()).toString());\n\n    // Construct result\n    int resultSize = matchList.size();\n    if (limit == 0)\n        while (resultSize &gt; 0 &amp;&amp; matchList.get(resultSize-1).equals(\"\"))\n            resultSize--;\n    String[] result = new String[resultSize];\n    return matchList.subList(0, resultSize).toArray(result);\n}\n</code></pre>\n\n<h2>Java 8</h2>\n\n<pre><code>public String[] split(CharSequence input, int limit) {\n    int index = 0;\n    boolean matchLimited = limit &gt; 0;\n    ArrayList&lt;String&gt; matchList = new ArrayList&lt;&gt;();\n    Matcher m = matcher(input);\n\n    // Add segments before each match found\n    while(m.find()) {\n        if (!matchLimited || matchList.size() &lt; limit - 1) {\n            if (index == 0 &amp;&amp; index == m.start() &amp;&amp; m.start() == m.end()) {\n                // no empty leading substring included for zero-width match\n                // at the beginning of the input char sequence.\n                continue;\n            }\n            String match = input.subSequence(index, m.start()).toString();\n            matchList.add(match);\n            index = m.end();\n        } else if (matchList.size() == limit - 1) { // last one\n            String match = input.subSequence(index,\n                                             input.length()).toString();\n            matchList.add(match);\n            index = m.end();\n        }\n    }\n\n    // If no match was found, return this\n    if (index == 0)\n        return new String[] {input.toString()};\n\n    // Add remaining segment\n    if (!matchLimited || matchList.size() &lt; limit)\n        matchList.add(input.subSequence(index, input.length()).toString());\n\n    // Construct result\n    int resultSize = matchList.size();\n    if (limit == 0)\n        while (resultSize &gt; 0 &amp;&amp; matchList.get(resultSize-1).equals(\"\"))\n            resultSize--;\n    String[] result = new String[resultSize];\n    return matchList.subList(0, resultSize).toArray(result);\n}\n</code></pre>\n\n<p>The addition of the following code in Java 8 excludes the zero-length match at the beginning of the input string, which explains the behavior above.</p>\n\n<pre><code>            if (index == 0 &amp;&amp; index == m.start() &amp;&amp; m.start() == m.end()) {\n                // no empty leading substring included for zero-width match\n                // at the beginning of the input char sequence.\n                continue;\n            }\n</code></pre>\n\n<h1>Maintaining compatibility</h1>\n\n<h2>Following behavior in Java 8 and above</h2>\n\n<p>To make <code>split</code> behaves consistently across versions and compatible with the behavior in Java 8:</p>\n\n<ol>\n<li>If your regex <strong>can</strong> match zero-length string, just add <code>(?!\\A)</code> at <strong>the end</strong> of the regex and wrap the original regex in non-capturing group <code>(?:...)</code> (if necessary).</li>\n<li>If your regex <strong>can't</strong> match zero-length string, you don't need to do anything.</li>\n<li>If you don't know whether the regex can match zero-length string or not, do both the actions in step 1.</li>\n</ol>\n\n<p><code>(?!\\A)</code> checks that the string does not end at the beginning of the string, which implies that the match is an empty match at the beginning of the string.</p>\n\n<h2>Following behavior in Java 7 and prior</h2>\n\n<p>There is no general solution to make <code>split</code> backward-compatible with Java 7 and prior, short of replacing all instance of <code>split</code> to point to your own custom implementation.</p>\n", "title": "Why in Java 8 split sometimes removes empty strings at start of result array?", "tags": ["java", "regex", "split", "java-8"], "link": "http://stackoverflow.com/questions/22718744/why-in-java-8-split-sometimes-removes-empty-strings-at-start-of-result-array/27477312#27477312", "post_type": "answer", "question_id": 22718744, "answer_id": 27477312}]}