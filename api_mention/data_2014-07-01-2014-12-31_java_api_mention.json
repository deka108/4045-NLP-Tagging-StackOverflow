{"items": [{"body": "<p>I don't know whether I am asking the right question. I was exploring <code>RecyclerView</code> and I was surprised to see that <code>RecyclerView</code> does not have <code>onItemClickListener()</code>. Because <code>RecyclerView</code> extends     </p>\n\n<blockquote>\n  <p><strong>android.view.ViewGroup</strong></p>\n</blockquote>\n\n<p>and <code>ListView</code> extends </p>\n\n<blockquote>\n  <p><strong>android.widget.AbsListView</strong></p>\n</blockquote>\n\n<p>.  However I solved my problem by writing <code>onClick</code> in my <code>RecyclerView.Adapter</code>:</p>\n\n<pre><code>public static class ViewHolder extends RecyclerView.ViewHolder implements OnClickListener {\n\n    public TextView txtViewTitle;\n    public ImageView imgViewIcon;\n\n    public ViewHolder(View itemLayoutView) {\n        super(itemLayoutView);\n        txtViewTitle = (TextView) itemLayoutView.findViewById(R.id.item_title);\n        imgViewIcon = (ImageView) itemLayoutView.findViewById(R.id.item_icon);\n    }\n\n    @Override\n    public void onClick(View v) {\n\n    }\n}\n</code></pre>\n\n<p>But still I want to know why Google removed <code>onItemClickListener()</code>? </p>\n\n<p>Is there a performance issue or something else?</p>\n", "title": "Why doesn&#39;t RecyclerView have onItemClickListener()? And how RecyclerView is different from Listview?", "tags": ["java", "android", "recyclerview"], "link": "http://stackoverflow.com/questions/24885223/why-doesnt-recyclerview-have-onitemclicklistener-and-how-recyclerview-is-dif", "post_type": "question", "question_id": 24885223}, {"body": "<p>In Java 8, what's the difference between <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#map-java.util.function.Function-\"><code>Stream.map</code></a> and <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#flatMap-java.util.function.Function-\"><code>Stream.flatMap</code></a> methods?</p>\n", "title": "What&#39;s the difference between map and flatMap methods in Java 8?", "tags": ["java", "java-8"], "link": "http://stackoverflow.com/questions/26684562/whats-the-difference-between-map-and-flatmap-methods-in-java-8", "post_type": "question", "question_id": 26684562}, {"body": "<p>The Java language specification specifies that </p>\n\n<blockquote>\n  <p>In the Java programming language arrays are objects (\u00a74.3.1), are dynamically created, and may be assigned to variables of type Object (\u00a74.3.2). All methods of class <code>Object</code> may be invoked on an array.</p>\n</blockquote>\n\n<p>So, considering arrays are objects \u2014 why did the Java designers make the decision not to allow inherit and override from it, for example, <a href=\"http://stackoverflow.com/questions/10295600/is-it-possible-in-java-to-override-tostring-for-an-objects-array\"><code>toString()</code></a> or <code>equals()</code>?</p>\n\n<p>The current syntax wouldn't allow creating anonymous classes with an array as the base class, but I don't think <em>that</em> was the reason for their decision.</p>\n", "title": "Why are arrays Objects, but can not be used as a base class?", "tags": ["java", "arrays", "inheritance", "compilation"], "link": "http://stackoverflow.com/questions/27504925/why-are-arrays-objects-but-can-not-be-used-as-a-base-class", "post_type": "question", "question_id": 27504925}, {"body": "<p>I just studied about generic programming, the <code>List&lt;E&gt;</code> interface, and <code>ArrayList</code>, so I can understand the statement below.</p>\n\n<pre><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();\n</code></pre>\n\n<p>But I don't understand the next statement which I saw while surfing the web.</p>\n\n<pre><code>List&lt;String&gt; list2 = Collections.&lt;String&gt;emptyList();\n</code></pre>\n\n<ol>\n<li>What is <code>Collections</code>? Why isn't it <code>Collections&lt;E&gt;</code> or <code>Collections&lt;String&gt;</code>?</li>\n<li>Why is <code>&lt;String&gt;</code> placed before the method name <code>emptyList</code>?</li>\n</ol>\n\n<p>(Isn't <code>emptyList&lt;String&gt;()</code> correct for Generic?)</p>\n\n<ol start=\"3\">\n<li>What does the statement mean?</li>\n</ol>\n", "title": "Explain the syntax of Collections.&lt;String&gt;emptyList()", "tags": ["java", "generics", "collections"], "link": "http://stackoverflow.com/questions/27683759/explain-the-syntax-of-collections-stringemptylist", "post_type": "question", "question_id": 27683759}, {"body": "<p>I was being taught that Marker interface in Java is an empty interface and is used to signal to compiler or JVM that the objects of the class implementing this interface must be treated in a special way, like serializing, cloning, etc.</p>\n\n<p>But lately I have learned that it actually has nothing to do with the compiler or the JVM. For example, in case of <code>Serializable</code> interface the method <code>writeObject(Object)</code> of <code>ObjectOutputStream</code> does something like <code>instanceOf Serializable</code> to detect whether the class implements <code>Serializable</code> &amp; throws <code>NotSerializableException</code> accordingly.\nEverything is handled in the code and this seems to be a design-pattern so I think we can define our own marker interfaces.</p>\n\n<p>Now my doubts:</p>\n\n<ol>\n<li><p>Is the definition of a marker interface mentioned above in 1st point wrong? How can we define a Marker interface then?</p></li>\n<li><p>And instead of using the <code>instanceOf</code> operator why can't the method be something like <code>writeObject(Serializable)</code> so that there is a compile-time type checking rather than runtime?</p></li>\n<li><p>How are Annotations better than Marker Interfaces?</p></li>\n</ol>\n", "title": "Marker Interfaces in Java?", "tags": ["java", "design-patterns", "marker-interfaces"], "link": "http://stackoverflow.com/questions/25850328/marker-interfaces-in-java", "post_type": "question", "question_id": 25850328}, {"body": "<p>The Java 8 <code>Collectors.toMap</code> throws a <code>NullPointerException</code> if one of the values is 'null'. I don't understand this behaviour, maps can contain null pointers as value without any problems. Is there a good reason why values cannot be null for <code>Collectors.toMap</code>?</p>\n\n<p>Also, is there a nice Java 8 way of fixing this, or should I revert to plain old for loop?</p>\n\n<p>An example of my problem:</p>\n\n<pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\n\nclass Answer {\n    private int id;\n\n    private Boolean answer;\n\n    Answer() {\n    }\n\n    Answer(int id, Boolean answer) {\n        this.id = id;\n        this.answer = answer;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public Boolean getAnswer() {\n        return answer;\n    }\n\n    public void setAnswer(Boolean answer) {\n        this.answer = answer;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        List&lt;Answer&gt; answerList = new ArrayList&lt;&gt;();\n\n        answerList.add(new Answer(1, true));\n        answerList.add(new Answer(2, true));\n        answerList.add(new Answer(3, null));\n\n        Map&lt;Integer, Boolean&gt; answerMap =\n        answerList\n                .stream()\n                .collect(Collectors.toMap(Answer::getId, Answer::getAnswer));\n    }\n}\n</code></pre>\n\n<p>Stacktrace:</p>\n\n<pre><code>Exception in thread \"main\" java.lang.NullPointerException\n    at java.util.HashMap.merge(HashMap.java:1216)\n    at java.util.stream.Collectors.lambda$toMap$168(Collectors.java:1320)\n    at java.util.stream.Collectors$$Lambda$5/1528902577.accept(Unknown Source)\n    at java.util.stream.ReduceOps$3ReducingSink.accept(ReduceOps.java:169)\n    at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1359)\n    at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:512)\n    at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:502)\n    at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)\n    at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n    at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)\n    at Main.main(Main.java:48)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)\n</code></pre>\n", "title": "Java 8 NullPointerException in Collectors.toMap", "tags": ["java", "nullpointerexception", "java-8", "java-stream", "collectors"], "link": "http://stackoverflow.com/questions/24630963/java-8-nullpointerexception-in-collectors-tomap", "post_type": "question", "question_id": 24630963}, {"body": "<p>I am getting following exception while running the tests. I am using Mockito for mocking. The hints mentioned by Mockito library are not helping.</p>\n\n<pre><code>org.mockito.exceptions.misusing.UnfinishedStubbingException: \nUnfinished stubbing detected here:\n    -&gt; at com.a.b.DomainTestFactory.myTest(DomainTestFactory.java:355)\n\n    E.g. thenReturn() may be missing.\n    Examples of correct stubbing:\n        when(mock.isOk()).thenReturn(true);\n        when(mock.isOk()).thenThrow(exception);\n        doThrow(exception).when(mock).someVoidMethod();\n    Hints:\n     1. missing thenReturn()\n     2. you are trying to stub a final method, you naughty developer!\n\n        at a.b.DomainTestFactory.myTest(DomainTestFactory.java:276)\n        ..........\n</code></pre>\n\n<p>Test Code from DomainTestFactory. When I run the following test, I see the exception</p>\n\n<pre><code>@Test\npublic myTest(){\n    MyMainModel mainModel =  Mockito.mock(MyMainModel.class);\n    Mockito.when(mainModel.getList()).thenReturn(getSomeList()); --&gt; Line 355\n}\n\nprivate List&lt;SomeModel&gt; getSomeList() {\n    SomeModel model = Mockito.mock(SomeModel.class);\n    Mockito.when(model.getName()).thenReturn(\"SomeName\"); --&gt; Line 276\n    Mockito.when(model.getAddress()).thenReturn(\"Address\");\n    return Arrays.asList(model);\n}\n\npublic class SomeModel extends SomeInputModel{\n    protected String address;\n    protected List&lt;SomeClass&gt; properties;\n\n    public SomeModel() {\n        this.Properties = new java.util.ArrayList&lt;SomeClass&gt;(); \n    }\n\n    public String getAddress() {\n        return this.address;\n    }\n\n}\n\npublic class SomeInputModel{\n\n    public NetworkInputModel() {\n        this.Properties = new java.util.ArrayList&lt;SomeClass&gt;(); \n    }\n\n    protected String Name;\n    protected List&lt;SomeClass&gt; properties;\n\n    public String getName() {\n        return this.Name;\n    }\n\n    public void setName(String value) {\n        this.Name = value;\n    }\n}\n</code></pre>\n", "title": "Unfinished Stubbing Detected in Mockito", "tags": ["java", "mocking", "mockito"], "link": "http://stackoverflow.com/questions/26318569/unfinished-stubbing-detected-in-mockito", "post_type": "question", "question_id": 26318569}, {"body": "<p>What's the main difference between <code>scheduleAtFixedRate</code> and <code>scheduleWithFixedDelay</code> methods of <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html\">ScheduledExecutorService</a>?</p>\n\n<pre><code>scheduler.scheduleAtFixedRate(new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"scheduleAtFixedRate:    \" + new Date());\n    }\n}, 1, 3L , SECONDS);\n\nscheduler.scheduleWithFixedDelay(new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"scheduleWithFixedDelay: \" + new Date());\n    }\n}, 1, 3L , SECONDS);\n</code></pre>\n\n<p>they print exact the same time, seems they are executed at exact the same interval.</p>\n", "title": "scheduleAtFixedRate vs scheduleWithFixedDelay", "tags": ["java", "scheduled-tasks", "scheduledexecutorservice"], "link": "http://stackoverflow.com/questions/24649842/scheduleatfixedrate-vs-schedulewithfixeddelay", "post_type": "question", "question_id": 24649842}, {"body": "<p>Use the <a href=\"http://commons.apache.org/proper/commons-lang/javadocs/api-release/org/apache/commons/lang3/StringUtils.html#replaceEach(java.lang.String,%20java.lang.String[],%20java.lang.String[])\"><code>replaceEach()</code></a> method from <a href=\"http://commons.apache.org/proper/commons-lang/javadocs/api-release/org/apache/commons/lang3/StringUtils.html\">Apache Commons StringUtils</a>:</p>\n\n<pre><code>StringUtils.replaceEach(story, new String[]{\"foo\", \"bar\"}, new String[]{\"bar\", \"foo\"})\n</code></pre>\n", "title": "How can I replace two strings in a way that one does not end up replacing the other?", "tags": ["java", "string", "replace"], "link": "http://stackoverflow.com/questions/26791441/how-can-i-replace-two-strings-in-a-way-that-one-does-not-end-up-replacing-the-ot/26791724#26791724", "post_type": "answer", "question_id": 26791441, "answer_id": 26791724}, {"body": "<p>Search for the first word to be replaced. If it's in the string, recurse on the the part of the string before the occurrence, and on the part of the string after the occurrence.</p>\n\n<p>Otherwise, continue with the next word to be replaced.</p>\n\n<p>A naive implementation might look like this</p>\n\n<pre><code>public static String replaceAll(String input, String[] search, String[] replace) {\n  return replaceAll(input, search, replace, 0);\n}\n\nprivate static String replaceAll(String input, String[] search, String[] replace, int i) {\n  if (i == search.length) {\n    return input;\n  }\n  int j = input.indexOf(search[i]);\n  if (j == -1) {\n    return replaceAll(input, search, replace, i + 1);\n  }\n  return replaceAll(input.substring(0, j), search, replace, i + 1) +\n         replace[i] +\n         replaceAll(input.substring(j + search[i].length()), search, replace, i);\n}\n</code></pre>\n\n<p>Sample usage:</p>\n\n<pre><code>String input = \"Once upon a baz, there was a foo and a bar.\";\nString[] search = new String[] { \"foo\", \"bar\", \"baz\" };\nString[] replace = new String[] { \"bar\", \"baz\", \"foo\" };\nSystem.out.println(replaceAll(input, search, replace));\n</code></pre>\n\n<p>Output:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Once upon a foo, there was a bar and a baz.\n</code></pre>\n\n<hr>\n\n<p>A less-naive version:</p>\n\n<pre><code>public static String replaceAll(String input, String[] search, String[] replace) {\n  StringBuilder sb = new StringBuilder();\n  replaceAll(sb, input, 0, input.length(), search, replace, 0);\n  return sb.toString();\n}\n\nprivate static void replaceAll(StringBuilder sb, String input, int start, int end, String[] search, String[] replace, int i) {\n  while (i &lt; search.length &amp;&amp; start &lt; end) {\n    int j = indexOf(input, search[i], start, end);\n    if (j == -1) {\n      i++;\n    } else {\n      replaceAll(sb, input, start, j, search, replace, i + 1);\n      sb.append(replace[i]);\n      start = j + search[i].length();\n    }\n  }\n  sb.append(input, start, end);\n}\n</code></pre>\n\n<p>Unfortunately, Java's <code>String</code> has no <code>indexOf(String str, int fromIndex, int toIndex)</code> method. I've omitted the implementation of <code>indexOf</code> here as I'm not certain it's correct, but it can be found on <a href=\"http://ideone.com/z1zM5H\">ideone</a>, along with some rough timings of various solutions posted here.</p>\n", "title": "How can I replace two strings in a way that one does not end up replacing the other?", "tags": ["java", "string", "replace"], "link": "http://stackoverflow.com/questions/26791441/how-can-i-replace-two-strings-in-a-way-that-one-does-not-end-up-replacing-the-ot/26791826#26791826", "post_type": "answer", "question_id": 26791441, "answer_id": 26791826}, {"body": "<h2>Swapping Only One Occurrence</h2>\n\n<p>If there is only one occurrence of each of the swapable strings in the input, you can do the following:</p>\n\n<p>Before proceeding to any replace, get the indices of the occurrences of the words. After that we only replace the word found at these indexes, and not all occurrences. This solution uses <code>StringBuilder</code> and does not produce intermediate <code>String</code>s like <code>String.replace()</code>.</p>\n\n<p>One thing to note: if the swapable words have different lengths, after the first replace the second index might change (if the 1st word occurs before the 2nd) exactly with the difference of the 2 lengths. So aligning the second index will ensure this works even if we're swapping words with different lengths.</p>\n\n<pre><code>public static String swap(String src, String s1, String s2) {\n    StringBuilder sb = new StringBuilder(src);\n    int i1 = src.indexOf(s1);\n    int i2 = src.indexOf(s2);\n\n    sb.replace(i1, i1 + s1.length(), s2); // Replace s1 with s2\n    // If s1 was before s2, idx2 might have changed after the replace\n    if (i1 &lt; i2)\n        i2 += s2.length() - s1.length();\n    sb.replace(i2, i2 + s2.length(), s1); // Replace s2 with s1\n\n    return sb.toString();\n}\n</code></pre>\n\n<h2>Swapping Arbitrary Number of Occurrences</h2>\n\n<p>Analogous to the previous case we will first collect the indexes (occurrences) of the words, but in this case it will a list of integers for each word, not just one <code>int</code>. For this we will use the following utility method:</p>\n\n<pre><code>public static List&lt;Integer&gt; occurrences(String src, String s) {\n    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n    for (int idx = 0;;)\n        if ((idx = src.indexOf(s, idx)) &gt;= 0) {\n            list.add(idx);\n            idx += s.length();\n        } else\n            return list;\n}\n</code></pre>\n\n<p>And using this we will replace the words with the other one by decreasing index (which might require to alternate between the 2 swapable words) so that we won't even have to correct the indices after a replace:</p>\n\n<pre><code>public static String swapAll(String src, String s1, String s2) {\n    List&lt;Integer&gt; l1 = occurrences(src, s1), l2 = occurrences(src, s2);\n\n    StringBuilder sb = new StringBuilder(src);\n\n    // Replace occurrences by decreasing index, alternating between s1 and s2\n    for (int i1 = l1.size() - 1, i2 = l2.size() - 1; i1 &gt;= 0 || i2 &gt;= 0;) {\n        int idx1 = i1 &lt; 0 ? -1 : l1.get(i1);\n        int idx2 = i2 &lt; 0 ? -1 : l2.get(i2);\n        if (idx1 &gt; idx2) { // Replace s1 with s2\n            sb.replace(idx1, idx1 + s1.length(), s2);\n            i1--;\n        } else { // Replace s2 with s1\n            sb.replace(idx2, idx2 + s2.length(), s1);\n            i2--;\n        }\n    }\n\n    return sb.toString();\n}\n</code></pre>\n", "title": "How can I replace two strings in a way that one does not end up replacing the other?", "tags": ["java", "string", "replace"], "link": "http://stackoverflow.com/questions/26791441/how-can-i-replace-two-strings-in-a-way-that-one-does-not-end-up-replacing-the-ot/26796725#26796725", "post_type": "answer", "question_id": 26791441, "answer_id": 26796725}, {"body": "<p>This is not an easy problem. And the more search-replacement parameters you have, the trickier it gets. You have several options, scattered on the palette of ugly-elegant, efficient-wasteful:</p>\n\n<ul>\n<li><p>Use <code>StringUtils.replaceEach</code> from Apache Commons as <a href=\"http://stackoverflow.com/users/1356423/alan-hay\">@AlanHay</a> recommended. This is a good option if you're free to add new dependencies in your project. You might get lucky: the dependency might be included already in your project</p></li>\n<li><p>Use a temporary placeholder as <a href=\"http://stackoverflow.com/users/1864167/jeroen-vannevel\">@Jeroen</a> suggested, and perform the replacement in 2 steps:</p>\n\n<ol>\n<li>Replace all search patterns with a unique tag that doesn't exist in the original text</li>\n<li>Replace the placeholders with the real target replacement</li>\n</ol>\n\n<p>This is not a great approach, for several reasons: it needs to ensure that the tags used in the first step are really unique; it performs more string replacement operations than really necessary</p></li>\n<li><p>Build a regex from all the patterns and use the method with <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#appendReplacement(java.lang.StringBuffer,%20java.lang.String)\"><code>Matcher</code> and <code>StringBuffer</code></a> as suggested by <a href=\"http://stackoverflow.com/users/1220238/mjolka\">@arshajii</a>. This is not terrible, but not that great either, as building the regex is kind of hackish, and it involves <code>StringBuffer</code> which went out of fashion a while ago in favor of <code>StringBuilder</code>.</p></li>\n<li><p>Use a recursive solution proposed by <a href=\"http://stackoverflow.com/users/1220238/mjolka\">@mjolka</a>, by splitting the string at the matched patterns, and recursing on the remaining segments. This is a fine solution, compact and quite elegant. Its weakness is the potentially many substring and concatenation operations, and the stack size limits that apply to all recursive solutions</p></li>\n<li><p>Split the text to words and use Java 8 streams to perform the replacements elegantly as <a href=\"http://stackoverflow.com/users/183397/msandiford\">@msandiford</a> suggested, but of course that only works if you are ok with splitting at word boundaries, which makes it not suitable as a general solution</p></li>\n</ul>\n\n<p>Here's my version, based on ideas borrowed from <a href=\"http://grepcode.com/file/repo1.maven.org/maven2/commons-lang/commons-lang/2.6/org/apache/commons/lang/StringUtils.java#StringUtils.replaceEach%28java.lang.String%2Cjava.lang.String%5B%5D%2Cjava.lang.String%5B%5D%29\">Apache's implementation</a>. It's neither simple nor elegant, but it works, and should be relatively efficient, without unnecessary steps. In a nutshell, it works like this: repeatedly find the next matching search pattern in the text, and use a <code>StringBuilder</code> to accumulate the unmatched segments and the replacements.</p>\n\n<pre><code>public static String replaceEach(String text, String[] searchList, String[] replacementList) {\n    // TODO: throw new IllegalArgumentException() if any param doesn't make sense\n    //validateParams(text, searchList, replacementList);\n\n    SearchTracker tracker = new SearchTracker(text, searchList, replacementList);\n    if (!tracker.hasNextMatch(0)) {\n        return text;\n    }\n\n    StringBuilder buf = new StringBuilder(text.length() * 2);\n    int start = 0;\n\n    do {\n        SearchTracker.MatchInfo matchInfo = tracker.matchInfo;\n        int textIndex = matchInfo.textIndex;\n        String pattern = matchInfo.pattern;\n        String replacement = matchInfo.replacement;\n\n        buf.append(text.substring(start, textIndex));\n        buf.append(replacement);\n\n        start = textIndex + pattern.length();\n    } while (tracker.hasNextMatch(start));\n\n    return buf.append(text.substring(start)).toString();\n}\n\nprivate static class SearchTracker {\n\n    private final String text;\n\n    private final Map&lt;String, String&gt; patternToReplacement = new HashMap&lt;&gt;();\n    private final Set&lt;String&gt; pendingPatterns = new HashSet&lt;&gt;();\n\n    private MatchInfo matchInfo = null;\n\n    private static class MatchInfo {\n        private final String pattern;\n        private final String replacement;\n        private final int textIndex;\n\n        private MatchInfo(String pattern, String replacement, int textIndex) {\n            this.pattern = pattern;\n            this.replacement = replacement;\n            this.textIndex = textIndex;\n        }\n    }\n\n    private SearchTracker(String text, String[] searchList, String[] replacementList) {\n        this.text = text;\n        for (int i = 0; i &lt; searchList.length; ++i) {\n            String pattern = searchList[i];\n            patternToReplacement.put(pattern, replacementList[i]);\n            pendingPatterns.add(pattern);\n        }\n    }\n\n    boolean hasNextMatch(int start) {\n        int textIndex = -1;\n        String nextPattern = null;\n\n        for (String pattern : new ArrayList&lt;&gt;(pendingPatterns)) {\n            int matchIndex = text.indexOf(pattern, start);\n            if (matchIndex == -1) {\n                pendingPatterns.remove(pattern);\n            } else {\n                if (textIndex == -1 || matchIndex &lt; textIndex) {\n                    textIndex = matchIndex;\n                    nextPattern = pattern;\n                }\n            }\n        }\n\n        if (nextPattern != null) {\n            matchInfo = new MatchInfo(nextPattern, patternToReplacement.get(nextPattern), textIndex);\n            return true;\n        }\n        return false;\n    }\n}\n</code></pre>\n\n<p>Unit tests:</p>\n\n<pre><code>@Test\npublic void testSingleExact() {\n    assertEquals(\"bar\", StringUtils.replaceEach(\"foo\", new String[]{\"foo\"}, new String[]{\"bar\"}));\n}\n\n@Test\npublic void testReplaceTwice() {\n    assertEquals(\"barbar\", StringUtils.replaceEach(\"foofoo\", new String[]{\"foo\"}, new String[]{\"bar\"}));\n}\n\n@Test\npublic void testReplaceTwoPatterns() {\n    assertEquals(\"barbaz\", StringUtils.replaceEach(\"foobar\",\n            new String[]{\"foo\", \"bar\"},\n            new String[]{\"bar\", \"baz\"}));\n}\n\n@Test\npublic void testReplaceNone() {\n    assertEquals(\"foofoo\", StringUtils.replaceEach(\"foofoo\", new String[]{\"x\"}, new String[]{\"bar\"}));\n}\n\n@Test\npublic void testStory() {\n    assertEquals(\"Once upon a foo, there was a bar and a baz, and another bar and a cat.\",\n            StringUtils.replaceEach(\"Once upon a baz, there was a foo and a bar, and another foo and a cat.\",\n                    new String[]{\"foo\", \"bar\", \"baz\"},\n                    new String[]{\"bar\", \"baz\", \"foo\"})\n    );\n}\n</code></pre>\n", "title": "How can I replace two strings in a way that one does not end up replacing the other?", "tags": ["java", "string", "replace"], "link": "http://stackoverflow.com/questions/26791441/how-can-i-replace-two-strings-in-a-way-that-one-does-not-end-up-replacing-the-ot/26819171#26819171", "post_type": "answer", "question_id": 26791441, "answer_id": 26819171}, {"body": "<blockquote>\n  <p>Though it is the instance of the same class in which testPrivate is\n  written, but shouldn't it through a compiler error at\n  System.out.println(o.count);</p>\n</blockquote>\n\n<p><strong>No</strong>. It will never throw a compilation error.</p>\n\n<p>This is much similar to what a simple getter and setter does or a copy constructor does. Remember we can access <code>private</code> members using <code>this.</code></p>\n\n<pre><code>public MyClass {\n  private String propertyOne;\n  private String propertyTwo;\n\n  // cannot access otherObject private members directly\n  // so we use getters\n  // But MyClass private members are accessible using this.\n  public MyClass(OtherClass otherObject) {\n      this.propertyOne = otherObject.getPropertyOne();\n      this.propertyTwo = otherObject.calculatePropertyTwo();\n  }\n\n  public void setPropertyOne(String propertyOne) {\n      this.propertyOne = propertyOne;\n  }\n\n  public String getPropertyOne() {\n      return this.propertyOne;\n  }\n}\n</code></pre>\n\n<p>Your <code>testPrivate</code> method accepts an instance of MyClass. Since <code>testPrivate</code> is a method inside <code>MyClass</code>, it will have access to <code>private</code> properties.</p>\n\n<pre><code>  public void testPrivate(MyClass o) {\n      this.propertyOne = o.propertOne;\n  }\n</code></pre>\n\n<p>Methods defined inside the class will always have access to it's <code>private</code> members, through <code>this.</code> and instance variable.</p>\n\n<p>But if you define <code>testPrivate</code> outside of <code>MyClass</code> then, you won't have access to <code>private</code> members. There you will have to use a method or a setter or a getter.</p>\n", "title": "How is this private variable accessible?", "tags": ["java", "private"], "link": "http://stackoverflow.com/questions/27482579/how-is-this-private-variable-accessible/27483288#27483288", "post_type": "answer", "question_id": 27482579, "answer_id": 27483288}, {"body": "<p>The Javadocs for <code>Collection.(parallelS|s)tream()</code> and <code>Stream</code> itself don't answer the question, so it's off to the mailing lists for the rationale.  I went through the lambda-libs-spec-observers archives and found <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-February/thread.html#1341\">one thread specifically about Collection.parallelStream()</a> and another thread that touched on whether <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-April/thread.html#1799\">java.util.Arrays should provide parallelStream()</a> to match (or actually, whether it should be removed).  There was no once-and-for-all conclusion, so perhaps I've missed something from another list or the matter was settled in private discussion.  (Perhaps <a href=\"https://stackoverflow.com/users/3553087/brian-goetz\">Brian Goetz</a>, one of the principals of this discussion, can fill in anything missing.)</p>\n\n<p>The participants made their points well, so this answer is mostly just an organization of the relevant quotes, with a few clarifications in <em>[brackets]</em>, presented in order of importance (as I interpret it).</p>\n\n<h2>parallelStream() covers a very common case</h2>\n\n<p><a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-February/001362.html\">Brian Goetz</a> in the first thread, explaining why <code>Collections.parallelStream()</code> is valuable enough to keep even after other parallel stream factory methods have been removed:</p>\n\n<blockquote>\n  <p>We do <em>not</em> have explicit parallel versions of each of these <em>[stream factories]</em>; we did \n  originally, and to prune down the API surface area, we cut them on the \n  theory that dropping 20+ methods from the API was worth the tradeoff of \n  the surface yuckiness and performance cost of <code>.intRange(...).parallel()</code>. \n    But we did not make that choice with Collection.</p>\n  \n  <p>We could either remove the <code>Collection.parallelStream()</code>, or we could add \n  the parallel versions of all the generators, or we could do nothing and \n  leave it as is.  I think all are justifiable on API design grounds.</p>\n  \n  <p>I kind of like the status quo, despite its inconsistency.  Instead of \n  having 2N stream construction methods, we have N+1 -- but that extra 1 \n  covers a huge number of cases, because it is inherited by every \n  Collection.  So I can justify to myself why having that extra 1 method \n  is worth it, and why accepting the inconsistency of going no further is \n  acceptable.</p>\n  \n  <p>Do others disagree?  Is N+1 <em>[Collections.parallelStream() only]</em> the practical choice here?  Or should we go \n  for the purity of N <em>[rely on Stream.parallel()]</em>?  Or the convenience and consistency of 2N <em>[parallel versions of all factories]</em>?  Or is \n  there some even better N+3 <em>[Collections.parallelStream() plus other special cases]</em>, for some other specially chosen cases we \n  want to give special support to?</p>\n</blockquote>\n\n<p><a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-April/001799.html\">Brian Goetz</a> stands by this position in the later discussion about <code>Arrays.parallelStream()</code>:</p>\n\n<blockquote>\n  <p>I still really like Collection.parallelStream; it has huge \n  discoverability advantages, and offers a pretty big return on API \n  surface area -- one more method, but provides value in a lot of places, \n  since Collection will be a really common case of a stream source.</p>\n</blockquote>\n\n<h2>parallelStream() is more performant</h2>\n\n<p><a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-April/001799.html\">Brian Goetz</a>:</p>\n\n<blockquote>\n  <p>Direct version <em>[parallelStream()]</em> is more performant, in that it requires less wrapping (to \n  turn a stream into a parallel stream, you have to first create the \n  sequential stream, then transfer ownership of its state into a new \n  Stream.)</p>\n</blockquote>\n\n<p>In response to Kevin Bourrillion's skepticism about whether the effect is significant, <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-February/001346.html\">Brian again</a>:</p>\n\n<blockquote>\n  <p>Depends how seriously you are counting.  Doug counts individual object \n  creations and virtual invocations on the way to a parallel operation, \n  because until you start forking, you're on the wrong side of Amdahl's \n  law -- this is all \"serial fraction\" that happens before you can fork \n  any work, which pushes your breakeven threshold further out.  So getting \n  the setup path for parallel ops fast is valuable.</p>\n</blockquote>\n\n<p><a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-February/001354.html\">Doug Lea follows up</a>, but hedges his position:</p>\n\n<blockquote>\n  <p>People dealing with parallel library support need some attitude\n  adjustment about such things. On a soon-to-be-typical machine,\n  every cycle you waste setting up parallelism costs you say 64 cycles.\n  You would probably have had a different reaction if it required 64\n  object creations to start a parallel computation.</p>\n  \n  <p>That said, I'm always completely supportive of forcing implementors\n  to work harder for the sake of better APIs, so long as the\n  APIs do not rule out efficient implementation. So if killing\n  <code>parallelStream</code> is really important, we'll find some way to\n  turn <code>stream().parallel()</code> into a bit-flip or somesuch.</p>\n</blockquote>\n\n<p>Indeed, the later discussion about <code>Arrays.parallelStream()</code> <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-April/001799.html\">takes notice of lower Stream.parallel() cost</a>.</p>\n\n<h2>stream().parallel() statefulness complicates the future</h2>\n\n<p>At the time of the discussion, switching a stream from sequential to parallel and back could be interleaved with other stream operations.  <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-February/001363.html\">Brian Goetz, on behalf of Doug Lea</a>, explains why sequential/parallel mode switching may complicate future development of the Java platform:</p>\n\n<blockquote>\n  <p>I'll take my best stab at explaining why: because it (like the stateful \n  methods (sort, distinct, limit)) which you also don't like, move us \n  incrementally farther from being able to express stream pipelines in \n  terms of traditional data-parallel constructs, which further constrains \n  our ability to to map them directly to tomorrow's computing substrate, \n  whether that be vector processors, FPGAs, GPUs, or whatever we cook up.</p>\n  \n  <p>Filter-map-reduce map[s] very cleanly to all sorts of parallel computing \n  substrates; filter-parallel-map-sequential-sorted-limit-parallel-map-uniq-reduce \n  does not.</p>\n  \n  <p>So the whole API design here embodies many tensions between making it \n  easy to express things the user is likely to want to express, and doing \n  is in a manner that we can predictably make fast with transparent cost \n  models.</p>\n</blockquote>\n\n<p>This mode switching was <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-experts/2013-March/001504.html\">removed after further discussion</a>.  In the current version of the library, a stream pipeline is either sequential or parallel; last call to <code>sequential()</code>/<code>parallel()</code> wins.  Besides side-stepping the statefulness problem, this change also improved the performance of using <code>parallel()</code> to set up a parallel pipeline from a sequential stream factory.</p>\n\n<h2>exposing parallelStream() as a first-class citizen improves programmer perception of the library, leading them to write better code</h2>\n\n<p><a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-February/001352.html\">Brian Goetz again</a>, in response to <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-April/001801.html\">Tim Peierls's argument</a> that <code>Stream.parallel()</code> allows programmers to understand streams sequentially before going parallel:</p>\n\n<blockquote>\n  <p>I have a slightly different viewpoint about the value of this sequential \n  intuition -- I view the pervasive \"sequential expectation\" as one if the \n  biggest challenges of this entire effort; people are <em>constantly</em> \n  bringing their incorrect sequential bias, which leads them to do stupid \n  things like using a one-element array as a way to \"trick\" the \"stupid\" \n  compiler into letting them capture a mutable local, or using lambdas as \n  arguments to map that mutate state that will be used during the \n  computation (in a non-thread-safe way), and then, when its pointed out \n  that what they're doing, shrug it off and say \"yeah, but I'm not doing \n  it in parallel.\"</p>\n  \n  <p>We've made a lot of design tradeoffs to merge sequential and parallel \n  streams.  The result, I believe, is a clean one and will add to the \n  library's chances of still being useful in 10+ years, but I don't \n  particularly like the idea of encouraging people to think this is a \n  sequential library with some parallel bags nailed on the side.</p>\n</blockquote>\n", "title": "Why does Collection.parallelStream() exist when .stream().parallel() does the same thing?", "tags": ["java", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/24603186/why-does-collection-parallelstream-exist-when-stream-parallel-does-the-sa/24603187#24603187", "post_type": "answer", "question_id": 24603186, "answer_id": 24603187}, {"body": "<p><strong>Common features</strong></p>\n\n<p>a) Both libraries use immutable types. Joda-Time also offers additional mutable types like <code>MutableDateTime</code>. </p>\n\n<p>b) Furthermore: Both libraries are inspired by the design study <a href=\"http://timeandmoney.sourceforge.net/\">\"TimeAndMoney\" from Eric Evans</a> or ideas from <a href=\"http://martinfowler.com/tags/domain%20driven%20design.html\">Martin Fowler about domain driven style</a> so they strive more or less for a <a href=\"http://en.wikipedia.org/wiki/Fluent_interface\">fluent programming style</a> (although not always perfect ;-)).</p>\n\n<p>c) With both libraries we get a real calendar date type (called <code>LocalDate</code>), a real wall time type (called <code>LocalTime</code>) and the composition (called <code>LocalDateTime</code>). That is a very big win compared with old <code>java.util.Calendar</code> and <code>java.util.Date</code>.</p>\n\n<p>d) Both libraries use a method-centric approach meaning they encourage the user to use <code>getDayOfYear()</code> instead of <code>get(DAY_OF_YEAR)</code>. This causes a lot of extra methods compared with <code>java.util.Calendar</code> (although latter is not type-safe at all due to excessive use of ints).</p>\n\n<p><strong>Performance</strong></p>\n\n<p>See the other answer by @OO7 pointing to the analysis of Mikhail Vorontsov although point 3 (exception catching) is probably obsolete - see <a href=\"https://bugs.openjdk.java.net/browse/JDK-8046707\">this JDK-bug</a>. The different performance (which is in general favour of <a href=\"https://jcp.org/en/jsr/detail?id=310\">JSR-310</a>) is mainly due to the fact that the internal implementation of <a href=\"http://www.joda.org/joda-time/\">Joda-Time</a> always use a machine-time-like long-primitive (in milliseconds).</p>\n\n<p><strong>Null</strong></p>\n\n<p>Joda-Time often use NULL as default for system timezone, default locale, current timestamp etc. while JSR-310 almost always rejects NULL values.</p>\n\n<p><strong>Precision</strong></p>\n\n<p>JSR-310 handles <a href=\"http://en.wikipedia.org/wiki/Nanosecond\">nanosecond</a> precision while Joda-Time is limited to <a href=\"http://en.wikipedia.org/wiki/Millisecond\">millisecond</a> precision. </p>\n\n<p><strong>Supported fields:</strong></p>\n\n<p>An overview about supported fields in Java-8 (JSR-310) is given by some classes in the temporal-package (for example <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoField.html\">ChronoField</a> and <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html\">WeekFields</a>) while Joda-Time is rather weak on this area - see <a href=\"http://www.joda.org/joda-time/apidocs/org/joda/time/DateTimeFieldType.html\">DateTimeFieldType</a>. The biggest lack of Joda-Time is here the absence of localized week-related fields. A common feature of both field implementation design is that both are based on values of type long (no other types, not even enums).</p>\n\n<p><strong>Enum</strong></p>\n\n<p>JSR-310 offers <a href=\"http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html\">enums</a> like <code>DayOfWeek</code> or <code>Month</code> while Joda-Time does not offer this because it was mainly developed in years 2002-2004 before <a href=\"http://en.wikipedia.org/wiki/Java_version_history#J2SE_5.0_.28September_30.2C_2004.29\">Java 5</a>.</p>\n\n<p><strong>Zone API</strong></p>\n\n<p>a) JSR-310 offers more timezone features than Joda-Time. Latter is not able to yield a programmatical access to the history of timezone offset transitions while JSR-310 is capable to do this.</p>\n\n<p>b) For your information: JSR-310 has moved its internal timezone repository to a new location and a different format. The old library folder lib/zi does not exist any more.</p>\n\n<p><strong>Adjuster vs. Property</strong></p>\n\n<p>JSR-310 has introduced the <code>TemporalAdjuster</code>-interface as a formalized way to externalize temporal calculations and manipulations, especially for library or framework-writers this is a nice and relative easy way to embed new extensions of JSR-310 (a kind of equivalent to static helper classes for former <code>java.util.Date</code>).</p>\n\n<p>For most users however, this feature has very limited value because the burden to write code is still with the user. Built-in solutions based on the new <code>TemporalAdjuster</code>-concept are not so many, there is currently only the helper class <code>TemporalAdjusters</code> with a limited set of manipulations (and the enums <code>Month</code> or other temporal types). </p>\n\n<p>Joda-Time offers a field-package but practice has shown evidence that new field implementations are very hard to code. On the other side Joda-Time offers so-called properties which make some manipulations much easier and more elegant than in JSR-310, for example <a href=\"http://www.joda.org/joda-time/apidocs/org/joda/time/DateTime.Property.html#withMaximumValue()\">property.withMaximumValue()</a>.</p>\n\n<p><strong>Calendar systems</strong></p>\n\n<p>JSR-310 offers 4 extra calendar systems. The most interesting one is <a href=\"http://en.wikipedia.org/wiki/Islamic_calendar#Saudi_Arabia.27s_Umm_al-Qura_calendar\">Umalqura</a> (used in Saudi Arabia). The other 3 are: <a href=\"http://en.wikipedia.org/wiki/Minguo_calendar\">Minguo</a> (Taiwan), Japanese (only the modern calendar since 1871!) and <a href=\"http://en.wikipedia.org/wiki/Buddhist_calendar\">ThaiBuddhist</a> (only correct after 1940).</p>\n\n<p>Joda-Time offers an <a href=\"http://joda-time.sourceforge.net/cal_islamic.html\">Islamic calendar</a> based on calculatory base - not a sighting-based calendar like Umalqura. Thai-Buddhist is also offered by Joda-Time in a similar form, Minguo and the japanese one not. Otherwise Joda-Time offers coptic and ethiopic calendar, too (but without any support for internationalization).</p>\n\n<p>More interesting for Europeans: Joda-Time also offers a <a href=\"http://en.wikipedia.org/wiki/Gregorian_calendar\">Gregorian</a>, <a href=\"http://en.wikipedia.org/wiki/Julian_calendar\">Julian</a> and mixed-gregorian-julian calendar. However, the practical value for real historical calculations is limited because important features like different year starts in date history are not supported at all (the same criticism is valid for old <code>java.util.GregorianCalendar</code>).</p>\n\n<p>Other calendars like <a href=\"http://en.wikipedia.org/wiki/Hebrew_calendar\">Hebrew</a> or <a href=\"http://en.wikipedia.org/wiki/Iranian_calendars\">Persian</a> or <a href=\"http://en.wikipedia.org/wiki/Hindu_calendar\">Hindu</a> are completely missing in both libraries.</p>\n\n<p><strong>Epoch days</strong></p>\n\n<p>JSR-310 has the class <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/temporal/JulianFields.html\">JulianFields</a> while Joda-Time (version 2.0) offers some helper methods in the class <a href=\"http://www.joda.org/joda-time/apidocs/org/joda/time/DateTimeUtils.html#fromJulianDay(double)\">DateTimeUtils</a>.</p>\n\n<p><strong>Clocks</strong></p>\n\n<p>JSR-310 has no interface (a design mistake) but an abstract class <code>java.time.Clock</code> which can be used for any clock dependency injection. Joda-Time offers the interface <a href=\"http://www.joda.org/joda-time/apidocs/org/joda/time/DateTimeUtils.MillisProvider.html\">MillisProvider</a> and some helper methods in <a href=\"http://www.joda.org/joda-time/apidocs/org/joda/time/DateTimeUtils.html#setCurrentMillisProvider(org.joda.time.DateTimeUtils.MillisProvider)\">DateTimeUtils</a> instead. So this way Joda-Time is also capable of supporting test-driven models with different clocks (mocking etc.).</p>\n\n<p><strong>Duration arithmetic</strong></p>\n\n<p>Both libraries support the calculation of time distances in one or more temporal units. However, when handling single-unit-durations the JSR-310-style is obviously nicer (and long-based instead of using int):</p>\n\n<p>JSR-310 =&gt; <code>long days = ChronoUnit.DAYS.between(date1, date2);</code></p>\n\n<p>Joda-Time =&gt; <code>int days = DAYS.daysBetween(date1, date2).getDays();</code></p>\n\n<p>Handling of multiple-unit-durations are also different. Even the calculation results can differ - see this closed <a href=\"https://github.com/JodaOrg/joda-time/issues/132\">Joda-Time issue</a>. While JSR-310 use a very simple and limited approach to use just the classes <code>Period</code> (duration based on years, months and days) and <code>Duration</code> (based on seconds and nanoseconds), Joda-Time uses a more sophisticated way using the class <code>PeriodType</code> in order to control in which units a duration (Joda-Time call it \"Period\") shall be expressed. While the <code>PeriodType</code>-API is somehow awkward to use a similar way is not offered by JSR-310 at all. Especially it is not yet possible in JSR-310 to define mixed date and time durations (based on days and hours for example). So be warned if it comes to migration from one library to another. The libraries in discussion are incompatible - despite of partially same class names.</p>\n\n<p><strong>Intervals</strong></p>\n\n<p>JSR-310 does not support this feature while Joda-Time has limited support. See also this <a href=\"https://stackoverflow.com/questions/22150722/is-there-a-class-in-java-time-comparable-to-the-joda-time-interval/22152890#22152890\">SO-answer</a>.</p>\n\n<p><strong>Formatting and Parsing</strong></p>\n\n<p>Best way to compare both libraries is to view the equal-named classes <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatterBuilder.html\">DateTimeFormatterBuilder</a> (JSR-310) and <a href=\"http://www.joda.org/joda-time/apidocs/org/joda/time/format/DateTimeFormatterBuilder.html\">DateTimeFormatterBuilder</a> (Joda-Time). The JSR-310-variant is a little bit more powerful (can also handle any kind of <code>TemporalField</code> provided the field implementor has managed to code some extension points like <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalField.html#resolve-java.util.Map-java.time.temporal.TemporalAccessor-java.time.format.ResolverStyle-\">resolve()</a>). Most important difference is however - in my opinion: </p>\n\n<p>JSR-310 can much better parse timezone names (format pattern symbol z) while Joda-Time could not do this at all in its earlier versions and now only in a very limited way.</p>\n\n<p>Another advantage of JSR-310 is support for standalone month names which is important in languages like Russian or Polish etc. Joda-Time has <a href=\"https://github.com/JodaOrg/joda-time/issues/273\">no access to such resources</a> - not even on Java-8 platforms.</p>\n\n<p>The pattern syntax in JSR-310 is also more flexible than in Joda-Time, allows for optional sections (using square brackets), is more orientated towards CLDR-standard and offers padding (letter symbol p) and more fields.</p>\n\n<p>Otherwise it should be noted that Joda-Time can format durations using <a href=\"http://www.joda.org/joda-time/apidocs/org/joda/time/format/PeriodFormatter.html\">PeriodFormatter</a>. JSR-310 cannot do this.</p>\n\n<hr>\n\n<p>Hope this overview helps. All the gathered information is mainly there due to my efforts and investigations how to design and implement a better date-and-time library (nothing is perfect).</p>\n\n<p><strong>Update from 2015-06-24:</strong></p>\n\n<p>Meanwhile I have found the time to write and <a href=\"http://time4j.net/tutorial/appendix.html\">publish a tabular overview</a> for different time libraries in Java. The tables also contain a comparison between Joda-Time v2.8.1 and Java-8 (JSR-310). It is more detailed than this post.</p>\n", "title": "Differences between Java 8 Date Time API (java.time) and Joda-Time", "tags": ["java", "datetime", "java-8", "jodatime", "java-time"], "link": "http://stackoverflow.com/questions/24631909/differences-between-java-8-date-time-api-java-time-and-joda-time/24635657#24635657", "post_type": "answer", "question_id": 24631909, "answer_id": 24635657}, {"body": "<p>Both <code>map</code> and <code>flatMap</code> can be applied to a <code>Stream&lt;T&gt;</code> and they both return a <code>Stream&lt;R&gt;</code>. The difference is that the <code>map</code> operation produces one output value for each input value, whereas the <code>flatMap</code> operation produces an arbitrary number (zero or more) values for each input value.</p>\n\n<p>This is reflected in the arguments to each operation.</p>\n\n<p>The <code>map</code> operation takes a <code>Function</code>, which is called for each value in the input stream and produces one result value, which is sent to the output stream.</p>\n\n<p>The <code>flatMap</code> operation takes a function that conceptually wants to consume one value and produce an arbitrary number of values. However, in Java, it's cumbersome for a method to return an arbitrary number of values, since methods can return only zero or one value. One could imagine an API where the mapper function for <code>flatMap</code> takes a value and returns an array or a <code>List</code> of values, which are then sent to the output. Given that this is the streams library, a particularly apt way to represent an arbitrary number of return values is for the mapper function itself to return a stream! The values from the stream returned by the mapper are drained from the stream and are passed to the output stream. The \"clumps\" of values returned by each call to the mapper function are not distinguished at all in the output stream, thus the output is said to have been \"flattened.\"</p>\n\n<p>Typical use is for the mapper function of <code>flatMap</code> to return <code>Stream.empty()</code> if it wants to send zero values, or something like <code>Stream.of(a, b, c)</code> if it wants to return several values. But of course any stream can be returned.</p>\n", "title": "What&#39;s the difference between map and flatMap methods in Java 8?", "tags": ["java", "java-8"], "link": "http://stackoverflow.com/questions/26684562/whats-the-difference-between-map-and-flatmap-methods-in-java-8/26684710#26684710", "post_type": "answer", "question_id": 26684562, "answer_id": 26684710}, {"body": "<p>It's a curious omission.</p>\n\n<p>You would have to mark the field as <code>transient</code> and provide your own custom <code>writeObject()</code> method that wrote the <code>get()</code> result itself, and a <code>readObject()</code> method that restored the <code>Optional</code> by reading that result from the stream. Not forgetting to call <code>defaultWriteObject()</code> and <code>defaultReadObject()</code> respectively.</p>\n", "title": "Why java.util.Optional is not Serializable, how to serialize the object with such fields", "tags": ["java", "serialization", "java-8", "optional"], "link": "http://stackoverflow.com/questions/24547673/why-java-util-optional-is-not-serializable-how-to-serialize-the-object-with-suc/24547831#24547831", "post_type": "answer", "question_id": 24547673, "answer_id": 24547831}, {"body": "<p>A possible use case is in testing primality of a given number (at test which in itself has many uses). The <code>isProbablePrime</code> algorithm will run much faster than an exact algorithm, so if the number fails <code>isProbablePrime</code>, then one need not go to the expense of running the more expensive algorithm.</p>\n", "title": "What is a possible use case of BigInteger&#39;s .isProbablePrime()?", "tags": ["java", "primes"], "link": "http://stackoverflow.com/questions/27430092/what-is-a-possible-use-case-of-bigintegers-isprobableprime/27430172#27430172", "post_type": "answer", "question_id": 27430092, "answer_id": 27430172}, {"body": "<p>The standard use case for <a href=\"http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#isProbablePrime-int-\"><code>BigInteger.isProbablePrime(int)</code></a> is in cryptography.  Specifically, certain cryptographic algorithms, such as <a href=\"//en.wikipedia.org/wiki/RSA_%28cryptosystem%29\">RSA</a>, require randomly chosen large primes.  Importantly, however, these algorithms don't really require these numbers to be <em>guaranteed</em> to be prime &mdash; they just need to be prime with a <em>very</em> high probability.</p>\n\n<p>How high is very high?  Well, in a crypto application, one would typically call <code>.isProbablePrime()</code> with an argument somewhere between 128 and 256.  Thus, the probability of a non-prime number passing such a test is less than one in 2<sup>128</sup> or 2<sup>256</sup>.</p>\n\n<p>Let's put that in perspective: if you had 10 billion computers, each generating 10 billion probable prime numbers per second (which would mean less than one clock cycle per number on any modern CPU), and the primality of those numbers was tested with <code>.isProbablePrime(128)</code>, you would, on average, expect one non-prime number to slip in <strong>once in every 100 billion years</strong>.</p>\n\n<p>That is, that would be the case, if those 10 billion computers could somehow all run for hundreds of billions of years without experiencing <em>any</em> hardware failures.  In practice, though, <strong>it's a lot more likely for a random cosmic ray to strike your computer at just the right time and place to flip the return value</strong> of <code>.isProbablePrime(128)</code> from false to true, without causing any other detectable effects, than it is for a non-prime number to actually pass the probabilistic primality test at that certainty level.</p>\n\n<p>Of course, the same risk of random cosmic rays and other hardware faults also applies to deterministic primality tests like <a href=\"//en.wikipedia.org/wiki/AKS_primality_test\">AKS</a>.  Thus, in practice, even these tests have a (very small) baseline false positive rate due to random hardware failures (not to mention all other possible sources of errors, such as implementation bugs).</p>\n\n<p>Since it's easy to push the intrinsic false positive rate of the <a href=\"//en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test\">Miller&ndash;Rabin primality test</a> used by <code>.isProbablePrime()</code> far below this baseline rate, simply by repeating the test sufficiently many times, and since, even repeated so many times, the Miller&ndash;Rabin test is still much faster in practice than the best known deterministic primality tests like AKS, it remains the standard primality test for cryptographic applications.</p>\n\n<p>(Besides, even if you happened to accidentally select a strong pseudoprime as one of the factors of your RSA modulus, it would not generally lead to a catastrophic failure.  Typically, such pseudoprimes would be products of two (or rarely more) primes of approximately half the length, which means that you'd end up with a <a href=\"http://crypto.stackexchange.com/questions/11287/rsa-with-modulus-product-of-many-primes\">multi-prime RSA key</a>.  As long as none of the factors were <em>too</em> small (and if they were, the primality test should've caught them), the RSA algorithm will still work just fine, and the key, although somewhat weaker against certain types of attacks than normal RSA keys of the same length, should still be reasonably secure if you didn't needlessly skimp on the key length.)</p>\n", "title": "What is a possible use case of BigInteger&#39;s .isProbablePrime()?", "tags": ["java", "primes"], "link": "http://stackoverflow.com/questions/27430092/what-is-a-possible-use-case-of-bigintegers-isprobableprime/27449187#27449187", "post_type": "answer", "question_id": 27430092, "answer_id": 27449187}, {"body": "<p>OK, first of all, your <code>setExits()</code> method will not work as intended, chained if-elseif will maximally execute 1 branch of code, for example:</p>\n\n<pre><code>if (e.contains(\"N\"))\n    bexits[0] = true;\nelse if (e.contains(\"W\"))\n    bexits[1] = true;\n</code></pre>\n\n<p>Even if <code>e</code> contains both <code>N</code> and <code>W</code>, only <code>bexits[0]</code> will be set. Also this method will only add exits (for example calling <code>setExits(\"\")</code> will not delete any existing exits.</p>\n\n<p>I would change that method to:</p>\n\n<pre><code>bexits[0] = e.contains(\"N\");\nbexits[1] = e.contains(\"W\");\n...\n</code></pre>\n\n<p>Also, i definetly wouldn't remember that north is on index 0, west in on 1, ... so a common practice is to name your indexes using final static constants:</p>\n\n<pre><code>public static final int NORTH = 0;\npublic static final int WEST = 1;\n...\n</code></pre>\n\n<p>Then you can write in your <code>setExits</code> method:</p>\n\n<pre><code>bexits[NORTH] = e.contains(\"N\");\nbexits[WEST] = e.contains(\"W\");\n...\n</code></pre>\n\n<p>(much more readible)</p>\n\n<p>Finally, if you want your code even more well-arranged, you can make a <code>Exits</code> class representing avaliable exits, and backed by boolean array. Then on place where you create your String, you could create this class instead and save yourself work with generating and then parsing a string.</p>\n\n<p>EDIT:</p>\n\n<p>as @gexicide answers, there is a really handy class <code>EnumSet</code> which would be probably better for representing the exits than bollean array.</p>\n", "title": "Populating a Boolean Array in Java", "tags": ["java", "arrays"], "link": "http://stackoverflow.com/questions/24651403/populating-a-boolean-array-in-java/24651855#24651855", "post_type": "answer", "question_id": 24651403, "answer_id": 24651855}, {"body": "<p>If you will read comment above the code, It is mentioned that...</p>\n\n<p>If the caller is not a <code>ForkJoinTask</code>, this method is behaviorally equivalent to</p>\n\n<pre><code>while (!blocker.isReleasable())\n   if (blocker.block())\n      return;\n}\n</code></pre>\n\n<p>So it is just another form to implement above code in else part...!!</p>\n\n<p>In <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/concurrent/ForkJoinPool.java#l520\" rel=\"nofollow\">Style notes</a> it is mentioned that, </p>\n\n<blockquote>\n  <p>There are several occurrences of the unusual \"do {} while\n   (!cas...)\"  which is the simplest way to force an update of a\n   CAS'ed variable.</p>\n</blockquote>\n\n<p>And if you will see implementation of <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinPool.ManagedBlocker.html\" rel=\"nofollow\">ManagedLocker#isReleasable</a>, It is updating the lock and returns <code>true</code> if blocking is unnecessary.</p>\n\n<p><strong><em>Interpretation :</em></strong></p>\n\n<p>Blank while loops are used to provide an interrupt until some condition reset to true/false.</p>\n\n<p>Here, <code>do { } while(!...)</code> is a blocker/interrupt until <code>blocker.block()</code> will be <code>true</code> when <code>blocker.isReleasable()</code> is <code>false</code>. Loop will continue execution while <code>blocker</code> is not releasable (<code>!blocker.isReleasable()</code>) and <code>blocker</code> is not blocked !! Execution will be out of loop as soon as <code>blocker.block()</code> will set to true.</p>\n\n<p>Note that, <code>do{ } while(...)</code> does not update CAS variable, but it guarantee that program will wait until variable gets updated (force to wait until variable gets updated).  </p>\n", "title": "Do &quot;nothing&quot; while &quot;condition&quot;", "tags": ["java", "while-loop", "do-while"], "link": "http://stackoverflow.com/questions/24609564/do-nothing-while-condition/24609841#24609841", "post_type": "answer", "question_id": 24609564, "answer_id": 24609841}, {"body": "<p><strong>In a nutshell, this creates an empty, immutable list of strings.</strong></p>\n\n<p>Let's look at the expression bit by bit.</p>\n\n<p><a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html\"><code>Collections</code></a> is the name of a class. From the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html\">Javadoc</a>:</p>\n\n<blockquote>\n  <p>This class consists exclusively of static methods that operate on or return collections. It contains polymorphic algorithms that operate on collections, \"wrappers\", which return a new collection backed by a specified collection, and a few other odds and ends.</p>\n</blockquote>\n\n<p><a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#emptyList--\"><code>emptyList()</code></a> is the name of a static method defined in the <code>Collections</code> class (<a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#emptyList--\">Javadoc</a>). It is a generic method, and the <code>&lt;String&gt;</code> in <code>Collections.&lt;String&gt;emptyList()</code> specifies the generic type argument.</p>\n\n<p>The method returns a <code>List&lt;T&gt;</code>, which in this case is <code>List&lt;String&gt;</code>: a list of strings. More specifically, it returns an <em>empty</em>, <em>immutable</em> list of strings.</p>\n", "title": "Explain the syntax of Collections.&lt;String&gt;emptyList()", "tags": ["java", "generics", "collections"], "link": "http://stackoverflow.com/questions/27683759/explain-the-syntax-of-collections-stringemptylist/27684042#27684042", "post_type": "answer", "question_id": 27683759, "answer_id": 27684042}, {"body": "<p>I have a few points to add to <a href=\"http://stackoverflow.com/a/24679745/1441122\">Brian Goetz' excellent answer</a>.</p>\n\n<p>It's quite common to return a Stream from a \"getter\" style method call. See the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/class-use/Stream.html\">Stream usage page</a> in the Java 8 javadoc and look for \"methods... that return Stream\" for the packages other than <code>java.util.Stream</code>. These methods are usually on classes that represent or can contain multiple values or aggregations of something. In such cases, APIs typically have returned collections or arrays of them. For all the reasons that Brian noted in his answer, it's very flexible to add Stream-returning methods here. Many of these classes have collections- or array-returning methods already, because the classes predate the Streams API. If you're designing a new API, and it makes sense to provide Stream-returning methods, it might not be necessary to add collection-returning methods as well.</p>\n\n<p>Brian mentioned the cost of \"materializing\" the values into a collection. To amplify this point, there are actually two costs here: the cost of storing values in the collection (memory allocation and copying) and also the cost of creating the values in the first place. The latter cost can often be reduced or avoided by taking advantage of a Stream's laziness-seeking behavior. A good example of this are the APIs in <code>java.nio.file.Files</code>:</p>\n\n<pre><code>static Stream&lt;String&gt;  lines(path)\nstatic List&lt;String&gt;    readAllLines(path)\n</code></pre>\n\n<p>Not only does <code>readAllLines</code> have to hold the entire file contents in memory in order to store it into the result list, it also has to read the file to the very end before it returns the list. The <code>lines</code> method can return almost immediately after it has performed some setup, leaving file reading and line breaking until later when it's necessary -- or not at all. This is a huge benefit, if for example, the caller is interested only in the first ten lines:</p>\n\n<pre><code>List&lt;String&gt; firstTen = Files.lines(path).limit(10).collect(toList());\n</code></pre>\n\n<p>Of course considerable memory space can be saved if the caller filters the stream to return only lines matching a pattern, etc.</p>\n\n<p>An idiom that seems to be emerging is to name stream-returning methods after the plural of the name of the things that it represents or contains, without a <code>get</code> prefix. Also, while <code>stream()</code> is a reasonable name for a stream-returning method when there is only one possible set of values to be returned, sometimes there are classes that have aggregations of multiple types of values. For example, suppose you have some object that contains both attributes and elements. You might provide two stream-returning APIs:</p>\n\n<pre><code>Stream&lt;Attribute&gt;  attributes();\nStream&lt;Element&gt;    elements();\n</code></pre>\n", "title": "Should I return a Collection or a Stream?", "tags": ["java", "collections", "java-8", "encapsulation", "java-stream"], "link": "http://stackoverflow.com/questions/24676877/should-i-return-a-collection-or-a-stream/24681959#24681959", "post_type": "answer", "question_id": 24676877, "answer_id": 24681959}, {"body": "<pre><code>Map&lt;String, String&gt; x;\nMap&lt;String, Integer&gt; y =\n    x.entrySet().stream()\n        .collect(Collectors.toMap(\n            e -&gt; e.getKey(),\n            e -&gt; Integer.parseInt(e.getValue())\n        ));\n</code></pre>\n\n<p>It's not quite as nice as the list code. You can't construct new <code>Map.Entry</code>s in a <code>map()</code> call so the work is mixed into the <code>collect()</code> call.</p>\n", "title": "Java8: HashMap&lt;X, Y&gt; to HashMap&lt;X, Z&gt; using Stream / Map-Reduce / Collector", "tags": ["java", "mapreduce", "java-8", "java-stream", "collectors"], "link": "http://stackoverflow.com/questions/25903137/java8-hashmapx-y-to-hashmapx-z-using-stream-map-reduce-collector/25903190#25903190", "post_type": "answer", "question_id": 25903137, "answer_id": 25903190}, {"body": "<p>We can take a look into <a href=\"http://hg.openjdk.java.net/jdk7u/jdk7u/jdk/file/677a0ad1e733/src/share/classes/java/util/regex/Pattern.java\" rel=\"nofollow\">the source code of <code>java.util.regex.Pattern</code></a> which is behind <code>String.split</code>. Way down the rabbit hole the method</p>\n\n<pre><code>public String[] split(CharSequence input, int limit)\n</code></pre>\n\n<p>is invoked.</p>\n\n<h2>Input <code>\"\"</code></h2>\n\n<p>For input <code>\"\"</code> this method is called as</p>\n\n<pre><code>String[] parts = split(\"\", 0);\n</code></pre>\n\n<p><a href=\"http://hg.openjdk.java.net/jdk7u/jdk7u/jdk/file/677a0ad1e733/src/share/classes/java/util/regex/Pattern.java#l1193\" rel=\"nofollow\">The intersting part of this method is</a>:</p>\n\n<pre><code>  int index = 0;\n  boolean matchLimited = limit &gt; 0;\n  ArrayList&lt;String&gt; matchList = new ArrayList&lt;&gt;();\n  Matcher m = matcher(input);\n\n  while(m.find()) {\n    // Tichodroma: this will not happen for our input\n  }\n\n  // If no match was found, return this\n  if (index == 0)\n    return new String[] {input.toString()};\n</code></pre>\n\n<p>And that is what happens: <a href=\"http://hg.openjdk.java.net/jdk7u/jdk7u/jdk/file/677a0ad1e733/src/share/classes/java/util/regex/Pattern.java#l1213\" rel=\"nofollow\"><code>new String[] {input.toString()}</code> is returned</a>.</p>\n\n<h2>Input <code>\",\"</code></h2>\n\n<p>For input <code>\",\"</code><a href=\"http://hg.openjdk.java.net/jdk7u/jdk7u/jdk/file/677a0ad1e733/src/share/classes/java/util/regex/Pattern.java#l1221\" rel=\"nofollow\">the intersting part is</a></p>\n\n<pre><code>    // Construct result\n    int resultSize = matchList.size();\n    if (limit == 0)\n        while (resultSize &gt; 0 &amp;&amp; matchList.get(resultSize-1).equals(\"\"))\n            resultSize--;\n    String[] result = new String[resultSize];\n    return matchList.subList(0, resultSize).toArray(result);\n</code></pre>\n\n<p>Here <code>resultSize == 0</code> and <code>limit == 0</code> so <a href=\"http://hg.openjdk.java.net/jdk7u/jdk7u/jdk/file/677a0ad1e733/src/share/classes/java/util/regex/Pattern.java#l1226\" rel=\"nofollow\"><code>new String[0]</code> is returned</a>.</p>\n", "title": "Confusing output from String.split", "tags": ["java", "regex", "string", "class", "core"], "link": "http://stackoverflow.com/questions/25056607/confusing-output-from-string-split/25056878#25056878", "post_type": "answer", "question_id": 25056607, "answer_id": 25056878}, {"body": "<p>I would argue first-off that Serializable and Cloneable are bad examples of marker interfaces. Sure, they're interfaces with methods, but they <em>imply</em> methods, such as <code>writeObject(ObjectOutputStream)</code>. (The compiler will create a <code>writeObject(ObjectOutputStream)</code> method for you if you don't override it, and all objects already have <code>clone()</code>, but the compiler will again create a real <code>clone()</code> method for you but with caveats. Both of these are weird edge cases that really aren't good design examples.)</p>\n\n<p>Marker interfaces are generally used for one of two purposes:</p>\n\n<p>1) As a shortcut to avoid an excessively long type, which can happen with lots of generics. For instance, say you have this method signature:</p>\n\n<pre><code>public void doSomething(Foobar&lt;String, Map&lt;String, SomethingElse&lt;Integer, Long&gt;&gt;&gt;) { ... }\n</code></pre>\n\n<p>That's messy and annoying to type, and more importantly, difficult to understand. Consider this instead:</p>\n\n<pre><code>public interface Widget extends Foobar&lt;String, Map&lt;String, SomethingElse&lt;Integer, Long&gt;&gt;&gt; { }\n</code></pre>\n\n<p>Then your method looks like this:</p>\n\n<pre><code>public void doSomething(Widget widget) { ... }\n</code></pre>\n\n<p>Not only is it clearer, but you can now Javadoc the Widget interface, and it's also easier to search for all occurrences in your code of Widget.</p>\n\n<p>2) Marker interfaces can also be used as a way around Java's lack of intersection types. With a marker interface, you can require something to be of two different types, such as in a method signature. Say you have some interface Widget in your application, like we described above. If you have a method that requires a Widget that also happens to let you iterate over it (it's contrived, but work with me here), your only good solution is to create a marker interface that extends both interfaces:</p>\n\n<pre><code>public interface IterableWidget extends Iterable&lt;String&gt;, Widget { }\n</code></pre>\n\n<p>And in your code:</p>\n\n<pre><code>public void doSomething(IterableWidget widget) {\n    for (String s : widget) { ... }\n}\n</code></pre>\n", "title": "Marker Interfaces in Java?", "tags": ["java", "design-patterns", "marker-interfaces"], "link": "http://stackoverflow.com/questions/25850328/marker-interfaces-in-java/25853827#25853827", "post_type": "answer", "question_id": 25850328, "answer_id": 25853827}]}