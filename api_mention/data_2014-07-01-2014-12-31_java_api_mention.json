{"items": [{"body": "<p>I don't know whether I am asking the right question. I was exploring <code>RecyclerView</code> and I was surprised to see that <code>RecyclerView</code> does not have <code>onItemClickListener()</code>. Because <code>RecyclerView</code> extends     </p>\n\n<blockquote>\n  <p><strong>android.view.ViewGroup</strong></p>\n</blockquote>\n\n<p>and <code>ListView</code> extends </p>\n\n<blockquote>\n  <p><strong>android.widget.AbsListView</strong></p>\n</blockquote>\n\n<p>.  However I solved my problem by writing <code>onClick</code> in my <code>RecyclerView.Adapter</code>:</p>\n\n<pre><code>public static class ViewHolder extends RecyclerView.ViewHolder implements OnClickListener {\n\n    public TextView txtViewTitle;\n    public ImageView imgViewIcon;\n\n    public ViewHolder(View itemLayoutView) {\n        super(itemLayoutView);\n        txtViewTitle = (TextView) itemLayoutView.findViewById(R.id.item_title);\n        imgViewIcon = (ImageView) itemLayoutView.findViewById(R.id.item_icon);\n    }\n\n    @Override\n    public void onClick(View v) {\n\n    }\n}\n</code></pre>\n\n<p>But still I want to know why Google removed <code>onItemClickListener()</code>? </p>\n\n<p>Is there a performance issue or something else?</p>\n", "title": "Why doesn&#39;t RecyclerView have onItemClickListener()? And how RecyclerView is different from Listview?", "tags": ["java", "android", "recyclerview"], "link": "http://stackoverflow.com/questions/24885223/why-doesnt-recyclerview-have-onitemclicklistener-and-how-recyclerview-is-dif", "post_type": "question", "question_id": 24885223}, {"body": "<p>I am looking for a concise way to convert an <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\"><code>Iterator</code></a> to a <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html\"><code>Stream</code></a> or more specifically to \"view\" the iterator as a stream.</p>\n\n<p>For performance reason, I would like to avoid a copy of the iterator in a new list:</p>\n\n<pre><code>Iterator&lt;String&gt; sourceIterator = Arrays.asList(\"A\", \"B\", \"C\").iterator();\nCollection&lt;String&gt; copyList = new ArrayList&lt;String&gt;();\nsourceIterator.forEachRemaining(copyList::add);\nStream&lt;String&gt; targetStream = copyList.stream();\n</code></pre>\n\n<hr>\n\n<p>Based on the some suggestions in the comments, I have also tried to use <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#generate-java.util.function.Supplier-\"><code>Stream.generate</code></a>:</p>\n\n<pre><code>public static void main(String[] args) throws Exception {\n    Iterator&lt;String&gt; sourceIterator = Arrays.asList(\"A\", \"B\", \"C\").iterator();\n    Stream&lt;String&gt; targetStream = Stream.generate(sourceIterator::next);\n    targetStream.forEach(System.out::println);\n}\n</code></pre>\n\n<p>However, I get a <code>NoSuchElementException</code> (since there is no invocation of <code>hasNext</code>)</p>\n\n<pre><code>Exception in thread \"main\" java.util.NoSuchElementException\n    at java.util.AbstractList$Itr.next(AbstractList.java:364)\n    at Main$$Lambda$1/1175962212.get(Unknown Source)\n    at java.util.stream.StreamSpliterators$InfiniteSupplyingSpliterator$OfRef.tryAdvance(StreamSpliterators.java:1351)\n    at java.util.Spliterator.forEachRemaining(Spliterator.java:326)\n    at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:580)\n    at Main.main(Main.java:20)\n</code></pre>\n\n<p>I have looked at <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/StreamSupport.html\"><code>StreamSupport</code></a> and <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html\"><code>Collections</code></a> but I didn't find anything.</p>\n", "title": "How to convert an iterator to a stream?", "tags": ["java", "iterator", "java-8"], "link": "http://stackoverflow.com/questions/24511052/how-to-convert-an-iterator-to-a-stream", "post_type": "question", "question_id": 24511052}, {"body": "<p>I just studied about generic programming, the <code>List&lt;E&gt;</code> interface, and <code>ArrayList</code>, so I can understand the statement below.</p>\n\n<pre><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();\n</code></pre>\n\n<p>But I don't understand the next statement which I saw while surfing the web.</p>\n\n<pre><code>List&lt;String&gt; list2 = Collections.&lt;String&gt;emptyList();\n</code></pre>\n\n<ol>\n<li>What is <code>Collections</code>? Why isn't it <code>Collections&lt;E&gt;</code> or <code>Collections&lt;String&gt;</code>?</li>\n<li>Why is <code>&lt;String&gt;</code> placed before the method name <code>emptyList</code>?</li>\n</ol>\n\n<p>(Isn't <code>emptyList&lt;String&gt;()</code> correct for Generic?)</p>\n\n<ol start=\"3\">\n<li>What does the statement mean?</li>\n</ol>\n", "title": "Explain the syntax of Collections.&lt;String&gt;emptyList()", "tags": ["java", "generics", "collections"], "link": "http://stackoverflow.com/questions/27683759/explain-the-syntax-of-collections-stringemptylist", "post_type": "question", "question_id": 27683759}, {"body": "<p>The Javadocs for <code>Collection.(parallelS|s)tream()</code> and <code>Stream</code> itself don't answer the question, so it's off to the mailing lists for the rationale.  I went through the lambda-libs-spec-observers archives and found <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-February/thread.html#1341\">one thread specifically about Collection.parallelStream()</a> and another thread that touched on whether <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-April/thread.html#1799\">java.util.Arrays should provide parallelStream()</a> to match (or actually, whether it should be removed).  There was no once-and-for-all conclusion, so perhaps I've missed something from another list or the matter was settled in private discussion.  (Perhaps <a href=\"https://stackoverflow.com/users/3553087/brian-goetz\">Brian Goetz</a>, one of the principals of this discussion, can fill in anything missing.)</p>\n\n<p>The participants made their points well, so this answer is mostly just an organization of the relevant quotes, with a few clarifications in <em>[brackets]</em>, presented in order of importance (as I interpret it).</p>\n\n<h2>parallelStream() covers a very common case</h2>\n\n<p><a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-February/001362.html\">Brian Goetz</a> in the first thread, explaining why <code>Collections.parallelStream()</code> is valuable enough to keep even after other parallel stream factory methods have been removed:</p>\n\n<blockquote>\n  <p>We do <em>not</em> have explicit parallel versions of each of these <em>[stream factories]</em>; we did \n  originally, and to prune down the API surface area, we cut them on the \n  theory that dropping 20+ methods from the API was worth the tradeoff of \n  the surface yuckiness and performance cost of <code>.intRange(...).parallel()</code>. \n    But we did not make that choice with Collection.</p>\n  \n  <p>We could either remove the <code>Collection.parallelStream()</code>, or we could add \n  the parallel versions of all the generators, or we could do nothing and \n  leave it as is.  I think all are justifiable on API design grounds.</p>\n  \n  <p>I kind of like the status quo, despite its inconsistency.  Instead of \n  having 2N stream construction methods, we have N+1 -- but that extra 1 \n  covers a huge number of cases, because it is inherited by every \n  Collection.  So I can justify to myself why having that extra 1 method \n  is worth it, and why accepting the inconsistency of going no further is \n  acceptable.</p>\n  \n  <p>Do others disagree?  Is N+1 <em>[Collections.parallelStream() only]</em> the practical choice here?  Or should we go \n  for the purity of N <em>[rely on Stream.parallel()]</em>?  Or the convenience and consistency of 2N <em>[parallel versions of all factories]</em>?  Or is \n  there some even better N+3 <em>[Collections.parallelStream() plus other special cases]</em>, for some other specially chosen cases we \n  want to give special support to?</p>\n</blockquote>\n\n<p><a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-April/001799.html\">Brian Goetz</a> stands by this position in the later discussion about <code>Arrays.parallelStream()</code>:</p>\n\n<blockquote>\n  <p>I still really like Collection.parallelStream; it has huge \n  discoverability advantages, and offers a pretty big return on API \n  surface area -- one more method, but provides value in a lot of places, \n  since Collection will be a really common case of a stream source.</p>\n</blockquote>\n\n<h2>parallelStream() is more performant</h2>\n\n<p><a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-April/001799.html\">Brian Goetz</a>:</p>\n\n<blockquote>\n  <p>Direct version <em>[parallelStream()]</em> is more performant, in that it requires less wrapping (to \n  turn a stream into a parallel stream, you have to first create the \n  sequential stream, then transfer ownership of its state into a new \n  Stream.)</p>\n</blockquote>\n\n<p>In response to Kevin Bourrillion's skepticism about whether the effect is significant, <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-February/001346.html\">Brian again</a>:</p>\n\n<blockquote>\n  <p>Depends how seriously you are counting.  Doug counts individual object \n  creations and virtual invocations on the way to a parallel operation, \n  because until you start forking, you're on the wrong side of Amdahl's \n  law -- this is all \"serial fraction\" that happens before you can fork \n  any work, which pushes your breakeven threshold further out.  So getting \n  the setup path for parallel ops fast is valuable.</p>\n</blockquote>\n\n<p><a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-February/001354.html\">Doug Lea follows up</a>, but hedges his position:</p>\n\n<blockquote>\n  <p>People dealing with parallel library support need some attitude\n  adjustment about such things. On a soon-to-be-typical machine,\n  every cycle you waste setting up parallelism costs you say 64 cycles.\n  You would probably have had a different reaction if it required 64\n  object creations to start a parallel computation.</p>\n  \n  <p>That said, I'm always completely supportive of forcing implementors\n  to work harder for the sake of better APIs, so long as the\n  APIs do not rule out efficient implementation. So if killing\n  <code>parallelStream</code> is really important, we'll find some way to\n  turn <code>stream().parallel()</code> into a bit-flip or somesuch.</p>\n</blockquote>\n\n<p>Indeed, the later discussion about <code>Arrays.parallelStream()</code> <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-April/001799.html\">takes notice of lower Stream.parallel() cost</a>.</p>\n\n<h2>stream().parallel() statefulness complicates the future</h2>\n\n<p>At the time of the discussion, switching a stream from sequential to parallel and back could be interleaved with other stream operations.  <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-February/001363.html\">Brian Goetz, on behalf of Doug Lea</a>, explains why sequential/parallel mode switching may complicate future development of the Java platform:</p>\n\n<blockquote>\n  <p>I'll take my best stab at explaining why: because it (like the stateful \n  methods (sort, distinct, limit)) which you also don't like, move us \n  incrementally farther from being able to express stream pipelines in \n  terms of traditional data-parallel constructs, which further constrains \n  our ability to to map them directly to tomorrow's computing substrate, \n  whether that be vector processors, FPGAs, GPUs, or whatever we cook up.</p>\n  \n  <p>Filter-map-reduce map[s] very cleanly to all sorts of parallel computing \n  substrates; filter-parallel-map-sequential-sorted-limit-parallel-map-uniq-reduce \n  does not.</p>\n  \n  <p>So the whole API design here embodies many tensions between making it \n  easy to express things the user is likely to want to express, and doing \n  is in a manner that we can predictably make fast with transparent cost \n  models.</p>\n</blockquote>\n\n<p>This mode switching was <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-experts/2013-March/001504.html\">removed after further discussion</a>.  In the current version of the library, a stream pipeline is either sequential or parallel; last call to <code>sequential()</code>/<code>parallel()</code> wins.  Besides side-stepping the statefulness problem, this change also improved the performance of using <code>parallel()</code> to set up a parallel pipeline from a sequential stream factory.</p>\n\n<h2>exposing parallelStream() as a first-class citizen improves programmer perception of the library, leading them to write better code</h2>\n\n<p><a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-February/001352.html\">Brian Goetz again</a>, in response to <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-April/001801.html\">Tim Peierls's argument</a> that <code>Stream.parallel()</code> allows programmers to understand streams sequentially before going parallel:</p>\n\n<blockquote>\n  <p>I have a slightly different viewpoint about the value of this sequential \n  intuition -- I view the pervasive \"sequential expectation\" as one if the \n  biggest challenges of this entire effort; people are <em>constantly</em> \n  bringing their incorrect sequential bias, which leads them to do stupid \n  things like using a one-element array as a way to \"trick\" the \"stupid\" \n  compiler into letting them capture a mutable local, or using lambdas as \n  arguments to map that mutate state that will be used during the \n  computation (in a non-thread-safe way), and then, when its pointed out \n  that what they're doing, shrug it off and say \"yeah, but I'm not doing \n  it in parallel.\"</p>\n  \n  <p>We've made a lot of design tradeoffs to merge sequential and parallel \n  streams.  The result, I believe, is a clean one and will add to the \n  library's chances of still being useful in 10+ years, but I don't \n  particularly like the idea of encouraging people to think this is a \n  sequential library with some parallel bags nailed on the side.</p>\n</blockquote>\n", "title": "Why does Collection.parallelStream() exist when .stream().parallel() does the same thing?", "tags": ["java", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/24603186/why-does-collection-parallelstream-exist-when-stream-parallel-does-the-sa/24603187#24603187", "post_type": "answer", "question_id": 24603186, "answer_id": 24603187}, {"body": "<p>This is not an easy problem. And the more search-replacement parameters you have, the trickier it gets. You have several options, scattered on the palette of ugly-elegant, efficient-wasteful:</p>\n\n<ul>\n<li><p>Use <code>StringUtils.replaceEach</code> from Apache Commons as <a href=\"http://stackoverflow.com/users/1356423/alan-hay\">@AlanHay</a> recommended. This is a good option if you're free to add new dependencies in your project. You might get lucky: the dependency might be included already in your project</p></li>\n<li><p>Use a temporary placeholder as <a href=\"http://stackoverflow.com/users/1864167/jeroen-vannevel\">@Jeroen</a> suggested, and perform the replacement in 2 steps:</p>\n\n<ol>\n<li>Replace all search patterns with a unique tag that doesn't exist in the original text</li>\n<li>Replace the placeholders with the real target replacement</li>\n</ol>\n\n<p>This is not a great approach, for several reasons: it needs to ensure that the tags used in the first step are really unique; it performs more string replacement operations than really necessary</p></li>\n<li><p>Build a regex from all the patterns and use the method with <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#appendReplacement(java.lang.StringBuffer,%20java.lang.String)\"><code>Matcher</code> and <code>StringBuffer</code></a> as suggested by <a href=\"http://stackoverflow.com/users/1220238/mjolka\">@arshajii</a>. This is not terrible, but not that great either, as building the regex is kind of hackish, and it involves <code>StringBuffer</code> which went out of fashion a while ago in favor of <code>StringBuilder</code>.</p></li>\n<li><p>Use a recursive solution proposed by <a href=\"http://stackoverflow.com/users/1220238/mjolka\">@mjolka</a>, by splitting the string at the matched patterns, and recursing on the remaining segments. This is a fine solution, compact and quite elegant. Its weakness is the potentially many substring and concatenation operations, and the stack size limits that apply to all recursive solutions</p></li>\n<li><p>Split the text to words and use Java 8 streams to perform the replacements elegantly as <a href=\"http://stackoverflow.com/users/183397/msandiford\">@msandiford</a> suggested, but of course that only works if you are ok with splitting at word boundaries, which makes it not suitable as a general solution</p></li>\n</ul>\n\n<p>Here's my version, based on ideas borrowed from <a href=\"http://grepcode.com/file/repo1.maven.org/maven2/commons-lang/commons-lang/2.6/org/apache/commons/lang/StringUtils.java#StringUtils.replaceEach%28java.lang.String%2Cjava.lang.String%5B%5D%2Cjava.lang.String%5B%5D%29\">Apache's implementation</a>. It's neither simple nor elegant, but it works, and should be relatively efficient, without unnecessary steps. In a nutshell, it works like this: repeatedly find the next matching search pattern in the text, and use a <code>StringBuilder</code> to accumulate the unmatched segments and the replacements.</p>\n\n<pre><code>public static String replaceEach(String text, String[] searchList, String[] replacementList) {\n    // TODO: throw new IllegalArgumentException() if any param doesn't make sense\n    //validateParams(text, searchList, replacementList);\n\n    SearchTracker tracker = new SearchTracker(text, searchList, replacementList);\n    if (!tracker.hasNextMatch(0)) {\n        return text;\n    }\n\n    StringBuilder buf = new StringBuilder(text.length() * 2);\n    int start = 0;\n\n    do {\n        SearchTracker.MatchInfo matchInfo = tracker.matchInfo;\n        int textIndex = matchInfo.textIndex;\n        String pattern = matchInfo.pattern;\n        String replacement = matchInfo.replacement;\n\n        buf.append(text.substring(start, textIndex));\n        buf.append(replacement);\n\n        start = textIndex + pattern.length();\n    } while (tracker.hasNextMatch(start));\n\n    return buf.append(text.substring(start)).toString();\n}\n\nprivate static class SearchTracker {\n\n    private final String text;\n\n    private final Map&lt;String, String&gt; patternToReplacement = new HashMap&lt;&gt;();\n    private final Set&lt;String&gt; pendingPatterns = new HashSet&lt;&gt;();\n\n    private MatchInfo matchInfo = null;\n\n    private static class MatchInfo {\n        private final String pattern;\n        private final String replacement;\n        private final int textIndex;\n\n        private MatchInfo(String pattern, String replacement, int textIndex) {\n            this.pattern = pattern;\n            this.replacement = replacement;\n            this.textIndex = textIndex;\n        }\n    }\n\n    private SearchTracker(String text, String[] searchList, String[] replacementList) {\n        this.text = text;\n        for (int i = 0; i &lt; searchList.length; ++i) {\n            String pattern = searchList[i];\n            patternToReplacement.put(pattern, replacementList[i]);\n            pendingPatterns.add(pattern);\n        }\n    }\n\n    boolean hasNextMatch(int start) {\n        int textIndex = -1;\n        String nextPattern = null;\n\n        for (String pattern : new ArrayList&lt;&gt;(pendingPatterns)) {\n            int matchIndex = text.indexOf(pattern, start);\n            if (matchIndex == -1) {\n                pendingPatterns.remove(pattern);\n            } else {\n                if (textIndex == -1 || matchIndex &lt; textIndex) {\n                    textIndex = matchIndex;\n                    nextPattern = pattern;\n                }\n            }\n        }\n\n        if (nextPattern != null) {\n            matchInfo = new MatchInfo(nextPattern, patternToReplacement.get(nextPattern), textIndex);\n            return true;\n        }\n        return false;\n    }\n}\n</code></pre>\n\n<p>Unit tests:</p>\n\n<pre><code>@Test\npublic void testSingleExact() {\n    assertEquals(\"bar\", StringUtils.replaceEach(\"foo\", new String[]{\"foo\"}, new String[]{\"bar\"}));\n}\n\n@Test\npublic void testReplaceTwice() {\n    assertEquals(\"barbar\", StringUtils.replaceEach(\"foofoo\", new String[]{\"foo\"}, new String[]{\"bar\"}));\n}\n\n@Test\npublic void testReplaceTwoPatterns() {\n    assertEquals(\"barbaz\", StringUtils.replaceEach(\"foobar\",\n            new String[]{\"foo\", \"bar\"},\n            new String[]{\"bar\", \"baz\"}));\n}\n\n@Test\npublic void testReplaceNone() {\n    assertEquals(\"foofoo\", StringUtils.replaceEach(\"foofoo\", new String[]{\"x\"}, new String[]{\"bar\"}));\n}\n\n@Test\npublic void testStory() {\n    assertEquals(\"Once upon a foo, there was a bar and a baz, and another bar and a cat.\",\n            StringUtils.replaceEach(\"Once upon a baz, there was a foo and a bar, and another foo and a cat.\",\n                    new String[]{\"foo\", \"bar\", \"baz\"},\n                    new String[]{\"bar\", \"baz\", \"foo\"})\n    );\n}\n</code></pre>\n", "title": "How can I replace two strings in a way that one does not end up replacing the other?", "tags": ["java", "string", "replace"], "link": "http://stackoverflow.com/questions/26791441/how-can-i-replace-two-strings-in-a-way-that-one-does-not-end-up-replacing-the-ot/26819171#26819171", "post_type": "answer", "question_id": 26791441, "answer_id": 26819171}, {"body": "<p>If you will read comment above the code, It is mentioned that...</p>\n\n<p>If the caller is not a <code>ForkJoinTask</code>, this method is behaviorally equivalent to</p>\n\n<pre><code>while (!blocker.isReleasable())\n   if (blocker.block())\n      return;\n}\n</code></pre>\n\n<p>So it is just another form to implement above code in else part...!!</p>\n\n<p>In <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/concurrent/ForkJoinPool.java#l520\" rel=\"nofollow\">Style notes</a> it is mentioned that, </p>\n\n<blockquote>\n  <p>There are several occurrences of the unusual \"do {} while\n   (!cas...)\"  which is the simplest way to force an update of a\n   CAS'ed variable.</p>\n</blockquote>\n\n<p>And if you will see implementation of <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinPool.ManagedBlocker.html\" rel=\"nofollow\">ManagedLocker#isReleasable</a>, It is updating the lock and returns <code>true</code> if blocking is unnecessary.</p>\n\n<p><strong><em>Interpretation :</em></strong></p>\n\n<p>Blank while loops are used to provide an interrupt until some condition reset to true/false.</p>\n\n<p>Here, <code>do { } while(!...)</code> is a blocker/interrupt until <code>blocker.block()</code> will be <code>true</code> when <code>blocker.isReleasable()</code> is <code>false</code>. Loop will continue execution while <code>blocker</code> is not releasable (<code>!blocker.isReleasable()</code>) and <code>blocker</code> is not blocked !! Execution will be out of loop as soon as <code>blocker.block()</code> will set to true.</p>\n\n<p>Note that, <code>do{ } while(...)</code> does not update CAS variable, but it guarantee that program will wait until variable gets updated (force to wait until variable gets updated).  </p>\n", "title": "Do &quot;nothing&quot; while &quot;condition&quot;", "tags": ["java", "while-loop", "do-while"], "link": "http://stackoverflow.com/questions/24609564/do-nothing-while-condition/24609841#24609841", "post_type": "answer", "question_id": 24609564, "answer_id": 24609841}, {"body": "<p>The short answer to \"why isn't <code>Cloneable</code> deprecated?\" (or indeed, why isn't <code>X</code> deprecated, for any <code>X</code>) is that there hasn't been much attention paid to deprecating them.</p>\n\n<p>Most things that have been deprecated recently were deprecated because there is a specific plan to remove them. For example, the <code>addPropertyChangeListener</code> and <code>removePropertyChangeListener</code> methods of <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/logging/LogManager.html\">LogManager</a> were <a href=\"https://bugs.openjdk.java.net/browse/JDK-7192274\">deprecated in Java SE 8</a> with the intention of removing them in Java SE 9. (The reason is that they unnecessarily complicated module interdependencies.) Indeed, these APIs have already been <a href=\"https://bugs.openjdk.java.net/browse/jdk-8029805\">removed from early JDK 9</a> development builds. (Note that similar property change listener calls were also removed from <code>Pack200</code>; see <a href=\"https://bugs.openjdk.java.net/browse/JDK-8029806\">JDK-8029806</a>.)</p>\n\n<p>No such similar plan exists to for <code>Cloneable</code> and <code>Object.clone()</code>.</p>\n\n<p>A longer answer would involve discussing further questions, such as what one might expect to happen to these APIs, what costs or benefits would accrue the platform if they were deprecated, and what is being communicated to developers when an API is deprecated. I explored this topic in my recent JavaOne talk, <a href=\"https://oracleus.activeevents.com/2014/connect/sessionDetail.ww?SESSION_ID=6377\">Debt and Deprecation</a>. (Slides available at that link; <a href=\"https://www.parleys.com/talk/debt-deprecation\">video here</a>.) It turns out that the JDK itself hasn't been very consistent in its usage of deprecation. It's been used to mean several different things, including for example,</p>\n\n<ul>\n<li><p>This is dangerous and you should be aware of the risks of using it (example:<code>Thread.stop()</code>, <code>Thread.resume()</code>, and <code>Thread.suspend()</code>).</p></li>\n<li><p>This is going to be removed in a future release</p></li>\n<li>This is obsolete and it's a good idea for you to use something different (example: many of the methods in <code>java.util.Date</code>)</li>\n</ul>\n\n<p>All of these are distinct meanings, and different subsets of them apply to different things that are deprecated. And some subset of them apply to things that aren't deprecated (but that maybe should be deprecated).</p>\n\n<p><code>Cloneable</code> and <code>Object.clone()</code> are \"broken\" in the sense that they have design flaws and are difficult to use correctly. However, <code>clone()</code> is still the best way to copy arrays, and cloning has some limited usefulness to make copies of instances of classes that are carefully implemented. Removing cloning would be an incompatible change that would break a lot of things. A cloning operation could be reimplemented a different way, but it would probably be slower than <code>Object.clone()</code>.</p>\n\n<p>However, for most things a copy constructor is preferable to cloning. So perhaps marking <code>Cloneable</code> as \"obsolete\" or \"superseded\" or something similar would be appropriate. This would tell developers that they probably want to look elsewhere, but it would not signal that the cloning mechanism might be removed in a future release. Unfortunately, no such marker exists.</p>\n\n<p>As things stand, \"deprecation\" seems to imply eventual removal -- despite the fact that a vanishingly small number of deprecated features have ever been removed -- and so deprecation doesn't seem warranted for the cloning mechanism. Perhaps in the future an alternative marking can be applied that directs developers to use alternative mechanisms instead.</p>\n\n<p><strong>UPDATE</strong></p>\n\n<p>I've added some additional history to the <a href=\"https://bugs.openjdk.java.net/browse/JDK-4098033\">bug report</a>. Frank Yellin, an early JVM implementor and co-author of the JVM specification, made some comments in response to the \"lost in the mists of time\" comment in the TRC recommendation quoted in the <a href=\"http://stackoverflow.com/a/26403314/1441122\">other answer</a>. I've quoted the relevant portions here; the full message is in the bug report.</p>\n\n<blockquote>\n  <p>Cloneable has no methods for the same reason that Serializable doesn't. Cloneable indicates a property of the class, rather than specifically saying anything about the methods that the class supported.</p>\n  \n  <p>Prior to reflection, we needed a native method to make a shallow copy of an Object.  Hence Object.clone() was born.  It was also clear that many classes would want to override this method, and that not every class would want to be cloned.  Hence Cloneable was born to indicate the programmer's intention.</p>\n  \n  <p>So, in short.  The purpose of Cloneable was not to indicate that you had a public clone() method.  It was to indicate that you were willing to be cloned using Object.clone(), and it was up to the implementation to decide whether or not to make clone() public.</p>\n</blockquote>\n", "title": "Why is Cloneable not deprecated?", "tags": ["java", "java-8", "deprecated", "cloneable"], "link": "http://stackoverflow.com/questions/26398951/why-is-cloneable-not-deprecated/26415589#26415589", "post_type": "answer", "question_id": 26398951, "answer_id": 26415589}, {"body": "<p>Here are some variations on <a href=\"http://stackoverflow.com/a/25903212/1441122\">Sotirios Delimanolis' answer</a>, which was pretty good to begin with (+1). Consider the following:</p>\n\n<pre><code>static &lt;X, Y, Z&gt; Map&lt;X, Z&gt; transform(Map&lt;? extends X, ? extends Y&gt; input,\n                                     Function&lt;Y, Z&gt; function) {\n    return input.keySet().stream()\n        .collect(Collectors.toMap(Function.identity(),\n                                  key -&gt; function.apply(input.get(key))));\n}\n</code></pre>\n\n<p>A couple points here. First is the use of wildcards in the generics; this makes the function somewhat more flexible. A wildcard would be necessary if, for example, you wanted the output map to have a key that's a superclass of the input map's key:</p>\n\n<pre><code>Map&lt;String, String&gt; input = new HashMap&lt;String, String&gt;();\ninput.put(\"string1\", \"42\");\ninput.put(\"string2\", \"41\");\nMap&lt;CharSequence, Integer&gt; output = transform(input, Integer::parseInt);\n</code></pre>\n\n<p>(There is also an example for the map's values, but it's really contrived, and I admit that having the bounded wildcard for Y only helps in edge cases.)</p>\n\n<p>A second point is that instead of running the stream over the input map's <code>entrySet</code>, I ran it over the <code>keySet</code>. This makes the code a little cleaner, I think, at the cost of having to fetch values out of the map instead of from the map entry. Incidentally, I initially had <code>key -&gt; key</code> as the first argument to <code>toMap()</code> and this failed with a type inference error for some reason. Changing it to <code>(X key) -&gt; key</code> worked, as did <code>Function.identity()</code>.</p>\n\n<p>Still another variation is as follows:</p>\n\n<pre><code>static &lt;X, Y, Z&gt; Map&lt;X, Z&gt; transform1(Map&lt;? extends X, ? extends Y&gt; input,\n                                      Function&lt;Y, Z&gt; function) {\n    Map&lt;X, Z&gt; result = new HashMap&lt;&gt;();\n    input.forEach((k, v) -&gt; result.put(k, function.apply(v)));\n    return result;\n}\n</code></pre>\n\n<p>This uses <code>Map.forEach()</code> instead of streams. This is even simpler, I think, because it dispenses with the collectors, which are somewhat clumsy to use with maps. The reason is that <code>Map.forEach()</code> gives the key and value as separate parameters, whereas the stream has only one value -- and you have to choose whether to use the key or the map entry as that value. On the minus side, this lacks the rich, streamy goodness of the other approaches. :-)</p>\n", "title": "Java8: HashMap&lt;X, Y&gt; to HashMap&lt;X, Z&gt; using Stream / Map-Reduce / Collector", "tags": ["java", "mapreduce", "java-8", "java-stream", "collectors"], "link": "http://stackoverflow.com/questions/25903137/java8-hashmapx-y-to-hashmapx-z-using-stream-map-reduce-collector/25905196#25905196", "post_type": "answer", "question_id": 25903137, "answer_id": 25905196}, {"body": "<p>The way I read the JLS here the exact bit value of a NaN is dependent on who/what made it and since the JVM didn't make it, don't ask them.  You might as well ask them what an \"Error code 4\" string means.   </p>\n\n<p>The hardware produces different bit patterns meant to represent different kinds of NaN's.  Unfortunately the different kinds hardware produce different bit patterns for the same kinds of NaN's.  Fortunately there is a standard pattern that Java can use to at least tell that it is some kind of NaN.  </p>\n\n<p>It's like Java looked at the \"Error code 4\" string and said, \"We don't know what 'code 4' means on your hardware, but there was the word 'error' in that string, so we think it's an error.\"</p>\n\n<p>The JLS tries to give you a chance to figure it out on your own though:</p>\n\n<p>\"However, version 1.3 of the Java SE platform introduced methods enabling the programmer to distinguish between NaN values: the <code>Float.floatToRawIntBits</code> and <code>Double.doubleToRawLongBits</code> methods. The interested reader is referred to the specifications for the <code>Float</code> and <code>Double</code> classes for more information.\"</p>\n\n<p>Which looks to me like a C++ <code>reinterpret_cast</code>.  It's Java giving you a chance to analyze the NaN yourself in case you happen to know how its signal was encoded.  If you want to track down the hardware specs so you can predict what different events should produce which NaN bit patterns you are free to do so but you are outside the uniformity the JVM was meant to give us.  So expect it might change from hardware to hardware.</p>\n\n<p>When testing if a number is NaN we check if it's equal to itself since it's the only number that isn't.  This isn't to say that the bits are different.  Before comparing the bits the JVM tests for the many bit patterns that say it's a NaN.  If it's any of those patterns then it reports that it's not equal, even if the bits of the two operands really are the same (and even if they're different).  </p>\n\n<p>Back in 1964, when pressed to give an exact definition for pornography, U.S. Supreme Court Justice Stewart famously said, \u201cI Know It When I See It\u201d.  I think of Java as doing the same thing with NaN's.  Java can't tell you anything that a \"signaling\" NaN might be signaling cause it doesn't know how that signal was encoded.  But it can look at the bits and tell it's a NaN of some kind since that pattern follows one standard.  </p>\n\n<p>If you happen to be on hardware that encodes all NaN's with uniform bits you'll never prove that Java is doing anything to make NaN's have uniform bits.  Again, the way I read the JLS, they are outright saying you are on your own here.</p>\n\n<p>I can see why this feels flaky.  It is flaky.  It's just not Java's fault.  I'll lay odds that some where out there some enterprising hardware manufactures came up with wonderfully expressive signaling NaN bit patterns but they failed to get it adopted as a standard widely enough that Java can count on it.  That's what's flaky.  We have all these bits reserved for signalling what kind of NaN we have and can't use them because we don't agree what they mean.  Having Java beat NaN's into a uniform value after the hardware makes them would only destroy that information, harm performance, and the only payoff is to not seem flaky.  Given the situation, I'm glad they realized they could cheat their way out of the problem and define NaN as not being equal to anything.</p>\n", "title": "Are the bit patterns of NaNs really hardware-dependent?", "tags": ["java", "floating-point", "nan", "ieee-754"], "link": "http://stackoverflow.com/questions/25050133/are-the-bit-patterns-of-nans-really-hardware-dependent/25050550#25050550", "post_type": "answer", "question_id": 25050133, "answer_id": 25050550}, {"body": "<pre><code>String blank = \"\";                    \nString comma = \",\";                   \nSystem.out.println(\"Output1: \"+blank.split(\",\").length);  // case 1\nSystem.out.println(\"Output2: \"+comma.split(\",\").length);  // case 2\n</code></pre>\n\n<p>case 1 - Here <code>blank.split(\",\")</code> will return <code>\"\"</code> since there is no <code>,</code> in <code>blank</code> you get the same, So length will be <code>1</code></p>\n\n<p>case 2- Here <code>comma.split(\",\")</code> will return empty array, you have to scape <code>,</code> if you want to count <code>comma</code> with length <code>1</code> else length will be <code>0</code></p>\n\n<p>Again <code>comma.split(\",\")</code> split() expecting a <code>regex</code> as argument it will return result array to matching with that <code>regex</code>.</p>\n\n<blockquote>\n  <p>The array returned by this method contains each substring of this\n  string that is terminated by another substring that matches the given\n  expression or is terminated by the end of the string.</p>\n</blockquote>\n\n<p>Else</p>\n\n<blockquote>\n  <p>If the expression does not match any part of the input then the\n  resulting array has just one element, namely this string.</p>\n</blockquote>\n", "title": "Confusing output from String.split", "tags": ["java", "regex", "string", "class", "core"], "link": "http://stackoverflow.com/questions/25056607/confusing-output-from-string-split/25056731#25056731", "post_type": "answer", "question_id": 25056607, "answer_id": 25056731}]}