{"items": [{"body": "<p>I was reading Java's <code>ArrayList</code> source code and noticed some comparisons in if-statements.</p>\n\n<p>In Java 7, the method <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/util/ArrayList.java#ArrayList.grow%28int%29\"><code>grow(int)</code></a> uses</p>\n\n<pre><code>if (newCapacity - minCapacity &lt; 0)\n    newCapacity = minCapacity;\n</code></pre>\n\n<p>In Java 6, <code>grow</code> didn't exist. The method <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/util/ArrayList.java#ArrayList.ensureCapacity%28int%29\"><code>ensureCapacity(int)</code></a> however uses</p>\n\n<pre><code>if (newCapacity &lt; minCapacity)\n    newCapacity = minCapacity;\n</code></pre>\n\n<p>What was the reason behind the change? Was it a performance issue or just a style? </p>\n\n<p>I could imagine that comparing against zero is faster, but performing a complete subtraction just to check whether it's negative seems a bit overkill to me. Also in terms of bytecode, this would involve two instructions (<code>ISUB</code> and <code>IF_ICMPGE</code>) instead of one (<code>IFGE</code>).</p>\n", "title": "Difference between if (a - b &lt; 0) and if (a &lt; b)", "tags": ["java", "if-statement", "arraylist"], "link": "http://stackoverflow.com/questions/33147339/difference-between-if-a-b-0-and-if-a-b", "post_type": "question", "question_id": 33147339}, {"body": "<p>I was testing boundary conditions on some code involving a <code>BigDecimal</code>, and I noticed that when a <code>BigDecimal</code> is initialized with the String <code>\"1e2147483647\"</code> it behaves unexpectedly. It seems to have a value between <code>0</code> and <code>1e-2147483647</code>. When I try calling <code>intValue()</code>, I get a <code>NegativeArraySizeException</code>. I should note that <code>2147483647</code> is the max value of an integer on my system. Am I doing something wrong, or is this a problem with <code>BigDecimal</code>?</p>\n\n<pre><code>BigDecimal test = new BigDecimal(\"1e2147483647\");\n\ntest.compareTo(new BigDecimal(0));  //Returns 1\ntest.compareTo(new BigDecimal(\"1e-2147483647\"));  //Returns -1\ntest.intValue();  //Throws NegativeArraySizeException\n</code></pre>\n", "title": "Java BigDecimal Possible Overflow Bug", "tags": ["java", "bigdecimal"], "link": "http://stackoverflow.com/questions/31170459/java-bigdecimal-possible-overflow-bug", "post_type": "question", "question_id": 31170459}, {"body": "<p>Is there a good reason that the <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#list(java.util.Enumeration)\">Collections.list()</a> method in the <code>java.utils</code> package returns an <code>ArrayList&lt;T&gt;</code> instead of <code>List&lt;T&gt;</code>?</p>\n\n<p>Obviously an <code>ArrayList</code> is a <code>List</code>, but I'm under the impression that it's generally good practice to return the interface type instead of implementation type.</p>\n", "title": "Why does Enumeration get converted to ArrayList and not List in java.utils?", "tags": ["java", "arraylist", "collections", "return-type", "utils"], "link": "http://stackoverflow.com/questions/32356762/why-does-enumeration-get-converted-to-arraylist-and-not-list-in-java-utils", "post_type": "question", "question_id": 32356762}, {"body": "<p>I've read on many Web sites Optional should be used as a return type only, and not used in method arguments.  I'm struggling to find a logical reason why.  For example I have a piece of logic which has 2 optional parameters.  Therefore I think it would make sense to write my method signature like this (solution 1):</p>\n\n<pre><code>public int calculateSomething(Optional&lt;String&gt; p1, Optional&lt;BigDecimal&gt; p2 {\n    // my logic\n}\n</code></pre>\n\n<p>Many web pages specify Optional should not be used as method arguments. With this in mind I could use the following method signature and add a clear Javadoc comment specifying the arguments maybe null hoping future future maintainers will read the javadoc and therefore always carry out null checks prior to using the arguments (solution 2):</p>\n\n<pre><code>public int calculateSomething(String p1, BigDecimal p2) {\n    // my logic\n}\n</code></pre>\n\n<p>Alternatively I could replace my method with 4 public methods to provide a nicer interface and make it more obvious p1 and p2 are optional (solution 3):</p>\n\n<pre><code>public int calculateSomething() {\n    calculateSomething(null, null);\n}\n\npublic int calculateSomething(String p1) {\n    calculateSomething(p1, null);\n}\n\npublic int calculateSomething(BigDecimal p2) {\n    calculateSomething(null, p2);\n}\n\npublic int calculateSomething(String p1, BigDecimal p2) {\n    // my logic\n}\n</code></pre>\n\n<p>Now I try writing the code of the class which invokes this piece of logic for each approach.  I first retrieve the 2 input parameters from another object which returns optionals and then I invoke calculateSomething.  Therefore if solution 1 is used the calling code would look like this:</p>\n\n<pre><code>Optional&lt;String&gt; p1 = otherObject.getP1();\nOptional&lt;BigInteger&gt; p2 = otherObject.getP2();\nint result = myObject.calculateSomething(p1, p2);\n</code></pre>\n\n<p>if solution 2 is used the calling code would look like this:</p>\n\n<pre><code>Optional&lt;String&gt; p1 = otherObject.getP1();\nOptional&lt;BigInteger&gt; p2 = otherObject.getP2();\nint result = myObject.calculateSomething(p1.orElse(null), p2.orElse(null));\n</code></pre>\n\n<p>if solution 3 is used I could use the code above or I could use the following (but its a significant amount more code):</p>\n\n<pre><code>Optional&lt;String&gt; p1 = otherObject.getP1();\nOptional&lt;BigInteger&gt; p2 = otherObject.getP2();\nint result;\nif (p1.isPresent()) {\n    if (p2.isPresent()) {\n        result = myObject.calculateSomething(p1, p2);\n    } else {\n        result = myObject.calculateSomething(p1);\n    }\n} else {\n    if (p2.isPresent()) {\n        result = myObject.calculateSomething(p2);\n    } else {\n        result = myObject.calculateSomething();\n    }\n}\n</code></pre>\n\n<p><strong>So my question is why is it considered bad practice to use Optionals as method arguments as in solution 1?</strong>  It looks like the most readable solution to me and makes it most obvious that the parameters could be empty/null to future maintainers.  (I'm aware the designers of Optional intended it to only be used as a return type, but I can't find any logical reasons not to use it in this scenario)</p>\n", "title": "Why should Java 8&#39;s Optional not be used in arguments", "tags": ["java", "java-8", "optional"], "link": "http://stackoverflow.com/questions/31922866/why-should-java-8s-optional-not-be-used-in-arguments", "post_type": "question", "question_id": 31922866}, {"body": "<p>I noticed something strange in the implementation of <code>HashMap.clear()</code>. This is how it looked in <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/java/util/HashMap.java#737\" rel=\"nofollow\">OpenJDK 7u40</a>:</p>\n\n<pre><code>public void clear() {\n    modCount++;\n    Arrays.fill(table, null);\n    size = 0;\n}\n</code></pre>\n\n<p>And this is how it looks as of <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/util/HashMap.java#857\" rel=\"nofollow\">OpenJDK 8u40</a>:</p>\n\n<pre><code>public void clear() {\n    Node&lt;K,V&gt;[] tab;\n    modCount++;\n    if ((tab = table) != null &amp;&amp; size &gt; 0) {\n        size = 0;\n        for (int i = 0; i &lt; tab.length; ++i)\n            tab[i] = null;\n    }\n}\n</code></pre>\n\n<p>I understand that now the <code>table</code> can be null for empty an map, thus the additional check and caching in a local variable is required. But why was <code>Arrays.fill()</code> replaced with a for-loop?</p>\n\n<p>It seems that the change was introduced in <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/diff/d62c911aebbb/src/share/classes/java/util/HashMap.java#l1.2459\" rel=\"nofollow\">this commit</a>. Unfortunately I found no explanation for why a plain for loop might be better than <code>Arrays.fill()</code>. Is it faster? Or safer?</p>\n", "title": "Why is Arrays.fill() not used in HashMap.clear() anymore?", "tags": ["java", "arrays", "hashmap", "java-8"], "link": "http://stackoverflow.com/questions/32693704/why-is-arrays-fill-not-used-in-hashmap-clear-anymore", "post_type": "question", "question_id": 32693704}, {"body": "<p>Why was the <code>Thread</code> class implemented as a regular class and not an <strong>abstract</strong> class with <code>run()</code> method being abstract.</p>\n\n<p>Will it possibly introduce any problems? Or does it have any use in being this way?</p>\n\n<p>Also, the <code>Thread.start()</code> method is supposed to be a very specific method <strong>whose functionality cannot be implemented by any other class</strong> (If I am not wrong). And hence I guess the <code>final</code> keyword would be apt for this more than any other method.</p>\n\n<p>But I am able to override this method and use it as I like,</p>\n\n<pre><code>public class Test extends Thread {\n    public static void main (String... args) {\n        Thread test = new Test();\n        test.start();\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"New thread started...\");\n    }\n\n    @Override\n    public void start() {\n        System.out.println(\"Did anyone tell you I will spawn a new thread??\");\n    }\n}\n</code></pre>\n\n<p>It obviously only printed,</p>\n\n<blockquote>\n  <p>Did anyone tell you I will spawn a new thread??</p>\n</blockquote>\n\n<p>Is there any use in overriding other than confusing the engineer replacing you?</p>\n\n<p>If not, why was the method not declared final in Thread class?</p>\n", "title": "Why is Thread not an abstract class and start() not final?", "tags": ["java", "multithreading"], "link": "http://stackoverflow.com/questions/31202946/why-is-thread-not-an-abstract-class-and-start-not-final", "post_type": "question", "question_id": 31202946}, {"body": "<h2>Question</h2>\n\n<p>How is it that for a scanner object the <code>hasNextLine()</code> method returns true  while the <code>hasNext()</code> method returns false?</p>\n\n<p>Note: Based on the input file, the <code>hasNext()</code> method is returning the result as expected; the <code>hasNextLine()</code> does not seem to be returning the correct result.</p>\n\n<h2>Code</h2>\n\n<p>Here's the code I'm running that's creating the results below:</p>\n\n<pre><code>public void ScannerTest(Reader fileReaderObject){\n    Scanner scannerObj = new Scanner(fileReaderObject);\n\n    for(int i = 1; scannerObj.hasNext(); i++){\n        System.out.println(i + \": \" + scannerObj.next());\n        System.out.println(\"Has next line: \" + scannerObj.hasNextLine());\n        System.out.println(\"Has next: \" + scannerObj.hasNext());\n    }\n    System.out.println();\n\n    scannerObj.close();\n}\n</code></pre>\n\n<h2>Input File</h2>\n\n<p>The following is the actual content of the file that I'm passing to this scanner:</p>\n\n<pre><code>a   3   9\nb   3   6\nc   3   3\nd   2   8\ne   2   5\nf   2   2\ng   1   7\nh   1   4\ni   1   1\n</code></pre>\n\n<h2>Result</h2>\n\n<p>The following is the end of what's printed in the console when I run my code, and includes the portion I can't make sense of:</p>\n\n<pre><code>25: i\nHas next line: true\nHas next: true\n26: 1\nHas next line: true\nHas next: true\n27: 1\nHas next line: true\nHas next: false\n</code></pre>\n", "title": "Why is hasNext() False, but hasNextLine() is True?", "tags": ["java", "java.util.scanner"], "link": "http://stackoverflow.com/questions/31993377/why-is-hasnext-false-but-hasnextline-is-true", "post_type": "question", "question_id": 31993377}, {"body": "<p>As I recall, before Java 8, the default capacity of <code>ArrayList</code> was 10.</p>\n\n<p>Surprisingly, the comment on the default (void) constructor still says: <code>Constructs an empty list with an initial capacity of ten.</code></p>\n\n<p>From <code>ArrayList.java</code>:</p>\n\n<pre><code>/**\n * Shared empty array instance used for default sized empty instances. We\n * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when\n * first element is added.\n */\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n...\n\n/**\n * Constructs an empty list with an initial capacity of ten.\n */\npublic ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n</code></pre>\n", "title": "In Java 8, why is the default capacity of ArrayList now zero?", "tags": ["java", "arraylist", "java-8"], "link": "http://stackoverflow.com/questions/34250207/in-java-8-why-is-the-default-capacity-of-arraylist-now-zero", "post_type": "question", "question_id": 34250207}, {"body": "<p>It has generally been the case the Java source code has been forward compatible.  Until Java 8, as far as I know, both compiled classes <em>and</em> source have been forward compatible with later JDK/JVM releases.  [Update: this is not correct, see comments re 'enum', etc, below.]  However, with the addition of default methods in Java 8 this appears to no longer be the case.</p>\n\n<p>For example, a library I have been using has an implementation of <code>java.util.List</code> which includes a <code>List&lt;V&gt; sort()</code>.  This method returns a copy of the contents of the list sorted. This library, deployed as a jar file dependency, worked fine in a project being built using JDK 1.8.</p>\n\n<p>However, later I had occasion to recompile the library itself using JDK 1.8 and\nI found the library no longer compiles: the <code>List</code>-implementing class with its own <code>sort()</code> method now conflicts with the Java 8 <code>java.util.List.sort()</code> default method.  The Java 8 <code>sort()</code> default method sorts the list in place (returns <code>void</code>); my library's <code>sort()</code> method - since it returns a new sorted list - has an incompatible signature.</p>\n\n<p>So my basic question is:</p>\n\n<ul>\n<li>Doesn't JDK 1.8 introduce a forward incompatibility for Java source code due to default methods?</li>\n</ul>\n\n<p>Also:</p>\n\n<ul>\n<li>Is this the first such forward incompatible change?</li>\n<li>Was this considered or discussed when default methods where designed and implemented?  Is it documented anywhere?</li>\n<li>Was the (admittedly small) inconvenience discounted versus the benefits?</li>\n</ul>\n\n<p>The following is an example of some code that compiles and runs under 1.7 and\nruns under 1.8 - but does not compile under 1.8:</p>\n\n<pre><code>import java.util.*;\n\npublic final class Sort8 {\n\n    public static void main(String[] args) {\n        SortableList&lt;String&gt; l = new SortableList&lt;String&gt;(Arrays.asList(args));\n        System.out.println(\"unsorted: \"+l);\n        SortableList&lt;String&gt; s = l.sort(Collections.reverseOrder());\n        System.out.println(\"sorted  : \"+s);\n    }\n\n    public static class SortableList&lt;V&gt; extends ArrayList&lt;V&gt; {\n\n        public SortableList() { super(); }\n        public SortableList(Collection&lt;? extends V&gt; col) { super(col); }\n\n        public SortableList&lt;V&gt; sort(Comparator&lt;? super V&gt; cmp) {\n            SortableList&lt;V&gt; l = new SortableList&lt;V&gt;();\n            l.addAll(this);\n            Collections.sort(l, cmp);\n            return l;\n        }\n\n    }\n\n}\n</code></pre>\n\n<p>The following shows this code being compiled (or failing to) and being run.</p>\n\n<pre><code>&gt; c:\\tools\\jdk1.7.0_10\\bin\\javac Sort8.java\n\n&gt; c:\\tools\\jdk1.7.0_10\\bin\\java Sort8 this is a test\nunsorted: [this, is, a, test]\nsorted  : [this, test, is, a]\n\n&gt; c:\\tools\\jdk1.8.0_05\\bin\\java Sort8 this is a test\nunsorted: [this, is, a, test]\nsorted  : [this, test, is, a]\n\n&gt; del Sort8*.class\n\n&gt; c:\\tools\\jdk1.8.0_05\\bin\\javac Sort8.java\nSort8.java:46: error: sort(Comparator&lt;? super V&gt;) in SortableList cannot implement sort(Comparator&lt;? super E&gt;) in List\n                public SortableList&lt;V&gt; sort(Comparator&lt;? super V&gt; cmp) {\n                                       ^\n  return type SortableList&lt;V&gt; is not compatible with void\n  where V,E are type-variables:\n    V extends Object declared in class SortableList\n    E extends Object declared in interface List\n1 error\n</code></pre>\n", "title": "Do Java 8 default methods break source compatibility?", "tags": ["java", "java-8", "default-method", "forward-compatibility"], "link": "http://stackoverflow.com/questions/31188231/do-java-8-default-methods-break-source-compatibility", "post_type": "question", "question_id": 31188231}, {"body": "<p>I am using JDK-8 (x64). For <code>Arrays.sort</code> I found the following in the Java documentation: </p>\n\n<blockquote>\n  <p>The sorting algorithm is a Dual-Pivot <strong>Quicksort</strong> by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch.`</p>\n</blockquote>\n\n<p>For <code>Collections.sort</code> I found this: </p>\n\n<blockquote>\n  <p>This implementation is a stable, adaptive, iterative <strong>mergesort</strong> ... This implementation <strong>dumps the specified list into an array, sorts the array</strong>, and iterates over the list resetting each element from the corresponding position in the array.</p>\n</blockquote>\n\n<p>If <code>Collections.sort</code> uses an array, why doesn't it just call <code>Arrays.sort</code> or use dual-pivot <strong>QuickSort</strong>? Why use <strong>Mergesort</strong>?</p>\n", "title": "Why does Collections.sort use Mergesort but Arrays.sort does not?", "tags": ["java", "arrays", "sorting", "collections", "java-8"], "link": "http://stackoverflow.com/questions/32334319/why-does-collections-sort-use-mergesort-but-arrays-sort-does-not", "post_type": "question", "question_id": 32334319}, {"body": "<p>Exceptions, especially checked ones, can severely interrupt the flow of program logic when the FP idiom is used in Java 8. Here is an arbitrary example:</p>\n\n<pre><code>String s1 = \"oeu\", s2 = \"2\";\nStream.of(s1, s2).forEach(s -&gt; \n    System.out.println(Optional.of(s).map(Integer::parseInt).get()));\n</code></pre>\n\n<p>The above code breaks when there's an exception for an unparseable string. But say I just want to replace that with a default value, much like I can with <code>Optional</code>:</p>\n\n<pre><code>Stream.of(s1, s2).forEach(s -&gt; \n   System.out.println(Optional.of(s)\n                              .map(Integer::parseInt)\n                              .orElse(-1)));\n</code></pre>\n\n<p>Of course, this still fails because <code>Optional</code> only handles <code>null</code>s. I would like something as follows:</p>\n\n<pre><code>Stream.of(s1, s2).forEach(s -&gt;\n    System.out.println(\n        Exceptional.of(s)\n                   .map(Integer::parseInt)\n                   .handle(NumberFormatException.class, swallow())\n                   .orElse(-1)));\n</code></pre>\n\n<hr>\n\n<p><strong>Note:</strong> this is a self-answered question.</p>\n", "title": "A better approach to handling exceptions in a functional way", "tags": ["java", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/31270759/a-better-approach-to-handling-exceptions-in-a-functional-way", "post_type": "question", "question_id": 31270759}, {"body": "<p>I've tried to build my own Map to increase the performance for a special environment, and I realized something pretty interesting: Creating a <code>new Hashmap&lt;Integer,String&gt;(2000)</code> is faster than <code>new Object[2000]</code> - no matter in which order I execute these commands. That's pretty confusing to me, esp. because the Hashmap constructor contains a <code>table = new Entry[capacity]</code>, according to <a href=\"http://www.docjar.com/html/api/java/util/HashMap.java.html\">this</a>. Is there something wrong with my testbench?</p>\n\n<pre><code>public static void test(int amm){ //amm=1_000_000\n    Map&lt;Integer,String&gt; m1 = null;\n    Object[] arr = null;\n\n    long time = System.nanoTime();\n    for(int i = 0; i &lt; amm; i++){\n        m1 = new HashMap&lt;Integer, String&gt;(2000);\n    }\n    System.out.println(\"m1: \" + (System.nanoTime() - time)); //m1: 70_455_065\n\n    time = System.nanoTime();\n    for(int i = 0; i &lt; amm; i++){\n        arr = new Object[2000];\n    }\n    System.out.println(\"arr: \" + (System.nanoTime() - time)); //arr: 1_322_473_803\n}\n</code></pre>\n\n<p>I'd love to see the results of testing on another computer. I've got no clue why creating a <code>HashMap</code> is 10 times faster than creating a <code>Object[]</code>.</p>\n", "title": "Why is creating a HashMap faster than creating an Object[]?", "tags": ["java", "arrays", "performance", "hashmap"], "link": "http://stackoverflow.com/questions/31419029/why-is-creating-a-hashmap-faster-than-creating-an-object", "post_type": "question", "question_id": 31419029}, {"body": "<p>I'm currently in the process of writing a paint program in java, designed to have flexible and comprehensive functionalities. It stemmed from my final project, that I wrote overnight the day before. Because of that, it's got tons and tons of bugs, which I've been tackling one by one (e.g. I can only save files that will be empty, my rectangles don't draw right but my circles do...).</p>\n\n<p>This time, I've been trying to add undo/redo functionality to my program. However, I can't \"undo\" something that I have done. Therefore, I got an idea to save copies of my <code>BufferedImage</code> each time a <code>mouseReleased</code> event was fired. However, with some of the images going to 1920x1080 resolution, I figured that this wouldn't be efficient: storing them would probably take gigabytes of memory.</p>\n\n<p>The reason for why I can't simply paint the same thing with the background colour to undo is because I have many different brushes, which paint based on <code>Math.random()</code>, and because there are many different layers (in a single layer).</p>\n\n<p>Then, I've considered cloning the <code>Graphics</code> objects that I use to paint to the <code>BufferedImage</code>. Like this:</p>\n\n<pre><code>ArrayList&lt;Graphics&gt; revisions = new ArrayList&lt;Graphics&gt;();\n\n@Override\npublic void mouseReleased(MouseEvent event) {\n    Graphics g = image.createGraphics();\n    revisions.add(g);\n}\n</code></pre>\n\n<p>I haven't done this before, so I have a couple questions:</p>\n\n<ul>\n<li>Would I still be wasting pointless memory by doing this, like cloning my <code>BufferedImages</code>?</li>\n<li>Is there necessarily a different way I can do this?</li>\n</ul>\n", "title": "Is storing Graphics objects a good idea?", "tags": ["java", "memory-management", "graphics", "awt", "bufferedimage"], "link": "http://stackoverflow.com/questions/31370403/is-storing-graphics-objects-a-good-idea", "post_type": "question", "question_id": 31370403}, {"body": "<p>I'm trying to determine whether the following statements are guaranteed to be true:</p>\n\n<pre><code>((Boolean)true) == Boolean.TRUE\n((Boolean)true) == Boolean.valueOf(true)\n((Integer)1) == Integer.valueOf(1)\n</code></pre>\n\n<p>I've always assumed that autoboxing was equivalent to calling <code>valueOf()</code> on the corresponding type. Every <a href=\"http://stackoverflow.com/questions/5253256/which-is-better-letting-java-do-autoboxing-or-using-valueof\">discussion</a> that I've seen on the <a href=\"http://stackoverflow.com/questions/408661/what-code-does-the-compiler-generate-for-autoboxing\">topic</a> seems to <a href=\"http://stackoverflow.com/questions/2307904/autoboxing-vs-manual-boxing-java\">support</a> my assumption. But all I could find in the JLS was the following (<a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.7-300\">\u00a75.1.7</a>):</p>\n\n<blockquote>\n  <p>If the value <code>p</code> being boxed is an integer literal of type <code>int</code> between <code>-128</code> and <code>127</code> inclusive (\u00a73.10.1), or the boolean literal <code>true</code> or <code>false</code> (\u00a73.10.3), or a character literal between <code>'\\u0000'</code> and <code>'\\u007f'</code> inclusive (\u00a73.10.4), then let <code>a</code> and <code>b</code> be the results of any two boxing conversions of <code>p</code>. It is always the case that <code>a == b</code>.</p>\n</blockquote>\n\n<p>That describes behavior identical to that of <code>valueOf()</code>. But there doesn't seem to be any guarantee that <code>valueOf()</code> is actually invoked, meaning there could theoretically be an implementation that keeps a separate, dedicated cache for autoboxed values. In such a case, there might not be identity equality between cached autoboxed values and regular cached boxed values.</p>\n\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html\">Oracle's autoboxing tutorial</a> states matter-of-factly that <code>li.add(i)</code> is compiled to <code>li.add(Integer.valueOf(i))</code>, where <code>i</code> is an <code>int</code>. But I don't know whether the tutorial should be considered an authoritative source. </p>\n", "title": "Does autoboxing call valueOf()?", "tags": ["java", "boxing", "autoboxing"], "link": "http://stackoverflow.com/questions/31445024/does-autoboxing-call-valueof", "post_type": "question", "question_id": 31445024}, {"body": "<p>I have a server side implemented in <code>Scala</code> and <code>React/Flux</code> based front end. My services return <code>Futures</code> and they are handled within Scalatra's <code>AsyncResult</code> for JSON responses. </p>\n\n<p>For isomorphic/server side rendering setup I did not want to change services to be blocking so I started with Scala Future-> <code>java.util.function.Function</code> conversion <a href=\"http://blog.eigengo.com/2014/05/30/scala-futures-and-jdk-1-8-scripting/\">shown here</a>. </p>\n\n<p>But the dispatcher in Flux would like to have JS Promise. So far I found only rather complicated sounding way around this  <a href=\"http://www.slideshare.net/SpringCentral/serverside-javascript-with-nashorn-and-spring\">Slides 68-81</a></p>\n\n<p>Is there any recommended way to deal with this Scala Future -> JS Promise conversion?</p>\n", "title": "Nashorn and Scala future to JS Promise conversion", "tags": ["javascript", "java", "scala", "nashorn"], "link": "http://stackoverflow.com/questions/32046078/nashorn-and-scala-future-to-js-promise-conversion", "post_type": "question", "question_id": 32046078}, {"body": "<p>When using the Java 8 <code>Optional</code> class, there are two ways in which a value can be wrapped in an optional.</p>\n\n<pre><code>String foobar = &lt;value or null&gt;;\nOptional.of(foobar);         // May throw NullPointerException\nOptional.ofNullable(foobar); // Safe from NullPointerException\n</code></pre>\n\n<p>I understand <code>Optional.ofNullable</code> is the only safe way of using <code>Optional</code>, but why does <code>Optional.of</code> exist at all? Why not just use <code>Optional.ofNullable</code>  and be on the safe side at all times?</p>\n", "title": "Why use Optional.of over Optional.ofNullable?", "tags": ["java", "java-8", "optional"], "link": "http://stackoverflow.com/questions/31696485/why-use-optional-of-over-optional-ofnullable", "post_type": "question", "question_id": 31696485}, {"body": "<p>I have a question regarding Java 8 inference with respect to lambdas and their related exception signatures.</p>\n\n<p>If I define some method foo:</p>\n\n<pre><code>public static &lt;T&gt; void foo(Supplier&lt;T&gt; supplier) {\n    //some logic\n    ...\n}\n</code></pre>\n\n<p>then I get the nice and concise semantic of being able to write <code>foo(() -&gt; getTheT());</code> in most cases for a given <code>T</code>. However, in this example, if my <code>getTheT</code> operation declares that it <code>throws Exception</code>, my <code>foo</code> method which takes a Supplier no longer compiles: the Supplier method signature for <code>get</code> doesn't throw exceptions.</p>\n\n<p>It seems like a decent way to get around this would be to overload foo to accept either option, with the overloaded definition being:</p>\n\n<pre><code>public static &lt;T&gt; void foo(ThrowingSupplier&lt;T&gt; supplier) {\n   //same logic as other one\n   ...\n}\n</code></pre>\n\n<p>where ThrowingSupplier is defined as</p>\n\n<pre><code>public interface ThrowingSupplier&lt;T&gt; {\n   public T get() throws Exception;\n}\n</code></pre>\n\n<p>In this way, we have one Supplier type which throws exceptions and one which doesn't. The desired syntax would be something like this:</p>\n\n<pre><code>foo(() -&gt; operationWhichDoesntThrow()); //Doesn't throw, handled by Supplier\nfoo(() -&gt; operationWhichThrows()); //Does throw, handled by ThrowingSupplier\n</code></pre>\n\n<p>However, this causes issues due to the lambda type being ambiguous (presumably unable to resolve between Supplier and ThrowingSupplier). Doing an explicit cast a la <code>foo((ThrowingSupplier)(() -&gt; operationWhichThrows()));</code> would work, but it gets rid of most of the conciseness of the desired syntax.</p>\n\n<p>I guess the underlying question is: if the Java compiler is able to resolve the fact that one of my lambdas is incompatible due to it throwing an exception in the Supplier-only case, why isn't it able to use that same information to derive the type of the lambda in the secondary, type-inference case?</p>\n\n<p>Any information or resources which anyone could point me to would likewise be much appreciated, as I'm just not too sure where to look for more information on the matter.</p>\n\n<p>Thanks!</p>\n", "title": "Why Doesn&#39;t Java 8 Type Inference Consider Exceptions Thrown by Lambdas in Overload Selection?", "tags": ["java", "exception", "lambda", "java-8", "type-inference"], "link": "http://stackoverflow.com/questions/32323081/why-doesnt-java-8-type-inference-consider-exceptions-thrown-by-lambdas-in-overl", "post_type": "question", "question_id": 32323081}, {"body": "<p><code>String</code> is a special case in Java. It's a class, which I can examine in the <a href=\"http://hg.openjdk.java.net/jdk7u/jdk7u6/jdk/file/8c2c5d63a17e/src/share/classes/java/lang/String.java\">source code</a>, but it also has its own infix operator <code>+</code>, which seems to be syntactic sugar for <code>StringBuilder</code>. </p>\n\n<p>For example, </p>\n\n<pre><code>\"Hello \" + yourName;\n</code></pre>\n\n<p>could become </p>\n\n<pre><code>new StringBuilder().append(\"Hello \").append(yourName).toString();\n</code></pre>\n\n<p>There are no user-defined operators in Java, so where is <code>+</code> specified for <code>String</code>? </p>\n\n<p>Could the same mechanism be used to make additional operators, such as for vectors? </p>\n", "title": "Where is `+` implemented for Strings in the Java source code?", "tags": ["java", "string", "operators", "string-concatenation"], "link": "http://stackoverflow.com/questions/32714194/where-is-implemented-for-strings-in-the-java-source-code", "post_type": "question", "question_id": 32714194}, {"body": "<p>Currently the BlendModes (Subtract, Exclusion etc) use the LauncherImage as the mask. Can I apply these BlendModes to a ColorMatrix?</p>\n\n<p>I'm using the <a href=\"https://github.com/CyberAgent/android-gpuimage/tree/master/library/src/jp/co/cyberagent/android/gpuimage\">GPUImageLibrary</a> </p>\n\n<pre><code>colorMatrix[\n    0.393, 0.7689999, 0.18899999, 0, 0,\n    0.349, 0.6859999, 0.16799999, 0, 0,\n    0.272, 0.5339999, 0.13099999, 0, 0,\n    0,     0,         0,          1, 0];\n</code></pre>\n\n<p><strong>SubtractBlendFilter.java</strong></p>\n\n<pre><code>public class GPUImageSubtractBlendFilter extends GPUImageTwoInputFilter {\npublic static final String SUBTRACT_BLEND_FRAGMENT_SHADER = \"varying highp vec2 textureCoordinate;\\n\" +\n        \" varying highp vec2 textureCoordinate2;\\n\" +\n        \"\\n\" +\n        \" uniform sampler2D inputImageTexture;\\n\" +\n        \" uniform sampler2D inputImageTexture2;\\n\" +\n        \" \\n\" +\n        \" void main()\\n\" +\n        \" {\\n\" +\n        \"   lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\\n\" +\n        \"   lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\\n\" +\n        \"\\n\" +\n        \"   gl_FragColor = vec4(textureColor.rgb - textureColor2.rgb, textureColor.a);\\n\" +\n        \" }\";\n\npublic GPUImageSubtractBlendFilter() {\n    super(SUBTRACT_BLEND_FRAGMENT_SHADER);\n}\n}\n</code></pre>\n\n<p><strong>GPUIMageTwoInputFilter.java</strong></p>\n\n<pre><code>public class GPUImageTwoInputFilter extends GPUImageFilter {\nprivate static final String VERTEX_SHADER = \"attribute vec4 position;\\n\" +\n        \"attribute vec4 inputTextureCoordinate;\\n\" +\n        \"attribute vec4 inputTextureCoordinate2;\\n\" +\n        \" \\n\" +\n        \"varying vec2 textureCoordinate;\\n\" +\n        \"varying vec2 textureCoordinate2;\\n\" +\n        \" \\n\" +\n        \"void main()\\n\" +\n        \"{\\n\" +\n        \"    gl_Position = position;\\n\" +\n        \"    textureCoordinate = inputTextureCoordinate.xy;\\n\" +\n        \"    textureCoordinate2 = inputTextureCoordinate2.xy;\\n\" +\n        \"}\";\n\npublic int mFilterSecondTextureCoordinateAttribute;\npublic int mFilterInputTextureUniform2;\npublic int mFilterSourceTexture2 = OpenGlUtils.NO_TEXTURE;\nprivate ByteBuffer mTexture2CoordinatesBuffer;\nprivate Bitmap mBitmap;\n\npublic GPUImageTwoInputFilter(String fragmentShader) {\n    this(VERTEX_SHADER, fragmentShader);\n}\n\npublic GPUImageTwoInputFilter(String vertexShader, String fragmentShader) {\n    super(vertexShader, fragmentShader);\n    setRotation(Rotation.NORMAL, false, false);\n}\n\n@Override\npublic void onInit() {\n    super.onInit();\n\n    mFilterSecondTextureCoordinateAttribute = GLES20.glGetAttribLocation(getProgram(), \"inputTextureCoordinate2\");\n    mFilterInputTextureUniform2 = GLES20.glGetUniformLocation(getProgram(), \"inputImageTexture2\"); // This does assume a name of \"inputImageTexture2\" for second input texture in the fragment shader\n    GLES20.glEnableVertexAttribArray(mFilterSecondTextureCoordinateAttribute);\n\n    if (mBitmap != null&amp;&amp;!mBitmap.isRecycled()) {\n        setBitmap(mBitmap);\n    }\n}\n\npublic void setBitmap(final Bitmap bitmap) {\n    if (bitmap != null &amp;&amp; bitmap.isRecycled()) {\n        return;\n    }\n    mBitmap = bitmap;\n    if (mBitmap == null) {\n        return;\n    }\n    runOnDraw(new Runnable() {\n        public void run() {\n            if (mFilterSourceTexture2 == OpenGlUtils.NO_TEXTURE) {\n                if (bitmap == null || bitmap.isRecycled()) {\n                    return;\n                }\n                GLES20.glActiveTexture(GLES20.GL_TEXTURE3);\n                mFilterSourceTexture2 = OpenGlUtils.loadTexture(bitmap, OpenGlUtils.NO_TEXTURE, false);\n            }\n        }\n    });\n}\n\npublic Bitmap getBitmap() {\n    return mBitmap;\n}\n\npublic void recycleBitmap() {\n    if (mBitmap != null &amp;&amp; !mBitmap.isRecycled()) {\n        mBitmap.recycle();\n        mBitmap = null;\n    }\n}\n\npublic void onDestroy() {\n    super.onDestroy();\n    GLES20.glDeleteTextures(1, new int[]{\n            mFilterSourceTexture2\n    }, 0);\n    mFilterSourceTexture2 = OpenGlUtils.NO_TEXTURE;\n}\n\n@Override\nprotected void onDrawArraysPre() {\n    GLES20.glEnableVertexAttribArray(mFilterSecondTextureCoordinateAttribute);\n    GLES20.glActiveTexture(GLES20.GL_TEXTURE3);\n    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mFilterSourceTexture2);\n    GLES20.glUniform1i(mFilterInputTextureUniform2, 3);\n\n    mTexture2CoordinatesBuffer.position(0);\n    GLES20.glVertexAttribPointer(mFilterSecondTextureCoordinateAttribute, 2, GLES20.GL_FLOAT, false, 0, mTexture2CoordinatesBuffer);\n}\n\npublic void setRotation(final Rotation rotation, final boolean flipHorizontal, final boolean flipVertical) {\n    float[] buffer = TextureRotationUtil.getRotation(rotation, flipHorizontal, flipVertical);\n\n    ByteBuffer bBuffer = ByteBuffer.allocateDirect(32).order(ByteOrder.nativeOrder());\n    FloatBuffer fBuffer = bBuffer.asFloatBuffer();\n    fBuffer.put(buffer);\n    fBuffer.flip();\n\n    mTexture2CoordinatesBuffer = bBuffer;\n}\n}\n</code></pre>\n\n<p>My guess it involves changing something with <code>String SUBTRACT_BLEND_GRAGMENT_SHADER</code> &amp; <code>String VERTEX_SHADER</code>  . </p>\n", "title": "Use ColorMatrix or HexColor in BlendModeFilter - Android?", "tags": ["java", "android", "opengl-es", "gpuimage"], "link": "http://stackoverflow.com/questions/33358248/use-colormatrix-or-hexcolor-in-blendmodefilter-android", "post_type": "question", "question_id": 33358248}, {"body": "<pre><code>List&lt;Integer&gt; integer = Stream.generate(new Supplier&lt;Integer&gt;() {\n    int i = 0 ;\n\n    @Override\n    public Integer get() {\n        return ++i;\n    }\n}).filter(j -&gt; j &lt; 5)\n  .limit(10)   // Note the call to limit here\n  .collect(Collectors.toList());\n</code></pre>\n\n<p>Counter to my expectation, the <code>collect</code> call never returns. Setting <code>limit</code> before <code>filter</code> produces the expected result. Why?  </p>\n", "title": "Why doesn&#39;t Stream.limit work as expected in this snippet?", "tags": ["java", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/34172978/why-doesnt-stream-limit-work-as-expected-in-this-snippet", "post_type": "question", "question_id": 34172978}, {"body": "<p>I have a <code>List&lt;Item&gt;</code> collection.\nI need to convert it into <code>Map&lt;Integer, Item&gt;</code>\nThe key of the map must be the index of the item in the collection.\nI can not figure it out how to do this with streams.\nSomething like:</p>\n\n<pre><code>items.stream().collect(Collectors.toMap(...));\n</code></pre>\n\n<p>Any help?</p>\n\n<p>As this question is identified as possible duplicate I need to add that my concrete problem was - how to get the position of the item in the list and put it as a key value</p>\n", "title": "Java 8 list to map with stream", "tags": ["java", "dictionary", "collections", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/32859038/java-8-list-to-map-with-stream", "post_type": "question", "question_id": 32859038}, {"body": "<p>I'm reading up about Java streams and discovering new things as I go along. One of the new things I found was the <code>peek()</code> function. Almost everything I've read on peek says it should be used to debug your Streams.</p>\n\n<p>What if I had a Stream where each Account has a username, password field and a login() and loggedIn() method.</p>\n\n<p>I also have</p>\n\n<pre><code>Consumer&lt;Account&gt; login = account -&gt; account.login();\n</code></pre>\n\n<p>and</p>\n\n<pre><code>Predicate&lt;Account&gt; loggedIn = account -&gt; account.loggedIn();\n</code></pre>\n\n<p>Why would this be so bad?</p>\n\n<pre><code>List&lt;Account&gt; accounts; //assume it's been setup\nList&lt;Account&gt; loggedInAccount = \naccounts.stream()\n    .peek(login)\n    .filter(loggedIn)\n    .collect(Collectors.toList());\n</code></pre>\n\n<p>Now as far as I can tell this does exactly what it's intended to do. It;</p>\n\n<ul>\n<li>Takes a list of accounts</li>\n<li>Tries to log in to each account</li>\n<li>Filters out any account which aren't logged in</li>\n<li>Collects the logged in accounts into a new list</li>\n</ul>\n\n<p>What is the downside of doing something like this? Any reason I shouldn't proceed? Lastly, if not this solution then what?</p>\n\n<p>The original version of this used the .filter() method as follows;</p>\n\n<pre><code>.filter(account -&gt; {\n        account.login();\n        return account.loggedIn();\n    })\n</code></pre>\n", "title": "In Java streams is peek really only for debugging?", "tags": ["java", "java-8", "java-stream", "peek"], "link": "http://stackoverflow.com/questions/33635717/in-java-streams-is-peek-really-only-for-debugging", "post_type": "question", "question_id": 33635717}, {"body": "<p><code>a &lt; b</code> and <code>a - b &lt; 0</code> can mean two different things. Consider the following code:</p>\n\n<pre><code>int a = Integer.MAX_VALUE;\nint b = Integer.MIN_VALUE;\nif (a &lt; b) {\n    System.out.println(\"a &lt; b\");\n}\nif (a - b &lt; 0) {\n    System.out.println(\"a - b &lt; 0\");\n}\n</code></pre>\n\n<p>When run, this will only print <code>a - b &lt; 0</code>. What happens is that <code>a &lt; b</code> is clearly false, but <code>a - b</code> overflows and becomes <code>-1</code>, which is negative.</p>\n\n<p>Now, having said that, consider that the array has a length that is really close to <code>Integer.MAX_VALUE</code>. The code in <code>ArrayList</code> goes like this:</p>\n\n<pre><code>int oldCapacity = elementData.length;\nint newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);\nif (newCapacity - minCapacity &lt; 0)\n    newCapacity = minCapacity;\nif (newCapacity - MAX_ARRAY_SIZE &gt; 0)\n    newCapacity = hugeCapacity(minCapacity);\n</code></pre>\n\n<p><code>oldCapacity</code> is really close to <code>Integer.MAX_VALUE</code> so <code>newCapacity</code> (which is <code>oldCapacity + 0.5 * oldCapacity</code>) might overflow and become <code>Integer.MIN_VALUE</code> (i.e. negative). Then, subtracting <code>minCapacity</code> <em>underflows</em> back into a positive number.</p>\n\n<p>This check ensures that the <code>if</code> is not executed. If the code were written as <code>if (newCapacity &lt; minCapacity)</code>, it would be <code>true</code> in this case (since <code>newCapacity</code> is negative) so the <code>newCapacity</code> would be forced to <code>minCapacity</code> regardless of the <code>oldCapacity</code>.</p>\n\n<p>This overflow case is handled by the next if. When <code>newCapacity</code> has overflowed, this will be <code>true</code>: <code>MAX_ARRAY_SIZE</code> is defined as <code>Integer.MAX_VALUE - 8</code> and <code>Integer.MIN_VALUE - (Integer.MAX_VALUE - 8) &gt; 0</code> is <code>true</code>. The <code>newCapacity</code> is therefore rightly handled: <code>hugeCapacity</code> method returns <code>MAX_ARRAY_SIZE</code> or <code>Integer.MAX_VALUE</code>.</p>\n\n<p>NB: this is what the <code>// overflow-conscious code</code> comment in this method is saying.</p>\n", "title": "Difference between if (a - b &lt; 0) and if (a &lt; b)", "tags": ["java", "if-statement", "arraylist"], "link": "http://stackoverflow.com/questions/33147339/difference-between-if-a-b-0-and-if-a-b/33147610#33147610", "post_type": "answer", "question_id": 33147339, "answer_id": 33147610}, {"body": "<p>I found <a href=\"http://mail.openjdk.java.net/pipermail/core-libs-dev/2010-March/003736.html\">this explanation</a>:</p>\n\n<blockquote>\n  <p>On Tue, Mar 9, 2010 at 03:02, Kevin L. Stern  wrote: <br/></p>\n  \n  <blockquote>\n    <p>I did a quick search and it appears that Java is indeed two's complement\n    based. Nonetheless, please allow me to point out that, in general, this\n    type of code worries me since I fully expect that at some point someone will\n    come along and do exactly what Dmytro suggested; that is, someone will\n    change:</p>\n\n<pre><code>if (a - b &gt; 0)\n</code></pre>\n    \n    <p>to</p>\n\n<pre><code>if (a &gt; b)\n</code></pre>\n    \n    <p>and the entire ship will sink. I, personally, like to avoid obscurities\n    such as making integer overflow an essential basis for my algorithm unless\n    there is a good reason to do so. I would, in general, prefer to avoid\n    overflow altogether and to make the overflow scenario more explicit:</p>\n\n<pre><code>if (oldCapacity &gt; RESIZE_OVERFLOW_THRESHOLD) {\n   // Do something\n} else {\n  // Do something else\n}\n</code></pre>\n  </blockquote>\n  \n  <p>It's a good point.</p>\n  \n  <p>In <code>ArrayList</code> we cannot do this (or at least not compatibly), because\n  <code>ensureCapacity</code> is a public API and effectively already accepts\n  negative numbers as requests for a positive capacity that cannot be\n  satisfied.</p>\n  \n  <p>The current API is used like this:</p>\n\n<pre><code>int newcount = count + len;\nensureCapacity(newcount);\n</code></pre>\n  \n  <p>If you want to avoid overflow, you would need to change to something\n  less natural like</p>\n\n<pre><code>ensureCapacity(count, len);\nint newcount = count + len;\n</code></pre>\n  \n  <p>Anyway, I'm keeping the overflow-conscious code, but adding more\n  warning comments, and \"out-lining\" huge array creation so that\n  <code>ArrayList</code>'s code now looks like:</p>\n\n<pre><code>/**\n * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if\n * necessary, to ensure that it can hold at least the number of elements\n * specified by the minimum capacity argument.\n *\n * @param minCapacity the desired minimum capacity\n */\npublic void ensureCapacity(int minCapacity) {\n    modCount++;\n\n    // Overflow-conscious code\n    if (minCapacity - elementData.length &gt; 0)\n        grow(minCapacity);\n}\n\n/**\n * The maximum size of array to allocate.\n * Some VMs reserve some header words in an array.\n * Attempts to allocate larger arrays may result in\n * OutOfMemoryError: Requested array size exceeds VM limit\n */\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n/**\n * Increases the capacity to ensure that it can hold at least the\n * number of elements specified by the minimum capacity argument.\n *\n * @param minCapacity the desired minimum capacity\n */\nprivate void grow(int minCapacity) {\n    // Overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);\n    if (newCapacity - minCapacity &lt; 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)\n        newCapacity = hugeCapacity(minCapacity);\n\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n\nprivate int hugeCapacity(int minCapacity) {\n    if (minCapacity &lt; 0) // overflow\n        throw new OutOfMemoryError();\n    return (minCapacity &gt; MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n}\n</code></pre>\n  \n  <p>Webrev regenerated.</p>\n  \n  <p>Martin</p>\n</blockquote>\n\n<p>In Java 6, if you use the API as:</p>\n\n<pre><code>int newcount = count + len;\nensureCapacity(newcount);\n</code></pre>\n\n<p>And <code>newCount</code> overflows (this becomes negative), <code>if (minCapacity &gt; oldCapacity)</code> will return false and you may mistakenly assume that the <code>ArrayList</code> was increased by <code>len</code>.</p>\n", "title": "Difference between if (a - b &lt; 0) and if (a &lt; b)", "tags": ["java", "if-statement", "arraylist"], "link": "http://stackoverflow.com/questions/33147339/difference-between-if-a-b-0-and-if-a-b/33147762#33147762", "post_type": "answer", "question_id": 33147339, "answer_id": 33147762}, {"body": "<p>Looking at the code:</p>\n\n<pre><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);\n</code></pre>\n\n<p>If <code>oldCapacity</code> is quite large, this will overflow, and <code>newCapacity</code> will be a negative number. A comparison like <code>newCapacity &lt; oldCapacity</code> will incorrectly evaluate <code>true</code> and the <code>ArrayList</code> will fail to grow.</p>\n\n<p>Instead, the code as written (<code>newCapacity - minCapacity &lt; 0</code> returns false) will allow the negative value of <code>newCapacity</code> to be further evaluated in the next line, resulting in recalculating <code>newCapacity</code> by invoking <code>hugeCapacity</code> (<code>newCapacity = hugeCapacity(minCapacity);</code>) to allow for the <code>ArrayList</code> to grow up to <code>MAX_ARRAY_SIZE</code>.</p>\n\n<p>This is what the <code>// overflow-conscious code</code> comment is trying to communicate, though rather obliquely.</p>\n\n<p>So, bottom line, the new comparison protects against allocating an <code>ArrayList</code> larger than the predefined <code>MAX_ARRAY_SIZE</code> while allowing it to grow right up to that limit if needed.</p>\n", "title": "Difference between if (a - b &lt; 0) and if (a &lt; b)", "tags": ["java", "if-statement", "arraylist"], "link": "http://stackoverflow.com/questions/33147339/difference-between-if-a-b-0-and-if-a-b/33148103#33148103", "post_type": "answer", "question_id": 33147339, "answer_id": 33148103}, {"body": "<p>Any lambda which could be accepted as a <code>Supplier&lt;T&gt;</code> can also be accepted as a <code>ThrowingSupplier&lt;T&gt;</code>. The following compiles:</p>\n\n<pre><code>public static interface ThrowingSupplier&lt;T&gt;{\n    public T get() throws Exception;\n}\n\npublic static &lt;T&gt; void foo(ThrowingSupplier&lt;T&gt; supplier) {\n\n}\n\npublic static String getAString(){\n    return \"Hello\";\n}\n\npublic static String getAnotherString() throws Exception{\n    return \"World\";\n}\n\npublic static void main(String[] args) {\n    foo(()-&gt;getAString());\n    foo(()-&gt;getAnotherString());\n} \n</code></pre>\n\n<p>Given the above, you probably don't need this, but if <code>foo</code> <em>must</em> accept a non-throwing <code>Supplier&lt;T&gt;</code>, you can always wrap the Exception-throwing method in a method which launders it into an unchecked Exception:</p>\n\n<pre><code>public static &lt;T&gt; void foo(Supplier&lt;T&gt; supplier) {\n\n}\n\npublic static String getAString(){\n    return \"Hello\";\n}\n\npublic static String getAnotherString() throws Exception{\n    return \"World\";\n}\n\npublic static String getAnotherStringUnchecked(){\n    try{\n        return getAnotherString();\n    } catch(Exception e){\n        throw new RuntimeException(\"Error getting another string\",e);\n    }\n}   \n\npublic static void main(String[] args) throws Exception{\n    foo(()-&gt;getAString());\n    foo(()-&gt;getAnotherStringUnchecked());\n}\n</code></pre>\n", "title": "Why Doesn&#39;t Java 8 Type Inference Consider Exceptions Thrown by Lambdas in Overload Selection?", "tags": ["java", "exception", "lambda", "java-8", "type-inference"], "link": "http://stackoverflow.com/questions/32323081/why-doesnt-java-8-type-inference-consider-exceptions-thrown-by-lambdas-in-overl/32323305#32323305", "post_type": "answer", "question_id": 32323081, "answer_id": 32323305}, {"body": "<p>First of all, you don' have to overload :D - overloading is never a necessity; use 2 different method names, e.g. <code>foo</code> and <code>fooX</code></p>\n\n<p>Secondly, I don't see why you need 2 methods here. If you want to handle checked and unchecked exceptions differently, it can be done at runtime. To achieve \"exception transparency\", you can do</p>\n\n<pre><code>interface SupplierX&lt;T, X extends Throwable&gt;\n{\n    T get() throws X;\n}\n\n&lt;T, X extends Throwable&gt; void foo(Supplier&lt;T, X&gt; supplier)  throws X { .. }\n\n\nfoo( ()-&gt;\"\" );  // throws RuntimeException\n\nfoo( ()-&gt;{ throw new IOException(); } );  // X=IOException\n</code></pre>\n\n<p>Finally, disambiguity can be achieved throw lambda return type; the compiler uses the return type as if using an argument type for choosing the most specific method. This gives us the idea to wrap the value together with the exception type, as <code>Result&lt;T,X&gt;</code>, a \"monad\" as they say. </p>\n\n<pre><code>interface Result&lt;T, X extends Throwable&gt;\n{\n    T get() throws X;\n}\n\n// error type embedded in return type, not in `throws` clause\n\nstatic Result&lt;String,        Exception&gt; m1(){ return ()-&gt;{ throw new Exception();};  }\nstatic Result&lt;String, RuntimeException&gt; m2(){ return ()-&gt;{ return \"str\";         };  }\n\n  // better to have some factory method, e.g. return Result.success(\"str\");\n\npublic static void main(String[] args)\n{\n    foo(()-&gt;m1());  // foo#2 is not applicable\n    foo(()-&gt;m2());  // both applicable; foo#2 is more specific\n}\n\n\n\ninterface S1&lt;T&gt; { T get(); }  \n\nstatic &lt;T&gt; void foo(S1&lt;Result&lt;T, ? extends        Exception&gt;&gt; s)\n{\n    System.out.println(\"s1\");}\n}\n\n\ninterface S2&lt;T&gt; { T get(); }  // can't have two foo(S1) due to erasure\n\nstatic &lt;T&gt; void foo(S2&lt;Result&lt;T, ? extends RuntimeException&gt;&gt; s)\n{\n    System.out.println(\"s2\");\n}\n</code></pre>\n", "title": "Why Doesn&#39;t Java 8 Type Inference Consider Exceptions Thrown by Lambdas in Overload Selection?", "tags": ["java", "exception", "lambda", "java-8", "type-inference"], "link": "http://stackoverflow.com/questions/32323081/why-doesnt-java-8-type-inference-consider-exceptions-thrown-by-lambdas-in-overl/32323641#32323641", "post_type": "answer", "question_id": 32323081, "answer_id": 32323641}, {"body": "<p>The chief difference is that an <code>if</code> <code>else</code> block is a <em>statement</em> whereas the ternary (more often known as the <em>conditional</em> operator in Java) is an <em>expression</em>.</p>\n\n<p>A <em>statement</em> can do things like <code>return</code> to the caller on some of the control paths. An <em>expression</em> can be used in an assignment:</p>\n\n<p><code>int n = condition ? 3 : 2;</code></p>\n\n<p>So the two expressions in the ternary after the condition need to be coercable to the same type. This can cause some odd effects in Java particularly with auto-boxing and automatic reference casting - this is what the comment in your posted code is referring to. The coercion of the expressions in your case would be to a <code>java.lang.reflect.Executable</code> type (as that's the <em>most specialised type</em>) and that does not exist in older versions of Java.</p>\n\n<p>Stylistically you should use an <code>if</code> <code>else</code> block if the code is statement-like, and a ternary if it's expression-like.</p>\n\n<p>Of course, you can make an <code>if</code> <code>else</code> block behave like an expression if you use a lambda function.</p>\n", "title": "Java ternary operator vs if/else in &lt;JDK8 compatibility", "tags": ["java", "java-8", "ternary-operator"], "link": "http://stackoverflow.com/questions/32475166/java-ternary-operator-vs-if-else-in-jdk8-compatibility/32475290#32475290", "post_type": "answer", "question_id": 32475166, "answer_id": 32475290}, {"body": "<p>When you think about the type of the operands, the problem becomes more apparent:</p>\n\n<pre><code>this.method != null ? this.method : this.constructor\n</code></pre>\n\n<p>has as type the most specialized common type of both the operands, i.e. the most specialized type common to both <code>this.method</code> and <code>this.constructor</code>. </p>\n\n<p>In Java 7 this is <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Member.html\"><code>java.lang.reflect.Member</code></a>, however the Java 8 class library introduces a new type <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Executable.html\"><code>java.lang.reflect.Executable</code></a> which is more specialized than the generic <code>Member</code>. Hence with a Java 8 class library the result type of the ternary expression is <code>Executable</code> rather than <code>Member</code>.</p>\n\n<p>Some (pre-release) versions of the Java 8 compiler seem to have produced an explicit reference to <code>Executable</code> inside generated code when compiling the ternary operator. This would trigger a class load, and thus in turn a <code>ClassNotFoundException</code> at runtime when running with a class library &lt; JDK 8, because <code>Executable</code> only exists for JDK \u2265 8.</p>\n\n<p>As noted by Tagir Valeev in <a href=\"http://stackoverflow.com/questions/32475166/java-ternary-operator-vs-if-else-in-jdk8-compatibility/32476850#answer-32477696\">this answer</a>, this is actually a bug in pre-release versions of JDK 8 and has since been fixed, so both the <code>if-else</code> workaround and the explanatory comment are now obsolete.</p>\n\n<p><strong>Additional note:</strong> One might come to the conclusion that this compiler bug was present before Java 8. However, the byte code generated for the ternary by OpenJDK 7 is the same as the byte code generated by OpenJDK 8. In fact, the type of the expression goes completely unmentioned at runtime,  the code is really only test, branch, load, return without any additional checks going on. So rest assured that this is not a problem (anymore) and indeed seems to have been a temporary problem during development of Java 8.</p>\n", "title": "Java ternary operator vs if/else in &lt;JDK8 compatibility", "tags": ["java", "java-8", "ternary-operator"], "link": "http://stackoverflow.com/questions/32475166/java-ternary-operator-vs-if-else-in-jdk8-compatibility/32476850#32476850", "post_type": "answer", "question_id": 32475166, "answer_id": 32476850}, {"body": "<p>An <code>IntFunction&lt;R&gt;</code> is a function <code>int -&gt; R</code>. An <code>IntUnaryOperator</code> is a function <code>int -&gt; int</code>.</p>\n\n<p>Thus an <code>IntFunction&lt;IntUnaryOperator&gt;</code> is a function that takes an <code>int</code> as parameter and return a function that takes an <code>int</code> as parameter and return an <code>int</code>.</p>\n\n<pre><code>a -&gt; b -&gt; a + b;\n^    |         |\n|     ---------\n|         ^\n|         |\n|         The IntUnaryOperator (that takes an int, b) and return an int (the sum of a and b)\n|\nThe parameter you give to the IntFunction\n</code></pre>\n\n<p>Maybe it is more clear if you use anonymous classes to \"decompose\" the lambda:</p>\n\n<pre><code>IntFunction&lt;IntUnaryOperator&gt; add = new IntFunction&lt;IntUnaryOperator&gt;() {\n    @Override\n    public IntUnaryOperator apply(int a) {\n        return new IntUnaryOperator() {\n            @Override\n            public int applyAsInt(int b) {\n                return a + b;\n            }\n        };\n    }\n};\n</code></pre>\n", "title": "What does lambda with 2 arrows mean in Java 8?", "tags": ["java", "lambda", "java-8", "currying"], "link": "http://stackoverflow.com/questions/32820722/what-does-lambda-with-2-arrows-mean-in-java-8/32820940#32820940", "post_type": "answer", "question_id": 32820722, "answer_id": 32820940}, {"body": "<p>Let's rewrite that lambda expression with parentheses to make it more clear:</p>\n\n<pre><code>IntFunction&lt;IntUnaryOperator&gt; curriedAdd = a -&gt; (b -&gt; (a + b));\n</code></pre>\n\n<p>So we are declaring a function taking an <code>int</code> which returns a <code>Function</code>. More specifically, the function returned takes an <code>int</code> and returns an <code>int</code> (the sum of the two elements): this can be represented as an <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/function/IntUnaryOperator.html\"><code>IntUnaryOperator</code></a>.</p>\n\n<p>Therefore, <code>curriedAdd</code> is a function taking an <code>int</code> and returning an <code>IntUnaryOperator</code>, so it can be represented as <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/function/IntFunction.html\"><code>IntFunction&lt;IntUnaryOperator&gt;</code></a>.</p>\n", "title": "What does lambda with 2 arrows mean in Java 8?", "tags": ["java", "lambda", "java-8", "currying"], "link": "http://stackoverflow.com/questions/32820722/what-does-lambda-with-2-arrows-mean-in-java-8/32820984#32820984", "post_type": "answer", "question_id": 32820722, "answer_id": 32820984}, {"body": "<p>If you look at <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/function/IntFunction.html\" rel=\"nofollow\"><code>IntFunction</code></a> it might become clearer: <code>IntFunction&lt;R&gt;</code> is a <code>FunctionalInterface</code>. It represents a function that takes an <code>int</code> and returns a value of type <code>R</code>.</p>\n\n<p>In this case, the return type <code>R</code> is also a <code>FunctionalInterface</code>, namely an <code>IntUnaryOperator</code>. So the <em>first</em> (outer) function itself returns a function. </p>\n\n<p>In this case: When applied to an <code>int</code>, <code>curriedAdd</code> is supposed to return a function that again takes an <code>int</code> (and returns again <code>int</code>, because that's what <code>IntUnaryOperator</code> does).</p>\n\n<p>In functional programming it is common to write the type of a function as <code>param -&gt; return_value</code> and you see exactly that here. So the type of <code>curriedAdd</code> is <code>int -&gt; int -&gt; int</code> (or <code>int -&gt; (int -&gt; int)</code> if you like that better).</p>\n\n<p>Java 8's lambda syntax goes along with this. To define such a function, you write</p>\n\n<pre><code>a -&gt; b -&gt; a + b\n</code></pre>\n\n<p>which is very much similar to actual lambda calculus:</p>\n\n<pre><code>\u03bba \u03bbb a + b\n</code></pre>\n\n<p><code>\u03bbb a + b</code> is a function that takes a single parameter <code>b</code> and returns a value (the sum). <code>\u03bba \u03bbb a + b</code> is a function that accepts a single parameter <code>a</code> and returns another function of a single parameter. <code>\u03bba \u03bbb a + b</code> returns <code>\u03bbb a + b</code> with <code>a</code> set to the parameter value.</p>\n", "title": "What does lambda with 2 arrows mean in Java 8?", "tags": ["java", "lambda", "java-8", "currying"], "link": "http://stackoverflow.com/questions/32820722/what-does-lambda-with-2-arrows-mean-in-java-8/32821016#32821016", "post_type": "answer", "question_id": 32820722, "answer_id": 32821016}, {"body": "<p>This is possible using the <code>mergeFunction</code> parameter of <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-\"><code>Collectors.toMap(keyMapper, valueMapper, mergeFunction)</code></a>:</p>\n\n<pre><code>Map&lt;String, String&gt; phoneBook = \n    people.stream()\n          .collect(Collectors.toMap(\n             Person::getName,\n             Person::getAddress,\n             (address1, address2) -&gt; {\n                 System.out.println(\"duplicate key found!\");\n                 return address1;\n             }\n          ));\n</code></pre>\n\n<p><code>mergeFunction</code> is a function that operates on two values associated with the same key. <code>adress1</code> corresponds to the first address that was encountered when collecting elements and <code>adress2</code> corresponds to the second address encountered: this lambda just tells to keep the first address and ignores the second.</p>\n", "title": "Ignore duplicates when producing map using streams", "tags": ["java", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/32312876/ignore-duplicates-when-producing-map-using-streams/32313069#32313069", "post_type": "answer", "question_id": 32312876, "answer_id": 32313069}, {"body": "<p>There's a long list of things that have been changed in Hibernate 5:</p>\n\n<ol>\n<li><p>New bootstrap API so we can <a href=\"http://vladmihalcea.com/2015/11/26/how-to-bootstrap-hibernate-without-the-persistence-xml-file/\">bootstrap a JPA environment programmatically without the need of a <code>persistence.xml</code> file</a>.</p></li>\n<li><p>Starting in 5.0 Hibernate Spatial is part of the Hibernate project so we can handle GIS data too.</p></li>\n<li><p>The Java 8 Date and Time types are supported in domain model mappings. The mapping between the standard SQL Date/Time types and the supported Java 8 Date/Time class types looks as follows;</p>\n\n<ul>\n<li>DATE: <code>java.time.LocalDate</code></li>\n<li>TIME: <code>java.time.LocalTime</code>, <code>java.time.OffsetTime</code></li>\n<li>TIMESTAMP: <code>java.time.Instant</code>, <code>java.time.LocalDateTime</code>, <code>java.time.OffsetDateTime</code> and <code>java.time.ZonedDateTime</code></li>\n</ul></li>\n<li><p>The bytecode enhancement mechanism was redesigned from scratch, and Hibernate features both a Maven and a Gradle plugin. There are three main aspects which we can enhance with bytecode instrumentation:</p>\n\n<ul>\n<li><p>Lazy initialization: Fields can be declared as <code>LAZY</code> and they will be fetched only when being accessed for the first time.</p></li>\n<li><p>Dirty checking: Entities are enhanced so that they can keep track of all the properties that get changed after being loaded in a Persistence Context.</p></li>\n<li><p>Bidirectional associations: It's possible to synchronize both sides of a bidirectional association automatically, even if the developer only updates a single side.</p></li>\n</ul></li>\n<li><p>Hibernate's native APIs (<code>Session</code>, etc) have been updated to use generic typed. No need to cast when fetching entities.</p></li>\n<li><p>Hibernate 5.0 expends this to a broader set of types (e.g. <code>UUID</code>).</p></li>\n<li><p>Second-level cache by reference. This feature enables direct storage of entity references into the second level cache for immutable entities.</p></li>\n<li><p>Starting with Hibernate 5.0, we have a completely <a href=\"http://docs.jboss.org/hibernate/orm/5.0/userguide/html_single/Hibernate_User_Guide.html\">new User Guide</a> that was written from scratch.</p></li>\n</ol>\n", "title": "What&#39;s new in Hibernate 5?", "tags": ["java", "hibernate", "jpa", "orm", "hibernate-5.x"], "link": "http://stackoverflow.com/questions/31965179/whats-new-in-hibernate-5/35427268#35427268", "post_type": "answer", "question_id": 31965179, "answer_id": 35427268}, {"body": "<p><code>+</code> is implemented in java <em>compilers</em>. The compiler <em>replaces</em> <code>String</code> + <code>String</code> with either <em>compile time</em> constants or <code>StringBuilder</code> code. Note that this applies to <em>primitives</em> too. i.e, <code>int  i=1+2</code> could get directly replaced to <code>int i=3</code> during compilation itself.</p>\n", "title": "Where is `+` implemented for Strings in the Java source code?", "tags": ["java", "string", "operators", "string-concatenation"], "link": "http://stackoverflow.com/questions/32714194/where-is-implemented-for-strings-in-the-java-source-code/32714222#32714222", "post_type": "answer", "question_id": 32714194, "answer_id": 32714222}, {"body": "<p>While currently most of Java compilers using <code>StringBuilder</code> chain, it's not specified that it should be always in this way. In particular there's a <a href=\"http://openjdk.java.net/jeps/8085796\">proposal</a> to change this drastically in Java-9 replacing with single <code>invokedynamic</code> call and introduce new metafactory which will generate an appropriate <code>MethodHandle</code> in runtime to perform concatenation.</p>\n", "title": "Where is `+` implemented for Strings in the Java source code?", "tags": ["java", "string", "operators", "string-concatenation"], "link": "http://stackoverflow.com/questions/32714194/where-is-implemented-for-strings-in-the-java-source-code/32714537#32714537", "post_type": "answer", "question_id": 32714194, "answer_id": 32714537}, {"body": "<p>Note that <code>a</code>. <code>b</code> and <code>c</code> are instances of primitive wrapper classes (such as Integer, Double, etc...). These classes are final and cannot be extended, so you can't override their <code>equals</code> implementation. </p>\n\n<p>Therefore <code>a.equals(a)</code> will always return true, since those classes implement <code>equals</code> properly.</p>\n", "title": "Can .equals be overridden such that a.equals(a) returns false?", "tags": ["java", "equals"], "link": "http://stackoverflow.com/questions/32175145/can-equals-be-overridden-such-that-a-equalsa-returns-false/32175175#32175175", "post_type": "answer", "question_id": 32175145, "answer_id": 32175175}, {"body": "<p>Since <a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals%28java.lang.Object%29\"><code>equals(...)</code></a> is not a final method of <code>Object</code>, yes, it is very well be possible <strong>in a different situation</strong>.</p>\n\n<pre><code>@Override\npublic boolean equals(Object obj) {\n    return false;\n}\n</code></pre>\n\n<p>This question, however, specifically says that these are primitive wrappers (e.g. <a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html\">Integer</a>, <a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/Boolean.html\">Boolean</a>, etc.) and since these classes are final, you cannot extend them, thus <code>a.equals(a)</code> will always return <code>true</code>.</p>\n", "title": "Can .equals be overridden such that a.equals(a) returns false?", "tags": ["java", "equals"], "link": "http://stackoverflow.com/questions/32175145/can-equals-be-overridden-such-that-a-equalsa-returns-false/32175224#32175224", "post_type": "answer", "question_id": 32175145, "answer_id": 32175224}, {"body": "<p>The other answers have already answered your question - no, this is not possible with the Java's primitive wrapper classes.</p>\n\n<p>I'll try to address the \"question behind the question\": Is this possible with other classes?</p>\n\n<blockquote>\n  <p>[...] in the deep dark abyss of overriding madness, is it possible to\n  create a situation where a.equals(a) returns false? I feel like this\n  would make Aristotle angry...</p>\n</blockquote>\n\n<p>This is actually a good question, and the answer is: Yes, it is possible to create such a situation, and yes, it would make Aristotle angry. Actually, I don't know if it would make Aristotle angry, not having known him, but it will certainly cause a lot of grief for whoever has to work with the code.</p>\n\n<p>The thing is: There is a <em>contract</em> associated with <code>Object.equals()</code>:</p>\n\n<blockquote>\n  <p>The equals method implements an equivalence relation on non-null\n  object references:</p>\n  \n  <p>[...]</p>\n  \n  <p>It is reflexive: for any non-null reference value x, x.equals(x) should return true. </p>\n</blockquote>\n\n<p><em><a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-\">Javadocs for Object.equals</a></em></p>\n\n<p>Yes, when creating your own class, you can violate this contract. There is (unfortunately) nothing in the compiler or runtime stopping you.</p>\n\n<p>However, a lot of code relies on this contract, so if you violate it, any code that uses <code>equals</code> will probably fail in mysterious ways.</p>\n\n<p>One example: Java's own Collection classes (<code>java.util.Collection</code> and friends) rely on <code>equals</code>. If an instance of a class that does not correctly implement <code>equals</code> is put into a collection, weird things happen, such as the collection sometimes containing the instance and sometimes not.</p>\n", "title": "Can .equals be overridden such that a.equals(a) returns false?", "tags": ["java", "equals"], "link": "http://stackoverflow.com/questions/32175145/can-equals-be-overridden-such-that-a-equalsa-returns-false/32177563#32177563", "post_type": "answer", "question_id": 32175145, "answer_id": 32177563}, {"body": "<h1>Integer a.equals( a ) can return false</h1>\n\n<p>But you have to be really evil and use reflections and Multithreading:</p>\n\n<p>If you run this code, there is a chance that a racing condition can change the internal Value of <code>myInt</code> while the comparision takes place. If you want to simulate this condition, just set a breakpoint inside of <code>Integer.intValue()</code> run the code in debug and hit continue. This will create a delay which creates the race condition artificially and the console will return false.</p>\n\n<pre><code>class IntegerEqualsTest\n{\n    public static void main( final String[] args )\n    {\n        final Integer myInt = new Integer( 420 );\n\n        new Thread() {\n            public void run() {\n                try {\n                    final Field f = Integer.class.getDeclaredField( \"value\" );\n                    f.setAccessible( true );\n                    f.setInt( myInt, 100 );\n                } catch( final Exception e ) {}\n            }; }.start();\n\n        System.out.println( myInt.equals( myInt ) );\n    }\n}\n</code></pre>\n", "title": "Can .equals be overridden such that a.equals(a) returns false?", "tags": ["java", "equals"], "link": "http://stackoverflow.com/questions/32175145/can-equals-be-overridden-such-that-a-equalsa-returns-false/32182250#32182250", "post_type": "answer", "question_id": 32175145, "answer_id": 32182250}, {"body": "<p>You just changed the <code>String</code> of <strong><em>String constant pool</em></strong> <code>Mario</code> to <code>Luigi</code> which was referenced by multiple <code>String</code>s, so every referencing <em>literal</em> <code>Mario</code> is now <code>Luigi</code>.</p>\n\n<pre><code>Field stringValue = String.class.getDeclaredField(\"value\");\n</code></pre>\n\n<p>You have fetched the <code>char[]</code> named <code>value</code> field from class <code>String</code></p>\n\n<pre><code>stringValue.setAccessible(true);\n</code></pre>\n\n<p>Make it accessible.</p>\n\n<pre><code>stringValue.set(original, \"Luigi\".toCharArray());\n</code></pre>\n\n<p>You changed <code>original</code> <code>String</code>  field to <code>Luigi</code>. But original is <code>Mario</code> the <code>String</code> <em>literal</em> and literal belongs to the <code>String</code> pool and all are <em>interned</em>.  Which means all the literals which has same content refers to the same memory address.</p>\n\n<pre><code>String a = \"Mario\";//Created in String pool\nString b = \"Mario\";//Refers to the same Mario of String pool\na == b//TRUE\n//You changed 'a' to Luigi and 'b' don't know that\n//'a' has been internally changed and \n//'b' still refers to the same address.\n</code></pre>\n\n<p>Basically you have changed the Mario of <code>String</code> pool which got <em>reflected</em> in all the referencing fields. If you create <code>String</code> <code>Object</code> (i.e. <code>new String(\"Mario\")</code>) instead of literal you will not face this behavior because than you will have two different <code>Mario</code>s . </p>\n", "title": "How does this Java code snippet work? (String pool and reflection)", "tags": ["java", "string", "reflection", "string-pool"], "link": "http://stackoverflow.com/questions/32623834/how-does-this-java-code-snippet-work-string-pool-and-reflection/32624143#32624143", "post_type": "answer", "question_id": 32623834, "answer_id": 32624143}, {"body": "<p>Another related point: you can make use of the constant pool to improve the performance of string comparisons in some circumstances, by using the <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#intern--\" rel=\"nofollow\"><code>String.intern()</code></a> method.</p>\n\n<p>That method returns the instance of String with the same contents as the String on which it is invoked from the String constants pool, adding it it if is not yet present. In other words, after using <code>intern()</code>, all Strings with the same contents are guaranteed to be the same String instance as each other and as any String constants with those contents, meaning you can then use the equals operator (<code>==</code>) on them.</p>\n\n<p>This is just an example which is not very useful on its own, but it illustrates the point:</p>\n\n<pre class=\"lang-java prettyprint-override\"><code>class Key {\n    Key(String keyComponent) {\n        this.keyComponent = keyComponent.intern();\n    }\n\n    public boolean equals(Object o) {\n        // String comparison using the equals operator allowed due to the\n        // intern() in the constructor, which guarantees that all values\n        // of keyComponent with the same content will refer to the same\n        // instance of String:\n        return (o instanceof Key) &amp;&amp; (keyComponent == ((Key) o).keyComponent);\n    }\n\n    public int hashCode() {\n        return keyComponent.hashCode();\n    }\n\n    boolean isSpecialCase() {\n        // String comparison using equals operator valid due to use of\n        // intern() in constructor, which guarantees that any keyComponent\n        // with the same contents as the SPECIAL_CASE constant will\n        // refer to the same instance of String:\n        return keyComponent == SPECIAL_CASE;\n    }\n\n    private final String keyComponent;\n\n    private static final String SPECIAL_CASE = \"SpecialCase\";\n}\n</code></pre>\n\n<p>This little trick isn't worth designing your code around, but it is worth keeping in mind for the day when you notice a little more speed could be eked out of some bit of performance sensitive code by using the <code>==</code> operator on a string with judicious use of <code>intern()</code>.</p>\n", "title": "How does this Java code snippet work? (String pool and reflection)", "tags": ["java", "string", "reflection", "string-pool"], "link": "http://stackoverflow.com/questions/32623834/how-does-this-java-code-snippet-work-string-pool-and-reflection/32652449#32652449", "post_type": "answer", "question_id": 32623834, "answer_id": 32652449}, {"body": "<p>No, you appear to have a legit bug. The bug presents in JDK7 but fixed in JDK8. Your values are correctly representable as <code>BigDecimal</code>s, and should behave correctly, but don't.</p>\n\n<p>Tracing through <a href=\"http://www.docjar.com/html/api/java/math/BigDecimal.java.html#2571\">the source code of <code>BigDecimal</code></a>, on line 2585, <code>this.precision()</code> is 1, and <code>this.scale</code> is <code>-2147483647</code>.  <code>this.precision() - this.scale</code> therefore overflows, and the following overflow is not handled correctly.</p>\n\n<p>This bug <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/rev/216a4b93cee8\">has been fixed</a> in JDK8 by <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/math/BigDecimal.java#BigDecimal.compareMagnitude%28java.math.BigDecimal%29\">doing the subtraction in <code>long</code> arithmetic</a>.</p>\n", "title": "Java BigDecimal Possible Overflow Bug", "tags": ["java", "bigdecimal"], "link": "http://stackoverflow.com/questions/31170459/java-bigdecimal-possible-overflow-bug/31170506#31170506", "post_type": "answer", "question_id": 31170459, "answer_id": 31170506}, {"body": "<p>In this sort of situation I would write</p>\n\n<pre><code>public Object getClone(SomeInterface a) throws TotallyFooException {\n    // Precondition: \"a\" should be null or should have a someMethod method that\n    // does not throw a SomeException.\n    if (a == null) {\n        throw new TotallyFooException() ; }\n    else {\n        try {\n            return a.someMethod(); }\n        catch (SomeException e) {\n            throw new IllegalArgumentException(e) ; } }\n}\n</code></pre>\n\n<p>Interestingly you say that the \"try statement will never fail\", but you still took the trouble to write a statement <code>e.printStackTrace();</code> that you claim will never be executed.  Why?</p>\n\n<p>Perhaps your belief is not that firmly held.  That is good (in my opinion), since your belief is not based on the code you wrote, but rather on the expectation that your client will not violate the precondition.  Better to program public methods defensively. </p>\n\n<p>By the way, your code won't compile for me.  You can't call <code>a.clone()</code> even if the type of <code>a</code> is <code>Cloneable</code>.  At least Eclipse's compiler says so. Expression <code>a.clone()</code> gives error</p>\n\n<blockquote>\n  <p>The method clone() is undefined for the type Cloneable</p>\n</blockquote>\n\n<p>What I would do for your specific case is</p>\n\n<pre><code>public Object getClone(PubliclyCloneable a) throws TotallyFooException {\n    if (a == null) {\n        throw new TotallyFooException(); }\n    else {\n        return a.clone(); }\n}\n</code></pre>\n\n<p>Where <code>PubliclyCloneable</code> is defined by</p>\n\n<pre><code>interface PubliclyCloneable {\n    public Object clone() ;\n}\n</code></pre>\n\n<p>Or, if you absolutely need the parameter type to be <code>Cloneable</code>, the following at least compiles.</p>\n\n<pre><code>public static Object getClone(Cloneable a) throws TotallyFooException {\n//  Precondition: \"a\" should be null or point to an object that can be cloned without\n// throwing any checked exception.\n    if (a == null) {\n        throw new TotallyFooException(); }\n    else {\n        try {\n            return a.getClass().getMethod(\"clone\").invoke(a) ; }\n        catch( IllegalAccessException e ) {\n            throw new AssertionError(null, e) ; }\n        catch( InvocationTargetException e ) {\n            Throwable t = e.getTargetException() ;\n            if( t instanceof Error ) {\n                // Unchecked exceptions are bubbled\n                throw (Error) t ; }\n            else if( t instanceof RuntimeException ) {\n                // Unchecked exceptions are bubbled\n                throw (RuntimeException) t ; }\n            else {\n                // Checked exceptions indicate a precondition violation.\n                throw new IllegalArgumentException(t) ; } }\n        catch( NoSuchMethodException e ) {\n            throw new AssertionError(null, e) ; } }\n}\n</code></pre>\n", "title": "Is having a return statement just to satisfy syntax bad practice?", "tags": ["java", "return", "try-catch"], "link": "http://stackoverflow.com/questions/33804394/is-having-a-return-statement-just-to-satisfy-syntax-bad-practice/33814549#33814549", "post_type": "answer", "question_id": 33804394, "answer_id": 33814549}, {"body": "<p>When returning <code>List</code>, you'll be promoting <em>program to an interface</em>, which is a very good practice. However, this approach has its limitation. For example, you cannot use some methods that are defined for <code>ArrayList</code> and don't exist in the <code>List</code> interface - See <a href=\"http://stackoverflow.com/questions/10328658/should-i-return-list-or-arraylist\">this answer</a> for details.</p>\n\n<p>I'm quoting the <a href=\"https://docs.oracle.com/javase/tutorial/collections/interoperability/api-design.html\">API Design</a> from the The Java\u2122 Tutorials:</p>\n\n<blockquote>\n  <p>... It's fine to return an object of <strong>any type</strong> that <em>implements</em> or <em>extends</em> one of the collection interfaces. This can be one of the interfaces or a special-purpose type that extends or implements one of these interfaces.</p>\n  \n  <p>.. In one sense, return values should have the opposite behavior of input parameters: It's <em>best</em> to return the <em>most specific applicable collection interface rather than the most general</em>. For example, if you're sure that you'll always return a <code>SortedMap</code>, you should give the relevant method the return type of <code>SortedMap</code> rather than <code>Map</code>. <code>SortedMap</code> instances are more time-consuming to build than ordinary <code>Map</code> instances and are also more powerful. Given that your module has already invested the time to build a <code>SortedMap</code>, it makes good sense to give the user access to its increased power. Furthermore, the user will be able to pass the returned object to methods that demand a <code>SortedMap</code>, as well as those that accept any <code>Map</code>.</p>\n</blockquote>\n\n<p>Since <code>ArrayList</code> is essentially an array, they are my first choice when I need to have a \"collection-array\". So if I want to convert enumeration to a list, my choice would be an array list.</p>\n\n<p>In any other cases, it's still valid to write:</p>\n\n<pre><code>List&lt;T&gt; list = Collections.list(e);\n</code></pre>\n", "title": "Why does Enumeration get converted to ArrayList and not List in java.utils?", "tags": ["java", "arraylist", "collections", "return-type", "utils"], "link": "http://stackoverflow.com/questions/32356762/why-does-enumeration-get-converted-to-arraylist-and-not-list-in-java-utils/32357142#32357142", "post_type": "answer", "question_id": 32356762, "answer_id": 32357142}, {"body": "<p><strong>Disclaimer: I am not a JDK author.</strong></p>\n\n<p>I agree that it's correct to write your <em>own code</em> to interfaces, but if you're going return a <strong>mutable</strong> collection to a third party, it's important to let the third party know what sort of <code>List</code> they're getting back.</p>\n\n<p><code>LinkedList</code> and <code>ArrayList</code> are very different, performance wise, for various operations. For example, removing the first element of an <code>ArrayList</code> is <code>O(n)</code>, but removing the first element of a <code>LinkedList</code> is <code>O(1)</code>.</p>\n\n<p>By fully specifying the return type, the JDK authors are <strong>communicating extra information</strong>, in unambiguous code, about what sort of object they're giving back to you, so you can write your code to use this method properly. If you really need a <code>LinkedList</code>, you know that you have to specify one here.</p>\n\n<p>Finally, the main reason to code to an interface over an implementation is if you think that the implementation will change. The JDK authors probably figure they are <em>never</em> going to change this method; it's never going to return a <code>LinkedList</code> or a <code>Collections.UnmodifiableList</code>. However, in most cases, you would probably still do:</p>\n\n<pre><code>List&lt;T&gt; list = Collections.list(enumeration);\n</code></pre>\n", "title": "Why does Enumeration get converted to ArrayList and not List in java.utils?", "tags": ["java", "arraylist", "collections", "return-type", "utils"], "link": "http://stackoverflow.com/questions/32356762/why-does-enumeration-get-converted-to-arraylist-and-not-list-in-java-utils/32357149#32357149", "post_type": "answer", "question_id": 32356762, "answer_id": 32357149}, {"body": "<p>There is a <strong>small</strong> overhead in calling methods var an interface rather than directly on an object.   </p>\n\n<p>This overhead is often no more than 1 or 2 processor instructions.     The overhead of calling a method is even lower if the JIT knows that the method is final.   This is not measurable for most code you and me right, but for the low level methods in java.utils may be used in some code where it is an issue.</p>\n\n<p>Also as has been pointed out in other answers, the concrete type of the object that is return (even when hidden behind an interface) effects the performance of code that uses it.    This change in performance can be very great, so such an extent that the calling software fails to work.</p>\n\n<p>Clearly the authors of <code>java.utils</code> have no way to know what all the software that calls Collections.list() does with the result and no way to re-test this software if they change the implantation of Collections.list().    <strong>Therefore they are not going to change the implantation of Collections.list() to return a different type of List, even if the type system allowed it!</strong></p>\n\n<p>When writing your own software, you (hopefully) have automated test that cover all your code and a good understand of how your code interrelates include know where performance is an issue.   Being able to make a change to a method, without having to change the callers is of great value while the design of the software is changing.</p>\n\n<p><strong>Therefore the two set of trade offs are very different.</strong></p>\n", "title": "Why does Enumeration get converted to ArrayList and not List in java.utils?", "tags": ["java", "arraylist", "collections", "return-type", "utils"], "link": "http://stackoverflow.com/questions/32356762/why-does-enumeration-get-converted-to-arraylist-and-not-list-in-java-utils/32370677#32370677", "post_type": "answer", "question_id": 32356762, "answer_id": 32370677}, {"body": "<p>I think that is because you usually write your functions to manipulate data, and then lift it to <code>Optional</code> using <code>map</code> and similar functions. This adds the default <code>Optional</code> behavior to it.\nOf course, there might be cases, when it is necessary to write your own auxilary function that works on <code>Optional</code>.</p>\n", "title": "Why should Java 8&#39;s Optional not be used in arguments", "tags": ["java", "java-8", "optional"], "link": "http://stackoverflow.com/questions/31922866/why-should-java-8s-optional-not-be-used-in-arguments/31922994#31922994", "post_type": "answer", "question_id": 31922866, "answer_id": 31922994}, {"body": "<p>I believe the reson of being is you have to first check whether or not Optional is null itself and then try to evaluate value it wraps. Too many unnecessary validations.</p>\n", "title": "Why should Java 8&#39;s Optional not be used in arguments", "tags": ["java", "java-8", "optional"], "link": "http://stackoverflow.com/questions/31922866/why-should-java-8s-optional-not-be-used-in-arguments/31923015#31923015", "post_type": "answer", "question_id": 31922866, "answer_id": 31923015}, {"body": "<p>The pattern with <code>Optional</code> is for one to avoid <em>returning</em> <code>null</code>.  It's still perfectly possible to pass in <code>null</code> to a method.</p>\n\n<p>While these aren't really official yet, you can use <a href=\"http://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use\">JSR-308 style</a> annotations to indicate whether or not you accept <code>null</code> values into the function.  Note that you'd have to have the right tooling to actually identify it, and it'd provide more of a static check than an enforceable runtime policy, but it would help.</p>\n\n<pre><code>public int calculateSomething(@NotNull final String p1, @NotNull final String p2) {}\n</code></pre>\n", "title": "Why should Java 8&#39;s Optional not be used in arguments", "tags": ["java", "java-8", "optional"], "link": "http://stackoverflow.com/questions/31922866/why-should-java-8s-optional-not-be-used-in-arguments/31923042#31923042", "post_type": "answer", "question_id": 31922866, "answer_id": 31923042}, {"body": "<p>Oh, those coding styles are to be taken with a bit of salt.</p>\n\n<ol>\n<li>(+) Passing an Option result to another method, without any semantic analysis; leaving that to the method, is quite alright.</li>\n<li>(-) Using Optional parameters causing conditional logic inside the methods is literally contra-productive.</li>\n<li>(-) Needing to pack an argument in an Optional, is suboptimal for the compiler, and does an unnecessary wrapping.</li>\n<li>(-) In comparison to nullable parameters Optional is more costly.</li>\n</ol>\n\n<p>In general: Optional unifies two states, which have to be unraveled. Hence better suited for result than input, for the complexity of the data flow.</p>\n", "title": "Why should Java 8&#39;s Optional not be used in arguments", "tags": ["java", "java-8", "optional"], "link": "http://stackoverflow.com/questions/31922866/why-should-java-8s-optional-not-be-used-in-arguments/31923105#31923105", "post_type": "answer", "question_id": 31922866, "answer_id": 31923105}, {"body": "<p>This advice is a variant of the \"be as unspecific as possible regarding inputs and as specific as possible regarding outputs\" rule of thumb.</p>\n\n<p>Usually if you have a method that takes a plain non-null value, you can map it over the <code>Optional</code>, so the plain version is strictly more unspecific regarding inputs. <em>However</em> there are a bunch of possible reasons why you would want to require an <code>Optional</code> argument nonetheless:</p>\n\n<ul>\n<li>you want your function to be used in conjunction with another API that returns an <code>Optional</code></li>\n<li>Your function should return something other than an empty <code>Optional</code> if the given value is empty</li>\n<li><s>You think <code>Optional</code> is so awesome that whoever uses your API should be required to learn about it ;-)</s></li>\n</ul>\n", "title": "Why should Java 8&#39;s Optional not be used in arguments", "tags": ["java", "java-8", "optional"], "link": "http://stackoverflow.com/questions/31922866/why-should-java-8s-optional-not-be-used-in-arguments/31923211#31923211", "post_type": "answer", "question_id": 31922866, "answer_id": 31923211}, {"body": "<p>This seems a bit silly to me, but the only reason I can think of is that object arguments in method parameters already are optional in a way - they can be null. Therefore forcing someone to take an existing object and wrap it in an optional is sort of pointless. </p>\n\n<p>That being said, chaining methods together that take/return optionals is a reasonable thing to do, e.g. Maybe monad.</p>\n", "title": "Why should Java 8&#39;s Optional not be used in arguments", "tags": ["java", "java-8", "optional"], "link": "http://stackoverflow.com/questions/31922866/why-should-java-8s-optional-not-be-used-in-arguments/31923214#31923214", "post_type": "answer", "question_id": 31922866, "answer_id": 31923214}, {"body": "<p>Optionals aren't designed for this purpose, as explained nicely by <a href=\"http://stackoverflow.com/questions/26327957/should-java-8-getters-return-optional-type/26328555#26328555\">Brian Goetz</a>.</p>\n\n<p>You can always use <a href=\"http://stackoverflow.com/questions/14076296/nullable-annotation-usage\">@Nullable</a> to denote that a method argument can be null. Using an optional does not really enable you to write your method logic more neatly.</p>\n", "title": "Why should Java 8&#39;s Optional not be used in arguments", "tags": ["java", "java-8", "optional"], "link": "http://stackoverflow.com/questions/31922866/why-should-java-8s-optional-not-be-used-in-arguments/31923227#31923227", "post_type": "answer", "question_id": 31922866, "answer_id": 31923227}, {"body": "<p>There are almost no good reasons for not using Optional as parameters.  The arguments against this rely on arguments from authority (see Brian Goetz - his argument is we can't enforce non null optionals) or that the Optional arguments may be null (essentially the same argument).  Of course, any reference in Java can be null, we need to encourage rules being enforced by the compiler, not programmers memory (which is problematic and does not scale).  </p>\n\n<p>Functional programming languages encourage Optional parameters.  One of the best ways of using this is to have multiple optional parameters and using liftM2 to use a function assuming the parameters are not empty and returning an optional (see <a href=\"http://www.functionaljava.org/javadoc/4.4/functionaljava/fj/data/Option.html#liftM2-fj.F-\">http://www.functionaljava.org/javadoc/4.4/functionaljava/fj/data/Option.html#liftM2-fj.F-</a>).  Java 8 has unfortunately implemented a very limited library supporting optional.</p>\n\n<p>As Java programmers we should only be using null to interact with legacy libraries.</p>\n", "title": "Why should Java 8&#39;s Optional not be used in arguments", "tags": ["java", "java-8", "optional"], "link": "http://stackoverflow.com/questions/31922866/why-should-java-8s-optional-not-be-used-in-arguments/31924845#31924845", "post_type": "answer", "question_id": 31922866, "answer_id": 31924845}, {"body": "<p>The best post I've seen on the topic was written by <a href=\"http://stackoverflow.com/users/1487809/daniel-olszewski\">Daniel Olszewski</a> and can be found at <a href=\"http://dolszewski.com/java/java-8-optional-use-cases/\" rel=\"nofollow\">http://dolszewski.com/java/java-8-optional-use-cases/</a>. While others mention when you should or should not use Optional, this post actually explains <strong>why</strong>. Cross-posting here in case the link goes down:</p>\n\n<blockquote>\n  <p>It\u2019s been almost two years since Java 8 was officially released and\n  many excellent articles about new enhancements and related best\n  practices have been written through that time. <strong>Surprisingly, one of\n  the more controversial topics amongst all the added features is the\n  Optional class</strong>. The type is a container, which can be either empty\n  or contain a non-null value. Such construction reminds the user of an\n  Optional object that the situation when there\u2019s nothing inside must be\n  handled appropriately. Although <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html\" rel=\"nofollow\">the definition of the type on\n  Javadoc</a>\n  is quite descriptive, when it comes to identifying valid use cases\n  it\u2019s getting more problematic.</p>\n  \n  <p><strong>Method result</strong></p>\n  \n  <p>The first possible use case is actually a no-brainer. Brian Goetz, who is working on the Java language at Oracle, stated this purpose <a href=\"http://stackoverflow.com/a/26328555/1487809\">in his answer on Stack Overflow</a> as <strong>the main motivator to add the type to the standard library</strong>.</p>\n  \n  <blockquote>\n    <p>Our intention was to provide a limited mechanism for library method return types where there needed to be a clear way to represent \u201cno result\u201d, and using null for such was overwhelmingly likely to cause errors.</p>\n  </blockquote>\n  \n  <p>Before Java 8, receiving a null value from a method was ambiguous. It\n  could mean there\u2019s nothing to return or that an error occurred during\n  execution. Besides, developers tended to forget verifying if the\n  result was null, which led to nasty NullPointerException at runtime.\n  Optional solves both problems by providing a convenient way to force\n  the user of the method to check its self-explanatory output.</p>\n  \n  <p><strong>Collection wrapper</strong></p>\n  \n  <p>While putting a nullable method result inside Optional is advisable,\n  the rule doesn\u2019t apply when the output is a collection or an array. In\n  case when there\u2019s no element to return, <strong>an empty instance is\n  superior to empty Optional and null</strong> as it conveys all necessary\n  information. Optional doesn\u2019t provide any additional value and only\n  complicates client code, hence it should be avoided. Here\u2019s a bad\n  practice sample:</p>\n\n<pre><code>Optional&lt;List&lt;Item&gt;&gt; itemsOptional = getItems();\nif (itemsOptional.isPresent()) { // do we really need this?\n    itemsOptional.get().forEach(item -&gt; {\n        // process item\n    });\n} else {\n    // the result is empty\n}\n</code></pre>\n  \n  <p>As long as the <code>getItems()</code> method returned the unwrapped list\n  instance, client code could get rid of one condition check and simply\n  iterate over the collection. If we want to verify the absence of the\n  result, each collection has the <code>isEmpty()</code> method and in case of\n  arrays, the length property can be used. On the whole, Optional adds\n  unnecessary complexity.</p>\n  \n  <p><strong>Constructor and method parameters</strong></p>\n  \n  <p>Although it might be tempting to consider Optional for not mandatory method parameters, such a solution pale in comparison with other possible alternatives. To illustrate the problem, examine the following constructor declaration:</p>\n\n<pre><code>public SystemMessage(String title, String content, Optional&lt;Attachment&gt; attachment) {\n    // assigning field values\n}\n</code></pre>\n  \n  <p>At first glance it may look as a right design decision. After all, we\n  explicitly marked the attachment parameter as optional. However, as\n  for calling the constructor, client code can become a little bit\n  clumsy.</p>\n\n<pre><code>SystemMessage withoutAttachment = new SystemMessage(\"title\", \"content\", Optional.empty());\nAttachment attachment = new Attachment();\nSystemMessage withAttachment = new SystemMessage(\"title\", \"content\", Optional.ofNullable(attachment));\n</code></pre>\n  \n  <p>Instead of providing clarity, the factory methods of the Optional\n  class only distract the reader. Note there\u2019s only one optional\n  parameter, but imagine having two or three. Uncle Bob definitely\n  wouldn\u2019t be proud of such code \ud83d\ude09</p>\n  \n  <p><strong>When a method can accept optional parameters, it\u2019s preferable to adopt the well-proven approach and design such case using method\n  overloading.</strong> In the example of the SystemMessage class, declaring\n  two separate constructors are superior to using Optional.</p>\n\n<pre><code>public SystemMessage(String title, String content) {\n    this(title, content, null);\n}\n\npublic SystemMessage(String title, String content, Attachment attachment) {\n    // assigning field values\n}\n</code></pre>\n  \n  <p>That change makes client code much simpler and easier to read.</p>\n\n<pre><code>SystemMessage withoutAttachment = new SystemMessage(\"title\", \"content\");\nAttachment attachment = new Attachment();\nSystemMessage withAttachment = new SystemMessage(\"title\", \"content\", attachment);\n</code></pre>\n  \n  <p><strong>POJOs</strong></p>\n  \n  <p>POJO fields or getters are probably the most controversial candidates\n  for Optional usage and judging by different blog posts, articles, and\n  comments we all can agree only on one thing: another holy war has\n  already been started. On the one hand, in the aforementioned Stack\n  Overflow post, <strong>Brian Goetz left no doubt the type isn\u2019t suitable for\n  accessors</strong>.</p>\n  \n  <blockquote>\n    <p>I think routinely using it as a return value for getters would definitely be over-use.</p>\n  </blockquote>\n  \n  <p>What is more, <a href=\"http://mail.openjdk.java.net/pipermail/jdk8-dev/2013-September/003274.html\" rel=\"nofollow\">Optional deliberately doesn\u2019t implement the\n  Serializable\n  interface</a>,\n  which essentially disqualifies the type as a member of any class that\n  relies on the mechanism. For a number of developers these two\n  justifications are sufficient to reject the idea of Optional POJO\n  fields.</p>\n  \n  <p>On the other side of the coin, others started to question the\n  previously mentioned arguments. As a matter of fact, a nullable model\n  field isn\u2019t a rare case and considering Optional is reasonable.\n  Stephen Colebourne, mostly known as a principal contributor of\n  Joda-Time and the JSR-310 specification, proposed <a href=\"http://blog.joda.org/2015/08/java-se-8-optional-pragmatic-approach.html\" rel=\"nofollow\">on his blog\n  post</a>\n  to <strong>keep nullable fields inside of a class, but wrap them up with\n  Optional when they leave the private scope through public getters</strong>.\n  Just like in the case of the method result, we want to aware other\n  developers of possible lack of value.</p>\n  \n  <p>Besides memory overhead, <strong>the main obstacle which prevents using\n  Optional as a POJO field is support of libraries and frameworks</strong>.\n  Reflection is widely used to read and manipulate objects and Optional\n  requires special treatment. For instance, the Jackson development team\n  has already provided an additional module that handles Optional fields\n  while converting a POJO into JSON format. Hibernate validator also\n  works with Optional entity fields, but in many cases you don\u2019t get\n  support out of the box and some additional work might be inevitable.</p>\n  \n  <p>If you choose the dark side and ignore the advice from Brian Goetz,\n  you have to <strong>make sure all libraries and frameworks that you use can\n  fully deal with the Optional class</strong>. No matter what your team decides\n  when starting a new application, the best advice is to keep it\n  consistent across the whole project.</p>\n  \n  <p><strong>Optional class dependency</strong></p>\n  \n  <p>Sometimes features or some part of business logic can be toggled on and off based on an application configuration. When such code is externalized into a separate class, it becomes an optional runtime dependency. Stateless classes don\u2019t implement the Serializable interface, so there are no technical obstacles to use Optional as a class field. Consider the following example:</p>\n\n<pre><code>public class OrderProcessor {\n\n    private Optional&lt;SmsNotifier&gt; smsNotifier = Optional.empty();\n\n    public void process(final Order order) {\n        // some processing logic here\n        smsNotifier.ifPresent(n -&gt; n.sendConfirmation(order));\n    }\n\n    public void setSmsNotifier(SmsNotifier smsNotifier) {\n        this.smsNotifier = Optional.ofNullable(smsNotifier);\n    }\n\n}\n</code></pre>\n  \n  <p>If a nullable field were used, we\u2019d risk someone, while extending the\n  class, would unknowingly use the field without verifying its presence.\n  <strong>In the world dominated by dependency injection frameworks, a multitude of developers automatically assume if there\u2019s a field in a\n  business logic class then it must be set by a container</strong>. The\n  Optional type is highly expressive in this situation and prevents\n  automatic behavior from occurring.</p>\n  \n  <p>As usual in programming, there\u2019s no one best way to tackle the\n  problem. Another possible solution for optional dependencies is the\n  <a href=\"https://en.wikipedia.org/wiki/Null_Object_pattern\" rel=\"nofollow\">Null Object\n  pattern</a>, which in\n  some cases may be preferable.</p>\n  \n  <p><strong>Not a silver bullet</strong></p>\n  \n  <p>Although in many situations the temptation to use Optional may be\n  strong, the original idea behind the type wasn\u2019t to create an\n  all-purpose replacement for every nullable value. Before applying the\n  type, all possible alternatives should be considered as <strong>overusing of\n  Optional may lead to introducing new burdensome code smells</strong>. If you\n  have practical experience with Optional, especially as POJO fields or\n  getter outputs, I\u2019d be glad to read about what you\u2019ve learned. Every\n  comment is highly appreciated, so don\u2019t hesitate to share your\n  observations.</p>\n</blockquote>\n", "title": "Why should Java 8&#39;s Optional not be used in arguments", "tags": ["java", "java-8", "optional"], "link": "http://stackoverflow.com/questions/31922866/why-should-java-8s-optional-not-be-used-in-arguments/39005452#39005452", "post_type": "answer", "question_id": 31922866, "answer_id": 39005452}, {"body": "<p>There is no actual difference in the functionality between the 2 version's loop. <code>Arrays.fill</code> does the exact same thing.</p>\n\n<p>So the choice to use it or not may not necessarily be considered a mistake. It is left up to the developer to decide when it comes to this kind of micromanagement.</p>\n\n<p>There are 2 separate concerns for each approach:</p>\n\n<ul>\n<li>using the <code>Arrays.fill</code> makes the code less verbose and more readable.</li>\n<li>looping directly in the <code>HashMap</code> code (like version 8) peformance wise is actually a better option. While the overhead that inserting the <code>Arrays</code> class is negligible it may become less so when it comes to something as widespread as <code>HashMap</code> where every bit of performance enhancement has a large effect(imagine the tiniest footprint reduce of a HashMap in fullblown webapp). Take into consideration the fact that the Arrays class was used only for this one loop. The change is small enough that it doesn't make the clear method less readable.</li>\n</ul>\n\n<p>The precise reason can't be found out without asking the developer who actually did this, however i suspect it's either a mistake or a small enhancement.\nbetter option.</p>\n\n<p>My opinion is it can be considered an enhancement, even if only by accident. </p>\n", "title": "Why is Arrays.fill() not used in HashMap.clear() anymore?", "tags": ["java", "arrays", "hashmap", "java-8"], "link": "http://stackoverflow.com/questions/32693704/why-is-arrays-fill-not-used-in-hashmap-clear-anymore/32744190#32744190", "post_type": "answer", "question_id": 32693704, "answer_id": 32744190}, {"body": "<p>For me, the reason is a likely performance inprovement, at a negligible cost in terms of code clarity.</p>\n\n<p>Note that the implementation of the <code>fill</code> method is trivial, a simple for-loop setting each array element to null. So, replacing a call to it with the actual implementation does not cause any significant degradation in the clarity/conciseness of the caller method.</p>\n\n<p>The potential performance benefits are not so insignificant, if you consider everything that is involved:</p>\n\n<ol>\n<li><p>There will be no need for the JVM to resolve the <code>Arrays</code> class, plus loading and initializing it if needed. This is a non-trivial process where the JVM performs several steps. Firstly, it checks the class loader to see if the class is already loaded, and this happens every time a method is called; there are optimizations involved here, of course, but it still takes some effort. If the class is not loaded, the JVM will need to go through the expensive process of loading it, verifying the bytecode, resolving other necessary dependencies, and finally performing static initialization of the class (which can be arbitrarily expensive). Given that <code>HashMap</code> is such a core class, and that <code>Arrays</code> is such a huge class (3600+ lines), avoiding these costs may add up to noticeable savings.</p></li>\n<li><p>Since there is no <code>Arrays.fill(...)</code> method call, the JVM won't have to decide whether/when to inline the method into the caller's body. Since <code>HashMap#clear()</code> tends to get called a lot, the JVM will eventually perform the inlining, which requires JIT recompilation of the <code>clear</code> method. With no method calls, <code>clear</code> will always run at top-speed (once initially JITed).</p></li>\n</ol>\n\n<p>Another benefit of no longer calling methods in <code>Arrays</code> is that it simplifies the dependency graph inside the <code>java.util</code> package, since one dependency is removed.</p>\n", "title": "Why is Arrays.fill() not used in HashMap.clear() anymore?", "tags": ["java", "arrays", "hashmap", "java-8"], "link": "http://stackoverflow.com/questions/32693704/why-is-arrays-fill-not-used-in-hashmap-clear-anymore/32745612#32745612", "post_type": "answer", "question_id": 32693704, "answer_id": 32745612}, {"body": "<p>I'm going to shoot in the dark here... </p>\n\n<p>My <em>guess</em> is that it might have been changed in order to prepare the ground for <a href=\"http://openjdk.java.net/jeps/218\" rel=\"nofollow\">Specialization</a> (aka generics over primitive types). <em>Maybe</em> (and I insist on <em>maybe</em>), this change is meant to make transition to Java 10 easier, in the event of specialization being part of the JDK.</p>\n\n<p>If you look at the <a href=\"http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html\" rel=\"nofollow\">State of the Specialization document</a>, <strong>Language restrictions</strong> section, it says the following:</p>\n\n<blockquote>\n  <p>Because any type variables can take on value as well as reference types, the type checking rules involving such type variables (henceforth, \"avars\"). For example, for an avar T:</p>\n  \n  <ul>\n  <li><strong>Cannot convert null to a variable whose type is T</strong></li>\n  <li>Cannot compare T to null</li>\n  <li><strong>Cannot convert T to Object</strong></li>\n  <li><strong>Cannot convert T[] to Object[]</strong></li>\n  <li>...</li>\n  </ul>\n</blockquote>\n\n<p>(Emphasis is mine).</p>\n\n<p>And ahead in the <strong>Specializer transformations</strong> section, it says:</p>\n\n<blockquote>\n  <p>When specializing an any-generic class, the specializer is going to perform a number of transformations, most localized, but some requiring a global view of a class or method, including:</p>\n  \n  <ul>\n  <li>...</li>\n  <li><strong>Type variable substitution and name mangling is performed on the signatures of all methods</strong></li>\n  <li>...</li>\n  </ul>\n</blockquote>\n\n<p>Later on, near the end of the document, in the <strong>Further investigation</strong> section, it says:</p>\n\n<blockquote>\n  <p>While our experiments have proven that specialization in this manner is practical, much more investigation is needed. Specifically, we need to perform a number of targeted experiments aimed at any-fying core JDK libraries, specifically Collections and Streams.</p>\n</blockquote>\n\n<hr>\n\n<p>Now, regarding the change...</p>\n\n<p>If the <code>Arrays.fill(Object[] array, Object value)</code> method is going to be specialized, then its signature should change to <code>Arrays.fill(T[] array, T value)</code>. However this case is specifically listed in the (already mentioned) <em>Language restrictions</em> section (it would violate the emphasized items). So <em>maybe</em> someone decided that it would be better to not use it from the <code>HashMap.clear()</code> method, especially if <code>value</code> is <code>null</code>.</p>\n", "title": "Why is Arrays.fill() not used in HashMap.clear() anymore?", "tags": ["java", "arrays", "hashmap", "java-8"], "link": "http://stackoverflow.com/questions/32693704/why-is-arrays-fill-not-used-in-hashmap-clear-anymore/32749756#32749756", "post_type": "answer", "question_id": 32693704, "answer_id": 32749756}, {"body": "<p>I will try to summarize three moreless reasonable versions which were proposed in comments.</p>\n\n<p>@Holger <a href=\"http://stackoverflow.com/questions/32693704/why-arrays-fill-is-not-used-in-hashmap-clear-anymore#comment53230781_32693704\">says</a>:</p>\n\n<blockquote>\n  <p>I guess that this is to avoid the class java.util.Arrays getting loading as a side effect of this method. For application code, this is usually not a concern.</p>\n</blockquote>\n\n<p>This is the most easy thing to test. Let's compile such program:</p>\n\n<pre><code>public class HashMapTest {\n    public static void main(String[] args) {\n        new java.util.HashMap();\n    }\n}\n</code></pre>\n\n<p>Run it with <code>java -verbose:class HashMapTest</code>. This will print the class loading events as they occur. With JDK 1.8.0_60 I see more than 400 classes loaded:</p>\n\n<pre><code>... 155 lines skipped ...\n[Loaded java.util.Set from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.util.AbstractSet from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.util.Collections$EmptySet from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.util.Collections$EmptyList from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.util.Collections$EmptyMap from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.util.Collections$UnmodifiableCollection from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.util.Collections$UnmodifiableList from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.util.Collections$UnmodifiableRandomAccessList from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded sun.reflect.Reflection from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n**[Loaded java.util.HashMap from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.util.HashMap$Node from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.lang.Class$3 from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.lang.Class$ReflectionData from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.lang.Class$Atomic from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded sun.reflect.generics.repository.AbstractRepository from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded sun.reflect.generics.repository.GenericDeclRepository from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded sun.reflect.generics.repository.ClassRepository from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.lang.Class$AnnotationData from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded sun.reflect.annotation.AnnotationType from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.util.WeakHashMap from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.lang.ClassValue$ClassValueMap from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.lang.reflect.Modifier from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded sun.reflect.LangReflectAccess from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n[Loaded java.lang.reflect.ReflectAccess from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n**[Loaded java.util.Arrays from C:\\Program Files\\Java\\jre1.8.0_60\\lib\\rt.jar]\n...\n</code></pre>\n\n<p>As you can see, <code>HashMap</code> is loaded long before application code and <code>Arrays</code> is loaded only 14 classes after <code>HashMap</code>. The <code>HashMap</code> load is triggered by <code>sun.reflect.Reflection</code> initialization as it has <code>HashMap</code> static fields. The <code>Arrays</code> load is likely to be triggered by <code>WeakHashMap</code> load which actually has <code>Arrays.fill</code> in the <code>clear()</code> method. The <code>WeakHashMap</code> load is triggered by <code>java.lang.ClassValue$ClassValueMap</code> which extends <code>WeakHashMap</code>. The <code>ClassValueMap</code> is present in every <code>java.lang.Class</code> instance. So to me seems that without <code>Arrays</code> class the JDK cannot be initialized at all. Also the <code>Arrays</code> static initializer is very short, it only initializes the assertion mechanism. This mechanism is used in many other classes (including, for example, <code>java.lang.Throwable</code> which is loaded very early). No other static initialization steps are performed in <code>java.util.Arrays</code>. Thus @Holger version seems incorrect to me.</p>\n\n<p>Here we also found very interesting thing. The <code>WeakHashMap.clear()</code> still uses <code>Arrays.fill</code>. It's interesting when it appeared there, but unfortunately this goes to <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/annotate/37a05a11f281/src/share/classes/java/util/WeakHashMap.java#l633\">prehistoric times</a> (it was already there in the very first public OpenJDK repository).</p>\n\n<p>Next, @MarcoTopolnik <a href=\"http://stackoverflow.com/questions/32693704/why-arrays-fill-is-not-used-in-hashmap-clear-anymore#comment53230663_32693704\">says</a>:</p>\n\n<blockquote>\n  <p>Safer surely not, but it <em>might</em> be faster when the <code>fill</code> call is not inlined and <code>tab</code> is short. On HotSpot both the loop and the explicit <code>fill</code> call will result in a fast compiler intrinsic (in a happy-day scenario). </p>\n</blockquote>\n\n<p>It was actually surprising for me that <code>Arrays.fill</code> is not directly intrinsified (see <a href=\"https://gist.github.com/apangin/7a9b7062a4bd0cd41fcc\">intrinsic list</a> generated by <a href=\"http://stackoverflow.com/users/3448419/apangin\">@apangin</a>). Seems that such loop can be recognized and vectorized by JVM without explicit intrinsic handling. So it's true that extra call can be not inlined in very specific cases (for example if <code>MaxInlineLevel</code> limit is reached). On the other hand it's very rare situation and it's only a single call, it's not a call inside loop, and it's a static, not virtual/interface call, thus the performance improvement could be only marginal and only in some specific scenarios. Not the thing the JVM developers usually care.</p>\n\n<p>Also it should be noted that even C1 'client' compiler (tier 1-3) is capable to inline <code>Arrays.fill</code> called, for example, in <code>WeakHashMap.clear()</code>, as inlining log (<code>-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining</code>) says:</p>\n\n<pre><code>36       3  java.util.WeakHashMap::clear (50 bytes)\n     !m        @ 4   java.lang.ref.ReferenceQueue::poll (28 bytes)\n                 @ 17   java.lang.ref.ReferenceQueue::reallyPoll (66 bytes)   callee is too large\n               @ 28   java.util.Arrays::fill (21 bytes)\n     !m        @ 40   java.lang.ref.ReferenceQueue::poll (28 bytes)\n                 @ 17   java.lang.ref.ReferenceQueue::reallyPoll (66 bytes)   callee is too large\n               @ 1   java.util.AbstractMap::&lt;init&gt; (5 bytes)   inline (hot)\n                 @ 1   java.lang.Object::&lt;init&gt; (1 bytes)   inline (hot)\n               @ 9   java.lang.ref.ReferenceQueue::&lt;init&gt; (27 bytes)   inline (hot)\n                 @ 1   java.lang.Object::&lt;init&gt; (1 bytes)   inline (hot)\n                 @ 10   java.lang.ref.ReferenceQueue$Lock::&lt;init&gt; (5 bytes)   unloaded signature classes\n               @ 62   java.lang.Float::isNaN (12 bytes)   inline (hot)\n               @ 112   java.util.WeakHashMap::newTable (8 bytes)   inline (hot)\n</code></pre>\n\n<p>Of course, it's also easily inlined by smart and powerful C2 'server' compiler. Thus I see no problems here. Seems that @Marco version is incorrect either.</p>\n\n<p>Finally we have a couple of <a href=\"http://stackoverflow.com/questions/32693704/why-arrays-fill-is-not-used-in-hashmap-clear-anymore/32752970#comment53251284_32693704\">comments</a> from @StuartMarks (who is JDK developer, thus some official voice):</p>\n\n<blockquote>\n  <p>Interesting. My hunch is that this is a mistake. The review thread for this changeset is <a href=\"http://mail.openjdk.java.net/pipermail/core-libs-dev/2013-August/020131.html\">here</a> and it references an <a href=\"http://mail.openjdk.java.net/pipermail/core-libs-dev/2013-July/018685.html\">earlier thread</a> that is <a href=\"http://mail.openjdk.java.net/pipermail/core-libs-dev/2013-August/019853.html\">continued here</a>. The initial message in that earlier thread points to a prototype of HashMap.java in Doug Lea's CVS repository. I don't know where this came from. It doesn't seem to match anything in the OpenJDK history.</p>\n  \n  <p>... In any case, it might have been some old snapshot; the for-loop was in the clear() method for many years. The Arrays.fill() call was introduced by <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/rev/2e3cc7f599ca\">this changeset</a>, so it was in the tree only for a few months. Note also that the power-of-two computation based on Integer.highestOneBit() introduced by <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/rev/36f4cf8872f3\">this changeset</a> also disappeared at the same time, though this was noted but dismissed during the review. Hmmm.</p>\n</blockquote>\n\n<p>Indeed the <code>HashMap.clear()</code> contained the loop many years, was <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/rev/2e3cc7f599ca#l2.156\">replaced</a> with <code>Arrays.fill</code> on Apr 10th, 2013 and stayed less one half-a-year until Sept 4th when the discussed <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/diff/d62c911aebbb/src/share/classes/java/util/HashMap.java#l1.2459\">commit</a> was introduced. The discussed commit was actually a major rewrite of the <code>HashMap</code> internals to fix <a href=\"https://bugs.openjdk.java.net/browse/JDK-8023463\">JDK-8023463</a> issue. It was a long story about possibility to poison the <code>HashMap</code> with keys having duplicating hashcodes reducing <code>HashMap</code> search speed to linear making it vulnerable to DoS-attacks. The attempts to solve this were performed in JDK-7 including some randomization of String hashCode. So seems that the <code>HashMap</code> implementation was forked from the earlier commit, developed independently, then merged into the master branch overwriting several changes introduced in-between.</p>\n\n<p>We may support this hypothesis performing a diff. Take the <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/raw-file/d62c911aebbb/src/share/classes/java/util/HashMap.java\">version</a> where <code>Arrays.fill</code> was removed (2013-09-04) and compare it with <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/raw-file/36f4cf8872f3/src/share/classes/java/util/HashMap.java\">previous version</a> (2013-07-30). The <code>diff -U0</code> output has 4341 lines. Now let's diff against the <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/raw-file/de228734b742/src/share/classes/java/util/HashMap.java\">version</a> prior to one when <code>Arrays.fill</code> was added (2013-04-01). Now <code>diff -U0</code> contains only 2680 lines. Thus the newer version actually more similar to the older than to immediate parent.</p>\n\n<p><strong>Conclusion</strong></p>\n\n<p>So to conclude I would agree with Stuart Marks. There were no concrete reason to remove <code>Arrays.fill</code>, it's just because the in-between change was overwritten by mistake. Using <code>Arrays.fill</code> is perfectly fine both in JDK code and in user applications and used, for example, in <code>WeakHashMap</code>. The <code>Arrays</code> class is loaded anyways pretty early during the JDK initialization, has very simple static initializer and <code>Arrays.fill</code> method can be easily inlined even by client compiler, so no performance drawback should be noted.</p>\n", "title": "Why is Arrays.fill() not used in HashMap.clear() anymore?", "tags": ["java", "arrays", "hashmap", "java-8"], "link": "http://stackoverflow.com/questions/32693704/why-is-arrays-fill-not-used-in-hashmap-clear-anymore/32752970#32752970", "post_type": "answer", "question_id": 32693704, "answer_id": 32752970}, {"body": "<p>Because it's <em>much</em> faster!</p>\n\n<p>I ran some thorough benchmarking tests on cut down versions of the two methods:</p>\n\n<pre><code>void jdk7clear() {\n    Arrays.fill(table, null);\n}\n\nvoid jdk8clear() {\n    Object[] tab;\n    if ((tab = table) != null) {\n        for (int i = 0; i &lt; tab.length; ++i)\n            tab[i] = null;\n    }\n}\n</code></pre>\n\n<p>operating on arrays of various sizes containing random values. Here are the (typical) results:</p>\n\n<pre><code>Map size |  JDK 7 (sd)|  JDK 8 (sd)| JDK 8 vs 7\n       16|   2267 (36)|   1521 (22)| 67%\n       64|   3781 (63)|   1434 ( 8)| 38%\n      256|   3092 (72)|   1620 (24)| 52%\n     1024|   4009 (38)|   2182 (19)| 54%\n     4096|   8622 (11)|   4732 (26)| 55%\n    16384|  27478 ( 7)|  12186 ( 8)| 44%\n    65536| 104587 ( 9)|  46158 ( 6)| 44%\n   262144| 445302 ( 7)| 183970 ( 8)| 41%\n</code></pre>\n\n<p>And here are the results when operating over an array filled with nulls (so garbage collection issues are eradicated):</p>\n\n<pre><code>Map size |  JDK 7 (sd)|  JDK 8 (sd)| JDK 8 vs 7\n       16|     75 (15)|     65 (10)|  87%\n       64|    116 (34)|     90 (15)|  78%\n      256|    246 (36)|    191 (20)|  78%\n     1024|    751 (40)|    562 (20)|  75%\n     4096|   2857 (44)|   2105 (21)|  74%\n    16384|  13086 (51)|   8837 (19)|  68%\n    65536|  52940 (53)|  36080 (16)|  68%\n   262144| 225727 (48)| 155981 (12)|  69%\n</code></pre>\n\n<p>The numbers are in nanoseconds, <code>(sd)</code> is 1 standard deviation expressed as a percentage of the result (fyi, a \"normally distributed\" population has an SD of 68), <code>vs</code> is the JDK 8 timing relative to JDK 7.</p>\n\n<p>It is interesting that not only is it significantly faster, but the deviation is also slightly narrower, which means that the JDK 8 implementation gives slightly more <em>consistent</em> performance.</p>\n\n<p>The tests were run on jdk 1.8.0_45 over a large (millions) number of times on arrays populated with random <code>Integer</code> objects. To remove out-lying numbers, on each set of results the fastest and slowest 3% of timings were discarded. Garbage collection was requested and the thread yielded and slept just prior to running each invocation of the method. JVM warm up was done on the first 20% of work and those results were discarded.</p>\n", "title": "Why is Arrays.fill() not used in HashMap.clear() anymore?", "tags": ["java", "arrays", "hashmap", "java-8"], "link": "http://stackoverflow.com/questions/32693704/why-is-arrays-fill-not-used-in-hashmap-clear-anymore/32852619#32852619", "post_type": "answer", "question_id": 32693704, "answer_id": 32852619}, {"body": "<p>You can of course choose to shoot yourself in the foot, but that doesn't mean you must.</p>\n\n<blockquote>\n  <p>Why was the Thread class implemented as a regular class and not an abstract class with run() method being abstract.</p>\n</blockquote>\n\n<p>Because the recommended way to create a start a thread is not to subclass Thread. The recommended way is to define a <code>Runnable</code>, and pass it as argument to the Thread constructor:</p>\n\n<pre><code>Runnable r = new Runnable() {\n    @Override\n    public void run() {\n        ...\n    }\n};\nThread t = new Thread(r);\nt.start();\n</code></pre>\n\n<blockquote>\n  <p>And hence I guess the final keyword would be apt for this more than any other method.</p>\n</blockquote>\n\n<p>Yes and no. You can't replace the implementation of start() by your own implementation, but you can do <em>additional</em> things in start() if you want:</p>\n\n<pre><code>@Override\npublic void start() {\n    System.out.println(\"Did anyone tell you I will spawn a new thread??\");\n    super.start();\n}\n</code></pre>\n\n<p>That said, if Java was redesigned from scratch today, there is a good chance the design would be different. Remember that this class dates from Java 1.0, and is still backward-compatible.</p>\n", "title": "Why is Thread not an abstract class and start() not final?", "tags": ["java", "multithreading"], "link": "http://stackoverflow.com/questions/31202946/why-is-thread-not-an-abstract-class-and-start-not-final/31203218#31203218", "post_type": "answer", "question_id": 31202946, "answer_id": 31203218}, {"body": "<blockquote>\n  <p>Why was the Thread class implemented as a regular class and not an\n  abstract class with run() method being abstract.</p>\n</blockquote>\n\n<p>This question actually boils down to the fact that you should always prefer composition over inheritance.</p>\n\n<p>If the <code>Thread</code> class was declared as <code>abstract</code>, the language would have to provide another class that extended from it which programmers could use to create a <code>Thread</code>. Your question would then be about why this class that <code>extends</code> from <code>Thread</code> is not <code>abstract</code>. If the language did not provide another class that <code>extends</code> from <code>Thread</code>, programmers would have to create their own class that <code>extend</code>s from <code>Thread</code> and override the <code>run()</code> method.</p>\n\n<blockquote>\n  <p>If not, why was the method not declared final in Thread class??</p>\n</blockquote>\n\n<p>The only possible explanation I can give is that the developers of the language saw some use-cases for overriding <code>start</code> when the class was introduced to the JDK. The first version of Java that I used was 1.5 and I personally have not come across a use-case where I found the need to override <code>start</code>. As JB Nizet stated in his answer</p>\n\n<blockquote>\n  <p>if Java was redesigned from scratch today, there is a good chance the design would be different</p>\n</blockquote>\n", "title": "Why is Thread not an abstract class and start() not final?", "tags": ["java", "multithreading"], "link": "http://stackoverflow.com/questions/31202946/why-is-thread-not-an-abstract-class-and-start-not-final/31203252#31203252", "post_type": "answer", "question_id": 31202946, "answer_id": 31203252}, {"body": "<p>Since there are only 4 elements that pass the filter, <code>limit(10)</code> never reaches 10 elements, so the Stream pipeline keeps generating new elements and feeding them to the filter, trying to reach 10 elements that pass the filter, but since only the first 4 elements pass the filter, the processing never ends (at least until <code>i</code> overflows).</p>\n\n<p>The Stream pipeline is not smart enough to know that no more elements can pass the filter, so it keeps processing new elements.</p>\n", "title": "Why doesn&#39;t Stream.limit work as expected in this snippet?", "tags": ["java", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/34172978/why-doesnt-stream-limit-work-as-expected-in-this-snippet/34173040#34173040", "post_type": "answer", "question_id": 34172978, "answer_id": 34173040}, {"body": "<p>Flipping the <code>limit</code> and the <code>filter</code> clauses has different behaviors.</p>\n\n<p>If you put the <code>limit</code> first, the stream will first generate 10 integers [1..10], and then filter them leaving only those smaller than 5.</p>\n\n<p>In the original ordering, with the <code>filter</code> applied first, integers are generated and filtered until you reach 10 elements. This isn't an infinite operator, as <code>i</code> in the supplier will eventually overflow, but it will take a while, especially on a slow computer, to reach <code>MAX_INT</code>.</p>\n", "title": "Why doesn&#39;t Stream.limit work as expected in this snippet?", "tags": ["java", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/34172978/why-doesnt-stream-limit-work-as-expected-in-this-snippet/34173110#34173110", "post_type": "answer", "question_id": 34172978, "answer_id": 34173110}, {"body": "<p>If you want to stop <em>either</em> if number 5 is reached or 10 elements are collected, there's <code>Stream.takeWhile()</code> method added in Java-9:</p>\n\n<pre><code>List&lt;Integer&gt; integer = Stream.generate(new Supplier&lt;Integer&gt;() {\n    int i = 0 ;\n\n    @Override\n    public Integer get() {\n        return ++i;\n    }\n}).takeWhile(j -&gt; j &lt; 5).limit(10).collect(Collectors.toList());\n</code></pre>\n", "title": "Why doesn&#39;t Stream.limit work as expected in this snippet?", "tags": ["java", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/34172978/why-doesnt-stream-limit-work-as-expected-in-this-snippet/34173658#34173658", "post_type": "answer", "question_id": 34172978, "answer_id": 34173658}, {"body": "<p>You can create a <code>Stream</code> of the indices using an <code>IntStream</code> and then convert them to a <code>Map</code> :</p>\n\n<pre><code>Map&lt;Integer,Item&gt; map = \n    IntStream.range(0,items.size())\n             .boxed()\n             .collect(Collectors.toMap (i -&gt; i, i -&gt; items.get(i)));\n</code></pre>\n", "title": "Java 8 list to map with stream", "tags": ["java", "dictionary", "collections", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/32859038/java-8-list-to-map-with-stream/32859065#32859065", "post_type": "answer", "question_id": 32859038, "answer_id": 32859065}, {"body": "<p>Don't feel like you have to do <em>everything</em> in/with the stream. I would just do:</p>\n\n<pre><code>AtomicInteger index = new AtomicInteger();\nitems.stream().collect(Collectors.toMap(i -&gt; index.getAndIncrement(), i -&gt; i));\n</code></pre>\n\n<p>As long as you don't parallelise the stream this will work and it avoids potentially expensive and/or problematic (in the case of duplicates) <code>get()</code> and <code>indexOf()</code> operations.</p>\n\n<p>(You cannot use a regular <code>int</code> variable in place of the <code>AtomicInteger</code> because variables used from outside a lambda expression must be effectively final. Note that when uncontested (as in this case), <code>AtomicInteger</code> is very fast and won't pose a performance problem. But if it worries you you can use a non-thread-safe counter.)</p>\n", "title": "Java 8 list to map with stream", "tags": ["java", "dictionary", "collections", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/32859038/java-8-list-to-map-with-stream/32863263#32863263", "post_type": "answer", "question_id": 32859038, "answer_id": 32863263}, {"body": "<p><a href=\"http://stackoverflow.com/a/32859065/1441122\">Eran's answer</a> is usually the best approach for random-access lists.</p>\n\n<p>If your <code>List</code> isn't random access, or if you have a <code>Stream</code> instead of a <code>List</code>, you can use <code>forEachOrdered</code>:</p>\n\n<pre><code>Stream&lt;Item&gt; stream = ... ;\nMap&lt;Integer, Item&gt; map = new HashMap&lt;&gt;();\nAtomicInteger index = new AtomicInteger();\nstream.forEachOrdered(item -&gt; map.put(index.getAndIncrement(), item));\n</code></pre>\n\n<p>This is safe, if the stream is parallel, even though the destination map is thread-unsafe and is operated upon as a side effect. The <code>forEachOrdered</code> guarantees that items are processed one-at-a-time, in order. For this reason it's unlikely that any speedup will result from running in parallel. (There might be some speedup if there are expensive operations in the pipeline before the <code>forEachOrdered</code>.)</p>\n", "title": "Java 8 list to map with stream", "tags": ["java", "dictionary", "collections", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/32859038/java-8-list-to-map-with-stream/32918035#32918035", "post_type": "answer", "question_id": 32859038, "answer_id": 32918035}, {"body": "<p><code>org.apache.commons.lang.math.NumberUtils.INTEGER_ONE</code> it gives you a <code>final static Integer</code> object rather than primitive <code>int</code> 1, and as it is <code>final static</code> it acts as a constant and can be used in comparison of <code>Integer</code> objects because will always return same instance.</p>\n\n<p>So in the above scenario it might not look <em>fit</em> but somewhere if you are using it while comparison, it for sure has impact.</p>\n\n<p>Moreover, as much as we can, should prefer the use of constants over hardcoded beacuse:</p>\n\n<ol>\n<li>It can make your code easily maintainable. If any situation occurs in future for change, you can change only at a single place.</li>\n<li>The code looks cleaner &amp; more readable.</li>\n</ol>\n", "title": "Morbid use of constants", "tags": ["java", "constants"], "link": "http://stackoverflow.com/questions/31471444/morbid-use-of-constants/31471520#31471520", "post_type": "answer", "question_id": 31471444, "answer_id": 31471520}, {"body": "<p>You should not. The <code>INTEGER_ONE</code> name is no more meaningful than 1. If however this value has some other meaning (for example, month in the year), then using a constant (like <code>Calendar.FEBRUARY</code>) will make your code clearer.</p>\n\n<p>I can guess that this constant in Commons Math library was created in Java 1.4 when there were no Integer cache and autoboxing, so it had sense in terms that you may reuse the same <code>Integer</code> object (not primitive <code>int</code>) in different places to save memory. So it was added for performance reasons, not for code clarity. Now it's obsolete: even if you need an <code>Integer</code> object, you can use <code>Integer.valueOf(1)</code> or implicit autoboxing and get the cached one.</p>\n", "title": "Morbid use of constants", "tags": ["java", "constants"], "link": "http://stackoverflow.com/questions/31471444/morbid-use-of-constants/31471530#31471530", "post_type": "answer", "question_id": 31471444, "answer_id": 31471530}, {"body": "<p>From <a href=\"https://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/math/NumberUtils.html#INTEGER_ONE\" rel=\"nofollow\">Class NumberUtils</a> you'll see it's defined as:</p>\n\n<pre><code>/** Reusable Integer constant for one. */\npublic static final Integer INTEGER_ONE = new Integer(1)\n</code></pre>\n\n<p>So, you'll see that INTEGER_ONE is not the same as 1. It's an object that's already been constructed for you. So, if we're needing an instance of <code>Integer(1)</code>, rather than create your own, you can reuse the one from the library saving time and memory.</p>\n\n<p>It really depends on your application, if you indeed what the <code>int</code> version of 1, then, you'd probably be better of using that instead of this <code>Integer</code> class.</p>\n", "title": "Morbid use of constants", "tags": ["java", "constants"], "link": "http://stackoverflow.com/questions/31471444/morbid-use-of-constants/31476657#31476657", "post_type": "answer", "question_id": 31471444, "answer_id": 31476657}, {"body": "<p>It shouldn't have compiled, according to <a href=\"http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.21\" rel=\"nofollow\">JLS 7</a>. <code>int</code> can be compared to boxed numeric types, i.e. Byte, Short, Character, Integer, Long, Float, Double. But that is all.</p>\n\n<p>And if comparison is between <code>int</code> and say <code>Float</code>, <code>Float</code> will be unboxed first, so that the comparison is between <code>float</code> and <code>int</code>. It'll make no sense to do the other way around - box <code>int</code> then examine the identity of the <code>Integer</code> (with a <code>Float</code> no less).</p>\n", "title": "Why is an int-to-Object comparison valid in Java 7, but not in Java 8?", "tags": ["java"], "link": "http://stackoverflow.com/questions/32632364/why-is-an-int-to-object-comparison-valid-in-java-7-but-not-in-java-8/32633199#32633199", "post_type": "answer", "question_id": 32632364, "answer_id": 32633199}, {"body": "<p>The <code>java.time</code> API in general <em>does</em> have nanosecond precision. For example:</p>\n\n<pre><code>DateTimeFormatter formatter = DateTimeFormatter\n    .ofPattern(\"yyyy-MM-dd'T'HH:mm:ss,nnnnnnnnnZ\");\nOffsetDateTime odt = OffsetDateTime.of(2015, 11, 2, 12, 38, 0, 123456789, ZoneOffset.UTC);\nSystem.out.println(odt.format(formatter));\n</code></pre>\n\n<p>Output:</p>\n\n<pre><code>2015-11-02T12:38:00,123456789+0000\n</code></pre>\n\n<p>However, it's the clock value returned by <code>OffsetDateTime.now()</code> which is returning a value which only has milliseconds.</p>\n\n<p>From <a href=\"https://docs.oracle.com/javase/8/docs/api/java/time/Clock.html\" rel=\"nofollow\"><code>Clock</code></a> implementation in Java 8:</p>\n\n<blockquote>\n  <p>The clock implementation provided here is based on <code>System.currentTimeMillis()</code>. That method provides little to no guarantee about the accuracy of the clock. Applications requiring a more accurate clock must implement this abstract class themselves using a different external clock, such as an NTP server.</p>\n</blockquote>\n\n<p>So there's nothing inherently imprecise here - just the default implementation of <code>Clock</code> using <code>System.currentTimeMillis()</code>. You could potentially create your own more precise subclass. However, you should note that adding more precision without adding more <em>accuracy</em> probably isn't terribly useful. (There are times when it might be, admittedly...)</p>\n", "title": "Why does the new Java 8 Date Time API not have nanosecond precision?", "tags": ["java", "java-8", "java-time"], "link": "http://stackoverflow.com/questions/33477695/why-does-the-new-java-8-date-time-api-not-have-nanosecond-precision/33477803#33477803", "post_type": "answer", "question_id": 33477695, "answer_id": 33477803}, {"body": "<p>If type inference produces a single upper bound for a type variable, typically the upper bound is chosen as the solution. For example, if <code>T&lt;&lt;Number</code>, the solution is <code>T=Number</code>. Although <code>Integer</code>, <code>Float</code> etc. could also satisfy the constraint, there's no good reason to choose them over <code>Number</code>.</p>\n\n<p>That was also the case for <code>throws T</code> in java 5-7: <code>T&lt;&lt;Throwable  =&gt;  T=Throwable</code>. (Sneaky throw solutions all had explicit <code>&lt;RuntimeException&gt;</code> type arguments, otherwise <code>&lt;Throwable&gt;</code> is inferred.)</p>\n\n<p>In java8, with the introduction of lambda, this becomes problematic. Consider this case</p>\n\n<pre><code>interface Action&lt;T extends Throwable&gt;\n{\n    void doIt() throws T;\n}\n\n&lt;T extends Throwable&gt; void invoke(Action&lt;T&gt; action) throws T\n{\n    action.doIt(); // throws T\n}    \n</code></pre>\n\n<p>If we invoke with an empty lambda, what would <code>T</code> be inferred as?</p>\n\n<pre><code>    invoke( ()-&gt;{} ); \n</code></pre>\n\n<p>The only constraint on <code>T</code> is an upper bound <code>Throwable</code>. In earlier stage of java8, <code>T=Throwable</code> would be inferred. See this <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2013-February/007981.html\">report</a> I filed.</p>\n\n<p>But that is pretty silly, to infer <code>Throwable</code>, a checked exception, out of an empty block. A solution was proposed in the report (which is apparently adopted by JLS) -</p>\n\n<pre><code>If E has not been inferred from previous steps, and E is in the throw clause, \nand E has an upper constraint E&lt;&lt;X,\n    if X:&gt;RuntimeException, infer E=RuntimeException\n    otherwise, infer E=X. (X is an Error or a checked exception)\n</code></pre>\n\n<p>i.e. if the upper bound is <code>Exception</code> or <code>Throwable</code>, choose <code>RuntimeException</code> as the solution. In this case, there <em>is</em> a good reason to choose a particular subtype of the upper bound. </p>\n", "title": "A peculiar feature of exception type inference in Java 8", "tags": ["java", "generics", "java-8", "type-inference"], "link": "http://stackoverflow.com/questions/31316581/a-peculiar-feature-of-exception-type-inference-in-java-8/31327420#31327420", "post_type": "answer", "question_id": 31316581, "answer_id": 31327420}, {"body": "<p>You are consuming the value of <code>next()</code>, but asking for <code>hasNext()</code> and <code>hasNextLine()</code>. <code>next()</code>, per default, returns everything to the next <code>whitespace()</code>. So you are iterating through all whitespace seperated strings, and after each of them you are asking about the <code>nextLine()</code>.</p>\n\n<p><code>i   1   1</code> -> <code>hasNextLine()</code>? True. <code>hasNext()</code>? Also true.</p>\n\n<p><code>1   1</code> -> <code>hasNextLine()</code>? True. <code>hasNext()</code>? Also true (still a whitespace left)</p>\n\n<p><code>1</code> -> <code>hasNextLine()</code>? True (Line Seperator, probably). haxNext? False, no whitespace anymore.</p>\n", "title": "Why is hasNext() False, but hasNextLine() is True?", "tags": ["java", "java.util.scanner"], "link": "http://stackoverflow.com/questions/31993377/why-is-hasnext-false-but-hasnextline-is-true/31993478#31993478", "post_type": "answer", "question_id": 31993377, "answer_id": 31993478}, {"body": "<p>The reason is that <code>hasNext()</code> checks if there are any more non-whitespace characters available. <code>hasNextLine()</code> checks to see if there is another line of text available. Your text file probably has a newline at the end of it so it has another line but no more characters that are not whitespace.</p>\n\n<p>Many text editors automatically add a newline to the end of a file if there isn't one already.</p>\n\n<p>In other words, your input file is not this (the numbers are line numbers):</p>\n\n<pre><code>1. a   3   9\n2. b   3   6\n3. c   3   3\n4. d   2   8\n5. e   2   5\n</code></pre>\n\n<p>It is actually this:</p>\n\n<pre><code>1. a   3   9\n2. b   3   6\n3. c   3   3\n4. d   2   8\n5. e   2   5\n6. \n</code></pre>\n", "title": "Why is hasNext() False, but hasNextLine() is True?", "tags": ["java", "java.util.scanner"], "link": "http://stackoverflow.com/questions/31993377/why-is-hasnext-false-but-hasnextline-is-true/31993533#31993533", "post_type": "answer", "question_id": 31993377, "answer_id": 31993533}, {"body": "<h3>You have a single extra newline at the end of your file.</h3>\n\n<ul>\n<li><a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#hasNextLine()\"><code>hasNextLine()</code></a> checks to see if there is another <code>linePattern</code> in the buffer.</li>\n<li><a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#hasNext()\"><code>hasNext()</code></a> checks to see if there is a parseable token in the buffer, as separated by the scanner's delimiter.</li>\n</ul>\n\n<p>Since the scanner's delimiter is whitespace, and the <code>linePattern</code> is also white space, it is possible for there to be a <code>linePattern</code> in the buffer but no parseable tokens.</p>\n\n<p>Typically, the most common way to deal with this issue by always calling <code>nextLine()</code> after parsing all the tokens (e.g. numbers) in each line of your text. You need to do this when using <code>Scanner</code> when reading a user's input too from <code>System.in</code>. To advance the scanner past this whitespace delimiter, you must use <code>scanner.nextLine()</code> to clear the line delimiter. See: <a href=\"http://stackoverflow.com/q/5032356/1768232\">Using scanner.nextLine()</a></p>\n\n<hr>\n\n<p><strong>Appendix:</strong></p>\n\n<p><code>LinePattern</code> is defined to be a <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html\"><code>Pattern</code></a> that matches this:</p>\n\n<pre><code>private static final String LINE_SEPARATOR_PATTERN =\n                                       \"\\r\\n|[\\n\\r\\u2028\\u2029\\u0085]\";\nprivate static final String LINE_PATTERN = \".*(\"+LINE_SEPARATOR_PATTERN+\")|.+$\";\n</code></pre>\n\n<p>The default token delimiter is this <code>Pattern</code>:</p>\n\n<pre><code>private static Pattern WHITESPACE_PATTERN = Pattern.compile(\n                                            \"\\\\p{javaWhitespace}+\");\n</code></pre>\n", "title": "Why is hasNext() False, but hasNextLine() is True?", "tags": ["java", "java.util.scanner"], "link": "http://stackoverflow.com/questions/31993377/why-is-hasnext-false-but-hasnextline-is-true/31993534#31993534", "post_type": "answer", "question_id": 31993377, "answer_id": 31993534}, {"body": "<p>Technically, it's <code>10</code>, not zero, if you admit for a lazy initialisation of the backing array. See:</p>\n\n<pre><code>public boolean add(E e) {\n    ensureCapacityInternal(size + 1);\n    elementData[size++] = e;\n    return true;\n}\n\nprivate void ensureCapacityInternal(int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n\n    ensureExplicitCapacity(minCapacity);\n}\n</code></pre>\n\n<p>where</p>\n\n<pre><code>/**\n * Default initial capacity.\n */\nprivate static final int DEFAULT_CAPACITY = 10;\n</code></pre>\n\n<p>What you're referring to is just the zero-sized initial array object that is shared among all initially empty <code>ArrayList</code> objects. I.e. the capacity of <code>10</code> is guaranteed <em>lazily</em>, an optimisation that is present also in Java 7.</p>\n\n<p>Admittedly, the constructor contract is not entirely accurate. Perhaps this is the source of confusion here.</p>\n\n<h3>Background</h3>\n\n<p>Here's an E-Mail by Mike Duigou</p>\n\n<blockquote>\n  <p>I have posted an updated version of the empty ArrayList and HashMap patch.</p>\n  \n  <p><a href=\"http://cr.openjdk.java.net/~mduigou/JDK-7143928/1/webrev/\">http://cr.openjdk.java.net/~mduigou/JDK-7143928/1/webrev/</a></p>\n  \n  <p>This revised implementation introduces <em>no new fields</em> to either class. For ArrayList the lazy allocation of the backing array occurs only if the list is created at default size. According to our performance analysis team, approximately 85% of ArrayList instances are created at default size so this optimization will be valid for an overwhelming majority of cases. </p>\n  \n  <p>For HashMap, creative use is made of the threshold field to track the requested initial size until the bucket array is needed. On the read side the empty map case is tested with isEmpty(). On the write size a comparison of (table == EMPTY_TABLE) is used to detect the need to inflate the bucket array. In readObject there's a little more work to try to choose an efficient initial capacity.</p>\n  \n  <p><em>From: <a href=\"http://mail.openjdk.java.net/pipermail/core-libs-dev/2013-April/015585.html\">http://mail.openjdk.java.net/pipermail/core-libs-dev/2013-April/015585.html</a></em></p>\n</blockquote>\n", "title": "In Java 8, why is the default capacity of ArrayList now zero?", "tags": ["java", "arraylist", "java-8"], "link": "http://stackoverflow.com/questions/34250207/in-java-8-why-is-the-default-capacity-of-arraylist-now-zero/34250231#34250231", "post_type": "answer", "question_id": 34250207, "answer_id": 34250231}, {"body": "<p>Despite of the fact that there is no <code>AtomicDouble</code> or <code>AtomicDoubleArray</code> in java, you can easily create your own based on <code>AtomicLongArray</code>.</p>\n\n<pre><code>static class AtomicDoubleArray {\n    private final AtomicLongArray inner;\n\n    public AtomicDoubleArray(int length) {\n        inner = new AtomicLongArray(length);\n    }\n\n    public int length() {\n        return inner.length();\n    }\n\n    public double get(int i) {\n        return Double.longBitsToDouble(inner.get(i));\n    }\n\n    public void set(int i, double newValue) {\n        inner.set(i, Double.doubleToLongBits(newValue));\n    }\n\n    public void add(int i, double delta) {\n        long prevLong, nextLong;\n        do {\n            prevLong = inner.get(i);\n            nextLong = Double.doubleToLongBits(Double.longBitsToDouble(prevLong) + delta);\n        } while (!inner.compareAndSet(i, prevLong, nextLong));\n    }\n}\n</code></pre>\n\n<p>As you can see, I use <code>Double.doubleToLongBits</code> and <code>Double.longBitsToDouble</code> to store <code>Doubles</code> as <code>Longs</code> in <code>AtomicLongArray</code>. They both have the same size in bits, so precision is not lost (except for -NaN, but I don't think it is important).</p>\n\n<p>In Java 8 the implementation of <code>add</code> can be even easier, as you can use <code>accumulateAndGet</code> method of <code>AtomicLongArray</code> that was added in java 1.8.</p>\n\n<p><strong>Upd</strong>: It appears that I virtually re-implemented guava's <a href=\"https://code.google.com/p/guava-libraries/source/browse/guava/src/com/google/common/util/concurrent/AtomicDoubleArray.java?r=8b5f8e0945ee9e0bbd7048945f17d2fdc2b108e0\">AtomicDoubleArray</a>.</p>\n", "title": "Is the += operator thread-safe in Java?", "tags": ["java", "multithreading"], "link": "http://stackoverflow.com/questions/32676771/is-the-operator-thread-safe-in-java/32677400#32677400", "post_type": "answer", "question_id": 32676771, "answer_id": 32677400}, {"body": "<p>Ironically default methods in interfaces were introduced to allow existing libraries using those interfaces <em>not</em> to break, while introducing massive <em>new</em> functionality in the interfaces. (backward compatibility.)</p>\n\n<p>Conflicts like that <code>sort</code> method might arise. Something to pay for the extra functionality. In your case also something to investigate (should new functionality be used instead?).</p>\n\n<p>Java forward compatibility breaks are little, more in its typing system, which was constantly enlarged. First with generic types and now with inferred types from functional interfaces. From version to version and from compiler to compiler there were slight differences.</p>\n", "title": "Do Java 8 default methods break source compatibility?", "tags": ["java", "java-8", "default-method", "forward-compatibility"], "link": "http://stackoverflow.com/questions/31188231/do-java-8-default-methods-break-source-compatibility/31188818#31188818", "post_type": "answer", "question_id": 31188231, "answer_id": 31188818}, {"body": "<p>We can draw a parallel with abstract class. An abstract class is intended to be subclassed so that the abstract methods can be implemented. The abstract class itself contains concrete methods that invoke the abstract methods. The abstract class is free to evolve by adding more concrete methods; and this practice may break subclasses.</p>\n\n<p>Therefore the exact problem you described existed even before Java8. The problem is much more manifested on Collection APIs because there are a lot of subclasses out in the wild.</p>\n\n<p>While the leading motivation of default method was to add some useful methods to existing Collection APIs without breaking subclasses, they had to exercise great self-control of doing it too much, for fear of breaking subclasses. A default method is added only if it's absolutely necessary. The real question here is, why <code>List.sort</code> is considered absolutely necessary. I think that is debatable. </p>\n\n<p>Regardless of why default method was introduced in the 1st place, it is now a great tool for API designers, and we ought to treat it the same as concrete methods in abstract classes - they need to be designed carefully up front; and new ones must be introduced with great caution. </p>\n", "title": "Do Java 8 default methods break source compatibility?", "tags": ["java", "java-8", "default-method", "forward-compatibility"], "link": "http://stackoverflow.com/questions/31188231/do-java-8-default-methods-break-source-compatibility/31190722#31190722", "post_type": "answer", "question_id": 31188231, "answer_id": 31190722}, {"body": "<p>As you said internally the last concatenation is done to something similar to</p>\n\n<pre><code>String e = new StringBuilder().append(c).append(\"ender\").toString();\n</code></pre>\n\n<p>the implementation of <code>toString()</code> of <code>StringBuilder</code> <strong>creates a new String</strong>. Here is the implementation.</p>\n\n<pre><code>public String toString() {\n     // Create a copy, don't share the array\n     return new String(value, 0, count);\n}\n</code></pre>\n\n<p>Comparing strings using <code>==</code> instead of <code>.equals()</code> <strong>returns <code>true</code> only if both strings are the same</strong>. In this case <strong>they are not the same because the second string is created as a new</strong> object of type <strong><code>String</code></strong>.</p>\n\n<p>The other concatenations are performed directly by the compiler so no new String is created.</p>\n", "title": "&quot;==&quot; in case of String concatenation in Java", "tags": ["java", "string"], "link": "http://stackoverflow.com/questions/34509566/in-case-of-string-concatenation-in-java/34509655#34509655", "post_type": "answer", "question_id": 34509566, "answer_id": 34509655}, {"body": "<p>Four things are going on:</p>\n\n<ol>\n<li><p>(You clearly know this, but for lurkers) <code>==</code> tests to see if the variables point to the <strong>same <code>String</code> object</strong>, not <em>equivalent</em> strings. So even if <code>x</code> is <code>\"foo\"</code> and <code>y</code> is also <code>\"foo\"</code>, <code>x == y</code> may be true or false, depending on whether <code>x</code> and <code>y</code> refer to the same <code>String</code> object or different ones. That's why we use <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#equals-java.lang.Object-\"><code>equals</code></a>, not <code>==</code>, to compare strings for equivalence. All of the following is just meant to explain why <code>==</code> is sometimes true, it's not a suggestion to use <code>==</code> to compare strings. :-)</p></li>\n<li><p>Equivalent string constants (strings the compiler knows are constants according to various rules in the JLS) within the same class are made to refer to the same string by the compiler (which also lists them in the class's <a href=\"https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4\">\"constant pool\"</a>). That's why <code>a == b</code> is true.</p></li>\n<li><p>When the class is loaded, each of its string constants is automatically <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#intern--\"><em>interned</em></a>&nbsp;&mdash; the JVM's string pool is checked for an equivalent string and if one is found, that <code>String</code> object is used (if not, the new <code>String</code> object for the new constant is added to the pool). So even if <code>x</code> is a string constant initialized in class <code>Foo</code> and <code>y</code> is a string constant initialized in class <code>Bar</code>, they'll be <code>==</code> each other.</p>\n\n<p>Points 2 and 3 above are covered in part by <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5\">JLS\u00a73.10.5</a>. (The bit about the class constant pool is a bit of an implementation detail, hence the link to the JVM spec earlier; the JLS just speaks of interning.)</p></li>\n<li><p>The compiler does string concatenation if it's dealing with constant values, so </p>\n\n<pre><code>String d = \"dev\" + \"ender\";\n</code></pre>\n\n<p>is compiled to</p>\n\n<pre><code>String d = \"devender\";\n</code></pre>\n\n<p>and <code>\"devender\"</code> is a string constant the compiler and JVM apply points 2 and 3 above to. E.g., no <code>StringBuilder</code> is used, the concatenation happens at <em>compile-time</em>, not runtime. This is covered in <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.28\">JLS\u00a715.28 - <em>Constant Expressions</em></a>. So <code>a == d</code> is true for the same reason <code>a == b</code> is true: They refer to the same constant string, so the compiler ensured they were referring to the same string in the class's constant pool.</p>\n\n<p>The compiler can't do that when any of the operands is not a constant, so it can't do that with:</p>\n\n<pre><code>String e = c + \"ender\";\n</code></pre>\n\n<p>...even though code analysis could easily show that the value of <code>c</code> will definitely be <code>\"dev\"</code> and thus <code>e</code> will definitely be <code>\"devender\"</code>. The specification only has the compiler do the concatenation with constant values, specifically. So since the compiler can't do it, it outputs the <code>StringBuilder</code> code you referred to and that work is done at runtime, creating a new <code>String</code> object. That string isn't automatically interned, so <code>e</code> ends up referring to a different <code>String</code> object than <code>a</code> does, and so <code>a == e</code> is false.</p>\n\n<p>Note that <a href=\"http://stackoverflow.com/questions/34509566/in-case-of-string-concatenation-in-java/34509659#comment56760592_34509566\">as Vinod said</a>, if you declared <code>c</code> as <code>final</code>:</p>\n\n<pre><code>final String c = \"dev\";\n</code></pre>\n\n<p>Then it would be a <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.12.4\"><em>constant variable</em></a> (yes, they're really called that) and so \u00a715.28 would apply and the compiler would turn</p>\n\n<pre><code>String e = c + \"ender\";\n</code></pre>\n\n<p>into</p>\n\n<pre><code>String e = \"devender\";\n</code></pre>\n\n<p>and <code>a == e</code> would also be true.</p></li>\n</ol>\n\n<p>Just to reiterate: None of which means we should use <code>==</code> to compare strings for equivalence. :-) That's what <code>equals</code> is for.</p>\n", "title": "&quot;==&quot; in case of String concatenation in Java", "tags": ["java", "string"], "link": "http://stackoverflow.com/questions/34509566/in-case-of-string-concatenation-in-java/34509659#34509659", "post_type": "answer", "question_id": 34509566, "answer_id": 34509659}, {"body": "<p>The difference between <code>d</code> and <code>e</code> is that when you concatenate string <em>literals</em>, the concatenation is performed at compile time. Java compiler treats <code>\"dev\" + \"ender\"</code> expression in the same way as <code>\"devender\"</code> expression, producing the same literal at compile time. Since all <code>String</code> literals get interned, <code>d</code>, which is a result of <code>\"dev\" + \"ender\"</code>, also ends up referencing the same object as <code>a</code> and <code>b</code>'s <code>\"devender\"</code>. </p>\n\n<p>The expression for <code>e</code>, which is <code>c + \"ender\"</code>, is evaluated at <em>runtime</em>. Even though it produces the same string, this fact is not used by the compiler. That's why a different <code>String</code> object is produced, resulting in failed comparison on <code>==</code>.</p>\n", "title": "&quot;==&quot; in case of String concatenation in Java", "tags": ["java", "string"], "link": "http://stackoverflow.com/questions/34509566/in-case-of-string-concatenation-in-java/34509669#34509669", "post_type": "answer", "question_id": 34509566, "answer_id": 34509669}, {"body": "<p>Keep in mind that Java holds a pool of all string literals found in program, used for matching purposes among others, so any different string <strong>literal</strong> concatenation above will lead to the same object, to the same string literal. You can check out <a href=\"http://www.xyzws.com/javafaq/what-is-string-literal-pool/3\" rel=\"nofollow\">this</a> useful article for more.</p>\n\n<p>On the other hand, the concatenation of a <code>String</code> object and a literal (case <code>c + \"ender\"</code>) will lead to the creation of a as <code>StringBuilder</code> object at runtime, different to the literals found in pool.</p>\n", "title": "&quot;==&quot; in case of String concatenation in Java", "tags": ["java", "string"], "link": "http://stackoverflow.com/questions/34509566/in-case-of-string-concatenation-in-java/34529067#34529067", "post_type": "answer", "question_id": 34509566, "answer_id": 34529067}, {"body": "<p>The API guarantees a <em>stable</em> sorting which Quicksort doesn\u2019t offer. However, when sorting <em>primitive values</em> by their natural order you won\u2019t notice a difference as primitive values have no identity. Therefore, Quicksort is used for primitive arrays as it is slightly more efficient.</p>\n\n<p>For objects you may notice, when objects which are deemed equal according to their <code>equals</code> implementation or the provided <code>Comparator</code> change their order. Therefore, Quicksort is not an option. So a variant of MergeSort is used, the current Java versions use <em>TimSort</em>. This applies to both, <code>Arrays.sort</code> and <code>Collections.sort</code>, though with Java\u00a08, the <code>List</code> itself may override the sort algorithms.</p>\n", "title": "Why does Collections.sort use Mergesort but Arrays.sort does not?", "tags": ["java", "arrays", "sorting", "collections", "java-8"], "link": "http://stackoverflow.com/questions/32334319/why-does-collections-sort-use-mergesort-but-arrays-sort-does-not/32334651#32334651", "post_type": "answer", "question_id": 32334319, "answer_id": 32334651}, {"body": "<p>As stated across many of the answers.</p>\n\n<p>The Quicksort is used by Arrays.sort for sorting primitive collections because stability isn't required (you won't know or care if two identical ints were swapped in the sort)</p>\n\n<p>MergeSort or more specifically Timsort is used by Arrays.sort for sorting collections of objects. Stability is required. Quicksort does not provide for stability, Timsort does.  </p>\n\n<p>Collections.sort delegates to Arrays.sort which is why you see the javadoc referencing the MergeSort.</p>\n", "title": "Why does Collections.sort use Mergesort but Arrays.sort does not?", "tags": ["java", "arrays", "sorting", "collections", "java-8"], "link": "http://stackoverflow.com/questions/32334319/why-does-collections-sort-use-mergesort-but-arrays-sort-does-not/39380442#39380442", "post_type": "answer", "question_id": 32334319, "answer_id": 39380442}, {"body": "<p>Presented below is the full code of the <code>Exceptional</code> class. It has a quite large API which is a pure extension of the <code>Optional</code> API so it can be a drop-in replacement for it in any existing code&mdash;except that it isn't a subtype of the final <code>Optional</code> class. The class can be seen as being in the same relationship with the <a href=\"http://mauricio.github.io/2014/02/17/scala-either-try-and-the-m-word.html\"><code>Try</code></a> monad as <code>Optional</code> is with the <code>Maybe</code> monad: it draws inspiration from it, but is adapted to the Java idiom (such as actually throwing exceptions, even from non-terminal operations).</p>\n\n<p>These are some key guidelines followed by the class:</p>\n\n<ul>\n<li><p>as opposed to the monadic approach, doesn't ignore Java's exception mechanism; </p></li>\n<li><p>instead it relieves the impedance mismatch between exceptions and higher-order functions;</p></li>\n<li><p>exception handling not statically typesafe (due to sneaky throwing), but always safe at runtime (never swallows an exception except on explicit request).</p></li>\n</ul>\n\n<p>The class tries to cover all the typical ways to handle an exception:</p>\n\n<ul>\n<li><code>recover</code> with some handling code which provides a substitute value;</li>\n<li><code>flatRecover</code> which, analogous to <code>flatMap</code>, allows to return a new <code>Exceptional</code> instance which will be unwrapped and the state of the current instance suitably updated;</li>\n<li><code>propagate</code> an exception, throwing it from the <code>Exceptional</code> expression and making the <code>propagate</code> call declare this exception type;</li>\n<li><code>propagate</code> it after wrapping into another exception (<em>translate</em> it);</li>\n<li><code>handle</code> it, resulting in an empty <code>Exceptional</code>;</li>\n<li>as a special case of handling, <code>swallow</code> it with an empty handler block.</li>\n</ul>\n\n<p>The <code>propagate</code> approach allows one to selectively pick which checked exceptions he wants to expose from his code. Exceptions which remain unhandled at the time a terminal operation is called (like <code>get</code>) will be <em>sneakily</em> thrown without declaration. This is often considered as an advanced and dangerous approach, but is nevertheless often employed as a way to somewhat alleviate the nuisance of checked exceptions in combination with lambda shapes which do not declare them. The <code>Exceptional</code> class hopes to offer a cleaner and more selective alternative to sneaky throw.</p>\n\n<hr>\n\n<pre><code>/*\n * Copyright (c) 2015, Marko Topolnik. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\npublic final class Exceptional&lt;T&gt;\n{\n  private final T value;\n  private final Throwable exception;\n\n  private Exceptional(T value, Throwable exc) {\n    this.value = value;\n    this.exception = exc;\n  }\n\n  public static &lt;T&gt; Exceptional&lt;T&gt; empty() {\n    return new Exceptional&lt;&gt;(null, null);\n  }\n\n  public static &lt;T&gt; Exceptional&lt;T&gt; ofNullable(T value) {\n    return value != null ? of(value) : empty();\n  }\n\n  public static &lt;T&gt; Exceptional&lt;T&gt; of(T value) {\n    return new Exceptional&lt;&gt;(Objects.requireNonNull(value), null);\n  }\n\n  public static &lt;T&gt; Exceptional&lt;T&gt; ofNullableException(Throwable exception) {\n    return exception != null? new Exceptional&lt;&gt;(null, exception) : empty();\n  }\n\n  public static &lt;T&gt; Exceptional&lt;T&gt; ofException(Throwable exception) {\n    return new Exceptional&lt;&gt;(null, Objects.requireNonNull(exception));\n  }\n\n  public static &lt;T&gt; Exceptional&lt;T&gt; from(TrySupplier&lt;T&gt; supplier) {\n    try {\n      return ofNullable(supplier.tryGet());\n    } catch (Throwable t) {\n      return new Exceptional&lt;&gt;(null, t);\n    }\n  }\n\n  public static Exceptional&lt;Void&gt; fromVoid(TryRunnable task) {\n    try {\n      task.run();\n      return new Exceptional&lt;&gt;(null, null);\n    } catch (Throwable t) {\n      return new Exceptional&lt;&gt;(null, t);\n    }\n  }\n\n  public static &lt;E extends Throwable&gt; Consumer&lt;? super E&gt; swallow() {\n    return e -&gt; {};\n  }\n\n  public T get() {\n    if (value != null) return value;\n    if (exception != null) sneakyThrow(exception);\n    throw new NoSuchElementException(\"No value present\");\n  }\n\n  public T orElse(T other) {\n    if (value != null) return value;\n    if (exception != null) sneakyThrow(exception);\n    return other;\n  }\n\n  public T orElseGet(Supplier&lt;? extends T&gt; other) {\n    if (value != null) return value;\n    if (exception != null) sneakyThrow(exception);\n    return other.get();\n  }\n\n  public&lt;U&gt; Exceptional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) {\n    Objects.requireNonNull(mapper);\n    if (value == null) return new Exceptional&lt;&gt;(null, exception);\n    final U u;\n    try {\n      u = mapper.apply(value);\n    } catch (Throwable exc) {\n      return new Exceptional&lt;&gt;(null, exc);\n    }\n    return ofNullable(u);\n  }\n\n  public&lt;U&gt; Exceptional&lt;U&gt; flatMap(Function&lt;? super T, Exceptional&lt;U&gt;&gt; mapper) {\n    Objects.requireNonNull(mapper);\n    return value != null ? Objects.requireNonNull(mapper.apply(value)) : empty();\n  }\n\n  public Exceptional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) {\n    Objects.requireNonNull(predicate);\n    if (value == null) return this;\n    final boolean b;\n    try {\n      b = predicate.test(value);\n    } catch (Throwable t) {\n      return ofException(t);\n    }\n    return b ? this : empty();\n  }\n\n  public &lt;X extends Throwable&gt; Exceptional&lt;T&gt; recover(\n      Class&lt;? extends X&gt; excType, Function&lt;? super X, T&gt; mapper)\n  {\n    Objects.requireNonNull(mapper);\n    return excType.isInstance(exception) ? ofNullable(mapper.apply(excType.cast(exception))) : this;\n  }\n\n  public &lt;X extends Throwable&gt; Exceptional&lt;T&gt; recover(\n      Iterable&lt;Class&lt;? extends X&gt;&gt; excTypes, Function&lt;? super X, T&gt; mapper)\n  {\n    Objects.requireNonNull(mapper);\n    for (Class&lt;? extends X&gt; excType : excTypes)\n      if (excType.isInstance(exception))\n        return ofNullable(mapper.apply(excType.cast(exception)));\n    return this;\n  }\n\n  public &lt;X extends Throwable&gt; Exceptional&lt;T&gt; flatRecover(\n      Class&lt;? extends X&gt; excType, Function&lt;? super X, Exceptional&lt;T&gt;&gt; mapper)\n  {\n    Objects.requireNonNull(mapper);\n    return excType.isInstance(exception) ? Objects.requireNonNull(mapper.apply(excType.cast(exception))) : this;\n  }\n\n  public &lt;X extends Throwable&gt; Exceptional&lt;T&gt; flatRecover(\n      Iterable&lt;Class&lt;? extends X&gt;&gt; excTypes, Function&lt;? super X, Exceptional&lt;T&gt;&gt; mapper)\n  {\n    Objects.requireNonNull(mapper);\n    for (Class&lt;? extends X&gt; c : excTypes)\n      if (c.isInstance(exception))\n        return Objects.requireNonNull(mapper.apply(c.cast(exception)));\n    return this;\n  }\n\n  public &lt;E extends Throwable&gt; Exceptional&lt;T&gt; propagate(Class&lt;E&gt; excType) throws E {\n    if (excType.isInstance(exception))\n      throw excType.cast(exception);\n    return this;\n  }\n\n  public &lt;E extends Throwable&gt; Exceptional&lt;T&gt; propagate(Iterable&lt;Class&lt;? extends E&gt;&gt; excTypes) throws E {\n    for (Class&lt;? extends E&gt; excType : excTypes)\n      if (excType.isInstance(exception))\n        throw excType.cast(exception);\n    return this;\n  }\n\n  public &lt;E extends Throwable, F extends Throwable&gt; Exceptional&lt;T&gt; propagate(\n      Class&lt;E&gt; excType, Function&lt;? super E, ? extends F&gt; translator)\n  throws F\n  {\n    if (excType.isInstance(exception))\n      throw translator.apply(excType.cast(exception));\n    return this;\n  }\n\n  public &lt;E extends Throwable, F extends Throwable&gt; Exceptional&lt;T&gt; propagate(\n      Iterable&lt;Class&lt;E&gt;&gt; excTypes, Function&lt;? super E, ? extends F&gt; translator)\n  throws F\n  {\n    for (Class&lt;? extends E&gt; excType : excTypes)\n      if (excType.isInstance(exception))\n        throw translator.apply(excType.cast(exception));\n    return this;\n  }\n\n  public &lt;E extends Throwable&gt; Exceptional&lt;T&gt; handle(Class&lt;E&gt; excType, Consumer&lt;? super E&gt; action) {\n    if (excType.isInstance(exception)) {\n      action.accept(excType.cast(exception));\n      return empty();\n    }\n    return this;\n  }\n\n  public &lt;E extends Throwable&gt; Exceptional&lt;T&gt; handle(Iterable&lt;Class&lt;E&gt;&gt; excTypes, Consumer&lt;? super E&gt; action) {\n    for (Class&lt;? extends E&gt; excType : excTypes)\n      if (excType.isInstance(exception)) {\n        action.accept(excType.cast(exception));\n        return empty();\n      }\n    return this;\n  }\n\n  public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X {\n    if (value != null) return value;\n    if (exception != null) sneakyThrow(exception);\n    throw exceptionSupplier.get();\n  }\n\n  public boolean isPresent() {\n    return value != null;\n  }\n\n  public void ifPresent(Consumer&lt;? super T&gt; consumer) {\n    if (value != null)\n      consumer.accept(value);\n    if (exception != null) sneakyThrow(exception);\n  }\n\n  public boolean isException() {\n    return exception != null;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) return true;\n    return obj instanceof Exceptional &amp;&amp; Objects.equals(value, ((Exceptional)obj).value);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hashCode(value);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private static &lt;T extends Throwable&gt; void sneakyThrow(Throwable t) throws T {\n    throw (T) t;\n  }\n}\n</code></pre>\n\n<hr>\n\n<pre><code>@FunctionalInterface\npublic interface TrySupplier&lt;T&gt; {\n  T tryGet() throws Throwable;\n}\n</code></pre>\n\n<hr>\n\n<pre><code>@FunctionalInterface\npublic interface TryRunnable {\n  void run() throws Throwable;\n}\n</code></pre>\n", "title": "A better approach to handling exceptions in a functional way", "tags": ["java", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/31270759/a-better-approach-to-handling-exceptions-in-a-functional-way/31270760#31270760", "post_type": "answer", "question_id": 31270759, "answer_id": 31270760}, {"body": "<p>What if every functional interface provided by <code>java.util.function</code> was allowed to throw an exception?</p>\n\n<pre><code>public interface ThrowingSupplier&lt;R, X extends Throwable&gt; {\n    public R get() throws X;\n}\n</code></pre>\n\n<p>We could use some default methods to provide the behavior you want.</p>\n\n<ul>\n<li>You could <em>fallback to</em> some default value or action</li>\n<li><em>Or</em> you could <em>try</em> to perform another action which may throw an exception</li>\n</ul>\n\n<p>I've <a href=\"https://github.com/JeffreyFalgout/ThrowingStream/tree/master/src/main/java/throwing/function\" rel=\"nofollow\">written a library</a> which redefines most of the interfaces in <code>java.util.function</code> this way. I even provide a <a href=\"https://github.com/JeffreyFalgout/ThrowingStream/blob/master/README.md\" rel=\"nofollow\"><code>ThrowingStream</code></a> which let's you use these new interfaces with the same API as a regular <code>Stream</code>. </p>\n\n<pre><code>@FunctionalInterface\npublic interface ThrowingSupplier&lt;R, X extends Throwable&gt; {\n    public R get() throws X;\n\n    default public Supplier&lt;R&gt; fallbackTo(Supplier&lt;? extends R&gt; supplier) {\n        ThrowingSupplier&lt;R, Nothing&gt; t = supplier::get;\n        return orTry(t)::get;\n    }\n\n    default public &lt;Y extends Throwable&gt; ThrowingSupplier&lt;R, Y&gt; orTry(\n            ThrowingSupplier&lt;? extends R, ? extends Y&gt; supplier) {\n        Objects.requireNonNull(supplier, \"supplier\");\n        return () -&gt; {\n            try {\n                return get();\n            } catch (Throwable x) {\n                try {\n                    return supplier.get();\n                } catch (Throwable y) {\n                    y.addSuppressed(x);\n                    throw y;\n                }\n            }\n        };\n    }\n}\n</code></pre>\n\n<p>(<a href=\"https://github.com/JeffreyFalgout/ThrowingStream/blob/master/src/main/java/throwing/Nothing.java\" rel=\"nofollow\"><code>Nothing</code></a> is a <code>RuntimeException</code> that can never be thrown.)</p>\n\n<hr>\n\n<p>Your original example would become</p>\n\n<pre><code>ThrowingFunction&lt;String, Integer, NumberFormatException&gt; parse = Integer::parseInt;\nFunction&lt;String, Optional&lt;Integer&gt;&gt; safeParse = parse.fallbackTo(s -&gt; null)\n    .andThen(Optional::ofNullable);\nStream.of(s1, s2)\n    .map(safeParse)\n    .map(i -&gt; i.orElse(-1))\n    .forEach(System.out::println);\n</code></pre>\n", "title": "A better approach to handling exceptions in a functional way", "tags": ["java", "java-8", "java-stream"], "link": "http://stackoverflow.com/questions/31270759/a-better-approach-to-handling-exceptions-in-a-functional-way/31273726#31273726", "post_type": "answer", "question_id": 31270759, "answer_id": 31273726}, {"body": "<p>An empty <code>HashMap</code> object is much smaller than an array of 2000 <code>Object</code> references. Even though you pass 2000 to the <code>initialCapacity</code> parameter of the <code>HashMap</code> constructor, it's not actually creating 2000 spaces for objects yet.</p>\n", "title": "Why is creating a HashMap faster than creating an Object[]?", "tags": ["java", "arrays", "performance", "hashmap"], "link": "http://stackoverflow.com/questions/31419029/why-is-creating-a-hashmap-faster-than-creating-an-object/31419047#31419047", "post_type": "answer", "question_id": 31419029, "answer_id": 31419047}, {"body": "<p>If you look at the implementation of <code>HashMap</code>, the constructor looks like: </p>\n\n<pre><code>public HashMap(int initialCapacity, float loadFactor) {\n    if (initialCapacity &lt; 0)\n        throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                           initialCapacity);\n    if (initialCapacity &gt; MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                           loadFactor);\n\n    this.loadFactor = loadFactor;\n    threshold = initialCapacity;\n    init();\n}\n</code></pre>\n\n<p>And <code>init()</code> looks like:</p>\n\n<pre><code>/**\n * Initialization hook for subclasses. This method is called\n * in all constructors and pseudo-constructors (clone, readObject)\n * after HashMap has been initialized but before any entries have\n * been inserted.  (In the absence of this method, readObject would\n * require explicit knowledge of subclasses.)\n */\nvoid init() {\n}\n</code></pre>\n\n<p>So <code>initialCapacity</code> doesn't actually get used to create an array. Where does it get used? Look at the <code>put()</code> method. </p>\n\n<pre><code>public V put(K key, V value) {\n    if (table == EMPTY_TABLE) {\n        inflateTable(threshold);\n    }\n    // hidden\n} \n</code></pre>\n\n<p>When doing a put, the array is actually created. I didn't show <code>inflateTable()</code> but it does some math and initializes the array. </p>\n", "title": "Why is creating a HashMap faster than creating an Object[]?", "tags": ["java", "arrays", "performance", "hashmap"], "link": "http://stackoverflow.com/questions/31419029/why-is-creating-a-hashmap-faster-than-creating-an-object/31419077#31419077", "post_type": "answer", "question_id": 31419029, "answer_id": 31419077}, {"body": "<blockquote>\n  <p>when Java thread dies, it too does not impact other threads</p>\n</blockquote>\n\n<p>Let me ask a counterquestion: why do you think <code>Thread.stop()</code> has been deprecated for more than a decade? The reason why is precisely the negation of your statement above.</p>\n\n<p>To give two specific examples: you <code>stop()</code> a thread while it's executing something as innocuous-sounding as <code>System.out.println()</code> or <code>Math.random()</code>. Result: those two features are now broken for the entire JVM. The same pertains to any other synchronized code your application may execute.</p>\n\n<blockquote>\n  <p>if we are looking at request-processing threads</p>\n</blockquote>\n\n<p>The application <em>may</em> theoretically be coded such that absolutely no shared resource protected by locks is ever used; however that will only help to point out the exact extent to which Java threads are codependent. And the \"independence\" achieved will only pertain to the request-processing threads, not to <em>all</em> threads in such an application.</p>\n", "title": "Erlang Process vs Java Thread", "tags": ["java", "erlang", "elixir"], "link": "http://stackoverflow.com/questions/32294367/erlang-process-vs-java-thread/32294898#32294898", "post_type": "answer", "question_id": 32294367, "answer_id": 32294898}, {"body": "<blockquote>\n  <p>Isn't that true for Java threads as well? I mean when Java thread crashes, it too does not crash other threads</p>\n</blockquote>\n\n<p>Yes and No. I explain:</p>\n\n<ul>\n<li><p>Referring to shared memory: Different threads in a Java process share the whole heap, therefore threads can interact in a huge number of planned and unplanned ways. <strong>However</strong> objects in the stack (e.g. a context you pass down to called method) or a <code>ThreadLocal</code> are their own thread's (unless they start sharing references).</p></li>\n<li><p>Crashing: If a thread crashes in Java (a <code>Throwable</code> is propagated into <code>Thread.run()</code>, or something gets looped or blocked), that mishap might not affect other threads (e.g. a pool of connections in a server will continue to operate). <strong>However</strong> as different threads interact. Other threads will easily get stranded if one of them ends abnormally (e.g. one thread trying to read from an empty pipe from another thread which did not close its end). So unless the developers are highly <s>paranoid</s> careful, it is very likely that side effects will occur.</p></li>\n</ul>\n\n<p>I doubt that any other paradigm intends threads to operate as totally independent islands. They must share information and coordinate somehow. And then there will be the chance to mess things up. It is just they will take a more defensive approach that \"gives you less rope to hang yourself\" (same idiom as with pointers).</p>\n", "title": "Erlang Process vs Java Thread", "tags": ["java", "erlang", "elixir"], "link": "http://stackoverflow.com/questions/32294367/erlang-process-vs-java-thread/32378895#32378895", "post_type": "answer", "question_id": 32294367, "answer_id": 32378895}, {"body": "<blockquote>\n  <p>how do I determine if the object referenced by boo is modified inside the body of the function (maybe using annotations)? </p>\n</blockquote>\n\n<p>The only way is to read the code unfortunately.</p>\n\n<blockquote>\n  <p>If there is no way to know, is there some widely used convention or some best practices to avoid confusion and bugs?</p>\n</blockquote>\n\n<p>The common convention is to pass an object which cannot be modified, using a wrapper if needed.  This ensure the class cannot modify the object.</p>\n\n<pre><code>List&lt;String&gt; readOnly = Collections.unmodifiableList(list);\n</code></pre>\n\n<p>If the object is Cloneable, you can also use <code>clone()</code> but another common approach is to use a copy.</p>\n\n<pre><code>List&lt;String&gt; readOnly = new ArrayList&lt;&gt;(list);\n</code></pre>\n\n<p>If you care about such behaviour, unit tests can show whether a method modifies an object or not.  If you have unit tests already, it is usually one or two lines extra to check for this.</p>\n", "title": "How to determine if a Java method modifies an object passed as parameter", "tags": ["java", "immutability"], "link": "http://stackoverflow.com/questions/32164385/how-to-determine-if-a-java-method-modifies-an-object-passed-as-parameter/32164423#32164423", "post_type": "answer", "question_id": 32164385, "answer_id": 32164423}, {"body": "<blockquote>\n  <p>How do I determine if the object referenced by boo is modified inside\n  the body of the function (maybe using annotations)?</p>\n</blockquote>\n\n<p>I must agree with other answers that there is no direct way to determine that method will modify your object or not and yes to make sure that method can not modify your <code>Object</code> you all have to do it is from your side.</p>\n\n<blockquote>\n  <p>If there is no way to know, is there some widely used convention or\n  some best practices to avoid confusion and bugs?</p>\n</blockquote>\n\n<p>Here the <strong><em>method name</em></strong> comes to the scene. Moving ahead with the naming convention of method we have to take a look at some method declarations which clearly convince you that your <code>Object</code> will not be changed at all.</p>\n\n<p>For example, You know that <code>Arrays.copyOf</code> will not change your actual array, <code>System.out.println(boo)</code> will not change your <code>boo</code></p>\n\n<p>Method names are real <em>weapons</em> to provide as much information as possible to the method user.<em>(Yes! it's always not possible but quite a good practice to follow.)</em></p>\n\n<p>Let's consider it in your case that say <code>printBoo</code> will only print, <code>copyBoo</code> will only copy, <code>clearBoo</code> will reset all attributes, <code>checkAndCreateNewBoo</code> will check your <code>boo</code> <code>Object</code> and create new if required.</p>\n\n<p>So, ultimately if we can use them in a proper way caller can be assured with the fact that <code>Object</code> will remain the same after calling the method.</p>\n", "title": "How to determine if a Java method modifies an object passed as parameter", "tags": ["java", "immutability"], "link": "http://stackoverflow.com/questions/32164385/how-to-determine-if-a-java-method-modifies-an-object-passed-as-parameter/32167166#32167166", "post_type": "answer", "question_id": 32164385, "answer_id": 32167166}, {"body": "<p>Idea #1, storing the <code>Graphics</code> objects simply wouldn't work. The <code>Graphics</code> should not be considered as \"holding\" some display memory, but rather as a handle to access an area of display memory. In the case of <code>BufferedImage</code>, each <code>Graphics</code> object will be always the handle to the same given image memory buffer, so they all will represent the same image. Even more importantly, <strong>you can't actually do anything with the stored <code>Graphics</code>:</strong> As they do not store anything, there is no way whatsoever they could \"re-store\" anything.</p>\n\n<p>Idea #2, cloning the <code>BufferedImage</code>s is a much better idea, but you'll indeed be wasting memory, and quickly run out of it. It helps only to store those parts of the image affected by the draw, for example using rectangular areas, but it still costs a lot of memory. Buffering those undo images to disk could help, but it will make your UI slow and unresponsive, and that's <em>bad</em>; furthermore, it makes you application more <strong>complex and error-prone</strong>.</p>\n\n<p>My alternative would be to store store the image modifications in a list, rendered from first to last on top of the image. An undo operation then simply consists of removing the modification from the list.</p>\n\n<p>This requires you to <strong>\"reify\" the image modifications</strong>, i.e. create a class that implements a single modification, by providing a <code>void draw(Graphics gfx)</code> method which performs the actual drawing.</p>\n\n<p>As you said, <strong>random modifications</strong> pose an additional problem. However, the key problem is your use of <code>Math.random()</code> to create random numbers. Instead, perform each random modification with a <code>Random</code> created from a fixed seed value, so that the (pseudo-)random number sequences are the same on each invocation of <code>draw()</code>, i.e., each draw has exactly the same effects. (That's why they are called \"pseudo-random\" -- the generated numbers look random, but they are just as deterministic as any other function.)</p>\n\n<p>In contrast to the image storing technique, which has memory problems, the problem with this technique is that many modifications may make the GUI slow, especially if the modifications are computationally intensive. To prevent this, the simplest way would be to fix an appropriate <strong>maximum size of the list of undoable modifications</strong>. If this limit would be exceeded by adding a new modification, remove the oldest modification the list and apply it to the backing <code>BufferedImage</code> itself.</p>\n\n<p>The following <strong>simple demo application</strong> shows that (and how) this all works together. It also includes a nice \"redo\" feature for redoing undone actions.</p>\n\n<pre><code>package stackoverflow;\n\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.image.BufferedImage;\nimport java.util.LinkedList;\nimport java.util.Random;\nimport javax.swing.*;\n\npublic final class UndoableDrawDemo\n        implements Runnable\n{\n    public static void main(String[] args) {\n        EventQueue.invokeLater(new UndoableDrawDemo()); // execute on EDT\n    }\n\n    // holds the list of drawn modifications, rendered back to front\n    private final LinkedList&lt;ImageModification&gt; undoable = new LinkedList&lt;&gt;();\n    // holds the list of undone modifications for redo, last undone at end\n    private final LinkedList&lt;ImageModification&gt; undone = new LinkedList&lt;&gt;();\n\n    // maximum # of undoable modifications\n    private static final int MAX_UNDO_COUNT = 4;\n\n    private BufferedImage image;\n\n    public UndoableDrawDemo() {\n        image = new BufferedImage(600, 600, BufferedImage.TYPE_INT_RGB);\n    }\n\n    public void run() {\n        // create display area\n        final JPanel drawPanel = new JPanel() {\n            @Override\n            public void paintComponent(Graphics gfx) {\n                super.paintComponent(gfx);\n\n                // display backing image\n                gfx.drawImage(image, 0, 0, null);\n\n                // and render all undoable modification\n                for (ImageModification action: undoable) {\n                    action.draw(gfx, image.getWidth(), image.getHeight());\n                }\n            }\n\n            @Override\n            public Dimension getPreferredSize() {\n                return new Dimension(image.getWidth(), image.getHeight());\n            }\n        };\n\n        // create buttons for drawing new stuff, undoing and redoing it\n        JButton drawButton = new JButton(\"Draw\");\n        JButton undoButton = new JButton(\"Undo\");\n        JButton redoButton = new JButton(\"Redo\");\n\n        drawButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                // maximum number of undo's reached?\n                if (undoable.size() == MAX_UNDO_COUNT) {\n                    // remove oldest undoable action and apply it to backing image\n                    ImageModification first = undoable.removeFirst();\n\n                    Graphics imageGfx = image.getGraphics();\n                    first.draw(imageGfx, image.getWidth(), image.getHeight());\n                    imageGfx.dispose();\n                }\n\n                // add new modification\n                undoable.addLast(new ExampleRandomModification());\n\n                // we shouldn't \"redo\" the undone actions\n                undone.clear();\n\n                drawPanel.repaint();\n            }\n        });\n\n        undoButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                if (!undoable.isEmpty()) {\n                    // remove last drawn modification, and append it to undone list\n                    ImageModification lastDrawn = undoable.removeLast();\n                    undone.addLast(lastDrawn);\n\n                    drawPanel.repaint();\n                }\n            }\n        });\n\n        redoButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                if (!undone.isEmpty()) {\n                    // remove last undone modification, and append it to drawn list again\n                    ImageModification lastUndone = undone.removeLast();\n                    undoable.addLast(lastUndone);\n\n                    drawPanel.repaint();\n                }\n            }\n        });\n\n        JPanel buttonPanel = new JPanel(new FlowLayout());\n        buttonPanel.add(drawButton);\n        buttonPanel.add(undoButton);\n        buttonPanel.add(redoButton);\n\n        // create frame, add all content, and open it\n        JFrame frame = new JFrame(\"Undoable Draw Demo\");\n        frame.getContentPane().add(drawPanel);\n        frame.getContentPane().add(buttonPanel, BorderLayout.NORTH);\n        frame.pack();\n        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n        frame.setLocationRelativeTo(null);\n        frame.setVisible(true);\n    }\n\n    //--- draw actions ---\n\n    // provides the seeds for the random modifications -- not for drawing itself\n    private static final Random SEEDS = new Random();\n\n    // interface for draw modifications\n    private interface ImageModification\n    {\n        void draw(Graphics gfx, int width, int height);\n    }\n\n    // example random modification, draws bunch of random lines in random color\n    private static class ExampleRandomModification implements ImageModification\n    {\n        private final long seed;\n\n        public ExampleRandomModification() {\n            // create some random seed for this modification\n            this.seed = SEEDS.nextLong();\n        }\n\n        @Override\n        public void draw(Graphics gfx, int width, int height) {\n            // create a new pseudo-random number generator with our seed...\n            Random random = new Random(seed);\n\n            // so that the random numbers generated are the same each time.\n            gfx.setColor(new Color(\n                    random.nextInt(256), random.nextInt(256), random.nextInt(256)));\n\n            for (int i = 0; i &lt; 16; i++) {\n                gfx.drawLine(\n                        random.nextInt(width), random.nextInt(height),\n                        random.nextInt(width), random.nextInt(height));\n            }\n        }\n    }\n}\n</code></pre>\n", "title": "Is storing Graphics objects a good idea?", "tags": ["java", "memory-management", "graphics", "awt", "bufferedimage"], "link": "http://stackoverflow.com/questions/31370403/is-storing-graphics-objects-a-good-idea/31466466#31466466", "post_type": "answer", "question_id": 31370403, "answer_id": 31466466}, {"body": "<p>I first tought your question was a dupe of <a href=\"http://stackoverflow.com/questions/408661/what-code-does-the-compiler-generate-for-autoboxing\">What code does the compiler generate for autoboxing?</a></p>\n\n<p>However, after your comment on @ElliottFrisch I realized it was different :</p>\n\n<blockquote>\n  <p>I know the compiler behaves that way. I'm trying to figure out whether\n  that behavior is guaranteed.</p>\n</blockquote>\n\n<p>For other readers, assume that \"behaves that way\" means using <code>valueOf</code>.</p>\n\n<p>Remember that there are multiples compilers for Java. To be \"legal\" they must follow the contract given in the <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.7\">JLS</a>. Therefore, as long as all the rules here are respected, there is no guarantee of how autoboxing is internally implemented.</p>\n\n<p>But I don't see any reason to not use <code>valueOf</code>, specially that it uses the cached values and is the recommended way as per <a href=\"https://blogs.oracle.com/darcy/entry/boxing_and_caches_integer_valueof\">this article</a> by Joseph D. Darcy.</p>\n", "title": "Does autoboxing call valueOf()?", "tags": ["java", "boxing", "autoboxing"], "link": "http://stackoverflow.com/questions/31445024/does-autoboxing-call-valueof/31445150#31445150", "post_type": "answer", "question_id": 31445024, "answer_id": 31445150}, {"body": "<p>Until the language specification mentions it, it is not guaranteed that autoboxing is equivalent to a call to the static <code>valueOf</code> methods. It is an <em>implementation</em> aspect, not part of the boxing conversion specification. An implementation is theoretically free to use another mechanism as long as it conforms to the rule you mentioned from the JLS.</p>\n\n<p>In practice, there are many Sun JDK bug reports (e.g. <a href=\"https://bugs.openjdk.java.net/browse/JDK-4990346\">JDK-4990346</a> and <a href=\"https://bugs.openjdk.java.net/browse/JDK-6628737\">JDK-6628737</a>) that clearly imply that when autoboxing was introduced in Java 5, the intention was having the compiler to rely on <code>valueOf</code> as stated in <a href=\"https://bugs.openjdk.java.net/browse/JDK-6628737\">JDK-6628737</a>:</p>\n\n<blockquote>\n  <p>The static factory methods Integer.valueOf(int), Long.valueOf(long), etc. were introduced in JDK 5 for javac to implement the caching behavior required by the autoboxing specification.</p>\n</blockquote>\n\n<p>But that's only for javac, not necessarily all compilers.</p>\n", "title": "Does autoboxing call valueOf()?", "tags": ["java", "boxing", "autoboxing"], "link": "http://stackoverflow.com/questions/31445024/does-autoboxing-call-valueof/31760309#31760309", "post_type": "answer", "question_id": 31445024, "answer_id": 31760309}, {"body": "<p>Autoboxing <strong>is</strong> absolutely implemented using <code>valueOf()</code> ...in the OpenJDK. If that's your implementation, read on... if not, skip to below.</p>\n\n<pre><code>((Boolean)true) == Boolean.TRUE\n((Boolean)true) == Boolean.valueOf(true)\n</code></pre>\n\n<p>Java documentation states that <code>Boolean.valueOf()</code> always returns <code>Boolean.TRUE</code> or <code>Boolean.FALSE</code>, therefore your reference comparisons in these cases will succeed.</p>\n\n<pre><code>((Integer)1) == Integer.valueOf(1)\n</code></pre>\n\n<p>For this particular example, under the OpenJDK implementation with default settings, it will <em>probably</em> work by virtue of the fact that you picked a value &lt; 128 which is cached at startup (although this can be overridden as a commandline arg). It <em>may</em> also work for larger values if it's frequently used enough to be cached. Unless you're working under \"safe\" assumptions about the Integer cache, don't expect the reference comparison to be an equality.</p>\n\n<p><code>Long</code>, <code>Short</code>, <code>Character</code> and <code>Byte</code> incidentally implement this caching too, but unlike <code>Integer</code>, it's not tunable. <code>Byte</code> will always work if you're comparing autobox/<code>valueOf()</code> references since obviously, you can't go out of range. <code>Float</code> and <code>Double</code> will unsurprisingly always create a new instance.</p>\n\n<hr>\n\n<p>Now, in purely generic terms? <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.7\" rel=\"nofollow\">See this section of the JLS</a> - you <strong>MUST</strong> be given equal references for <code>boolean</code> and any <code>int</code> or <code>char</code> within the -128 to 127 range. There are <strong>no guarantees</strong> for anything else.</p>\n", "title": "Does autoboxing call valueOf()?", "tags": ["java", "boxing", "autoboxing"], "link": "http://stackoverflow.com/questions/31445024/does-autoboxing-call-valueof/31871515#31871515", "post_type": "answer", "question_id": 31445024, "answer_id": 31871515}, {"body": "<p>Your question is based on assumption that the code which may throw <code>NullPointerException</code> is worse than the code which may not. This assumption is wrong. If you expect that your <code>foobar</code> is never null due to the program logic, it's much better to use <code>Optional.of(foobar)</code> as you will see a <code>NullPointerException</code> which will indicate that your program has a bug. If you use <code>Optional.ofNullable(foobar)</code> and the <code>foobar</code> happens to be <code>null</code> due to the bug, then your program will silently continue working incorrectly, which may be a bigger disaster. This way an error may occur much later and it would be much harder to understand at which point it went wrong.</p>\n", "title": "Why use Optional.of over Optional.ofNullable?", "tags": ["java", "java-8", "optional"], "link": "http://stackoverflow.com/questions/31696485/why-use-optional-of-over-optional-ofnullable/31696584#31696584", "post_type": "answer", "question_id": 31696485, "answer_id": 31696584}]}